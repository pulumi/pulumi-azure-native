# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdditionalLocationResponse',
    'ApiContactInformationResponse',
    'ApiLicenseInformationResponse',
    'ApiManagementGatewaySkuPropertiesResponse',
    'ApiManagementServiceIdentityResponse',
    'ApiManagementServiceSkuPropertiesResponse',
    'ApiVersionConstraintResponse',
    'ApiVersionSetContractDetailsResponse',
    'ArmIdWrapperResponse',
    'AuthenticationSettingsContractResponse',
    'AuthorizationErrorResponse',
    'AuthorizationProviderOAuth2GrantTypesResponse',
    'AuthorizationProviderOAuth2SettingsResponse',
    'BackendAuthorizationHeaderCredentialsResponse',
    'BackendBaseParametersResponsePool',
    'BackendCircuitBreakerResponse',
    'BackendConfigurationResponse',
    'BackendCredentialsContractResponse',
    'BackendPoolItemResponse',
    'BackendPropertiesResponse',
    'BackendProxyContractResponse',
    'BackendServiceFabricClusterPropertiesResponse',
    'BackendSubnetConfigurationResponse',
    'BackendTlsPropertiesResponse',
    'BodyDiagnosticSettingsResponse',
    'CertificateConfigurationResponse',
    'CertificateInformationResponse',
    'CircuitBreakerFailureConditionResponse',
    'CircuitBreakerRuleResponse',
    'DataMaskingEntityResponse',
    'DataMaskingResponse',
    'EmailTemplateParametersContractPropertiesResponse',
    'FailureStatusCodeRangeResponse',
    'FrontendConfigurationResponse',
    'GatewayConfigurationApiResponse',
    'GroupContractPropertiesResponse',
    'HostnameConfigurationResponse',
    'HttpMessageDiagnosticResponse',
    'KeyVaultContractPropertiesResponse',
    'KeyVaultLastAccessStatusContractPropertiesResponse',
    'LLMDiagnosticSettingsResponse',
    'LLMMessageDiagnosticSettingsResponse',
    'OAuth2AuthenticationSettingsContractResponse',
    'OpenIdAuthenticationSettingsContractResponse',
    'ParameterContractResponse',
    'ParameterExampleContractResponse',
    'PipelineDiagnosticSettingsResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RemotePrivateEndpointConnectionWrapperResponse',
    'RepresentationContractResponse',
    'RequestContractResponse',
    'ResourceCollectionResponseValue',
    'ResourceLocationDataContractResponse',
    'ResponseContractResponse',
    'SamplingSettingsResponse',
    'SubscriptionKeyParameterNamesContractResponse',
    'SystemDataResponse',
    'TokenBodyParameterContractResponse',
    'UserIdentityContractResponse',
    'UserIdentityPropertiesResponse',
    'VirtualNetworkConfigurationResponse',
    'WikiDocumentationContractResponse',
    'X509CertificateNameResponse',
]

@pulumi.output_type
class AdditionalLocationResponse(dict):
    """
    Description of an additional API Management resource location.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayRegionalUrl":
            suggest = "gateway_regional_url"
        elif key == "outboundPublicIPAddresses":
            suggest = "outbound_public_ip_addresses"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "privateIPAddresses":
            suggest = "private_ip_addresses"
        elif key == "publicIPAddresses":
            suggest = "public_ip_addresses"
        elif key == "disableGateway":
            suggest = "disable_gateway"
        elif key == "natGatewayState":
            suggest = "nat_gateway_state"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "virtualNetworkConfiguration":
            suggest = "virtual_network_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdditionalLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdditionalLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdditionalLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_regional_url: _builtins.str,
                 location: _builtins.str,
                 outbound_public_ip_addresses: Sequence[_builtins.str],
                 platform_version: _builtins.str,
                 private_ip_addresses: Sequence[_builtins.str],
                 public_ip_addresses: Sequence[_builtins.str],
                 sku: 'outputs.ApiManagementServiceSkuPropertiesResponse',
                 disable_gateway: Optional[_builtins.bool] = None,
                 nat_gateway_state: Optional[_builtins.str] = None,
                 public_ip_address_id: Optional[_builtins.str] = None,
                 virtual_network_configuration: Optional['outputs.VirtualNetworkConfigurationResponse'] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        Description of an additional API Management resource location.
        :param _builtins.str gateway_regional_url: Gateway URL of the API Management service in the Region.
        :param _builtins.str location: The location name of the additional region among Azure Data center regions.
        :param Sequence[_builtins.str] outbound_public_ip_addresses: Outbound public IPV4 address prefixes associated with NAT Gateway deployed service. Available only for Premium SKU on stv2 platform.
        :param _builtins.str platform_version: Compute Platform Version running the service.
        :param Sequence[_builtins.str] private_ip_addresses: Private Static Load Balanced IP addresses of the API Management service which is deployed in an Internal Virtual Network in a particular additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        :param Sequence[_builtins.str] public_ip_addresses: Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        :param 'ApiManagementServiceSkuPropertiesResponse' sku: SKU properties of the API Management service.
        :param _builtins.bool disable_gateway: Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
        :param _builtins.str nat_gateway_state: Property can be used to enable NAT Gateway for this API Management service.
        :param _builtins.str public_ip_address_id: Public Standard SKU IP V4 based IP address to be associated with Virtual Network deployed service in the location. Supported only for Premium SKU being deployed in Virtual Network.
        :param 'VirtualNetworkConfigurationResponse' virtual_network_configuration: Virtual network configuration for the location.
        :param Sequence[_builtins.str] zones: A list of availability zones denoting where the resource needs to come from.
        """
        pulumi.set(__self__, "gateway_regional_url", gateway_regional_url)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "outbound_public_ip_addresses", outbound_public_ip_addresses)
        pulumi.set(__self__, "platform_version", platform_version)
        pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        pulumi.set(__self__, "sku", sku)
        if disable_gateway is None:
            disable_gateway = False
        if disable_gateway is not None:
            pulumi.set(__self__, "disable_gateway", disable_gateway)
        if nat_gateway_state is None:
            nat_gateway_state = 'Disabled'
        if nat_gateway_state is not None:
            pulumi.set(__self__, "nat_gateway_state", nat_gateway_state)
        if public_ip_address_id is not None:
            pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        if virtual_network_configuration is not None:
            pulumi.set(__self__, "virtual_network_configuration", virtual_network_configuration)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="gatewayRegionalUrl")
    def gateway_regional_url(self) -> _builtins.str:
        """
        Gateway URL of the API Management service in the Region.
        """
        return pulumi.get(self, "gateway_regional_url")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The location name of the additional region among Azure Data center regions.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="outboundPublicIPAddresses")
    def outbound_public_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Outbound public IPV4 address prefixes associated with NAT Gateway deployed service. Available only for Premium SKU on stv2 platform.
        """
        return pulumi.get(self, "outbound_public_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> _builtins.str:
        """
        Compute Platform Version running the service.
        """
        return pulumi.get(self, "platform_version")

    @_builtins.property
    @pulumi.getter(name="privateIPAddresses")
    def private_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Private Static Load Balanced IP addresses of the API Management service which is deployed in an Internal Virtual Network in a particular additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="publicIPAddresses")
    def public_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        """
        return pulumi.get(self, "public_ip_addresses")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> 'outputs.ApiManagementServiceSkuPropertiesResponse':
        """
        SKU properties of the API Management service.
        """
        return pulumi.get(self, "sku")

    @_builtins.property
    @pulumi.getter(name="disableGateway")
    def disable_gateway(self) -> Optional[_builtins.bool]:
        """
        Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
        """
        return pulumi.get(self, "disable_gateway")

    @_builtins.property
    @pulumi.getter(name="natGatewayState")
    def nat_gateway_state(self) -> Optional[_builtins.str]:
        """
        Property can be used to enable NAT Gateway for this API Management service.
        """
        return pulumi.get(self, "nat_gateway_state")

    @_builtins.property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[_builtins.str]:
        """
        Public Standard SKU IP V4 based IP address to be associated with Virtual Network deployed service in the location. Supported only for Premium SKU being deployed in Virtual Network.
        """
        return pulumi.get(self, "public_ip_address_id")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkConfiguration")
    def virtual_network_configuration(self) -> Optional['outputs.VirtualNetworkConfigurationResponse']:
        """
        Virtual network configuration for the location.
        """
        return pulumi.get(self, "virtual_network_configuration")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of availability zones denoting where the resource needs to come from.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class ApiContactInformationResponse(dict):
    """
    API contact information
    """
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        API contact information
        :param _builtins.str email: The email address of the contact person/organization. MUST be in the format of an email address
        :param _builtins.str name: The identifying name of the contact person/organization
        :param _builtins.str url: The URL pointing to the contact information. MUST be in the format of a URL
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email address of the contact person/organization. MUST be in the format of an email address
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The identifying name of the contact person/organization
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL pointing to the contact information. MUST be in the format of a URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiLicenseInformationResponse(dict):
    """
    API license information
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        API license information
        :param _builtins.str name: The license name used for the API
        :param _builtins.str url: A URL to the license used for the API. MUST be in the format of a URL
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The license name used for the API
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        A URL to the license used for the API. MUST be in the format of a URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiManagementGatewaySkuPropertiesResponse(dict):
    """
    API Management gateway resource SKU properties.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 capacity: Optional[_builtins.int] = None):
        """
        API Management gateway resource SKU properties.
        :param _builtins.str name: Name of the Sku.
        :param _builtins.int capacity: Capacity of the SKU (number of deployed units of the SKU)
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Sku.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        Capacity of the SKU (number of deployed units of the SKU)
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class ApiManagementServiceIdentityResponse(dict):
    """
    Identity properties of the Api Management service resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiManagementServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiManagementServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiManagementServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']] = None):
        """
        Identity properties of the Api Management service resource.
        :param _builtins.str principal_id: The principal id of the identity.
        :param _builtins.str tenant_id: The client tenant id of the identity.
        :param _builtins.str type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param Mapping[str, 'UserIdentityPropertiesResponse'] user_assigned_identities: The list of user identities associated with the resource. The user identity 
               dictionary key references will be ARM resource ids in the form: 
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
                   providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal id of the identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The client tenant id of the identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']]:
        """
        The list of user identities associated with the resource. The user identity 
        dictionary key references will be ARM resource ids in the form: 
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
            providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ApiManagementServiceSkuPropertiesResponse(dict):
    """
    API Management service resource SKU properties.
    """
    def __init__(__self__, *,
                 capacity: _builtins.int,
                 name: _builtins.str):
        """
        API Management service resource SKU properties.
        :param _builtins.int capacity: Capacity of the SKU (number of deployed units of the SKU). For Consumption SKU capacity must be specified as 0.
        :param _builtins.str name: Name of the Sku.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.int:
        """
        Capacity of the SKU (number of deployed units of the SKU). For Consumption SKU capacity must be specified as 0.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Sku.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApiVersionConstraintResponse(dict):
    """
    Control Plane Apis version constraint for the API Management service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minApiVersion":
            suggest = "min_api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiVersionConstraintResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiVersionConstraintResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiVersionConstraintResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_api_version: Optional[_builtins.str] = None):
        """
        Control Plane Apis version constraint for the API Management service.
        :param _builtins.str min_api_version: Limit control plane API calls to API Management service with version equal to or newer than this value.
        """
        if min_api_version is not None:
            pulumi.set(__self__, "min_api_version", min_api_version)

    @_builtins.property
    @pulumi.getter(name="minApiVersion")
    def min_api_version(self) -> Optional[_builtins.str]:
        """
        Limit control plane API calls to API Management service with version equal to or newer than this value.
        """
        return pulumi.get(self, "min_api_version")


@pulumi.output_type
class ApiVersionSetContractDetailsResponse(dict):
    """
    An API Version Set contains the common configuration for a set of API Versions relating 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionHeaderName":
            suggest = "version_header_name"
        elif key == "versionQueryName":
            suggest = "version_query_name"
        elif key == "versioningScheme":
            suggest = "versioning_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiVersionSetContractDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiVersionSetContractDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiVersionSetContractDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version_header_name: Optional[_builtins.str] = None,
                 version_query_name: Optional[_builtins.str] = None,
                 versioning_scheme: Optional[_builtins.str] = None):
        """
        An API Version Set contains the common configuration for a set of API Versions relating 
        :param _builtins.str description: Description of API Version Set.
        :param _builtins.str id: Identifier for existing API Version Set. Omit this value to create a new Version Set.
        :param _builtins.str name: The display Name of the API Version Set.
        :param _builtins.str version_header_name: Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        :param _builtins.str version_query_name: Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        :param _builtins.str versioning_scheme: An value that determines where the API Version identifier will be located in a HTTP request.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version_header_name is not None:
            pulumi.set(__self__, "version_header_name", version_header_name)
        if version_query_name is not None:
            pulumi.set(__self__, "version_query_name", version_query_name)
        if versioning_scheme is not None:
            pulumi.set(__self__, "versioning_scheme", versioning_scheme)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of API Version Set.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Identifier for existing API Version Set. Omit this value to create a new Version Set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The display Name of the API Version Set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="versionHeaderName")
    def version_header_name(self) -> Optional[_builtins.str]:
        """
        Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        """
        return pulumi.get(self, "version_header_name")

    @_builtins.property
    @pulumi.getter(name="versionQueryName")
    def version_query_name(self) -> Optional[_builtins.str]:
        """
        Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        """
        return pulumi.get(self, "version_query_name")

    @_builtins.property
    @pulumi.getter(name="versioningScheme")
    def versioning_scheme(self) -> Optional[_builtins.str]:
        """
        An value that determines where the API Version identifier will be located in a HTTP request.
        """
        return pulumi.get(self, "versioning_scheme")


@pulumi.output_type
class ArmIdWrapperResponse(dict):
    """
    A wrapper for an ARM resource id
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        A wrapper for an ARM resource id
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class AuthenticationSettingsContractResponse(dict):
    """
    API Authentication Settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth2":
            suggest = "o_auth2"
        elif key == "oAuth2AuthenticationSettings":
            suggest = "o_auth2_authentication_settings"
        elif key == "openidAuthenticationSettings":
            suggest = "openid_authentication_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth2: Optional['outputs.OAuth2AuthenticationSettingsContractResponse'] = None,
                 o_auth2_authentication_settings: Optional[Sequence['outputs.OAuth2AuthenticationSettingsContractResponse']] = None,
                 openid: Optional['outputs.OpenIdAuthenticationSettingsContractResponse'] = None,
                 openid_authentication_settings: Optional[Sequence['outputs.OpenIdAuthenticationSettingsContractResponse']] = None):
        """
        API Authentication Settings.
        :param 'OAuth2AuthenticationSettingsContractResponse' o_auth2: OAuth2 Authentication settings
        :param Sequence['OAuth2AuthenticationSettingsContractResponse'] o_auth2_authentication_settings: Collection of OAuth2 authentication settings included into this API.
        :param 'OpenIdAuthenticationSettingsContractResponse' openid: OpenID Connect Authentication Settings
        :param Sequence['OpenIdAuthenticationSettingsContractResponse'] openid_authentication_settings: Collection of Open ID Connect authentication settings included into this API.
        """
        if o_auth2 is not None:
            pulumi.set(__self__, "o_auth2", o_auth2)
        if o_auth2_authentication_settings is not None:
            pulumi.set(__self__, "o_auth2_authentication_settings", o_auth2_authentication_settings)
        if openid is not None:
            pulumi.set(__self__, "openid", openid)
        if openid_authentication_settings is not None:
            pulumi.set(__self__, "openid_authentication_settings", openid_authentication_settings)

    @_builtins.property
    @pulumi.getter(name="oAuth2")
    def o_auth2(self) -> Optional['outputs.OAuth2AuthenticationSettingsContractResponse']:
        """
        OAuth2 Authentication settings
        """
        return pulumi.get(self, "o_auth2")

    @_builtins.property
    @pulumi.getter(name="oAuth2AuthenticationSettings")
    def o_auth2_authentication_settings(self) -> Optional[Sequence['outputs.OAuth2AuthenticationSettingsContractResponse']]:
        """
        Collection of OAuth2 authentication settings included into this API.
        """
        return pulumi.get(self, "o_auth2_authentication_settings")

    @_builtins.property
    @pulumi.getter
    def openid(self) -> Optional['outputs.OpenIdAuthenticationSettingsContractResponse']:
        """
        OpenID Connect Authentication Settings
        """
        return pulumi.get(self, "openid")

    @_builtins.property
    @pulumi.getter(name="openidAuthenticationSettings")
    def openid_authentication_settings(self) -> Optional[Sequence['outputs.OpenIdAuthenticationSettingsContractResponse']]:
        """
        Collection of Open ID Connect authentication settings included into this API.
        """
        return pulumi.get(self, "openid_authentication_settings")


@pulumi.output_type
class AuthorizationErrorResponse(dict):
    """
    Authorization error details.
    """
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        Authorization error details.
        :param _builtins.str code: Error code
        :param _builtins.str message: Error message
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Error code
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Error message
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AuthorizationProviderOAuth2GrantTypesResponse(dict):
    """
    Authorization Provider oauth2 grant types settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCode":
            suggest = "authorization_code"
        elif key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProviderOAuth2GrantTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProviderOAuth2GrantTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProviderOAuth2GrantTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_code: Optional[Mapping[str, _builtins.str]] = None,
                 client_credentials: Optional[Mapping[str, _builtins.str]] = None):
        """
        Authorization Provider oauth2 grant types settings
        :param Mapping[str, _builtins.str] authorization_code: OAuth2 authorization code grant parameters
        :param Mapping[str, _builtins.str] client_credentials: OAuth2 client credential grant parameters
        """
        if authorization_code is not None:
            pulumi.set(__self__, "authorization_code", authorization_code)
        if client_credentials is not None:
            pulumi.set(__self__, "client_credentials", client_credentials)

    @_builtins.property
    @pulumi.getter(name="authorizationCode")
    def authorization_code(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        OAuth2 authorization code grant parameters
        """
        return pulumi.get(self, "authorization_code")

    @_builtins.property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        OAuth2 client credential grant parameters
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class AuthorizationProviderOAuth2SettingsResponse(dict):
    """
    OAuth2 settings details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grantTypes":
            suggest = "grant_types"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProviderOAuth2SettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProviderOAuth2SettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProviderOAuth2SettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grant_types: Optional['outputs.AuthorizationProviderOAuth2GrantTypesResponse'] = None,
                 redirect_url: Optional[_builtins.str] = None):
        """
        OAuth2 settings details
        :param 'AuthorizationProviderOAuth2GrantTypesResponse' grant_types: OAuth2 settings
        :param _builtins.str redirect_url: Redirect URL to be set in the OAuth application.
        """
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @_builtins.property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional['outputs.AuthorizationProviderOAuth2GrantTypesResponse']:
        """
        OAuth2 settings
        """
        return pulumi.get(self, "grant_types")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Redirect URL to be set in the OAuth application.
        """
        return pulumi.get(self, "redirect_url")


@pulumi.output_type
class BackendAuthorizationHeaderCredentialsResponse(dict):
    """
    Authorization header information.
    """
    def __init__(__self__, *,
                 parameter: _builtins.str,
                 scheme: _builtins.str):
        """
        Authorization header information.
        :param _builtins.str parameter: Authentication Parameter value.
        :param _builtins.str scheme: Authentication Scheme name.
        """
        pulumi.set(__self__, "parameter", parameter)
        pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> _builtins.str:
        """
        Authentication Parameter value.
        """
        return pulumi.get(self, "parameter")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> _builtins.str:
        """
        Authentication Scheme name.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class BackendBaseParametersResponsePool(dict):
    def __init__(__self__, *,
                 services: Optional[Sequence['outputs.BackendPoolItemResponse']] = None):
        """
        :param Sequence['BackendPoolItemResponse'] services: The list of backend entities belonging to a pool.
        """
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.BackendPoolItemResponse']]:
        """
        The list of backend entities belonging to a pool.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class BackendCircuitBreakerResponse(dict):
    """
    The configuration of the backend circuit breaker
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.CircuitBreakerRuleResponse']] = None):
        """
        The configuration of the backend circuit breaker
        :param Sequence['CircuitBreakerRuleResponse'] rules: The rules for tripping the backend.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.CircuitBreakerRuleResponse']]:
        """
        The rules for tripping the backend.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class BackendConfigurationResponse(dict):
    """
    Information regarding how the gateway should integrate with backend systems.
    """
    def __init__(__self__, *,
                 subnet: Optional['outputs.BackendSubnetConfigurationResponse'] = None):
        """
        Information regarding how the gateway should integrate with backend systems.
        :param 'BackendSubnetConfigurationResponse' subnet: The default hostname of the data-plane gateway to which requests can be sent.
        """
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.BackendSubnetConfigurationResponse']:
        """
        The default hostname of the data-plane gateway to which requests can be sent.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class BackendCredentialsContractResponse(dict):
    """
    Details of the Credentials used to connect to Backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendCredentialsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendCredentialsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendCredentialsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: Optional['outputs.BackendAuthorizationHeaderCredentialsResponse'] = None,
                 certificate: Optional[Sequence[_builtins.str]] = None,
                 certificate_ids: Optional[Sequence[_builtins.str]] = None,
                 header: Optional[Mapping[str, Sequence[_builtins.str]]] = None,
                 query: Optional[Mapping[str, Sequence[_builtins.str]]] = None):
        """
        Details of the Credentials used to connect to Backend.
        :param 'BackendAuthorizationHeaderCredentialsResponse' authorization: Authorization header authentication
        :param Sequence[_builtins.str] certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        :param Sequence[_builtins.str] certificate_ids: List of Client Certificate Ids.
        :param Mapping[str, Sequence[_builtins.str]] header: Header Parameter description.
        :param Mapping[str, Sequence[_builtins.str]] query: Query Parameter description.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_ids is not None:
            pulumi.set(__self__, "certificate_ids", certificate_ids)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BackendAuthorizationHeaderCredentialsResponse']:
        """
        Authorization header authentication
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Client Certificate Ids.
        """
        return pulumi.get(self, "certificate_ids")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[Mapping[str, Sequence[_builtins.str]]]:
        """
        Header Parameter description.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[Mapping[str, Sequence[_builtins.str]]]:
        """
        Query Parameter description.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class BackendPoolItemResponse(dict):
    """
    Backend pool service information
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 priority: Optional[_builtins.int] = None,
                 weight: Optional[_builtins.int] = None):
        """
        Backend pool service information
        :param _builtins.str id: The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
        :param _builtins.int priority: The priority of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        :param _builtins.int weight: The weight of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        The priority of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The weight of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class BackendPropertiesResponse(dict):
    """
    Properties specific to the Backend Type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceFabricCluster":
            suggest = "service_fabric_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_fabric_cluster: Optional['outputs.BackendServiceFabricClusterPropertiesResponse'] = None):
        """
        Properties specific to the Backend Type.
        :param 'BackendServiceFabricClusterPropertiesResponse' service_fabric_cluster: Backend Service Fabric Cluster Properties
        """
        if service_fabric_cluster is not None:
            pulumi.set(__self__, "service_fabric_cluster", service_fabric_cluster)

    @_builtins.property
    @pulumi.getter(name="serviceFabricCluster")
    def service_fabric_cluster(self) -> Optional['outputs.BackendServiceFabricClusterPropertiesResponse']:
        """
        Backend Service Fabric Cluster Properties
        """
        return pulumi.get(self, "service_fabric_cluster")


@pulumi.output_type
class BackendProxyContractResponse(dict):
    """
    Details of the Backend WebProxy Server to use in the Request to Backend.
    """
    def __init__(__self__, *,
                 url: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        Details of the Backend WebProxy Server to use in the Request to Backend.
        :param _builtins.str url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        :param _builtins.str password: Password to connect to the WebProxy Server
        :param _builtins.str username: Username to connect to the WebProxy server
        """
        pulumi.set(__self__, "url", url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password to connect to the WebProxy Server
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username to connect to the WebProxy server
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BackendServiceFabricClusterPropertiesResponse(dict):
    """
    Properties of the Service Fabric Type Backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementEndpoints":
            suggest = "management_endpoints"
        elif key == "clientCertificateId":
            suggest = "client_certificate_id"
        elif key == "clientCertificatethumbprint":
            suggest = "client_certificatethumbprint"
        elif key == "maxPartitionResolutionRetries":
            suggest = "max_partition_resolution_retries"
        elif key == "serverCertificateThumbprints":
            suggest = "server_certificate_thumbprints"
        elif key == "serverX509Names":
            suggest = "server_x509_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceFabricClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceFabricClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceFabricClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_endpoints: Sequence[_builtins.str],
                 client_certificate_id: Optional[_builtins.str] = None,
                 client_certificatethumbprint: Optional[_builtins.str] = None,
                 max_partition_resolution_retries: Optional[_builtins.int] = None,
                 server_certificate_thumbprints: Optional[Sequence[_builtins.str]] = None,
                 server_x509_names: Optional[Sequence['outputs.X509CertificateNameResponse']] = None):
        """
        Properties of the Service Fabric Type Backend.
        :param Sequence[_builtins.str] management_endpoints: The cluster management endpoint.
        :param _builtins.str client_certificate_id: The client certificate id for the management endpoint.
        :param _builtins.str client_certificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        :param _builtins.int max_partition_resolution_retries: Maximum number of retries while attempting resolve the partition.
        :param Sequence[_builtins.str] server_certificate_thumbprints: Thumbprints of certificates cluster management service uses for tls communication
        :param Sequence['X509CertificateNameResponse'] server_x509_names: Server X509 Certificate Names Collection
        """
        pulumi.set(__self__, "management_endpoints", management_endpoints)
        if client_certificate_id is not None:
            pulumi.set(__self__, "client_certificate_id", client_certificate_id)
        if client_certificatethumbprint is not None:
            pulumi.set(__self__, "client_certificatethumbprint", client_certificatethumbprint)
        if max_partition_resolution_retries is not None:
            pulumi.set(__self__, "max_partition_resolution_retries", max_partition_resolution_retries)
        if server_certificate_thumbprints is not None:
            pulumi.set(__self__, "server_certificate_thumbprints", server_certificate_thumbprints)
        if server_x509_names is not None:
            pulumi.set(__self__, "server_x509_names", server_x509_names)

    @_builtins.property
    @pulumi.getter(name="managementEndpoints")
    def management_endpoints(self) -> Sequence[_builtins.str]:
        """
        The cluster management endpoint.
        """
        return pulumi.get(self, "management_endpoints")

    @_builtins.property
    @pulumi.getter(name="clientCertificateId")
    def client_certificate_id(self) -> Optional[_builtins.str]:
        """
        The client certificate id for the management endpoint.
        """
        return pulumi.get(self, "client_certificate_id")

    @_builtins.property
    @pulumi.getter(name="clientCertificatethumbprint")
    def client_certificatethumbprint(self) -> Optional[_builtins.str]:
        """
        The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        """
        return pulumi.get(self, "client_certificatethumbprint")

    @_builtins.property
    @pulumi.getter(name="maxPartitionResolutionRetries")
    def max_partition_resolution_retries(self) -> Optional[_builtins.int]:
        """
        Maximum number of retries while attempting resolve the partition.
        """
        return pulumi.get(self, "max_partition_resolution_retries")

    @_builtins.property
    @pulumi.getter(name="serverCertificateThumbprints")
    def server_certificate_thumbprints(self) -> Optional[Sequence[_builtins.str]]:
        """
        Thumbprints of certificates cluster management service uses for tls communication
        """
        return pulumi.get(self, "server_certificate_thumbprints")

    @_builtins.property
    @pulumi.getter(name="serverX509Names")
    def server_x509_names(self) -> Optional[Sequence['outputs.X509CertificateNameResponse']]:
        """
        Server X509 Certificate Names Collection
        """
        return pulumi.get(self, "server_x509_names")


@pulumi.output_type
class BackendSubnetConfigurationResponse(dict):
    """
    Information regarding how the subnet to which the gateway should be injected.
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        Information regarding how the subnet to which the gateway should be injected.
        :param _builtins.str id: The ARM ID of the subnet in which the backend systems are hosted.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ARM ID of the subnet in which the backend systems are hosted.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackendTlsPropertiesResponse(dict):
    """
    Properties controlling TLS Certificate Validation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validateCertificateChain":
            suggest = "validate_certificate_chain"
        elif key == "validateCertificateName":
            suggest = "validate_certificate_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendTlsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendTlsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendTlsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validate_certificate_chain: Optional[_builtins.bool] = None,
                 validate_certificate_name: Optional[_builtins.bool] = None):
        """
        Properties controlling TLS Certificate Validation.
        :param _builtins.bool validate_certificate_chain: Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        :param _builtins.bool validate_certificate_name: Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        if validate_certificate_chain is None:
            validate_certificate_chain = True
        if validate_certificate_chain is not None:
            pulumi.set(__self__, "validate_certificate_chain", validate_certificate_chain)
        if validate_certificate_name is None:
            validate_certificate_name = True
        if validate_certificate_name is not None:
            pulumi.set(__self__, "validate_certificate_name", validate_certificate_name)

    @_builtins.property
    @pulumi.getter(name="validateCertificateChain")
    def validate_certificate_chain(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_chain")

    @_builtins.property
    @pulumi.getter(name="validateCertificateName")
    def validate_certificate_name(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_name")


@pulumi.output_type
class BodyDiagnosticSettingsResponse(dict):
    """
    Body logging settings.
    """
    def __init__(__self__, *,
                 bytes: Optional[_builtins.int] = None):
        """
        Body logging settings.
        :param _builtins.int bytes: Number of request body bytes to log.
        """
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.int]:
        """
        Number of request body bytes to log.
        """
        return pulumi.get(self, "bytes")


@pulumi.output_type
class CertificateConfigurationResponse(dict):
    """
    Certificate configuration which consist of non-trusted intermediates and root certificates.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storeName":
            suggest = "store_name"
        elif key == "certificatePassword":
            suggest = "certificate_password"
        elif key == "encodedCertificate":
            suggest = "encoded_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 store_name: _builtins.str,
                 certificate: Optional['outputs.CertificateInformationResponse'] = None,
                 certificate_password: Optional[_builtins.str] = None,
                 encoded_certificate: Optional[_builtins.str] = None):
        """
        Certificate configuration which consist of non-trusted intermediates and root certificates.
        :param _builtins.str store_name: The System.Security.Cryptography.x509certificates.StoreName certificate store location. Only Root and CertificateAuthority are valid locations.
        :param 'CertificateInformationResponse' certificate: Certificate information.
        :param _builtins.str certificate_password: Certificate Password.
        :param _builtins.str encoded_certificate: Base64 Encoded certificate.
        """
        pulumi.set(__self__, "store_name", store_name)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if encoded_certificate is not None:
            pulumi.set(__self__, "encoded_certificate", encoded_certificate)

    @_builtins.property
    @pulumi.getter(name="storeName")
    def store_name(self) -> _builtins.str:
        """
        The System.Security.Cryptography.x509certificates.StoreName certificate store location. Only Root and CertificateAuthority are valid locations.
        """
        return pulumi.get(self, "store_name")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.CertificateInformationResponse']:
        """
        Certificate information.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[_builtins.str]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @_builtins.property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")


@pulumi.output_type
class CertificateInformationResponse(dict):
    """
    SSL certificate information.
    """
    def __init__(__self__, *,
                 expiry: _builtins.str,
                 subject: _builtins.str,
                 thumbprint: _builtins.str):
        """
        SSL certificate information.
        :param _builtins.str expiry: Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        :param _builtins.str subject: Subject of the certificate.
        :param _builtins.str thumbprint: Thumbprint of the certificate.
        """
        pulumi.set(__self__, "expiry", expiry)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "thumbprint", thumbprint)

    @_builtins.property
    @pulumi.getter
    def expiry(self) -> _builtins.str:
        """
        Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        return pulumi.get(self, "expiry")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject of the certificate.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> _builtins.str:
        """
        Thumbprint of the certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class CircuitBreakerFailureConditionResponse(dict):
    """
    The trip conditions of the circuit breaker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorReasons":
            suggest = "error_reasons"
        elif key == "statusCodeRanges":
            suggest = "status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitBreakerFailureConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitBreakerFailureConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitBreakerFailureConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.float] = None,
                 error_reasons: Optional[Sequence[_builtins.str]] = None,
                 interval: Optional[_builtins.str] = None,
                 percentage: Optional[_builtins.float] = None,
                 status_code_ranges: Optional[Sequence['outputs.FailureStatusCodeRangeResponse']] = None):
        """
        The trip conditions of the circuit breaker
        :param _builtins.float count: The threshold for opening the circuit.
        :param Sequence[_builtins.str] error_reasons: The error reasons which are considered as failure.
        :param _builtins.str interval: The interval during which the failures are counted.
        :param _builtins.float percentage: The threshold for opening the circuit.
        :param Sequence['FailureStatusCodeRangeResponse'] status_code_ranges: The status code ranges which are considered as failure.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if error_reasons is not None:
            pulumi.set(__self__, "error_reasons", error_reasons)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.float]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="errorReasons")
    def error_reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        The error reasons which are considered as failure.
        """
        return pulumi.get(self, "error_reasons")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        """
        The interval during which the failures are counted.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "percentage")

    @_builtins.property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.FailureStatusCodeRangeResponse']]:
        """
        The status code ranges which are considered as failure.
        """
        return pulumi.get(self, "status_code_ranges")


@pulumi.output_type
class CircuitBreakerRuleResponse(dict):
    """
    Rule configuration to trip the backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptRetryAfter":
            suggest = "accept_retry_after"
        elif key == "failureCondition":
            suggest = "failure_condition"
        elif key == "tripDuration":
            suggest = "trip_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitBreakerRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitBreakerRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitBreakerRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_retry_after: Optional[_builtins.bool] = None,
                 failure_condition: Optional['outputs.CircuitBreakerFailureConditionResponse'] = None,
                 name: Optional[_builtins.str] = None,
                 trip_duration: Optional[_builtins.str] = None):
        """
        Rule configuration to trip the backend.
        :param _builtins.bool accept_retry_after: flag to accept Retry-After header from the backend.
        :param 'CircuitBreakerFailureConditionResponse' failure_condition: The conditions for tripping the circuit breaker.
        :param _builtins.str name: The rule name.
        :param _builtins.str trip_duration: The duration for which the circuit will be tripped.
        """
        if accept_retry_after is not None:
            pulumi.set(__self__, "accept_retry_after", accept_retry_after)
        if failure_condition is not None:
            pulumi.set(__self__, "failure_condition", failure_condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trip_duration is not None:
            pulumi.set(__self__, "trip_duration", trip_duration)

    @_builtins.property
    @pulumi.getter(name="acceptRetryAfter")
    def accept_retry_after(self) -> Optional[_builtins.bool]:
        """
        flag to accept Retry-After header from the backend.
        """
        return pulumi.get(self, "accept_retry_after")

    @_builtins.property
    @pulumi.getter(name="failureCondition")
    def failure_condition(self) -> Optional['outputs.CircuitBreakerFailureConditionResponse']:
        """
        The conditions for tripping the circuit breaker.
        """
        return pulumi.get(self, "failure_condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="tripDuration")
    def trip_duration(self) -> Optional[_builtins.str]:
        """
        The duration for which the circuit will be tripped.
        """
        return pulumi.get(self, "trip_duration")


@pulumi.output_type
class DataMaskingEntityResponse(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Data masking mode.
        :param _builtins.str value: The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Data masking mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataMaskingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataMaskingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataMaskingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataMaskingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None,
                 query_params: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None):
        """
        :param Sequence['DataMaskingEntityResponse'] headers: Masking settings for headers
        :param Sequence['DataMaskingEntityResponse'] query_params: Masking settings for Url query parameters
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.DataMaskingEntityResponse']]:
        """
        Masking settings for headers
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Sequence['outputs.DataMaskingEntityResponse']]:
        """
        Masking settings for Url query parameters
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class EmailTemplateParametersContractPropertiesResponse(dict):
    """
    Email Template Parameter contract.
    """
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        Email Template Parameter contract.
        :param _builtins.str description: Template parameter description.
        :param _builtins.str name: Template parameter name.
        :param _builtins.str title: Template parameter title.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Template parameter description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Template parameter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Template parameter title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class FailureStatusCodeRangeResponse(dict):
    """
    The failure http status code range
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The failure http status code range
        :param _builtins.int max: The maximum http status code.
        :param _builtins.int min: The minimum http status code.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum http status code.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum http status code.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FrontendConfigurationResponse(dict):
    """
    Information regarding how the gateway should be exposed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultHostname":
            suggest = "default_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontendConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontendConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontendConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_hostname: _builtins.str):
        """
        Information regarding how the gateway should be exposed.
        :param _builtins.str default_hostname: The default hostname of the data-plane gateway to which requests can be sent. This is only applicable for API gateway with Standard SKU.
        """
        pulumi.set(__self__, "default_hostname", default_hostname)

    @_builtins.property
    @pulumi.getter(name="defaultHostname")
    def default_hostname(self) -> _builtins.str:
        """
        The default hostname of the data-plane gateway to which requests can be sent. This is only applicable for API gateway with Standard SKU.
        """
        return pulumi.get(self, "default_hostname")


@pulumi.output_type
class GatewayConfigurationApiResponse(dict):
    """
    Information regarding the Configuration API of the API Management gateway. This is only applicable for API gateway with Standard SKU.
    """
    def __init__(__self__, *,
                 hostname: _builtins.str):
        """
        Information regarding the Configuration API of the API Management gateway. This is only applicable for API gateway with Standard SKU.
        :param _builtins.str hostname: Hostname to which the agent connects to propagate configuration to the cloud.
        """
        pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname to which the agent connects to propagate configuration to the cloud.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class GroupContractPropertiesResponse(dict):
    """
    Group contract Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtIn":
            suggest = "built_in"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 built_in: _builtins.bool,
                 display_name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Group contract Properties.
        :param _builtins.bool built_in: true if the group is one of the three system groups (Administrators, Developers, or Guests); otherwise false.
        :param _builtins.str display_name: Group name.
        :param _builtins.str description: Group description. Can contain HTML formatting tags.
        :param _builtins.str external_id: For external groups, this property contains the id of the group from the external identity provider, e.g. for Azure Active Directory `aad://<tenant>.onmicrosoft.com/groups/<group object id>`; otherwise the value is null.
        :param _builtins.str type: Group type.
        """
        pulumi.set(__self__, "built_in", built_in)
        pulumi.set(__self__, "display_name", display_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="builtIn")
    def built_in(self) -> _builtins.bool:
        """
        true if the group is one of the three system groups (Administrators, Developers, or Guests); otherwise false.
        """
        return pulumi.get(self, "built_in")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Group name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Group description. Can contain HTML formatting tags.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        For external groups, this property contains the id of the group from the external identity provider, e.g. for Azure Active Directory `aad://<tenant>.onmicrosoft.com/groups/<group object id>`; otherwise the value is null.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Group type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HostnameConfigurationResponse(dict):
    """
    Custom hostname configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "certificatePassword":
            suggest = "certificate_password"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateStatus":
            suggest = "certificate_status"
        elif key == "defaultSslBinding":
            suggest = "default_ssl_binding"
        elif key == "encodedCertificate":
            suggest = "encoded_certificate"
        elif key == "identityClientId":
            suggest = "identity_client_id"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "negotiateClientCertificate":
            suggest = "negotiate_client_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostnameConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostnameConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostnameConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: _builtins.str,
                 type: _builtins.str,
                 certificate: Optional['outputs.CertificateInformationResponse'] = None,
                 certificate_password: Optional[_builtins.str] = None,
                 certificate_source: Optional[_builtins.str] = None,
                 certificate_status: Optional[_builtins.str] = None,
                 default_ssl_binding: Optional[_builtins.bool] = None,
                 encoded_certificate: Optional[_builtins.str] = None,
                 identity_client_id: Optional[_builtins.str] = None,
                 key_vault_id: Optional[_builtins.str] = None,
                 negotiate_client_certificate: Optional[_builtins.bool] = None):
        """
        Custom hostname configuration.
        :param _builtins.str host_name: Hostname to configure on the Api Management service.
        :param _builtins.str type: Hostname type.
        :param 'CertificateInformationResponse' certificate: Certificate information.
        :param _builtins.str certificate_password: Certificate Password.
        :param _builtins.str certificate_source: Certificate Source.
        :param _builtins.str certificate_status: Certificate Status.
        :param _builtins.bool default_ssl_binding: Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to gateway Hostname Type.
        :param _builtins.str encoded_certificate: Base64 Encoded certificate.
        :param _builtins.str identity_client_id: System or User Assigned Managed identity clientId as generated by Azure AD, which has GET access to the keyVault containing the SSL certificate.
        :param _builtins.str key_vault_id: Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with aka.ms/apimmsi. The secret should be of type *application/x-pkcs12*
        :param _builtins.bool negotiate_client_certificate: Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if certificate_status is not None:
            pulumi.set(__self__, "certificate_status", certificate_status)
        if default_ssl_binding is None:
            default_ssl_binding = False
        if default_ssl_binding is not None:
            pulumi.set(__self__, "default_ssl_binding", default_ssl_binding)
        if encoded_certificate is not None:
            pulumi.set(__self__, "encoded_certificate", encoded_certificate)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if negotiate_client_certificate is None:
            negotiate_client_certificate = False
        if negotiate_client_certificate is not None:
            pulumi.set(__self__, "negotiate_client_certificate", negotiate_client_certificate)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> _builtins.str:
        """
        Hostname to configure on the Api Management service.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Hostname type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.CertificateInformationResponse']:
        """
        Certificate information.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[_builtins.str]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[_builtins.str]:
        """
        Certificate Source.
        """
        return pulumi.get(self, "certificate_source")

    @_builtins.property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[_builtins.str]:
        """
        Certificate Status.
        """
        return pulumi.get(self, "certificate_status")

    @_builtins.property
    @pulumi.getter(name="defaultSslBinding")
    def default_ssl_binding(self) -> Optional[_builtins.bool]:
        """
        Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to gateway Hostname Type.
        """
        return pulumi.get(self, "default_ssl_binding")

    @_builtins.property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")

    @_builtins.property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[_builtins.str]:
        """
        System or User Assigned Managed identity clientId as generated by Azure AD, which has GET access to the keyVault containing the SSL certificate.
        """
        return pulumi.get(self, "identity_client_id")

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[_builtins.str]:
        """
        Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with aka.ms/apimmsi. The secret should be of type *application/x-pkcs12*
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="negotiateClientCertificate")
    def negotiate_client_certificate(self) -> Optional[_builtins.bool]:
        """
        Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        return pulumi.get(self, "negotiate_client_certificate")


@pulumi.output_type
class HttpMessageDiagnosticResponse(dict):
    """
    Http message diagnostic settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataMasking":
            suggest = "data_masking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMessageDiagnosticResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMessageDiagnosticResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMessageDiagnosticResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional['outputs.BodyDiagnosticSettingsResponse'] = None,
                 data_masking: Optional['outputs.DataMaskingResponse'] = None,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        Http message diagnostic settings.
        :param 'BodyDiagnosticSettingsResponse' body: Body logging settings.
        :param 'DataMaskingResponse' data_masking: Data masking settings.
        :param Sequence[_builtins.str] headers: Array of HTTP Headers to log.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if data_masking is not None:
            pulumi.set(__self__, "data_masking", data_masking)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.BodyDiagnosticSettingsResponse']:
        """
        Body logging settings.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> Optional['outputs.DataMaskingResponse']:
        """
        Data masking settings.
        """
        return pulumi.get(self, "data_masking")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of HTTP Headers to log.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class KeyVaultContractPropertiesResponse(dict):
    """
    KeyVault contract details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityClientId":
            suggest = "identity_client_id"
        elif key == "lastStatus":
            suggest = "last_status"
        elif key == "secretIdentifier":
            suggest = "secret_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_client_id: Optional[_builtins.str] = None,
                 last_status: Optional['outputs.KeyVaultLastAccessStatusContractPropertiesResponse'] = None,
                 secret_identifier: Optional[_builtins.str] = None):
        """
        KeyVault contract details.
        :param _builtins.str identity_client_id: Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        :param 'KeyVaultLastAccessStatusContractPropertiesResponse' last_status: Last time sync and refresh status of secret from key vault.
        :param _builtins.str secret_identifier: Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)
        if last_status is not None:
            pulumi.set(__self__, "last_status", last_status)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)

    @_builtins.property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[_builtins.str]:
        """
        Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        """
        return pulumi.get(self, "identity_client_id")

    @_builtins.property
    @pulumi.getter(name="lastStatus")
    def last_status(self) -> Optional['outputs.KeyVaultLastAccessStatusContractPropertiesResponse']:
        """
        Last time sync and refresh status of secret from key vault.
        """
        return pulumi.get(self, "last_status")

    @_builtins.property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[_builtins.str]:
        """
        Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        return pulumi.get(self, "secret_identifier")


@pulumi.output_type
class KeyVaultLastAccessStatusContractPropertiesResponse(dict):
    """
    Issue contract Update Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeStampUtc":
            suggest = "time_stamp_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultLastAccessStatusContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultLastAccessStatusContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultLastAccessStatusContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 time_stamp_utc: Optional[_builtins.str] = None):
        """
        Issue contract Update Properties.
        :param _builtins.str code: Last status code for sync and refresh of secret from key vault.
        :param _builtins.str message: Details of the error else empty.
        :param _builtins.str time_stamp_utc: Last time secret was accessed. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if time_stamp_utc is not None:
            pulumi.set(__self__, "time_stamp_utc", time_stamp_utc)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Last status code for sync and refresh of secret from key vault.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Details of the error else empty.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="timeStampUtc")
    def time_stamp_utc(self) -> Optional[_builtins.str]:
        """
        Last time secret was accessed. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        return pulumi.get(self, "time_stamp_utc")


@pulumi.output_type
class LLMDiagnosticSettingsResponse(dict):
    """
    Diagnostic settings for Large Language Models
    """
    def __init__(__self__, *,
                 logs: Optional[_builtins.str] = None,
                 requests: Optional['outputs.LLMMessageDiagnosticSettingsResponse'] = None,
                 responses: Optional['outputs.LLMMessageDiagnosticSettingsResponse'] = None):
        """
        Diagnostic settings for Large Language Models
        :param _builtins.str logs: Specifies whether default diagnostic should be enabled for Large Language Models or not.
        :param 'LLMMessageDiagnosticSettingsResponse' requests: Diagnostic settings for Large Language Models requests.
        :param 'LLMMessageDiagnosticSettingsResponse' responses: Diagnostic settings for Large Language Models responses.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[_builtins.str]:
        """
        Specifies whether default diagnostic should be enabled for Large Language Models or not.
        """
        return pulumi.get(self, "logs")

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional['outputs.LLMMessageDiagnosticSettingsResponse']:
        """
        Diagnostic settings for Large Language Models requests.
        """
        return pulumi.get(self, "requests")

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional['outputs.LLMMessageDiagnosticSettingsResponse']:
        """
        Diagnostic settings for Large Language Models responses.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class LLMMessageDiagnosticSettingsResponse(dict):
    """
    Diagnostic settings for Large Language Models Messages
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSizeInBytes":
            suggest = "max_size_in_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LLMMessageDiagnosticSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LLMMessageDiagnosticSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LLMMessageDiagnosticSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size_in_bytes: Optional[_builtins.int] = None,
                 messages: Optional[_builtins.str] = None):
        """
        Diagnostic settings for Large Language Models Messages
        :param _builtins.int max_size_in_bytes: Maximum size of message to logs in bytes. The default size is 32KB.
        :param _builtins.str messages: Specifies which message should be logged. Currently there is only 'all' option.
        """
        if max_size_in_bytes is not None:
            pulumi.set(__self__, "max_size_in_bytes", max_size_in_bytes)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)

    @_builtins.property
    @pulumi.getter(name="maxSizeInBytes")
    def max_size_in_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum size of message to logs in bytes. The default size is 32KB.
        """
        return pulumi.get(self, "max_size_in_bytes")

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[_builtins.str]:
        """
        Specifies which message should be logged. Currently there is only 'all' option.
        """
        return pulumi.get(self, "messages")


@pulumi.output_type
class OAuth2AuthenticationSettingsContractResponse(dict):
    """
    API OAuth2 Authentication settings details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationServerId":
            suggest = "authorization_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OAuth2AuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OAuth2AuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OAuth2AuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_server_id: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None):
        """
        API OAuth2 Authentication settings details.
        :param _builtins.str authorization_server_id: OAuth authorization server identifier.
        :param _builtins.str scope: operations scope.
        """
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[_builtins.str]:
        """
        OAuth authorization server identifier.
        """
        return pulumi.get(self, "authorization_server_id")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        operations scope.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class OpenIdAuthenticationSettingsContractResponse(dict):
    """
    API OAuth2 Authentication settings details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bearerTokenSendingMethods":
            suggest = "bearer_token_sending_methods"
        elif key == "openidProviderId":
            suggest = "openid_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdAuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdAuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdAuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bearer_token_sending_methods: Optional[Sequence[_builtins.str]] = None,
                 openid_provider_id: Optional[_builtins.str] = None):
        """
        API OAuth2 Authentication settings details.
        :param Sequence[_builtins.str] bearer_token_sending_methods: How to send token to the server.
        :param _builtins.str openid_provider_id: OAuth authorization server identifier.
        """
        if bearer_token_sending_methods is not None:
            pulumi.set(__self__, "bearer_token_sending_methods", bearer_token_sending_methods)
        if openid_provider_id is not None:
            pulumi.set(__self__, "openid_provider_id", openid_provider_id)

    @_builtins.property
    @pulumi.getter(name="bearerTokenSendingMethods")
    def bearer_token_sending_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        How to send token to the server.
        """
        return pulumi.get(self, "bearer_token_sending_methods")

    @_builtins.property
    @pulumi.getter(name="openidProviderId")
    def openid_provider_id(self) -> Optional[_builtins.str]:
        """
        OAuth authorization server identifier.
        """
        return pulumi.get(self, "openid_provider_id")


@pulumi.output_type
class ParameterContractResponse(dict):
    """
    Operation parameters details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
                 required: Optional[_builtins.bool] = None,
                 schema_id: Optional[_builtins.str] = None,
                 type_name: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        Operation parameters details.
        :param _builtins.str name: Parameter name.
        :param _builtins.str type: Parameter type.
        :param _builtins.str default_value: Default parameter value.
        :param _builtins.str description: Parameter description.
        :param Mapping[str, 'ParameterExampleContractResponse'] examples: Exampled defined for the parameter.
        :param _builtins.bool required: Specifies whether parameter is required or not.
        :param _builtins.str schema_id: Schema identifier.
        :param _builtins.str type_name: Type name defined by the schema.
        :param Sequence[_builtins.str] values: Parameter values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Parameter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Default parameter value.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']]:
        """
        Exampled defined for the parameter.
        """
        return pulumi.get(self, "examples")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Specifies whether parameter is required or not.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[_builtins.str]:
        """
        Schema identifier.
        """
        return pulumi.get(self, "schema_id")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[_builtins.str]:
        """
        Type name defined by the schema.
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ParameterExampleContractResponse(dict):
    """
    Parameter example.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalValue":
            suggest = "external_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterExampleContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterExampleContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterExampleContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 external_value: Optional[_builtins.str] = None,
                 summary: Optional[_builtins.str] = None,
                 value: Optional[Any] = None):
        """
        Parameter example.
        :param _builtins.str description: Long description for the example
        :param _builtins.str external_value: A URL that points to the literal example
        :param _builtins.str summary: Short description for the example
        :param Any value: Example value. May be a primitive value, or an object.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_value is not None:
            pulumi.set(__self__, "external_value", external_value)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Long description for the example
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="externalValue")
    def external_value(self) -> Optional[_builtins.str]:
        """
        A URL that points to the literal example
        """
        return pulumi.get(self, "external_value")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[_builtins.str]:
        """
        Short description for the example
        """
        return pulumi.get(self, "summary")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Example value. May be a primitive value, or an object.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineDiagnosticSettingsResponse(dict):
    """
    Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
    """
    def __init__(__self__, *,
                 request: Optional['outputs.HttpMessageDiagnosticResponse'] = None,
                 response: Optional['outputs.HttpMessageDiagnosticResponse'] = None):
        """
        Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
        :param 'HttpMessageDiagnosticResponse' request: Diagnostic settings for request.
        :param 'HttpMessageDiagnosticResponse' response: Diagnostic settings for response.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional['outputs.HttpMessageDiagnosticResponse']:
        """
        Diagnostic settings for request.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional['outputs.HttpMessageDiagnosticResponse']:
        """
        Diagnostic settings for response.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        The Private Endpoint resource.
        :param _builtins.str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param _builtins.str description: The reason for approval/rejection of the connection.
        :param _builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[_builtins.str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RemotePrivateEndpointConnectionWrapperResponse(dict):
    """
    Remote Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePrivateEndpointConnectionWrapperResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePrivateEndpointConnectionWrapperResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePrivateEndpointConnectionWrapperResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[_builtins.str],
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
                 type: Optional[_builtins.str] = None):
        """
        Remote Private Endpoint Connection resource.
        :param Sequence[_builtins.str] group_ids: All the Group ids.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param _builtins.str id: Private Endpoint connection resource id
        :param _builtins.str name: Private Endpoint Connection Name
        :param 'ArmIdWrapperResponse' private_endpoint: The resource of private end point.
        :param _builtins.str type: Private Endpoint Connection Resource Type
        """
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.str]:
        """
        All the Group ids.
        """
        return pulumi.get(self, "group_ids")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Private Endpoint connection resource id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Private Endpoint Connection Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.ArmIdWrapperResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Private Endpoint Connection Resource Type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RepresentationContractResponse(dict):
    """
    Operation request/response representation details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "formParameters":
            suggest = "form_parameters"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepresentationContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepresentationContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepresentationContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: _builtins.str,
                 examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
                 form_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 schema_id: Optional[_builtins.str] = None,
                 type_name: Optional[_builtins.str] = None):
        """
        Operation request/response representation details.
        :param _builtins.str content_type: Specifies a registered or custom content type for this representation, e.g. application/xml.
        :param Mapping[str, 'ParameterExampleContractResponse'] examples: Exampled defined for the representation.
        :param Sequence['ParameterContractResponse'] form_parameters: Collection of form parameters. Required if 'contentType' value is either 'application/x-www-form-urlencoded' or 'multipart/form-data'..
        :param _builtins.str schema_id: Schema identifier. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        :param _builtins.str type_name: Type name defined by the schema. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        pulumi.set(__self__, "content_type", content_type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if form_parameters is not None:
            pulumi.set(__self__, "form_parameters", form_parameters)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        """
        Specifies a registered or custom content type for this representation, e.g. application/xml.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']]:
        """
        Exampled defined for the representation.
        """
        return pulumi.get(self, "examples")

    @_builtins.property
    @pulumi.getter(name="formParameters")
    def form_parameters(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of form parameters. Required if 'contentType' value is either 'application/x-www-form-urlencoded' or 'multipart/form-data'..
        """
        return pulumi.get(self, "form_parameters")

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[_builtins.str]:
        """
        Schema identifier. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        return pulumi.get(self, "schema_id")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[_builtins.str]:
        """
        Type name defined by the schema. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        return pulumi.get(self, "type_name")


@pulumi.output_type
class RequestContractResponse(dict):
    """
    Operation request details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 query_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None):
        """
        Operation request details.
        :param _builtins.str description: Operation request description.
        :param Sequence['ParameterContractResponse'] headers: Collection of operation request headers.
        :param Sequence['ParameterContractResponse'] query_parameters: Collection of operation request query parameters.
        :param Sequence['RepresentationContractResponse'] representations: Collection of operation request representations.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if representations is not None:
            pulumi.set(__self__, "representations", representations)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Operation request description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation request query parameters.
        """
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter
    def representations(self) -> Optional[Sequence['outputs.RepresentationContractResponse']]:
        """
        Collection of operation request representations.
        """
        return pulumi.get(self, "representations")


@pulumi.output_type
class ResourceCollectionResponseValue(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param _builtins.str name: The name of the resource
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceLocationDataContractResponse(dict):
    """
    Resource location data properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryOrRegion":
            suggest = "country_or_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceLocationDataContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceLocationDataContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceLocationDataContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 city: Optional[_builtins.str] = None,
                 country_or_region: Optional[_builtins.str] = None,
                 district: Optional[_builtins.str] = None):
        """
        Resource location data properties.
        :param _builtins.str name: A canonical name for the geographic or physical location.
        :param _builtins.str city: The city or locality where the resource is located.
        :param _builtins.str country_or_region: The country or region where the resource is located.
        :param _builtins.str district: The district, state, or province where the resource is located.
        """
        pulumi.set(__self__, "name", name)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_or_region is not None:
            pulumi.set(__self__, "country_or_region", country_or_region)
        if district is not None:
            pulumi.set(__self__, "district", district)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A canonical name for the geographic or physical location.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        The city or locality where the resource is located.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryOrRegion")
    def country_or_region(self) -> Optional[_builtins.str]:
        """
        The country or region where the resource is located.
        """
        return pulumi.get(self, "country_or_region")

    @_builtins.property
    @pulumi.getter
    def district(self) -> Optional[_builtins.str]:
        """
        The district, state, or province where the resource is located.
        """
        return pulumi.get(self, "district")


@pulumi.output_type
class ResponseContractResponse(dict):
    """
    Operation response details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None):
        """
        Operation response details.
        :param _builtins.int status_code: Operation response HTTP status code.
        :param _builtins.str description: Operation response description.
        :param Sequence['ParameterContractResponse'] headers: Collection of operation response headers.
        :param Sequence['RepresentationContractResponse'] representations: Collection of operation response representations.
        """
        pulumi.set(__self__, "status_code", status_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if representations is not None:
            pulumi.set(__self__, "representations", representations)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.int:
        """
        Operation response HTTP status code.
        """
        return pulumi.get(self, "status_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Operation response description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation response headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def representations(self) -> Optional[Sequence['outputs.RepresentationContractResponse']]:
        """
        Collection of operation response representations.
        """
        return pulumi.get(self, "representations")


@pulumi.output_type
class SamplingSettingsResponse(dict):
    """
    Sampling settings for Diagnostic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingType":
            suggest = "sampling_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamplingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamplingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamplingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: Optional[_builtins.float] = None,
                 sampling_type: Optional[_builtins.str] = None):
        """
        Sampling settings for Diagnostic.
        :param _builtins.float percentage: Rate of sampling for fixed-rate sampling.
        :param _builtins.str sampling_type: Sampling type.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if sampling_type is not None:
            pulumi.set(__self__, "sampling_type", sampling_type)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.float]:
        """
        Rate of sampling for fixed-rate sampling.
        """
        return pulumi.get(self, "percentage")

    @_builtins.property
    @pulumi.getter(name="samplingType")
    def sampling_type(self) -> Optional[_builtins.str]:
        """
        Sampling type.
        """
        return pulumi.get(self, "sampling_type")


@pulumi.output_type
class SubscriptionKeyParameterNamesContractResponse(dict):
    """
    Subscription key parameter names details.
    """
    def __init__(__self__, *,
                 header: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None):
        """
        Subscription key parameter names details.
        :param _builtins.str header: Subscription key header name.
        :param _builtins.str query: Subscription key query string parameter name.
        """
        if header is not None:
            pulumi.set(__self__, "header", header)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[_builtins.str]:
        """
        Subscription key header name.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Subscription key query string parameter name.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TokenBodyParameterContractResponse(dict):
    """
    OAuth acquire token request body parameter (www-url-form-encoded).
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        OAuth acquire token request body parameter (www-url-form-encoded).
        :param _builtins.str name: body parameter name.
        :param _builtins.str value: body parameter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        body parameter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        body parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UserIdentityContractResponse(dict):
    """
    User identity details.
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None):
        """
        User identity details.
        :param _builtins.str id: Identifier value within provider.
        :param _builtins.str provider: Identity provider name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Identifier value within provider.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Identity provider name.
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class UserIdentityPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 principal_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The client id of user assigned identity.
        :param _builtins.str principal_id: The principal id of user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualNetworkConfigurationResponse(dict):
    """
    Configuration of a virtual network to which API Management service is deployed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetResourceId":
            suggest = "subnet_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnetname: _builtins.str,
                 vnetid: _builtins.str,
                 subnet_resource_id: Optional[_builtins.str] = None):
        """
        Configuration of a virtual network to which API Management service is deployed.
        :param _builtins.str subnetname: The name of the subnet.
        :param _builtins.str vnetid: The virtual network ID. This is typically a GUID. Expect a null GUID by default.
        :param _builtins.str subnet_resource_id: The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        pulumi.set(__self__, "subnetname", subnetname)
        pulumi.set(__self__, "vnetid", vnetid)
        if subnet_resource_id is not None:
            pulumi.set(__self__, "subnet_resource_id", subnet_resource_id)

    @_builtins.property
    @pulumi.getter
    def subnetname(self) -> _builtins.str:
        """
        The name of the subnet.
        """
        return pulumi.get(self, "subnetname")

    @_builtins.property
    @pulumi.getter
    def vnetid(self) -> _builtins.str:
        """
        The virtual network ID. This is typically a GUID. Expect a null GUID by default.
        """
        return pulumi.get(self, "vnetid")

    @_builtins.property
    @pulumi.getter(name="subnetResourceId")
    def subnet_resource_id(self) -> Optional[_builtins.str]:
        """
        The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        return pulumi.get(self, "subnet_resource_id")


@pulumi.output_type
class WikiDocumentationContractResponse(dict):
    """
    Wiki documentation details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentationId":
            suggest = "documentation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WikiDocumentationContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WikiDocumentationContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WikiDocumentationContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 documentation_id: Optional[_builtins.str] = None):
        """
        Wiki documentation details.
        :param _builtins.str documentation_id: Documentation Identifier
        """
        if documentation_id is not None:
            pulumi.set(__self__, "documentation_id", documentation_id)

    @_builtins.property
    @pulumi.getter(name="documentationId")
    def documentation_id(self) -> Optional[_builtins.str]:
        """
        Documentation Identifier
        """
        return pulumi.get(self, "documentation_id")


@pulumi.output_type
class X509CertificateNameResponse(dict):
    """
    Properties of server X509Names.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerCertificateThumbprint":
            suggest = "issuer_certificate_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509CertificateNameResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509CertificateNameResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509CertificateNameResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_certificate_thumbprint: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Properties of server X509Names.
        :param _builtins.str issuer_certificate_thumbprint: Thumbprint for the Issuer of the Certificate.
        :param _builtins.str name: Common Name of the Certificate.
        """
        if issuer_certificate_thumbprint is not None:
            pulumi.set(__self__, "issuer_certificate_thumbprint", issuer_certificate_thumbprint)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="issuerCertificateThumbprint")
    def issuer_certificate_thumbprint(self) -> Optional[_builtins.str]:
        """
        Thumbprint for the Issuer of the Certificate.
        """
        return pulumi.get(self, "issuer_certificate_thumbprint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Common Name of the Certificate.
        """
        return pulumi.get(self, "name")


