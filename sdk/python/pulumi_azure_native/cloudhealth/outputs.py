# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AlertConfigurationResponse',
    'AzureMonitorWorkspaceSignalGroupResponse',
    'AzureResourceSignalGroupResponse',
    'DependenciesSignalGroupResponse',
    'DiscoveryRulePropertiesResponse',
    'DynamicDetectionRuleResponse',
    'EntityAlertsResponse',
    'EntityCoordinatesResponse',
    'EntityPropertiesResponse',
    'EvaluationRuleResponse',
    'HealthModelPropertiesResponse',
    'IconDefinitionResponse',
    'LogAnalyticsQuerySignalDefinitionPropertiesResponse',
    'LogAnalyticsSignalGroupResponse',
    'ManagedIdentityAuthenticationSettingPropertiesResponse',
    'ManagedServiceIdentityResponse',
    'ModelDiscoverySettingsResponse',
    'PrometheusMetricsSignalDefinitionPropertiesResponse',
    'RelationshipPropertiesResponse',
    'ResourceMetricSignalDefinitionPropertiesResponse',
    'SignalAssignmentResponse',
    'SignalGroupResponse',
    'SystemDataResponse',
    'ThresholdRuleResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class AlertConfigurationResponse(dict):
    """
    Alert configuration details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupIds":
            suggest = "action_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 severity: _builtins.str,
                 action_group_ids: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None):
        """
        Alert configuration details
        :param _builtins.str severity: The severity of triggered alert.
        :param Sequence[_builtins.str] action_group_ids: Optional list of action group resource IDs to be notified when the alert is triggered.
        :param _builtins.str description: The alert rule description.
        """
        pulumi.set(__self__, "severity", severity)
        if action_group_ids is not None:
            pulumi.set(__self__, "action_group_ids", action_group_ids)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity of triggered alert.
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter(name="actionGroupIds")
    def action_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional list of action group resource IDs to be notified when the alert is triggered.
        """
        return pulumi.get(self, "action_group_ids")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The alert rule description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AzureMonitorWorkspaceSignalGroupResponse(dict):
    """
    A grouping of signal assignments for a Azure Monitor Workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationSetting":
            suggest = "authentication_setting"
        elif key == "azureMonitorWorkspaceResourceId":
            suggest = "azure_monitor_workspace_resource_id"
        elif key == "signalAssignments":
            suggest = "signal_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMonitorWorkspaceSignalGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMonitorWorkspaceSignalGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMonitorWorkspaceSignalGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_setting: _builtins.str,
                 azure_monitor_workspace_resource_id: _builtins.str,
                 signal_assignments: Optional[Sequence['outputs.SignalAssignmentResponse']] = None):
        """
        A grouping of signal assignments for a Azure Monitor Workspace
        :param _builtins.str authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param _builtins.str azure_monitor_workspace_resource_id: Azure Monitor workspace resource ID
        :param Sequence['SignalAssignmentResponse'] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_monitor_workspace_resource_id", azure_monitor_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> _builtins.str:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @_builtins.property
    @pulumi.getter(name="azureMonitorWorkspaceResourceId")
    def azure_monitor_workspace_resource_id(self) -> _builtins.str:
        """
        Azure Monitor workspace resource ID
        """
        return pulumi.get(self, "azure_monitor_workspace_resource_id")

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[Sequence['outputs.SignalAssignmentResponse']]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")


@pulumi.output_type
class AzureResourceSignalGroupResponse(dict):
    """
    A grouping of signal assignments for an Azure resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationSetting":
            suggest = "authentication_setting"
        elif key == "azureResourceId":
            suggest = "azure_resource_id"
        elif key == "signalAssignments":
            suggest = "signal_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureResourceSignalGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureResourceSignalGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureResourceSignalGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_setting: _builtins.str,
                 azure_resource_id: _builtins.str,
                 signal_assignments: Optional[Sequence['outputs.SignalAssignmentResponse']] = None):
        """
        A grouping of signal assignments for an Azure resource
        :param _builtins.str authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param _builtins.str azure_resource_id: Azure resource ID
        :param Sequence['SignalAssignmentResponse'] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> _builtins.str:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> _builtins.str:
        """
        Azure resource ID
        """
        return pulumi.get(self, "azure_resource_id")

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[Sequence['outputs.SignalAssignmentResponse']]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")


@pulumi.output_type
class DependenciesSignalGroupResponse(dict):
    """
    Properties for dependent entities, i.e. child entities
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "degradedThreshold":
            suggest = "degraded_threshold"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DependenciesSignalGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DependenciesSignalGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DependenciesSignalGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[_builtins.str] = None,
                 degraded_threshold: Optional[_builtins.str] = None,
                 unhealthy_threshold: Optional[_builtins.str] = None):
        """
        Properties for dependent entities, i.e. child entities
        :param _builtins.str aggregation_type: Aggregation type for child dependencies.
        :param _builtins.str degraded_threshold: Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        :param _builtins.str unhealthy_threshold: Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        if aggregation_type is None:
            aggregation_type = 'WorstOf'
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if degraded_threshold is not None:
            pulumi.set(__self__, "degraded_threshold", degraded_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Aggregation type for child dependencies.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="degradedThreshold")
    def degraded_threshold(self) -> Optional[_builtins.str]:
        """
        Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "degraded_threshold")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.str]:
        """
        Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class DiscoveryRulePropertiesResponse(dict):
    """
    Discovery rule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRecommendedSignals":
            suggest = "add_recommended_signals"
        elif key == "authenticationSetting":
            suggest = "authentication_setting"
        elif key == "deletionDate":
            suggest = "deletion_date"
        elif key == "discoverRelationships":
            suggest = "discover_relationships"
        elif key == "entityName":
            suggest = "entity_name"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "numberOfDiscoveredEntities":
            suggest = "number_of_discovered_entities"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGraphQuery":
            suggest = "resource_graph_query"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveryRulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveryRulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveryRulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_recommended_signals: _builtins.str,
                 authentication_setting: _builtins.str,
                 deletion_date: _builtins.str,
                 discover_relationships: _builtins.str,
                 entity_name: _builtins.str,
                 error_message: _builtins.str,
                 number_of_discovered_entities: _builtins.int,
                 provisioning_state: _builtins.str,
                 resource_graph_query: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        Discovery rule properties
        :param _builtins.str add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param _builtins.str authentication_setting: Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        :param _builtins.str deletion_date: Date when the discovery rule was (soft-)deleted.
        :param _builtins.str discover_relationships: Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        :param _builtins.str entity_name: Name of the entity which represents the discovery rule. Note: It might take a few minutes after creating the discovery rule until the entity is created.
        :param _builtins.str error_message: Error message if the last discovery operation failed.
        :param _builtins.int number_of_discovered_entities: Number of discovered entities in the last discovery operation.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str resource_graph_query: Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        :param _builtins.str display_name: Display name
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "discover_relationships", discover_relationships)
        pulumi.set(__self__, "entity_name", entity_name)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "number_of_discovered_entities", number_of_discovered_entities)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_graph_query", resource_graph_query)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> _builtins.str:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> _builtins.str:
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        return pulumi.get(self, "authentication_setting")

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the discovery rule was (soft-)deleted.
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="discoverRelationships")
    def discover_relationships(self) -> _builtins.str:
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        return pulumi.get(self, "discover_relationships")

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> _builtins.str:
        """
        Name of the entity which represents the discovery rule. Note: It might take a few minutes after creating the discovery rule until the entity is created.
        """
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        Error message if the last discovery operation failed.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="numberOfDiscoveredEntities")
    def number_of_discovered_entities(self) -> _builtins.int:
        """
        Number of discovered entities in the last discovery operation.
        """
        return pulumi.get(self, "number_of_discovered_entities")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="resourceGraphQuery")
    def resource_graph_query(self) -> _builtins.str:
        """
        Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        """
        return pulumi.get(self, "resource_graph_query")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class DynamicDetectionRuleResponse(dict):
    """
    ML-based evaluation rule for a signal definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicThresholdDirection":
            suggest = "dynamic_threshold_direction"
        elif key == "dynamicThresholdModel":
            suggest = "dynamic_threshold_model"
        elif key == "modelSensitivity":
            suggest = "model_sensitivity"
        elif key == "trainingStartTime":
            suggest = "training_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicDetectionRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicDetectionRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicDetectionRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_threshold_direction: _builtins.str,
                 dynamic_threshold_model: _builtins.str,
                 model_sensitivity: _builtins.float,
                 training_start_time: Optional[_builtins.str] = None):
        """
        ML-based evaluation rule for a signal definition
        :param _builtins.str dynamic_threshold_direction: Threshold direction
        :param _builtins.str dynamic_threshold_model: ML model to use for dynamic thresholds
        :param _builtins.float model_sensitivity: ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        :param _builtins.str training_start_time: Start time of the training in UTC.
        """
        pulumi.set(__self__, "dynamic_threshold_direction", dynamic_threshold_direction)
        pulumi.set(__self__, "dynamic_threshold_model", dynamic_threshold_model)
        pulumi.set(__self__, "model_sensitivity", model_sensitivity)
        if training_start_time is not None:
            pulumi.set(__self__, "training_start_time", training_start_time)

    @_builtins.property
    @pulumi.getter(name="dynamicThresholdDirection")
    def dynamic_threshold_direction(self) -> _builtins.str:
        """
        Threshold direction
        """
        return pulumi.get(self, "dynamic_threshold_direction")

    @_builtins.property
    @pulumi.getter(name="dynamicThresholdModel")
    def dynamic_threshold_model(self) -> _builtins.str:
        """
        ML model to use for dynamic thresholds
        """
        return pulumi.get(self, "dynamic_threshold_model")

    @_builtins.property
    @pulumi.getter(name="modelSensitivity")
    def model_sensitivity(self) -> _builtins.float:
        """
        ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        """
        return pulumi.get(self, "model_sensitivity")

    @_builtins.property
    @pulumi.getter(name="trainingStartTime")
    def training_start_time(self) -> Optional[_builtins.str]:
        """
        Start time of the training in UTC.
        """
        return pulumi.get(self, "training_start_time")


@pulumi.output_type
class EntityAlertsResponse(dict):
    """
    Alert configuration for an entity
    """
    def __init__(__self__, *,
                 degraded: Optional['outputs.AlertConfigurationResponse'] = None,
                 unhealthy: Optional['outputs.AlertConfigurationResponse'] = None):
        """
        Alert configuration for an entity
        :param 'AlertConfigurationResponse' degraded: Alert to be triggered on state change to degraded
        :param 'AlertConfigurationResponse' unhealthy: Alert to be triggered on state change to unhealthy
        """
        if degraded is not None:
            pulumi.set(__self__, "degraded", degraded)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @_builtins.property
    @pulumi.getter
    def degraded(self) -> Optional['outputs.AlertConfigurationResponse']:
        """
        Alert to be triggered on state change to degraded
        """
        return pulumi.get(self, "degraded")

    @_builtins.property
    @pulumi.getter
    def unhealthy(self) -> Optional['outputs.AlertConfigurationResponse']:
        """
        Alert to be triggered on state change to unhealthy
        """
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class EntityCoordinatesResponse(dict):
    """
    Visual position of the entity
    """
    def __init__(__self__, *,
                 x: _builtins.float,
                 y: _builtins.float):
        """
        Visual position of the entity
        :param _builtins.float x: X Coordinate
        :param _builtins.float y: Y Coordinate
        """
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.float:
        """
        X Coordinate
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter
    def y(self) -> _builtins.float:
        """
        Y Coordinate
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class EntityPropertiesResponse(dict):
    """
    Properties which are common across all kinds of entities
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletionDate":
            suggest = "deletion_date"
        elif key == "discoveredBy":
            suggest = "discovered_by"
        elif key == "healthState":
            suggest = "health_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "canvasPosition":
            suggest = "canvas_position"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "healthObjective":
            suggest = "health_objective"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deletion_date: _builtins.str,
                 discovered_by: _builtins.str,
                 health_state: _builtins.str,
                 provisioning_state: _builtins.str,
                 alerts: Optional['outputs.EntityAlertsResponse'] = None,
                 canvas_position: Optional['outputs.EntityCoordinatesResponse'] = None,
                 display_name: Optional[_builtins.str] = None,
                 health_objective: Optional[_builtins.float] = None,
                 icon: Optional['outputs.IconDefinitionResponse'] = None,
                 impact: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 signals: Optional['outputs.SignalGroupResponse'] = None):
        """
        Properties which are common across all kinds of entities
        :param _builtins.str deletion_date: Date when the entity was (soft-)deleted
        :param _builtins.str discovered_by: Discovered by which discovery rule. If set, the entity cannot be deleted manually.
        :param _builtins.str health_state: Health state of this entity
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'EntityAlertsResponse' alerts: Alert configuration for this entity
        :param 'EntityCoordinatesResponse' canvas_position: Positioning of the entity on the model canvas
        :param _builtins.str display_name: Display name
        :param _builtins.float health_objective: Health objective as a percentage of time the entity should be healthy.
        :param 'IconDefinitionResponse' icon: Visual icon definition. If not set, a default icon is used.
        :param _builtins.str impact: Impact of the entity in health state propagation
        :param _builtins.str kind: Entity kind
        :param Mapping[str, _builtins.str] labels: Optional set of labels (key-value pairs)
        :param 'SignalGroupResponse' signals: Signal groups which are assigned to this entity
        """
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "discovered_by", discovered_by)
        pulumi.set(__self__, "health_state", health_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if canvas_position is not None:
            pulumi.set(__self__, "canvas_position", canvas_position)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if health_objective is not None:
            pulumi.set(__self__, "health_objective", health_objective)
        if icon is not None:
            pulumi.set(__self__, "icon", icon)
        if impact is None:
            impact = 'Standard'
        if impact is not None:
            pulumi.set(__self__, "impact", impact)
        if kind is None:
            kind = 'Default'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if signals is not None:
            pulumi.set(__self__, "signals", signals)

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the entity was (soft-)deleted
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="discoveredBy")
    def discovered_by(self) -> _builtins.str:
        """
        Discovered by which discovery rule. If set, the entity cannot be deleted manually.
        """
        return pulumi.get(self, "discovered_by")

    @_builtins.property
    @pulumi.getter(name="healthState")
    def health_state(self) -> _builtins.str:
        """
        Health state of this entity
        """
        return pulumi.get(self, "health_state")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional['outputs.EntityAlertsResponse']:
        """
        Alert configuration for this entity
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter(name="canvasPosition")
    def canvas_position(self) -> Optional['outputs.EntityCoordinatesResponse']:
        """
        Positioning of the entity on the model canvas
        """
        return pulumi.get(self, "canvas_position")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="healthObjective")
    def health_objective(self) -> Optional[_builtins.float]:
        """
        Health objective as a percentage of time the entity should be healthy.
        """
        return pulumi.get(self, "health_objective")

    @_builtins.property
    @pulumi.getter
    def icon(self) -> Optional['outputs.IconDefinitionResponse']:
        """
        Visual icon definition. If not set, a default icon is used.
        """
        return pulumi.get(self, "icon")

    @_builtins.property
    @pulumi.getter
    def impact(self) -> Optional[_builtins.str]:
        """
        Impact of the entity in health state propagation
        """
        return pulumi.get(self, "impact")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Entity kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def signals(self) -> Optional['outputs.SignalGroupResponse']:
        """
        Signal groups which are assigned to this entity
        """
        return pulumi.get(self, "signals")


@pulumi.output_type
class EvaluationRuleResponse(dict):
    """
    Evaluation rule for a signal definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradedRule":
            suggest = "degraded_rule"
        elif key == "dynamicDetectionRule":
            suggest = "dynamic_detection_rule"
        elif key == "unhealthyRule":
            suggest = "unhealthy_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvaluationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvaluationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvaluationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degraded_rule: Optional['outputs.ThresholdRuleResponse'] = None,
                 dynamic_detection_rule: Optional['outputs.DynamicDetectionRuleResponse'] = None,
                 unhealthy_rule: Optional['outputs.ThresholdRuleResponse'] = None):
        """
        Evaluation rule for a signal definition
        :param 'ThresholdRuleResponse' degraded_rule: Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        :param 'DynamicDetectionRuleResponse' dynamic_detection_rule: Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        :param 'ThresholdRuleResponse' unhealthy_rule: Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        if degraded_rule is not None:
            pulumi.set(__self__, "degraded_rule", degraded_rule)
        if dynamic_detection_rule is not None:
            pulumi.set(__self__, "dynamic_detection_rule", dynamic_detection_rule)
        if unhealthy_rule is not None:
            pulumi.set(__self__, "unhealthy_rule", unhealthy_rule)

    @_builtins.property
    @pulumi.getter(name="degradedRule")
    def degraded_rule(self) -> Optional['outputs.ThresholdRuleResponse']:
        """
        Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "degraded_rule")

    @_builtins.property
    @pulumi.getter(name="dynamicDetectionRule")
    def dynamic_detection_rule(self) -> Optional['outputs.DynamicDetectionRuleResponse']:
        """
        Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        """
        return pulumi.get(self, "dynamic_detection_rule")

    @_builtins.property
    @pulumi.getter(name="unhealthyRule")
    def unhealthy_rule(self) -> Optional['outputs.ThresholdRuleResponse']:
        """
        Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "unhealthy_rule")


@pulumi.output_type
class HealthModelPropertiesResponse(dict):
    """
    HealthModel properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataplaneEndpoint":
            suggest = "dataplane_endpoint"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthModelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthModelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthModelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataplane_endpoint: _builtins.str,
                 provisioning_state: _builtins.str,
                 discovery: Optional['outputs.ModelDiscoverySettingsResponse'] = None):
        """
        HealthModel properties
        :param _builtins.str dataplane_endpoint: The data plane endpoint for interacting with health data
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'ModelDiscoverySettingsResponse' discovery: Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        pulumi.set(__self__, "dataplane_endpoint", dataplane_endpoint)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if discovery is not None:
            pulumi.set(__self__, "discovery", discovery)

    @_builtins.property
    @pulumi.getter(name="dataplaneEndpoint")
    def dataplane_endpoint(self) -> _builtins.str:
        """
        The data plane endpoint for interacting with health data
        """
        return pulumi.get(self, "dataplane_endpoint")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def discovery(self) -> Optional['outputs.ModelDiscoverySettingsResponse']:
        """
        Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        return pulumi.get(self, "discovery")


@pulumi.output_type
class IconDefinitionResponse(dict):
    """
    Visual icon definition of an entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iconName":
            suggest = "icon_name"
        elif key == "customData":
            suggest = "custom_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IconDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IconDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IconDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 icon_name: _builtins.str,
                 custom_data: Optional[_builtins.str] = None):
        """
        Visual icon definition of an entity
        :param _builtins.str icon_name: Name of the built-in icon, or 'Custom' to use customData
        :param _builtins.str custom_data: Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        pulumi.set(__self__, "icon_name", icon_name)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @_builtins.property
    @pulumi.getter(name="iconName")
    def icon_name(self) -> _builtins.str:
        """
        Name of the built-in icon, or 'Custom' to use customData
        """
        return pulumi.get(self, "icon_name")

    @_builtins.property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[_builtins.str]:
        """
        Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        return pulumi.get(self, "custom_data")


@pulumi.output_type
class LogAnalyticsQuerySignalDefinitionPropertiesResponse(dict):
    """
    Log Analytics Query Signal Definition properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletionDate":
            suggest = "deletion_date"
        elif key == "evaluationRules":
            suggest = "evaluation_rules"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "queryText":
            suggest = "query_text"
        elif key == "signalKind":
            suggest = "signal_kind"
        elif key == "dataUnit":
            suggest = "data_unit"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "refreshInterval":
            suggest = "refresh_interval"
        elif key == "timeGrain":
            suggest = "time_grain"
        elif key == "valueColumnName":
            suggest = "value_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsQuerySignalDefinitionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsQuerySignalDefinitionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsQuerySignalDefinitionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deletion_date: _builtins.str,
                 evaluation_rules: 'outputs.EvaluationRuleResponse',
                 provisioning_state: _builtins.str,
                 query_text: _builtins.str,
                 signal_kind: _builtins.str,
                 data_unit: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 refresh_interval: Optional[_builtins.str] = None,
                 time_grain: Optional[_builtins.str] = None,
                 value_column_name: Optional[_builtins.str] = None):
        """
        Log Analytics Query Signal Definition properties
        :param _builtins.str deletion_date: Date when the signal definition was (soft-)deleted
        :param 'EvaluationRuleResponse' evaluation_rules: Evaluation rules for the signal definition
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str query_text: Query text in KQL syntax
        :param _builtins.str signal_kind: Supported signal kinds as discriminator
               Expected value is 'LogAnalyticsQuery'.
        :param _builtins.str data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param _builtins.str display_name: Display name
        :param Mapping[str, _builtins.str] labels: Optional set of labels (key-value pairs)
        :param _builtins.str refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param _builtins.str time_grain: Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        :param _builtins.str value_column_name: Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'LogAnalyticsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)
        if value_column_name is not None:
            pulumi.set(__self__, "value_column_name", value_column_name)

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the signal definition was (soft-)deleted
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> 'outputs.EvaluationRuleResponse':
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="queryText")
    def query_text(self) -> _builtins.str:
        """
        Query text in KQL syntax
        """
        return pulumi.get(self, "query_text")

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> _builtins.str:
        """
        Supported signal kinds as discriminator
        Expected value is 'LogAnalyticsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[_builtins.str]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[_builtins.str]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[_builtins.str]:
        """
        Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        """
        return pulumi.get(self, "time_grain")

    @_builtins.property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> Optional[_builtins.str]:
        """
        Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        return pulumi.get(self, "value_column_name")


@pulumi.output_type
class LogAnalyticsSignalGroupResponse(dict):
    """
    A grouping of signal assignments for a Log Analytics Workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationSetting":
            suggest = "authentication_setting"
        elif key == "logAnalyticsWorkspaceResourceId":
            suggest = "log_analytics_workspace_resource_id"
        elif key == "signalAssignments":
            suggest = "signal_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsSignalGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsSignalGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsSignalGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_setting: _builtins.str,
                 log_analytics_workspace_resource_id: _builtins.str,
                 signal_assignments: Optional[Sequence['outputs.SignalAssignmentResponse']] = None):
        """
        A grouping of signal assignments for a Log Analytics Workspace
        :param _builtins.str authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param _builtins.str log_analytics_workspace_resource_id: Log Analytics Workspace resource ID
        :param Sequence['SignalAssignmentResponse'] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "log_analytics_workspace_resource_id", log_analytics_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> _builtins.str:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceResourceId")
    def log_analytics_workspace_resource_id(self) -> _builtins.str:
        """
        Log Analytics Workspace resource ID
        """
        return pulumi.get(self, "log_analytics_workspace_resource_id")

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[Sequence['outputs.SignalAssignmentResponse']]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")


@pulumi.output_type
class ManagedIdentityAuthenticationSettingPropertiesResponse(dict):
    """
    Authentication setting properties for Azure Managed Identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationKind":
            suggest = "authentication_kind"
        elif key == "managedIdentityName":
            suggest = "managed_identity_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityAuthenticationSettingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityAuthenticationSettingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityAuthenticationSettingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_kind: _builtins.str,
                 managed_identity_name: _builtins.str,
                 provisioning_state: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        Authentication setting properties for Azure Managed Identity
        :param _builtins.str authentication_kind: Supported kinds of authentication settings as discriminator
               Expected value is 'ManagedIdentity'.
        :param _builtins.str managed_identity_name: Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str display_name: Display name
        """
        pulumi.set(__self__, "authentication_kind", 'ManagedIdentity')
        pulumi.set(__self__, "managed_identity_name", managed_identity_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="authenticationKind")
    def authentication_kind(self) -> _builtins.str:
        """
        Supported kinds of authentication settings as discriminator
        Expected value is 'ManagedIdentity'.
        """
        return pulumi.get(self, "authentication_kind")

    @_builtins.property
    @pulumi.getter(name="managedIdentityName")
    def managed_identity_name(self) -> _builtins.str:
        """
        Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        """
        return pulumi.get(self, "managed_identity_name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ModelDiscoverySettingsResponse(dict):
    """
    Settings for automatically discovering entities for the health model.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRecommendedSignals":
            suggest = "add_recommended_signals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelDiscoverySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelDiscoverySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelDiscoverySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_recommended_signals: _builtins.str,
                 scope: _builtins.str,
                 identity: Optional[_builtins.str] = None):
        """
        Settings for automatically discovering entities for the health model.
        :param _builtins.str add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param _builtins.str scope: The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        :param _builtins.str identity: Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "scope", scope)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @_builtins.property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> _builtins.str:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class PrometheusMetricsSignalDefinitionPropertiesResponse(dict):
    """
    Prometheus Metrics Signal Definition properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletionDate":
            suggest = "deletion_date"
        elif key == "evaluationRules":
            suggest = "evaluation_rules"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "queryText":
            suggest = "query_text"
        elif key == "signalKind":
            suggest = "signal_kind"
        elif key == "dataUnit":
            suggest = "data_unit"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "refreshInterval":
            suggest = "refresh_interval"
        elif key == "timeGrain":
            suggest = "time_grain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusMetricsSignalDefinitionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusMetricsSignalDefinitionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusMetricsSignalDefinitionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deletion_date: _builtins.str,
                 evaluation_rules: 'outputs.EvaluationRuleResponse',
                 provisioning_state: _builtins.str,
                 query_text: _builtins.str,
                 signal_kind: _builtins.str,
                 data_unit: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 refresh_interval: Optional[_builtins.str] = None,
                 time_grain: Optional[_builtins.str] = None):
        """
        Prometheus Metrics Signal Definition properties
        :param _builtins.str deletion_date: Date when the signal definition was (soft-)deleted
        :param 'EvaluationRuleResponse' evaluation_rules: Evaluation rules for the signal definition
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str query_text: Query text in PromQL syntax
        :param _builtins.str signal_kind: Supported signal kinds as discriminator
               Expected value is 'PrometheusMetricsQuery'.
        :param _builtins.str data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param _builtins.str display_name: Display name
        :param Mapping[str, _builtins.str] labels: Optional set of labels (key-value pairs)
        :param _builtins.str refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param _builtins.str time_grain: Time range of signal. ISO duration format like PT10M.
        """
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'PrometheusMetricsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the signal definition was (soft-)deleted
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> 'outputs.EvaluationRuleResponse':
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="queryText")
    def query_text(self) -> _builtins.str:
        """
        Query text in PromQL syntax
        """
        return pulumi.get(self, "query_text")

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> _builtins.str:
        """
        Supported signal kinds as discriminator
        Expected value is 'PrometheusMetricsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[_builtins.str]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[_builtins.str]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[_builtins.str]:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")


@pulumi.output_type
class RelationshipPropertiesResponse(dict):
    """
    Relationship properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "childEntityName":
            suggest = "child_entity_name"
        elif key == "deletionDate":
            suggest = "deletion_date"
        elif key == "discoveredBy":
            suggest = "discovered_by"
        elif key == "parentEntityName":
            suggest = "parent_entity_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RelationshipPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RelationshipPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RelationshipPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 child_entity_name: _builtins.str,
                 deletion_date: _builtins.str,
                 discovered_by: _builtins.str,
                 parent_entity_name: _builtins.str,
                 provisioning_state: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        Relationship properties
        :param _builtins.str child_entity_name: Resource name of the child entity
        :param _builtins.str deletion_date: Date when the relationship was (soft-)deleted
        :param _builtins.str discovered_by: Discovered by which discovery rule. If set, the relationship cannot be deleted manually.
        :param _builtins.str parent_entity_name: Resource name of the parent entity
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str display_name: Display name
        :param Mapping[str, _builtins.str] labels: Optional set of labels (key-value pairs)
        """
        pulumi.set(__self__, "child_entity_name", child_entity_name)
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "discovered_by", discovered_by)
        pulumi.set(__self__, "parent_entity_name", parent_entity_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter(name="childEntityName")
    def child_entity_name(self) -> _builtins.str:
        """
        Resource name of the child entity
        """
        return pulumi.get(self, "child_entity_name")

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the relationship was (soft-)deleted
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="discoveredBy")
    def discovered_by(self) -> _builtins.str:
        """
        Discovered by which discovery rule. If set, the relationship cannot be deleted manually.
        """
        return pulumi.get(self, "discovered_by")

    @_builtins.property
    @pulumi.getter(name="parentEntityName")
    def parent_entity_name(self) -> _builtins.str:
        """
        Resource name of the parent entity
        """
        return pulumi.get(self, "parent_entity_name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ResourceMetricSignalDefinitionPropertiesResponse(dict):
    """
    Azure Resource Metric Signal Definition properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "deletionDate":
            suggest = "deletion_date"
        elif key == "evaluationRules":
            suggest = "evaluation_rules"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "signalKind":
            suggest = "signal_kind"
        elif key == "timeGrain":
            suggest = "time_grain"
        elif key == "dataUnit":
            suggest = "data_unit"
        elif key == "dimensionFilter":
            suggest = "dimension_filter"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "refreshInterval":
            suggest = "refresh_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMetricSignalDefinitionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMetricSignalDefinitionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMetricSignalDefinitionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: _builtins.str,
                 deletion_date: _builtins.str,
                 evaluation_rules: 'outputs.EvaluationRuleResponse',
                 metric_name: _builtins.str,
                 metric_namespace: _builtins.str,
                 provisioning_state: _builtins.str,
                 signal_kind: _builtins.str,
                 time_grain: _builtins.str,
                 data_unit: Optional[_builtins.str] = None,
                 dimension: Optional[_builtins.str] = None,
                 dimension_filter: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 refresh_interval: Optional[_builtins.str] = None):
        """
        Azure Resource Metric Signal Definition properties
        :param _builtins.str aggregation_type: Type of aggregation to apply to the metric
        :param _builtins.str deletion_date: Date when the signal definition was (soft-)deleted
        :param 'EvaluationRuleResponse' evaluation_rules: Evaluation rules for the signal definition
        :param _builtins.str metric_name: Name of the metric
        :param _builtins.str metric_namespace: Metric namespace
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str signal_kind: Supported signal kinds as discriminator
               Expected value is 'AzureResourceMetric'.
        :param _builtins.str time_grain: Time range of signal. ISO duration format like PT10M.
        :param _builtins.str data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param _builtins.str dimension: Optional: Dimension to split by
        :param _builtins.str dimension_filter: Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        :param _builtins.str display_name: Display name
        :param Mapping[str, _builtins.str] labels: Optional set of labels (key-value pairs)
        :param _builtins.str refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "deletion_date", deletion_date)
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "signal_kind", 'AzureResourceMetric')
        pulumi.set(__self__, "time_grain", time_grain)
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Type of aggregation to apply to the metric
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="deletionDate")
    def deletion_date(self) -> _builtins.str:
        """
        Date when the signal definition was (soft-)deleted
        """
        return pulumi.get(self, "deletion_date")

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> 'outputs.EvaluationRuleResponse':
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> _builtins.str:
        """
        Metric namespace
        """
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> _builtins.str:
        """
        Supported signal kinds as discriminator
        Expected value is 'AzureResourceMetric'.
        """
        return pulumi.get(self, "signal_kind")

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> _builtins.str:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[_builtins.str]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        Optional: Dimension to split by
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional[_builtins.str]:
        """
        Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        """
        return pulumi.get(self, "dimension_filter")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[_builtins.str]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")


@pulumi.output_type
class SignalAssignmentResponse(dict):
    """
    Group of signal definition assignments
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signalDefinitions":
            suggest = "signal_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalAssignmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalAssignmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalAssignmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 signal_definitions: Sequence[_builtins.str]):
        """
        Group of signal definition assignments
        :param Sequence[_builtins.str] signal_definitions: Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        pulumi.set(__self__, "signal_definitions", signal_definitions)

    @_builtins.property
    @pulumi.getter(name="signalDefinitions")
    def signal_definitions(self) -> Sequence[_builtins.str]:
        """
        Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        return pulumi.get(self, "signal_definitions")


@pulumi.output_type
class SignalGroupResponse(dict):
    """
    Contains various signal groups that can be assigned to an entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureLogAnalytics":
            suggest = "azure_log_analytics"
        elif key == "azureMonitorWorkspace":
            suggest = "azure_monitor_workspace"
        elif key == "azureResource":
            suggest = "azure_resource"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_log_analytics: Optional['outputs.LogAnalyticsSignalGroupResponse'] = None,
                 azure_monitor_workspace: Optional['outputs.AzureMonitorWorkspaceSignalGroupResponse'] = None,
                 azure_resource: Optional['outputs.AzureResourceSignalGroupResponse'] = None,
                 dependencies: Optional['outputs.DependenciesSignalGroupResponse'] = None):
        """
        Contains various signal groups that can be assigned to an entity
        :param 'LogAnalyticsSignalGroupResponse' azure_log_analytics: Log Analytics Signal Group
        :param 'AzureMonitorWorkspaceSignalGroupResponse' azure_monitor_workspace: Azure Monitor Workspace Signal Group
        :param 'AzureResourceSignalGroupResponse' azure_resource: Azure Resource Signal Group
        :param 'DependenciesSignalGroupResponse' dependencies: Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        if azure_log_analytics is not None:
            pulumi.set(__self__, "azure_log_analytics", azure_log_analytics)
        if azure_monitor_workspace is not None:
            pulumi.set(__self__, "azure_monitor_workspace", azure_monitor_workspace)
        if azure_resource is not None:
            pulumi.set(__self__, "azure_resource", azure_resource)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter(name="azureLogAnalytics")
    def azure_log_analytics(self) -> Optional['outputs.LogAnalyticsSignalGroupResponse']:
        """
        Log Analytics Signal Group
        """
        return pulumi.get(self, "azure_log_analytics")

    @_builtins.property
    @pulumi.getter(name="azureMonitorWorkspace")
    def azure_monitor_workspace(self) -> Optional['outputs.AzureMonitorWorkspaceSignalGroupResponse']:
        """
        Azure Monitor Workspace Signal Group
        """
        return pulumi.get(self, "azure_monitor_workspace")

    @_builtins.property
    @pulumi.getter(name="azureResource")
    def azure_resource(self) -> Optional['outputs.AzureResourceSignalGroupResponse']:
        """
        Azure Resource Signal Group
        """
        return pulumi.get(self, "azure_resource")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional['outputs.DependenciesSignalGroupResponse']:
        """
        Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        return pulumi.get(self, "dependencies")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class ThresholdRuleResponse(dict):
    """
    Threshold-based evaluation rule for a signal definition
    """
    def __init__(__self__, *,
                 operator: _builtins.str,
                 threshold: _builtins.str):
        """
        Threshold-based evaluation rule for a signal definition
        :param _builtins.str operator: Operator how to compare the signal value with the threshold
        :param _builtins.str threshold: Threshold value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operator how to compare the signal value with the threshold
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        Threshold value
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


