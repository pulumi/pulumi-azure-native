# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AlertConfigurationArgs',
    'AlertConfigurationArgsDict',
    'AzureMonitorWorkspaceSignalGroupArgs',
    'AzureMonitorWorkspaceSignalGroupArgsDict',
    'AzureResourceSignalGroupArgs',
    'AzureResourceSignalGroupArgsDict',
    'DependenciesSignalGroupArgs',
    'DependenciesSignalGroupArgsDict',
    'DiscoveryRulePropertiesArgs',
    'DiscoveryRulePropertiesArgsDict',
    'DynamicDetectionRuleArgs',
    'DynamicDetectionRuleArgsDict',
    'EntityAlertsArgs',
    'EntityAlertsArgsDict',
    'EntityCoordinatesArgs',
    'EntityCoordinatesArgsDict',
    'EntityPropertiesArgs',
    'EntityPropertiesArgsDict',
    'EvaluationRuleArgs',
    'EvaluationRuleArgsDict',
    'HealthModelPropertiesArgs',
    'HealthModelPropertiesArgsDict',
    'IconDefinitionArgs',
    'IconDefinitionArgsDict',
    'LogAnalyticsQuerySignalDefinitionPropertiesArgs',
    'LogAnalyticsQuerySignalDefinitionPropertiesArgsDict',
    'LogAnalyticsSignalGroupArgs',
    'LogAnalyticsSignalGroupArgsDict',
    'ManagedIdentityAuthenticationSettingPropertiesArgs',
    'ManagedIdentityAuthenticationSettingPropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'ModelDiscoverySettingsArgs',
    'ModelDiscoverySettingsArgsDict',
    'PrometheusMetricsSignalDefinitionPropertiesArgs',
    'PrometheusMetricsSignalDefinitionPropertiesArgsDict',
    'RelationshipPropertiesArgs',
    'RelationshipPropertiesArgsDict',
    'ResourceMetricSignalDefinitionPropertiesArgs',
    'ResourceMetricSignalDefinitionPropertiesArgsDict',
    'SignalAssignmentArgs',
    'SignalAssignmentArgsDict',
    'SignalGroupArgs',
    'SignalGroupArgsDict',
    'ThresholdRuleArgs',
    'ThresholdRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AlertConfigurationArgsDict(TypedDict):
        """
        Alert configuration details
        """
        severity: pulumi.Input[Union[builtins.str, 'AlertSeverity']]
        """
        The severity of triggered alert.
        """
        action_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional list of action group resource IDs to be notified when the alert is triggered.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The alert rule description.
        """
elif False:
    AlertConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationArgs:
    def __init__(__self__, *,
                 severity: pulumi.Input[Union[builtins.str, 'AlertSeverity']],
                 action_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        Alert configuration details
        :param pulumi.Input[Union[builtins.str, 'AlertSeverity']] severity: The severity of triggered alert.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] action_group_ids: Optional list of action group resource IDs to be notified when the alert is triggered.
        :param pulumi.Input[builtins.str] description: The alert rule description.
        """
        pulumi.set(__self__, "severity", severity)
        if action_group_ids is not None:
            pulumi.set(__self__, "action_group_ids", action_group_ids)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[Union[builtins.str, 'AlertSeverity']]:
        """
        The severity of triggered alert.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[Union[builtins.str, 'AlertSeverity']]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="actionGroupIds")
    def action_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional list of action group resource IDs to be notified when the alert is triggered.
        """
        return pulumi.get(self, "action_group_ids")

    @action_group_ids.setter
    def action_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "action_group_ids", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The alert rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AzureMonitorWorkspaceSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for a Azure Monitor Workspace
        """
        authentication_setting: pulumi.Input[builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        azure_monitor_workspace_resource_id: pulumi.Input[builtins.str]
        """
        Azure Monitor workspace resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    AzureMonitorWorkspaceSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorWorkspaceSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[builtins.str],
                 azure_monitor_workspace_resource_id: pulumi.Input[builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for a Azure Monitor Workspace
        :param pulumi.Input[builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[builtins.str] azure_monitor_workspace_resource_id: Azure Monitor workspace resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_monitor_workspace_resource_id", azure_monitor_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @property
    @pulumi.getter(name="azureMonitorWorkspaceResourceId")
    def azure_monitor_workspace_resource_id(self) -> pulumi.Input[builtins.str]:
        """
        Azure Monitor workspace resource ID
        """
        return pulumi.get(self, "azure_monitor_workspace_resource_id")

    @azure_monitor_workspace_resource_id.setter
    def azure_monitor_workspace_resource_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "azure_monitor_workspace_resource_id", value)

    @property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class AzureResourceSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for an Azure resource
        """
        authentication_setting: pulumi.Input[builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        azure_resource_id: pulumi.Input[builtins.str]
        """
        Azure resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    AzureResourceSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureResourceSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[builtins.str],
                 azure_resource_id: pulumi.Input[builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for an Azure resource
        :param pulumi.Input[builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[builtins.str] azure_resource_id: Azure resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> pulumi.Input[builtins.str]:
        """
        Azure resource ID
        """
        return pulumi.get(self, "azure_resource_id")

    @azure_resource_id.setter
    def azure_resource_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "azure_resource_id", value)

    @property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class DependenciesSignalGroupArgsDict(TypedDict):
        """
        Properties for dependent entities, i.e. child entities
        """
        aggregation_type: pulumi.Input[Union[builtins.str, 'DependenciesAggregationType']]
        """
        Aggregation type for child dependencies.
        """
        degraded_threshold: NotRequired[pulumi.Input[builtins.str]]
        """
        Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[builtins.str]]
        """
        Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
elif False:
    DependenciesSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DependenciesSignalGroupArgs:
    def __init__(__self__, *,
                 aggregation_type: Optional[pulumi.Input[Union[builtins.str, 'DependenciesAggregationType']]] = None,
                 degraded_threshold: Optional[pulumi.Input[builtins.str]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties for dependent entities, i.e. child entities
        :param pulumi.Input[Union[builtins.str, 'DependenciesAggregationType']] aggregation_type: Aggregation type for child dependencies.
        :param pulumi.Input[builtins.str] degraded_threshold: Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        :param pulumi.Input[builtins.str] unhealthy_threshold: Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        if aggregation_type is None:
            aggregation_type = 'WorstOf'
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if degraded_threshold is not None:
            pulumi.set(__self__, "degraded_threshold", degraded_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[Union[builtins.str, 'DependenciesAggregationType']]:
        """
        Aggregation type for child dependencies.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[Union[builtins.str, 'DependenciesAggregationType']]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="degradedThreshold")
    def degraded_threshold(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "degraded_threshold")

    @degraded_threshold.setter
    def degraded_threshold(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "degraded_threshold", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class DiscoveryRulePropertiesArgsDict(TypedDict):
        """
        Discovery rule properties
        """
        add_recommended_signals: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]
        """
        Whether to add all recommended signals to the discovered entities.
        """
        authentication_setting: pulumi.Input[builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        discover_relationships: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        resource_graph_query: pulumi.Input[builtins.str]
        """
        Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
elif False:
    DiscoveryRulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveryRulePropertiesArgs:
    def __init__(__self__, *,
                 add_recommended_signals: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']],
                 authentication_setting: pulumi.Input[builtins.str],
                 discover_relationships: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']],
                 resource_graph_query: pulumi.Input[builtins.str],
                 display_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Discovery rule properties
        :param pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']] add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param pulumi.Input[builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        :param pulumi.Input[Union[builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']] discover_relationships: Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        :param pulumi.Input[builtins.str] resource_graph_query: Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        :param pulumi.Input[builtins.str] display_name: Display name
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "discover_relationships", discover_relationships)
        pulumi.set(__self__, "resource_graph_query", resource_graph_query)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @add_recommended_signals.setter
    def add_recommended_signals(self, value: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]):
        pulumi.set(self, "add_recommended_signals", value)

    @property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @property
    @pulumi.getter(name="discoverRelationships")
    def discover_relationships(self) -> pulumi.Input[Union[builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]:
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        return pulumi.get(self, "discover_relationships")

    @discover_relationships.setter
    def discover_relationships(self, value: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]):
        pulumi.set(self, "discover_relationships", value)

    @property
    @pulumi.getter(name="resourceGraphQuery")
    def resource_graph_query(self) -> pulumi.Input[builtins.str]:
        """
        Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        """
        return pulumi.get(self, "resource_graph_query")

    @resource_graph_query.setter
    def resource_graph_query(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_graph_query", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DynamicDetectionRuleArgsDict(TypedDict):
        """
        ML-based evaluation rule for a signal definition
        """
        dynamic_threshold_direction: pulumi.Input[Union[builtins.str, 'DynamicThresholdDirection']]
        """
        Threshold direction
        """
        dynamic_threshold_model: pulumi.Input[Union[builtins.str, 'DynamicThresholdModel']]
        """
        ML model to use for dynamic thresholds
        """
        model_sensitivity: pulumi.Input[builtins.float]
        """
        ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        """
        training_start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time of the training in UTC.
        """
elif False:
    DynamicDetectionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DynamicDetectionRuleArgs:
    def __init__(__self__, *,
                 dynamic_threshold_direction: pulumi.Input[Union[builtins.str, 'DynamicThresholdDirection']],
                 dynamic_threshold_model: pulumi.Input[Union[builtins.str, 'DynamicThresholdModel']],
                 model_sensitivity: pulumi.Input[builtins.float],
                 training_start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        ML-based evaluation rule for a signal definition
        :param pulumi.Input[Union[builtins.str, 'DynamicThresholdDirection']] dynamic_threshold_direction: Threshold direction
        :param pulumi.Input[Union[builtins.str, 'DynamicThresholdModel']] dynamic_threshold_model: ML model to use for dynamic thresholds
        :param pulumi.Input[builtins.float] model_sensitivity: ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        :param pulumi.Input[builtins.str] training_start_time: Start time of the training in UTC.
        """
        pulumi.set(__self__, "dynamic_threshold_direction", dynamic_threshold_direction)
        pulumi.set(__self__, "dynamic_threshold_model", dynamic_threshold_model)
        pulumi.set(__self__, "model_sensitivity", model_sensitivity)
        if training_start_time is not None:
            pulumi.set(__self__, "training_start_time", training_start_time)

    @property
    @pulumi.getter(name="dynamicThresholdDirection")
    def dynamic_threshold_direction(self) -> pulumi.Input[Union[builtins.str, 'DynamicThresholdDirection']]:
        """
        Threshold direction
        """
        return pulumi.get(self, "dynamic_threshold_direction")

    @dynamic_threshold_direction.setter
    def dynamic_threshold_direction(self, value: pulumi.Input[Union[builtins.str, 'DynamicThresholdDirection']]):
        pulumi.set(self, "dynamic_threshold_direction", value)

    @property
    @pulumi.getter(name="dynamicThresholdModel")
    def dynamic_threshold_model(self) -> pulumi.Input[Union[builtins.str, 'DynamicThresholdModel']]:
        """
        ML model to use for dynamic thresholds
        """
        return pulumi.get(self, "dynamic_threshold_model")

    @dynamic_threshold_model.setter
    def dynamic_threshold_model(self, value: pulumi.Input[Union[builtins.str, 'DynamicThresholdModel']]):
        pulumi.set(self, "dynamic_threshold_model", value)

    @property
    @pulumi.getter(name="modelSensitivity")
    def model_sensitivity(self) -> pulumi.Input[builtins.float]:
        """
        ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        """
        return pulumi.get(self, "model_sensitivity")

    @model_sensitivity.setter
    def model_sensitivity(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "model_sensitivity", value)

    @property
    @pulumi.getter(name="trainingStartTime")
    def training_start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time of the training in UTC.
        """
        return pulumi.get(self, "training_start_time")

    @training_start_time.setter
    def training_start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "training_start_time", value)


if not MYPY:
    class EntityAlertsArgsDict(TypedDict):
        """
        Alert configuration for an entity
        """
        degraded: NotRequired[pulumi.Input['AlertConfigurationArgsDict']]
        """
        Alert to be triggered on state change to degraded
        """
        unhealthy: NotRequired[pulumi.Input['AlertConfigurationArgsDict']]
        """
        Alert to be triggered on state change to unhealthy
        """
elif False:
    EntityAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityAlertsArgs:
    def __init__(__self__, *,
                 degraded: Optional[pulumi.Input['AlertConfigurationArgs']] = None,
                 unhealthy: Optional[pulumi.Input['AlertConfigurationArgs']] = None):
        """
        Alert configuration for an entity
        :param pulumi.Input['AlertConfigurationArgs'] degraded: Alert to be triggered on state change to degraded
        :param pulumi.Input['AlertConfigurationArgs'] unhealthy: Alert to be triggered on state change to unhealthy
        """
        if degraded is not None:
            pulumi.set(__self__, "degraded", degraded)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter
    def degraded(self) -> Optional[pulumi.Input['AlertConfigurationArgs']]:
        """
        Alert to be triggered on state change to degraded
        """
        return pulumi.get(self, "degraded")

    @degraded.setter
    def degraded(self, value: Optional[pulumi.Input['AlertConfigurationArgs']]):
        pulumi.set(self, "degraded", value)

    @property
    @pulumi.getter
    def unhealthy(self) -> Optional[pulumi.Input['AlertConfigurationArgs']]:
        """
        Alert to be triggered on state change to unhealthy
        """
        return pulumi.get(self, "unhealthy")

    @unhealthy.setter
    def unhealthy(self, value: Optional[pulumi.Input['AlertConfigurationArgs']]):
        pulumi.set(self, "unhealthy", value)


if not MYPY:
    class EntityCoordinatesArgsDict(TypedDict):
        """
        Visual position of the entity
        """
        x: pulumi.Input[builtins.float]
        """
        X Coordinate
        """
        y: pulumi.Input[builtins.float]
        """
        Y Coordinate
        """
elif False:
    EntityCoordinatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityCoordinatesArgs:
    def __init__(__self__, *,
                 x: pulumi.Input[builtins.float],
                 y: pulumi.Input[builtins.float]):
        """
        Visual position of the entity
        :param pulumi.Input[builtins.float] x: X Coordinate
        :param pulumi.Input[builtins.float] y: Y Coordinate
        """
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[builtins.float]:
        """
        X Coordinate
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[builtins.float]:
        """
        Y Coordinate
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "y", value)


if not MYPY:
    class EntityPropertiesArgsDict(TypedDict):
        """
        Properties which are common across all kinds of entities
        """
        alerts: NotRequired[pulumi.Input['EntityAlertsArgsDict']]
        """
        Alert configuration for this entity
        """
        canvas_position: NotRequired[pulumi.Input['EntityCoordinatesArgsDict']]
        """
        Positioning of the entity on the model canvas
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        health_objective: NotRequired[pulumi.Input[builtins.float]]
        """
        Health objective as a percentage of time the entity should be healthy.
        """
        icon: NotRequired[pulumi.Input['IconDefinitionArgsDict']]
        """
        Visual icon definition. If not set, a default icon is used.
        """
        impact: NotRequired[pulumi.Input[Union[builtins.str, 'EntityImpact']]]
        """
        Impact of the entity in health state propagation
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Entity kind
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        signals: NotRequired[pulumi.Input['SignalGroupArgsDict']]
        """
        Signal groups which are assigned to this entity
        """
elif False:
    EntityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityPropertiesArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input['EntityAlertsArgs']] = None,
                 canvas_position: Optional[pulumi.Input['EntityCoordinatesArgs']] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 health_objective: Optional[pulumi.Input[builtins.float]] = None,
                 icon: Optional[pulumi.Input['IconDefinitionArgs']] = None,
                 impact: Optional[pulumi.Input[Union[builtins.str, 'EntityImpact']]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 signals: Optional[pulumi.Input['SignalGroupArgs']] = None):
        """
        Properties which are common across all kinds of entities
        :param pulumi.Input['EntityAlertsArgs'] alerts: Alert configuration for this entity
        :param pulumi.Input['EntityCoordinatesArgs'] canvas_position: Positioning of the entity on the model canvas
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[builtins.float] health_objective: Health objective as a percentage of time the entity should be healthy.
        :param pulumi.Input['IconDefinitionArgs'] icon: Visual icon definition. If not set, a default icon is used.
        :param pulumi.Input[Union[builtins.str, 'EntityImpact']] impact: Impact of the entity in health state propagation
        :param pulumi.Input[builtins.str] kind: Entity kind
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Optional set of labels (key-value pairs)
        :param pulumi.Input['SignalGroupArgs'] signals: Signal groups which are assigned to this entity
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if canvas_position is not None:
            pulumi.set(__self__, "canvas_position", canvas_position)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if health_objective is not None:
            pulumi.set(__self__, "health_objective", health_objective)
        if icon is not None:
            pulumi.set(__self__, "icon", icon)
        if impact is None:
            impact = 'Standard'
        if impact is not None:
            pulumi.set(__self__, "impact", impact)
        if kind is None:
            kind = 'Default'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if signals is not None:
            pulumi.set(__self__, "signals", signals)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input['EntityAlertsArgs']]:
        """
        Alert configuration for this entity
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input['EntityAlertsArgs']]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="canvasPosition")
    def canvas_position(self) -> Optional[pulumi.Input['EntityCoordinatesArgs']]:
        """
        Positioning of the entity on the model canvas
        """
        return pulumi.get(self, "canvas_position")

    @canvas_position.setter
    def canvas_position(self, value: Optional[pulumi.Input['EntityCoordinatesArgs']]):
        pulumi.set(self, "canvas_position", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="healthObjective")
    def health_objective(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Health objective as a percentage of time the entity should be healthy.
        """
        return pulumi.get(self, "health_objective")

    @health_objective.setter
    def health_objective(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "health_objective", value)

    @property
    @pulumi.getter
    def icon(self) -> Optional[pulumi.Input['IconDefinitionArgs']]:
        """
        Visual icon definition. If not set, a default icon is used.
        """
        return pulumi.get(self, "icon")

    @icon.setter
    def icon(self, value: Optional[pulumi.Input['IconDefinitionArgs']]):
        pulumi.set(self, "icon", value)

    @property
    @pulumi.getter
    def impact(self) -> Optional[pulumi.Input[Union[builtins.str, 'EntityImpact']]]:
        """
        Impact of the entity in health state propagation
        """
        return pulumi.get(self, "impact")

    @impact.setter
    def impact(self, value: Optional[pulumi.Input[Union[builtins.str, 'EntityImpact']]]):
        pulumi.set(self, "impact", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Entity kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def signals(self) -> Optional[pulumi.Input['SignalGroupArgs']]:
        """
        Signal groups which are assigned to this entity
        """
        return pulumi.get(self, "signals")

    @signals.setter
    def signals(self, value: Optional[pulumi.Input['SignalGroupArgs']]):
        pulumi.set(self, "signals", value)


if not MYPY:
    class EvaluationRuleArgsDict(TypedDict):
        """
        Evaluation rule for a signal definition
        """
        degraded_rule: NotRequired[pulumi.Input['ThresholdRuleArgsDict']]
        """
        Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        dynamic_detection_rule: NotRequired[pulumi.Input['DynamicDetectionRuleArgsDict']]
        """
        Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        """
        unhealthy_rule: NotRequired[pulumi.Input['ThresholdRuleArgsDict']]
        """
        Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
elif False:
    EvaluationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationRuleArgs:
    def __init__(__self__, *,
                 degraded_rule: Optional[pulumi.Input['ThresholdRuleArgs']] = None,
                 dynamic_detection_rule: Optional[pulumi.Input['DynamicDetectionRuleArgs']] = None,
                 unhealthy_rule: Optional[pulumi.Input['ThresholdRuleArgs']] = None):
        """
        Evaluation rule for a signal definition
        :param pulumi.Input['ThresholdRuleArgs'] degraded_rule: Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        :param pulumi.Input['DynamicDetectionRuleArgs'] dynamic_detection_rule: Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        :param pulumi.Input['ThresholdRuleArgs'] unhealthy_rule: Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        if degraded_rule is not None:
            pulumi.set(__self__, "degraded_rule", degraded_rule)
        if dynamic_detection_rule is not None:
            pulumi.set(__self__, "dynamic_detection_rule", dynamic_detection_rule)
        if unhealthy_rule is not None:
            pulumi.set(__self__, "unhealthy_rule", unhealthy_rule)

    @property
    @pulumi.getter(name="degradedRule")
    def degraded_rule(self) -> Optional[pulumi.Input['ThresholdRuleArgs']]:
        """
        Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "degraded_rule")

    @degraded_rule.setter
    def degraded_rule(self, value: Optional[pulumi.Input['ThresholdRuleArgs']]):
        pulumi.set(self, "degraded_rule", value)

    @property
    @pulumi.getter(name="dynamicDetectionRule")
    def dynamic_detection_rule(self) -> Optional[pulumi.Input['DynamicDetectionRuleArgs']]:
        """
        Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        """
        return pulumi.get(self, "dynamic_detection_rule")

    @dynamic_detection_rule.setter
    def dynamic_detection_rule(self, value: Optional[pulumi.Input['DynamicDetectionRuleArgs']]):
        pulumi.set(self, "dynamic_detection_rule", value)

    @property
    @pulumi.getter(name="unhealthyRule")
    def unhealthy_rule(self) -> Optional[pulumi.Input['ThresholdRuleArgs']]:
        """
        Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "unhealthy_rule")

    @unhealthy_rule.setter
    def unhealthy_rule(self, value: Optional[pulumi.Input['ThresholdRuleArgs']]):
        pulumi.set(self, "unhealthy_rule", value)


if not MYPY:
    class HealthModelPropertiesArgsDict(TypedDict):
        """
        HealthModel properties
        """
        discovery: NotRequired[pulumi.Input['ModelDiscoverySettingsArgsDict']]
        """
        Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
elif False:
    HealthModelPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthModelPropertiesArgs:
    def __init__(__self__, *,
                 discovery: Optional[pulumi.Input['ModelDiscoverySettingsArgs']] = None):
        """
        HealthModel properties
        :param pulumi.Input['ModelDiscoverySettingsArgs'] discovery: Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        if discovery is not None:
            pulumi.set(__self__, "discovery", discovery)

    @property
    @pulumi.getter
    def discovery(self) -> Optional[pulumi.Input['ModelDiscoverySettingsArgs']]:
        """
        Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        return pulumi.get(self, "discovery")

    @discovery.setter
    def discovery(self, value: Optional[pulumi.Input['ModelDiscoverySettingsArgs']]):
        pulumi.set(self, "discovery", value)


if not MYPY:
    class IconDefinitionArgsDict(TypedDict):
        """
        Visual icon definition of an entity
        """
        icon_name: pulumi.Input[builtins.str]
        """
        Name of the built-in icon, or 'Custom' to use customData
        """
        custom_data: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
elif False:
    IconDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IconDefinitionArgs:
    def __init__(__self__, *,
                 icon_name: pulumi.Input[builtins.str],
                 custom_data: Optional[pulumi.Input[builtins.str]] = None):
        """
        Visual icon definition of an entity
        :param pulumi.Input[builtins.str] icon_name: Name of the built-in icon, or 'Custom' to use customData
        :param pulumi.Input[builtins.str] custom_data: Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        pulumi.set(__self__, "icon_name", icon_name)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="iconName")
    def icon_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the built-in icon, or 'Custom' to use customData
        """
        return pulumi.get(self, "icon_name")

    @icon_name.setter
    def icon_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "icon_name", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_data", value)


if not MYPY:
    class LogAnalyticsQuerySignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Log Analytics Query Signal Definition properties
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        query_text: pulumi.Input[builtins.str]
        """
        Query text in KQL syntax
        """
        signal_kind: pulumi.Input[builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'LogAnalyticsQuery'.
        """
        data_unit: NotRequired[pulumi.Input[builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        refresh_interval: NotRequired[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        time_grain: NotRequired[pulumi.Input[builtins.str]]
        """
        Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        """
        value_column_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
elif False:
    LogAnalyticsQuerySignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsQuerySignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 query_text: pulumi.Input[builtins.str],
                 signal_kind: pulumi.Input[builtins.str],
                 data_unit: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]] = None,
                 time_grain: Optional[pulumi.Input[builtins.str]] = None,
                 value_column_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Log Analytics Query Signal Definition properties
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[builtins.str] query_text: Query text in KQL syntax
        :param pulumi.Input[builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'LogAnalyticsQuery'.
        :param pulumi.Input[builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Optional set of labels (key-value pairs)
        :param pulumi.Input[Union[builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param pulumi.Input[builtins.str] time_grain: Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        :param pulumi.Input[builtins.str] value_column_name: Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'LogAnalyticsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)
        if value_column_name is not None:
            pulumi.set(__self__, "value_column_name", value_column_name)

    @property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @property
    @pulumi.getter(name="queryText")
    def query_text(self) -> pulumi.Input[builtins.str]:
        """
        Query text in KQL syntax
        """
        return pulumi.get(self, "query_text")

    @query_text.setter
    def query_text(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "query_text", value)

    @property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'LogAnalyticsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)

    @property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_grain", value)

    @property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        return pulumi.get(self, "value_column_name")

    @value_column_name.setter
    def value_column_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value_column_name", value)


if not MYPY:
    class LogAnalyticsSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for a Log Analytics Workspace
        """
        authentication_setting: pulumi.Input[builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        log_analytics_workspace_resource_id: pulumi.Input[builtins.str]
        """
        Log Analytics Workspace resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    LogAnalyticsSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[builtins.str],
                 log_analytics_workspace_resource_id: pulumi.Input[builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for a Log Analytics Workspace
        :param pulumi.Input[builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[builtins.str] log_analytics_workspace_resource_id: Log Analytics Workspace resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "log_analytics_workspace_resource_id", log_analytics_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceResourceId")
    def log_analytics_workspace_resource_id(self) -> pulumi.Input[builtins.str]:
        """
        Log Analytics Workspace resource ID
        """
        return pulumi.get(self, "log_analytics_workspace_resource_id")

    @log_analytics_workspace_resource_id.setter
    def log_analytics_workspace_resource_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "log_analytics_workspace_resource_id", value)

    @property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class ManagedIdentityAuthenticationSettingPropertiesArgsDict(TypedDict):
        """
        Authentication setting properties for Azure Managed Identity
        """
        authentication_kind: pulumi.Input[builtins.str]
        """
        Supported kinds of authentication settings as discriminator
        Expected value is 'ManagedIdentity'.
        """
        managed_identity_name: pulumi.Input[builtins.str]
        """
        Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
elif False:
    ManagedIdentityAuthenticationSettingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentityAuthenticationSettingPropertiesArgs:
    def __init__(__self__, *,
                 authentication_kind: pulumi.Input[builtins.str],
                 managed_identity_name: pulumi.Input[builtins.str],
                 display_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Authentication setting properties for Azure Managed Identity
        :param pulumi.Input[builtins.str] authentication_kind: Supported kinds of authentication settings as discriminator
               Expected value is 'ManagedIdentity'.
        :param pulumi.Input[builtins.str] managed_identity_name: Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        :param pulumi.Input[builtins.str] display_name: Display name
        """
        pulumi.set(__self__, "authentication_kind", 'ManagedIdentity')
        pulumi.set(__self__, "managed_identity_name", managed_identity_name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="authenticationKind")
    def authentication_kind(self) -> pulumi.Input[builtins.str]:
        """
        Supported kinds of authentication settings as discriminator
        Expected value is 'ManagedIdentity'.
        """
        return pulumi.get(self, "authentication_kind")

    @authentication_kind.setter
    def authentication_kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "authentication_kind", value)

    @property
    @pulumi.getter(name="managedIdentityName")
    def managed_identity_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        """
        return pulumi.get(self, "managed_identity_name")

    @managed_identity_name.setter
    def managed_identity_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "managed_identity_name", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ModelDiscoverySettingsArgsDict(TypedDict):
        """
        Settings for automatically discovering entities for the health model.
        """
        add_recommended_signals: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]
        """
        Whether to add all recommended signals to the discovered entities.
        """
        scope: pulumi.Input[builtins.str]
        """
        The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        """
        identity: NotRequired[pulumi.Input[builtins.str]]
        """
        Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
elif False:
    ModelDiscoverySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDiscoverySettingsArgs:
    def __init__(__self__, *,
                 add_recommended_signals: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']],
                 scope: pulumi.Input[builtins.str],
                 identity: Optional[pulumi.Input[builtins.str]] = None):
        """
        Settings for automatically discovering entities for the health model.
        :param pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']] add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param pulumi.Input[builtins.str] scope: The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        :param pulumi.Input[builtins.str] identity: Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "scope", scope)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @add_recommended_signals.setter
    def add_recommended_signals(self, value: pulumi.Input[Union[builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]):
        pulumi.set(self, "add_recommended_signals", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[builtins.str]:
        """
        The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identity", value)


if not MYPY:
    class PrometheusMetricsSignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Prometheus Metrics Signal Definition properties
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        query_text: pulumi.Input[builtins.str]
        """
        Query text in PromQL syntax
        """
        signal_kind: pulumi.Input[builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'PrometheusMetricsQuery'.
        """
        data_unit: NotRequired[pulumi.Input[builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        refresh_interval: NotRequired[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        time_grain: NotRequired[pulumi.Input[builtins.str]]
        """
        Time range of signal. ISO duration format like PT10M.
        """
elif False:
    PrometheusMetricsSignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusMetricsSignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 query_text: pulumi.Input[builtins.str],
                 signal_kind: pulumi.Input[builtins.str],
                 data_unit: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]] = None,
                 time_grain: Optional[pulumi.Input[builtins.str]] = None):
        """
        Prometheus Metrics Signal Definition properties
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[builtins.str] query_text: Query text in PromQL syntax
        :param pulumi.Input[builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'PrometheusMetricsQuery'.
        :param pulumi.Input[builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Optional set of labels (key-value pairs)
        :param pulumi.Input[Union[builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param pulumi.Input[builtins.str] time_grain: Time range of signal. ISO duration format like PT10M.
        """
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'PrometheusMetricsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)

    @property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @property
    @pulumi.getter(name="queryText")
    def query_text(self) -> pulumi.Input[builtins.str]:
        """
        Query text in PromQL syntax
        """
        return pulumi.get(self, "query_text")

    @query_text.setter
    def query_text(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "query_text", value)

    @property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'PrometheusMetricsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)

    @property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_grain", value)


if not MYPY:
    class RelationshipPropertiesArgsDict(TypedDict):
        """
        Relationship properties
        """
        child_entity_name: pulumi.Input[builtins.str]
        """
        Resource name of the child entity
        """
        parent_entity_name: pulumi.Input[builtins.str]
        """
        Resource name of the parent entity
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
elif False:
    RelationshipPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RelationshipPropertiesArgs:
    def __init__(__self__, *,
                 child_entity_name: pulumi.Input[builtins.str],
                 parent_entity_name: pulumi.Input[builtins.str],
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Relationship properties
        :param pulumi.Input[builtins.str] child_entity_name: Resource name of the child entity
        :param pulumi.Input[builtins.str] parent_entity_name: Resource name of the parent entity
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Optional set of labels (key-value pairs)
        """
        pulumi.set(__self__, "child_entity_name", child_entity_name)
        pulumi.set(__self__, "parent_entity_name", parent_entity_name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter(name="childEntityName")
    def child_entity_name(self) -> pulumi.Input[builtins.str]:
        """
        Resource name of the child entity
        """
        return pulumi.get(self, "child_entity_name")

    @child_entity_name.setter
    def child_entity_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "child_entity_name", value)

    @property
    @pulumi.getter(name="parentEntityName")
    def parent_entity_name(self) -> pulumi.Input[builtins.str]:
        """
        Resource name of the parent entity
        """
        return pulumi.get(self, "parent_entity_name")

    @parent_entity_name.setter
    def parent_entity_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "parent_entity_name", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class ResourceMetricSignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Azure Resource Metric Signal Definition properties
        """
        aggregation_type: pulumi.Input[Union[builtins.str, 'MetricAggregationType']]
        """
        Type of aggregation to apply to the metric
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        metric_name: pulumi.Input[builtins.str]
        """
        Name of the metric
        """
        metric_namespace: pulumi.Input[builtins.str]
        """
        Metric namespace
        """
        signal_kind: pulumi.Input[builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'AzureResourceMetric'.
        """
        time_grain: pulumi.Input[builtins.str]
        """
        Time range of signal. ISO duration format like PT10M.
        """
        data_unit: NotRequired[pulumi.Input[builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        dimension: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional: Dimension to split by
        """
        dimension_filter: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        refresh_interval: NotRequired[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
elif False:
    ResourceMetricSignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMetricSignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 aggregation_type: pulumi.Input[Union[builtins.str, 'MetricAggregationType']],
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 metric_name: pulumi.Input[builtins.str],
                 metric_namespace: pulumi.Input[builtins.str],
                 signal_kind: pulumi.Input[builtins.str],
                 time_grain: pulumi.Input[builtins.str],
                 data_unit: Optional[pulumi.Input[builtins.str]] = None,
                 dimension: Optional[pulumi.Input[builtins.str]] = None,
                 dimension_filter: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]] = None):
        """
        Azure Resource Metric Signal Definition properties
        :param pulumi.Input[Union[builtins.str, 'MetricAggregationType']] aggregation_type: Type of aggregation to apply to the metric
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[builtins.str] metric_name: Name of the metric
        :param pulumi.Input[builtins.str] metric_namespace: Metric namespace
        :param pulumi.Input[builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'AzureResourceMetric'.
        :param pulumi.Input[builtins.str] time_grain: Time range of signal. ISO duration format like PT10M.
        :param pulumi.Input[builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[builtins.str] dimension: Optional: Dimension to split by
        :param pulumi.Input[builtins.str] dimension_filter: Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Optional set of labels (key-value pairs)
        :param pulumi.Input[Union[builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "signal_kind", 'AzureResourceMetric')
        pulumi.set(__self__, "time_grain", time_grain)
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[Union[builtins.str, 'MetricAggregationType']]:
        """
        Type of aggregation to apply to the metric
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[Union[builtins.str, 'MetricAggregationType']]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the metric
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[builtins.str]:
        """
        Metric namespace
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'AzureResourceMetric'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> pulumi.Input[builtins.str]:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_grain", value)

    @property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional: Dimension to split by
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        """
        return pulumi.get(self, "dimension_filter")

    @dimension_filter.setter
    def dimension_filter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dimension_filter", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)


if not MYPY:
    class SignalAssignmentArgsDict(TypedDict):
        """
        Group of signal definition assignments
        """
        signal_definitions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
elif False:
    SignalAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SignalAssignmentArgs:
    def __init__(__self__, *,
                 signal_definitions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        Group of signal definition assignments
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] signal_definitions: Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        pulumi.set(__self__, "signal_definitions", signal_definitions)

    @property
    @pulumi.getter(name="signalDefinitions")
    def signal_definitions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        return pulumi.get(self, "signal_definitions")

    @signal_definitions.setter
    def signal_definitions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "signal_definitions", value)


if not MYPY:
    class SignalGroupArgsDict(TypedDict):
        """
        Contains various signal groups that can be assigned to an entity
        """
        azure_log_analytics: NotRequired[pulumi.Input['LogAnalyticsSignalGroupArgsDict']]
        """
        Log Analytics Signal Group
        """
        azure_monitor_workspace: NotRequired[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgsDict']]
        """
        Azure Monitor Workspace Signal Group
        """
        azure_resource: NotRequired[pulumi.Input['AzureResourceSignalGroupArgsDict']]
        """
        Azure Resource Signal Group
        """
        dependencies: NotRequired[pulumi.Input['DependenciesSignalGroupArgsDict']]
        """
        Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
elif False:
    SignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SignalGroupArgs:
    def __init__(__self__, *,
                 azure_log_analytics: Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']] = None,
                 azure_monitor_workspace: Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']] = None,
                 azure_resource: Optional[pulumi.Input['AzureResourceSignalGroupArgs']] = None,
                 dependencies: Optional[pulumi.Input['DependenciesSignalGroupArgs']] = None):
        """
        Contains various signal groups that can be assigned to an entity
        :param pulumi.Input['LogAnalyticsSignalGroupArgs'] azure_log_analytics: Log Analytics Signal Group
        :param pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs'] azure_monitor_workspace: Azure Monitor Workspace Signal Group
        :param pulumi.Input['AzureResourceSignalGroupArgs'] azure_resource: Azure Resource Signal Group
        :param pulumi.Input['DependenciesSignalGroupArgs'] dependencies: Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        if azure_log_analytics is not None:
            pulumi.set(__self__, "azure_log_analytics", azure_log_analytics)
        if azure_monitor_workspace is not None:
            pulumi.set(__self__, "azure_monitor_workspace", azure_monitor_workspace)
        if azure_resource is not None:
            pulumi.set(__self__, "azure_resource", azure_resource)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @property
    @pulumi.getter(name="azureLogAnalytics")
    def azure_log_analytics(self) -> Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']]:
        """
        Log Analytics Signal Group
        """
        return pulumi.get(self, "azure_log_analytics")

    @azure_log_analytics.setter
    def azure_log_analytics(self, value: Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']]):
        pulumi.set(self, "azure_log_analytics", value)

    @property
    @pulumi.getter(name="azureMonitorWorkspace")
    def azure_monitor_workspace(self) -> Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']]:
        """
        Azure Monitor Workspace Signal Group
        """
        return pulumi.get(self, "azure_monitor_workspace")

    @azure_monitor_workspace.setter
    def azure_monitor_workspace(self, value: Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']]):
        pulumi.set(self, "azure_monitor_workspace", value)

    @property
    @pulumi.getter(name="azureResource")
    def azure_resource(self) -> Optional[pulumi.Input['AzureResourceSignalGroupArgs']]:
        """
        Azure Resource Signal Group
        """
        return pulumi.get(self, "azure_resource")

    @azure_resource.setter
    def azure_resource(self, value: Optional[pulumi.Input['AzureResourceSignalGroupArgs']]):
        pulumi.set(self, "azure_resource", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input['DependenciesSignalGroupArgs']]:
        """
        Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input['DependenciesSignalGroupArgs']]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class ThresholdRuleArgsDict(TypedDict):
        """
        Threshold-based evaluation rule for a signal definition
        """
        operator: pulumi.Input[Union[builtins.str, 'SignalOperator']]
        """
        Operator how to compare the signal value with the threshold
        """
        threshold: pulumi.Input[builtins.str]
        """
        Threshold value
        """
elif False:
    ThresholdRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThresholdRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[builtins.str, 'SignalOperator']],
                 threshold: pulumi.Input[builtins.str]):
        """
        Threshold-based evaluation rule for a signal definition
        :param pulumi.Input[Union[builtins.str, 'SignalOperator']] operator: Operator how to compare the signal value with the threshold
        :param pulumi.Input[builtins.str] threshold: Threshold value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[builtins.str, 'SignalOperator']]:
        """
        Operator how to compare the signal value with the threshold
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[builtins.str, 'SignalOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.str]:
        """
        Threshold value
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "threshold", value)


