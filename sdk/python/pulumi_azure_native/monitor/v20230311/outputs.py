# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdxDestinationResponse',
    'AgentSettingResponse',
    'ColumnDefinitionResponse',
    'DataCollectionEndpointResourceResponseIdentity',
    'DataCollectionEndpointResourceResponseSystemData',
    'DataCollectionEndpointResponseConfigurationAccess',
    'DataCollectionEndpointResponseFailoverConfiguration',
    'DataCollectionEndpointResponseLogsIngestion',
    'DataCollectionEndpointResponseMetadata',
    'DataCollectionEndpointResponseMetricsIngestion',
    'DataCollectionEndpointResponseNetworkAcls',
    'DataCollectionRuleAssociationProxyOnlyResourceResponseSystemData',
    'DataCollectionRuleAssociationResponseMetadata',
    'DataCollectionRuleResourceResponseIdentity',
    'DataCollectionRuleResourceResponseSystemData',
    'DataCollectionRuleResponseAgentSettings',
    'DataCollectionRuleResponseDataSources',
    'DataCollectionRuleResponseDestinations',
    'DataCollectionRuleResponseEndpoints',
    'DataCollectionRuleResponseMetadata',
    'DataCollectionRuleResponseReferences',
    'DataFlowResponse',
    'DataImportSourcesResponseEventHub',
    'DataSourcesSpecResponseDataImports',
    'DestinationsSpecResponseAzureMonitorMetrics',
    'EventHubDestinationResponse',
    'EventHubDirectDestinationResponse',
    'ExtensionDataSourceResponse',
    'IisLogsDataSourceResponse',
    'LocationSpecResponse',
    'LogAnalyticsDestinationResponse',
    'LogFileSettingsResponseText',
    'LogFilesDataSourceResponse',
    'LogFilesDataSourceResponseSettings',
    'MicrosoftFabricDestinationResponse',
    'MonitoringAccountDestinationResponse',
    'PerfCounterDataSourceResponse',
    'PlatformTelemetryDataSourceResponse',
    'PrivateLinkScopedResourceResponse',
    'PrometheusForwarderDataSourceResponse',
    'ReferencesSpecResponseEnrichmentData',
    'StorageBlobDestinationResponse',
    'StorageBlobResponse',
    'StorageTableDestinationResponse',
    'StreamDeclarationResponse',
    'SyslogDataSourceResponse',
    'UserAssignedIdentityResponse',
    'WindowsEventLogDataSourceResponse',
    'WindowsFirewallLogsDataSourceResponse',
]

@pulumi.output_type
class AdxDestinationResponse(dict):
    """
    Azure Data Explorer (Adx) destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingestionUri":
            suggest = "ingestion_uri"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdxDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdxDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdxDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingestion_uri: str,
                 database_name: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Azure Data Explorer (Adx) destination.
        :param str ingestion_uri: The ingestion uri of the Adx resource.
        :param str database_name: The name of the database to which data will be ingested.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param str resource_id: The ARM resource id of the Adx resource.
        """
        pulumi.set(__self__, "ingestion_uri", ingestion_uri)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="ingestionUri")
    def ingestion_uri(self) -> str:
        """
        The ingestion uri of the Adx resource.
        """
        return pulumi.get(self, "ingestion_uri")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of the database to which data will be ingested.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The ARM resource id of the Adx resource.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AgentSettingResponse(dict):
    """
    A setting used to control an agent behavior on a host machine
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        A setting used to control an agent behavior on a host machine
        :param str name: The name of the setting. 
               Must be part of the list of supported settings
        :param str value: The value of the setting
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the setting. 
        Must be part of the list of supported settings
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the setting
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ColumnDefinitionResponse(dict):
    """
    Definition of custom data column.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Definition of custom data column.
        :param str name: The name of the column.
        :param str type: The type of the column data.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the column data.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataCollectionEndpointResourceResponseIdentity(dict):
    """
    Managed service identity of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionEndpointResourceResponseIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionEndpointResourceResponseIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionEndpointResourceResponseIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity of the resource.
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class DataCollectionEndpointResourceResponseSystemData(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionEndpointResourceResponseSystemData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionEndpointResourceResponseSystemData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionEndpointResourceResponseSystemData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class DataCollectionEndpointResponseConfigurationAccess(dict):
    """
    The endpoint used by clients to access their configuration.
    """
    def __init__(__self__, *,
                 endpoint: str):
        """
        The endpoint used by clients to access their configuration.
        :param str endpoint: The endpoint. This property is READ-ONLY.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint. This property is READ-ONLY.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class DataCollectionEndpointResponseFailoverConfiguration(dict):
    """
    Failover configuration on this endpoint. This property is READ-ONLY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeLocation":
            suggest = "active_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionEndpointResponseFailoverConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionEndpointResponseFailoverConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionEndpointResponseFailoverConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_location: Optional[str] = None,
                 locations: Optional[Sequence['outputs.LocationSpecResponse']] = None):
        """
        Failover configuration on this endpoint. This property is READ-ONLY.
        :param str active_location: Active location where data flow will occur.
        :param Sequence['LocationSpecResponse'] locations: Locations that are configured for failover.
        """
        if active_location is not None:
            pulumi.set(__self__, "active_location", active_location)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter(name="activeLocation")
    def active_location(self) -> Optional[str]:
        """
        Active location where data flow will occur.
        """
        return pulumi.get(self, "active_location")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.LocationSpecResponse']]:
        """
        Locations that are configured for failover.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class DataCollectionEndpointResponseLogsIngestion(dict):
    """
    The endpoint used by clients to ingest logs.
    """
    def __init__(__self__, *,
                 endpoint: str):
        """
        The endpoint used by clients to ingest logs.
        :param str endpoint: The endpoint. This property is READ-ONLY.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint. This property is READ-ONLY.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class DataCollectionEndpointResponseMetadata(dict):
    """
    Metadata for the resource. This property is READ-ONLY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedBy":
            suggest = "provisioned_by"
        elif key == "provisionedByImmutableId":
            suggest = "provisioned_by_immutable_id"
        elif key == "provisionedByResourceId":
            suggest = "provisioned_by_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionEndpointResponseMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionEndpointResponseMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionEndpointResponseMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_by: str,
                 provisioned_by_immutable_id: str,
                 provisioned_by_resource_id: str):
        """
        Metadata for the resource. This property is READ-ONLY.
        :param str provisioned_by: Azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_immutable_id: Immutable Id of azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_resource_id: Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        pulumi.set(__self__, "provisioned_by", provisioned_by)
        pulumi.set(__self__, "provisioned_by_immutable_id", provisioned_by_immutable_id)
        pulumi.set(__self__, "provisioned_by_resource_id", provisioned_by_resource_id)

    @property
    @pulumi.getter(name="provisionedBy")
    def provisioned_by(self) -> str:
        """
        Azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by")

    @property
    @pulumi.getter(name="provisionedByImmutableId")
    def provisioned_by_immutable_id(self) -> str:
        """
        Immutable Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_immutable_id")

    @property
    @pulumi.getter(name="provisionedByResourceId")
    def provisioned_by_resource_id(self) -> str:
        """
        Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_resource_id")


@pulumi.output_type
class DataCollectionEndpointResponseMetricsIngestion(dict):
    """
    The endpoint used by clients to ingest metrics.
    """
    def __init__(__self__, *,
                 endpoint: str):
        """
        The endpoint used by clients to ingest metrics.
        :param str endpoint: The endpoint. This property is READ-ONLY.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint. This property is READ-ONLY.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class DataCollectionEndpointResponseNetworkAcls(dict):
    """
    Network access control rules for the endpoints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionEndpointResponseNetworkAcls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionEndpointResponseNetworkAcls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionEndpointResponseNetworkAcls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_network_access: Optional[str] = None):
        """
        Network access control rules for the endpoints.
        :param str public_network_access: The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[str]:
        """
        The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        return pulumi.get(self, "public_network_access")


@pulumi.output_type
class DataCollectionRuleAssociationProxyOnlyResourceResponseSystemData(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleAssociationProxyOnlyResourceResponseSystemData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleAssociationProxyOnlyResourceResponseSystemData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleAssociationProxyOnlyResourceResponseSystemData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class DataCollectionRuleAssociationResponseMetadata(dict):
    """
    Metadata about the resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedBy":
            suggest = "provisioned_by"
        elif key == "provisionedByImmutableId":
            suggest = "provisioned_by_immutable_id"
        elif key == "provisionedByResourceId":
            suggest = "provisioned_by_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleAssociationResponseMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleAssociationResponseMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleAssociationResponseMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_by: str,
                 provisioned_by_immutable_id: str,
                 provisioned_by_resource_id: str):
        """
        Metadata about the resource
        :param str provisioned_by: Azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_immutable_id: Immutable Id of azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_resource_id: Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        pulumi.set(__self__, "provisioned_by", provisioned_by)
        pulumi.set(__self__, "provisioned_by_immutable_id", provisioned_by_immutable_id)
        pulumi.set(__self__, "provisioned_by_resource_id", provisioned_by_resource_id)

    @property
    @pulumi.getter(name="provisionedBy")
    def provisioned_by(self) -> str:
        """
        Azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by")

    @property
    @pulumi.getter(name="provisionedByImmutableId")
    def provisioned_by_immutable_id(self) -> str:
        """
        Immutable Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_immutable_id")

    @property
    @pulumi.getter(name="provisionedByResourceId")
    def provisioned_by_resource_id(self) -> str:
        """
        Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_resource_id")


@pulumi.output_type
class DataCollectionRuleResourceResponseIdentity(dict):
    """
    Managed service identity of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResourceResponseIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResourceResponseIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResourceResponseIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity of the resource.
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class DataCollectionRuleResourceResponseSystemData(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResourceResponseSystemData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResourceResponseSystemData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResourceResponseSystemData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class DataCollectionRuleResponseAgentSettings(dict):
    """
    Agent settings used to modify agent behavior on a given host
    """
    def __init__(__self__, *,
                 logs: Optional[Sequence['outputs.AgentSettingResponse']] = None):
        """
        Agent settings used to modify agent behavior on a given host
        :param Sequence['AgentSettingResponse'] logs: All the settings that are applicable to the logs agent (AMA)
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> Optional[Sequence['outputs.AgentSettingResponse']]:
        """
        All the settings that are applicable to the logs agent (AMA)
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class DataCollectionRuleResponseDataSources(dict):
    """
    The specification of data sources. 
    This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataImports":
            suggest = "data_imports"
        elif key == "iisLogs":
            suggest = "iis_logs"
        elif key == "logFiles":
            suggest = "log_files"
        elif key == "performanceCounters":
            suggest = "performance_counters"
        elif key == "platformTelemetry":
            suggest = "platform_telemetry"
        elif key == "prometheusForwarder":
            suggest = "prometheus_forwarder"
        elif key == "windowsEventLogs":
            suggest = "windows_event_logs"
        elif key == "windowsFirewallLogs":
            suggest = "windows_firewall_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResponseDataSources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResponseDataSources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResponseDataSources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_imports: Optional['outputs.DataSourcesSpecResponseDataImports'] = None,
                 extensions: Optional[Sequence['outputs.ExtensionDataSourceResponse']] = None,
                 iis_logs: Optional[Sequence['outputs.IisLogsDataSourceResponse']] = None,
                 log_files: Optional[Sequence['outputs.LogFilesDataSourceResponse']] = None,
                 performance_counters: Optional[Sequence['outputs.PerfCounterDataSourceResponse']] = None,
                 platform_telemetry: Optional[Sequence['outputs.PlatformTelemetryDataSourceResponse']] = None,
                 prometheus_forwarder: Optional[Sequence['outputs.PrometheusForwarderDataSourceResponse']] = None,
                 syslog: Optional[Sequence['outputs.SyslogDataSourceResponse']] = None,
                 windows_event_logs: Optional[Sequence['outputs.WindowsEventLogDataSourceResponse']] = None,
                 windows_firewall_logs: Optional[Sequence['outputs.WindowsFirewallLogsDataSourceResponse']] = None):
        """
        The specification of data sources. 
        This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        :param 'DataSourcesSpecResponseDataImports' data_imports: Specifications of pull based data sources
        :param Sequence['ExtensionDataSourceResponse'] extensions: The list of Azure VM extension data source configurations.
        :param Sequence['IisLogsDataSourceResponse'] iis_logs: The list of IIS logs source configurations.
        :param Sequence['LogFilesDataSourceResponse'] log_files: The list of Log files source configurations.
        :param Sequence['PerfCounterDataSourceResponse'] performance_counters: The list of performance counter data source configurations.
        :param Sequence['PlatformTelemetryDataSourceResponse'] platform_telemetry: The list of platform telemetry configurations
        :param Sequence['PrometheusForwarderDataSourceResponse'] prometheus_forwarder: The list of Prometheus forwarder data source configurations.
        :param Sequence['SyslogDataSourceResponse'] syslog: The list of Syslog data source configurations.
        :param Sequence['WindowsEventLogDataSourceResponse'] windows_event_logs: The list of Windows Event Log data source configurations.
        :param Sequence['WindowsFirewallLogsDataSourceResponse'] windows_firewall_logs: The list of Windows Firewall logs source configurations.
        """
        if data_imports is not None:
            pulumi.set(__self__, "data_imports", data_imports)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if iis_logs is not None:
            pulumi.set(__self__, "iis_logs", iis_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if performance_counters is not None:
            pulumi.set(__self__, "performance_counters", performance_counters)
        if platform_telemetry is not None:
            pulumi.set(__self__, "platform_telemetry", platform_telemetry)
        if prometheus_forwarder is not None:
            pulumi.set(__self__, "prometheus_forwarder", prometheus_forwarder)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)
        if windows_event_logs is not None:
            pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        if windows_firewall_logs is not None:
            pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)

    @property
    @pulumi.getter(name="dataImports")
    def data_imports(self) -> Optional['outputs.DataSourcesSpecResponseDataImports']:
        """
        Specifications of pull based data sources
        """
        return pulumi.get(self, "data_imports")

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.ExtensionDataSourceResponse']]:
        """
        The list of Azure VM extension data source configurations.
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Optional[Sequence['outputs.IisLogsDataSourceResponse']]:
        """
        The list of IIS logs source configurations.
        """
        return pulumi.get(self, "iis_logs")

    @property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[Sequence['outputs.LogFilesDataSourceResponse']]:
        """
        The list of Log files source configurations.
        """
        return pulumi.get(self, "log_files")

    @property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Optional[Sequence['outputs.PerfCounterDataSourceResponse']]:
        """
        The list of performance counter data source configurations.
        """
        return pulumi.get(self, "performance_counters")

    @property
    @pulumi.getter(name="platformTelemetry")
    def platform_telemetry(self) -> Optional[Sequence['outputs.PlatformTelemetryDataSourceResponse']]:
        """
        The list of platform telemetry configurations
        """
        return pulumi.get(self, "platform_telemetry")

    @property
    @pulumi.getter(name="prometheusForwarder")
    def prometheus_forwarder(self) -> Optional[Sequence['outputs.PrometheusForwarderDataSourceResponse']]:
        """
        The list of Prometheus forwarder data source configurations.
        """
        return pulumi.get(self, "prometheus_forwarder")

    @property
    @pulumi.getter
    def syslog(self) -> Optional[Sequence['outputs.SyslogDataSourceResponse']]:
        """
        The list of Syslog data source configurations.
        """
        return pulumi.get(self, "syslog")

    @property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Optional[Sequence['outputs.WindowsEventLogDataSourceResponse']]:
        """
        The list of Windows Event Log data source configurations.
        """
        return pulumi.get(self, "windows_event_logs")

    @property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Optional[Sequence['outputs.WindowsFirewallLogsDataSourceResponse']]:
        """
        The list of Windows Firewall logs source configurations.
        """
        return pulumi.get(self, "windows_firewall_logs")


@pulumi.output_type
class DataCollectionRuleResponseDestinations(dict):
    """
    The specification of destinations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureDataExplorer":
            suggest = "azure_data_explorer"
        elif key == "azureMonitorMetrics":
            suggest = "azure_monitor_metrics"
        elif key == "eventHubs":
            suggest = "event_hubs"
        elif key == "eventHubsDirect":
            suggest = "event_hubs_direct"
        elif key == "logAnalytics":
            suggest = "log_analytics"
        elif key == "microsoftFabric":
            suggest = "microsoft_fabric"
        elif key == "monitoringAccounts":
            suggest = "monitoring_accounts"
        elif key == "storageAccounts":
            suggest = "storage_accounts"
        elif key == "storageBlobsDirect":
            suggest = "storage_blobs_direct"
        elif key == "storageTablesDirect":
            suggest = "storage_tables_direct"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResponseDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResponseDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResponseDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_data_explorer: Optional[Sequence['outputs.AdxDestinationResponse']] = None,
                 azure_monitor_metrics: Optional['outputs.DestinationsSpecResponseAzureMonitorMetrics'] = None,
                 event_hubs: Optional[Sequence['outputs.EventHubDestinationResponse']] = None,
                 event_hubs_direct: Optional[Sequence['outputs.EventHubDirectDestinationResponse']] = None,
                 log_analytics: Optional[Sequence['outputs.LogAnalyticsDestinationResponse']] = None,
                 microsoft_fabric: Optional[Sequence['outputs.MicrosoftFabricDestinationResponse']] = None,
                 monitoring_accounts: Optional[Sequence['outputs.MonitoringAccountDestinationResponse']] = None,
                 storage_accounts: Optional[Sequence['outputs.StorageBlobDestinationResponse']] = None,
                 storage_blobs_direct: Optional[Sequence['outputs.StorageBlobDestinationResponse']] = None,
                 storage_tables_direct: Optional[Sequence['outputs.StorageTableDestinationResponse']] = None):
        """
        The specification of destinations.
        :param Sequence['AdxDestinationResponse'] azure_data_explorer: List of Azure Data Explorer destinations.
        :param 'DestinationsSpecResponseAzureMonitorMetrics' azure_monitor_metrics: Azure Monitor Metrics destination.
        :param Sequence['EventHubDestinationResponse'] event_hubs: List of Event Hubs destinations.
        :param Sequence['EventHubDirectDestinationResponse'] event_hubs_direct: List of Event Hubs Direct destinations.
        :param Sequence['LogAnalyticsDestinationResponse'] log_analytics: List of Log Analytics destinations.
        :param Sequence['MicrosoftFabricDestinationResponse'] microsoft_fabric: List of Microsoft Fabric destinations.
        :param Sequence['MonitoringAccountDestinationResponse'] monitoring_accounts: List of monitoring account destinations.
        :param Sequence['StorageBlobDestinationResponse'] storage_accounts: List of storage accounts destinations.
        :param Sequence['StorageBlobDestinationResponse'] storage_blobs_direct: List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        :param Sequence['StorageTableDestinationResponse'] storage_tables_direct: List of Storage Table Direct destinations.
        """
        if azure_data_explorer is not None:
            pulumi.set(__self__, "azure_data_explorer", azure_data_explorer)
        if azure_monitor_metrics is not None:
            pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        if event_hubs is not None:
            pulumi.set(__self__, "event_hubs", event_hubs)
        if event_hubs_direct is not None:
            pulumi.set(__self__, "event_hubs_direct", event_hubs_direct)
        if log_analytics is not None:
            pulumi.set(__self__, "log_analytics", log_analytics)
        if microsoft_fabric is not None:
            pulumi.set(__self__, "microsoft_fabric", microsoft_fabric)
        if monitoring_accounts is not None:
            pulumi.set(__self__, "monitoring_accounts", monitoring_accounts)
        if storage_accounts is not None:
            pulumi.set(__self__, "storage_accounts", storage_accounts)
        if storage_blobs_direct is not None:
            pulumi.set(__self__, "storage_blobs_direct", storage_blobs_direct)
        if storage_tables_direct is not None:
            pulumi.set(__self__, "storage_tables_direct", storage_tables_direct)

    @property
    @pulumi.getter(name="azureDataExplorer")
    def azure_data_explorer(self) -> Optional[Sequence['outputs.AdxDestinationResponse']]:
        """
        List of Azure Data Explorer destinations.
        """
        return pulumi.get(self, "azure_data_explorer")

    @property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Optional['outputs.DestinationsSpecResponseAzureMonitorMetrics']:
        """
        Azure Monitor Metrics destination.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @property
    @pulumi.getter(name="eventHubs")
    def event_hubs(self) -> Optional[Sequence['outputs.EventHubDestinationResponse']]:
        """
        List of Event Hubs destinations.
        """
        return pulumi.get(self, "event_hubs")

    @property
    @pulumi.getter(name="eventHubsDirect")
    def event_hubs_direct(self) -> Optional[Sequence['outputs.EventHubDirectDestinationResponse']]:
        """
        List of Event Hubs Direct destinations.
        """
        return pulumi.get(self, "event_hubs_direct")

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Optional[Sequence['outputs.LogAnalyticsDestinationResponse']]:
        """
        List of Log Analytics destinations.
        """
        return pulumi.get(self, "log_analytics")

    @property
    @pulumi.getter(name="microsoftFabric")
    def microsoft_fabric(self) -> Optional[Sequence['outputs.MicrosoftFabricDestinationResponse']]:
        """
        List of Microsoft Fabric destinations.
        """
        return pulumi.get(self, "microsoft_fabric")

    @property
    @pulumi.getter(name="monitoringAccounts")
    def monitoring_accounts(self) -> Optional[Sequence['outputs.MonitoringAccountDestinationResponse']]:
        """
        List of monitoring account destinations.
        """
        return pulumi.get(self, "monitoring_accounts")

    @property
    @pulumi.getter(name="storageAccounts")
    def storage_accounts(self) -> Optional[Sequence['outputs.StorageBlobDestinationResponse']]:
        """
        List of storage accounts destinations.
        """
        return pulumi.get(self, "storage_accounts")

    @property
    @pulumi.getter(name="storageBlobsDirect")
    def storage_blobs_direct(self) -> Optional[Sequence['outputs.StorageBlobDestinationResponse']]:
        """
        List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        """
        return pulumi.get(self, "storage_blobs_direct")

    @property
    @pulumi.getter(name="storageTablesDirect")
    def storage_tables_direct(self) -> Optional[Sequence['outputs.StorageTableDestinationResponse']]:
        """
        List of Storage Table Direct destinations.
        """
        return pulumi.get(self, "storage_tables_direct")


@pulumi.output_type
class DataCollectionRuleResponseEndpoints(dict):
    """
    Defines the ingestion endpoints to send data to via this rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsIngestion":
            suggest = "logs_ingestion"
        elif key == "metricsIngestion":
            suggest = "metrics_ingestion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResponseEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResponseEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResponseEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_ingestion: str,
                 metrics_ingestion: str):
        """
        Defines the ingestion endpoints to send data to via this rule.
        :param str logs_ingestion: The ingestion endpoint for logs
        :param str metrics_ingestion: The ingestion endpoint for metrics
        """
        pulumi.set(__self__, "logs_ingestion", logs_ingestion)
        pulumi.set(__self__, "metrics_ingestion", metrics_ingestion)

    @property
    @pulumi.getter(name="logsIngestion")
    def logs_ingestion(self) -> str:
        """
        The ingestion endpoint for logs
        """
        return pulumi.get(self, "logs_ingestion")

    @property
    @pulumi.getter(name="metricsIngestion")
    def metrics_ingestion(self) -> str:
        """
        The ingestion endpoint for metrics
        """
        return pulumi.get(self, "metrics_ingestion")


@pulumi.output_type
class DataCollectionRuleResponseMetadata(dict):
    """
    Metadata about the resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedBy":
            suggest = "provisioned_by"
        elif key == "provisionedByImmutableId":
            suggest = "provisioned_by_immutable_id"
        elif key == "provisionedByResourceId":
            suggest = "provisioned_by_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResponseMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResponseMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResponseMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_by: str,
                 provisioned_by_immutable_id: str,
                 provisioned_by_resource_id: str):
        """
        Metadata about the resource
        :param str provisioned_by: Azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_immutable_id: Immutable Id of azure offering managing this resource on-behalf-of customer.
        :param str provisioned_by_resource_id: Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        pulumi.set(__self__, "provisioned_by", provisioned_by)
        pulumi.set(__self__, "provisioned_by_immutable_id", provisioned_by_immutable_id)
        pulumi.set(__self__, "provisioned_by_resource_id", provisioned_by_resource_id)

    @property
    @pulumi.getter(name="provisionedBy")
    def provisioned_by(self) -> str:
        """
        Azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by")

    @property
    @pulumi.getter(name="provisionedByImmutableId")
    def provisioned_by_immutable_id(self) -> str:
        """
        Immutable Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_immutable_id")

    @property
    @pulumi.getter(name="provisionedByResourceId")
    def provisioned_by_resource_id(self) -> str:
        """
        Resource Id of azure offering managing this resource on-behalf-of customer.
        """
        return pulumi.get(self, "provisioned_by_resource_id")


@pulumi.output_type
class DataCollectionRuleResponseReferences(dict):
    """
    Defines all the references that may be used in other sections of the DCR
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enrichmentData":
            suggest = "enrichment_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleResponseReferences. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleResponseReferences.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleResponseReferences.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enrichment_data: Optional['outputs.ReferencesSpecResponseEnrichmentData'] = None):
        """
        Defines all the references that may be used in other sections of the DCR
        :param 'ReferencesSpecResponseEnrichmentData' enrichment_data: All the enrichment data sources referenced in data flows
        """
        if enrichment_data is not None:
            pulumi.set(__self__, "enrichment_data", enrichment_data)

    @property
    @pulumi.getter(name="enrichmentData")
    def enrichment_data(self) -> Optional['outputs.ReferencesSpecResponseEnrichmentData']:
        """
        All the enrichment data sources referenced in data flows
        """
        return pulumi.get(self, "enrichment_data")


@pulumi.output_type
class DataFlowResponse(dict):
    """
    Definition of which streams are sent to which destinations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtInTransform":
            suggest = "built_in_transform"
        elif key == "captureOverflow":
            suggest = "capture_overflow"
        elif key == "outputStream":
            suggest = "output_stream"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 built_in_transform: Optional[str] = None,
                 capture_overflow: Optional[bool] = None,
                 destinations: Optional[Sequence[str]] = None,
                 output_stream: Optional[str] = None,
                 streams: Optional[Sequence[str]] = None,
                 transform_kql: Optional[str] = None):
        """
        Definition of which streams are sent to which destinations.
        :param str built_in_transform: The builtIn transform to transform stream data
        :param bool capture_overflow: Flag to enable overflow column in LA destinations
        :param Sequence[str] destinations: List of destinations for this data flow.
        :param str output_stream: The output stream of the transform. Only required if the transform changes data to a different stream.
        :param Sequence[str] streams: List of streams for this data flow.
        :param str transform_kql: The KQL query to transform stream data.
        """
        if built_in_transform is not None:
            pulumi.set(__self__, "built_in_transform", built_in_transform)
        if capture_overflow is not None:
            pulumi.set(__self__, "capture_overflow", capture_overflow)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if output_stream is not None:
            pulumi.set(__self__, "output_stream", output_stream)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> Optional[str]:
        """
        The builtIn transform to transform stream data
        """
        return pulumi.get(self, "built_in_transform")

    @property
    @pulumi.getter(name="captureOverflow")
    def capture_overflow(self) -> Optional[bool]:
        """
        Flag to enable overflow column in LA destinations
        """
        return pulumi.get(self, "capture_overflow")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[str]]:
        """
        List of destinations for this data flow.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> Optional[str]:
        """
        The output stream of the transform. Only required if the transform changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams for this data flow.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class DataImportSourcesResponseEventHub(dict):
    """
    Definition of Event Hub configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroup":
            suggest = "consumer_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataImportSourcesResponseEventHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataImportSourcesResponseEventHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataImportSourcesResponseEventHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group: Optional[str] = None,
                 name: Optional[str] = None,
                 stream: Optional[str] = None):
        """
        Definition of Event Hub configuration.
        :param str consumer_group: Event Hub consumer group name
        :param str name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param str stream: The stream to collect from EventHub
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[str]:
        """
        Event Hub consumer group name
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def stream(self) -> Optional[str]:
        """
        The stream to collect from EventHub
        """
        return pulumi.get(self, "stream")


@pulumi.output_type
class DataSourcesSpecResponseDataImports(dict):
    """
    Specifications of pull based data sources
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHub":
            suggest = "event_hub"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourcesSpecResponseDataImports. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourcesSpecResponseDataImports.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourcesSpecResponseDataImports.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub: Optional['outputs.DataImportSourcesResponseEventHub'] = None):
        """
        Specifications of pull based data sources
        :param 'DataImportSourcesResponseEventHub' event_hub: Definition of Event Hub configuration.
        """
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional['outputs.DataImportSourcesResponseEventHub']:
        """
        Definition of Event Hub configuration.
        """
        return pulumi.get(self, "event_hub")


@pulumi.output_type
class DestinationsSpecResponseAzureMonitorMetrics(dict):
    """
    Azure Monitor Metrics destination.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        Azure Monitor Metrics destination.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class EventHubDestinationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubResourceId":
            suggest = "event_hub_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventHubDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventHubDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventHubDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_resource_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str event_hub_resource_id: The resource ID of the event hub.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[str]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class EventHubDirectDestinationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubResourceId":
            suggest = "event_hub_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventHubDirectDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventHubDirectDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventHubDirectDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_resource_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str event_hub_resource_id: The resource ID of the event hub.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[str]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExtensionDataSourceResponse(dict):
    """
    Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
    Collected from either Windows and Linux machines, depending on which extension is defined.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionName":
            suggest = "extension_name"
        elif key == "extensionSettings":
            suggest = "extension_settings"
        elif key == "inputDataSources":
            suggest = "input_data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtensionDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtensionDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtensionDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_name: str,
                 extension_settings: Optional[Any] = None,
                 input_data_sources: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 streams: Optional[Sequence[str]] = None):
        """
        Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
        Collected from either Windows and Linux machines, depending on which extension is defined.
        :param str extension_name: The name of the VM extension.
        :param Any extension_settings: The extension settings. The format is specific for particular extension.
        :param Sequence[str] input_data_sources: The list of data sources this extension needs data from.
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param Sequence[str] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "extension_name", extension_name)
        if extension_settings is not None:
            pulumi.set(__self__, "extension_settings", extension_settings)
        if input_data_sources is not None:
            pulumi.set(__self__, "input_data_sources", input_data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> str:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @property
    @pulumi.getter(name="extensionSettings")
    def extension_settings(self) -> Optional[Any]:
        """
        The extension settings. The format is specific for particular extension.
        """
        return pulumi.get(self, "extension_settings")

    @property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Optional[Sequence[str]]:
        """
        The list of data sources this extension needs data from.
        """
        return pulumi.get(self, "input_data_sources")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class IisLogsDataSourceResponse(dict):
    """
    Enables IIS logs to be collected by this data collection rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDirectories":
            suggest = "log_directories"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IisLogsDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IisLogsDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IisLogsDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 streams: Sequence[str],
                 log_directories: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 transform_kql: Optional[str] = None):
        """
        Enables IIS logs to be collected by this data collection rule.
        :param Sequence[str] streams: IIS streams
        :param Sequence[str] log_directories: Absolute paths file location
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param str transform_kql: The KQL query to transform the data source.
        """
        pulumi.set(__self__, "streams", streams)
        if log_directories is not None:
            pulumi.set(__self__, "log_directories", log_directories)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        IIS streams
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Optional[Sequence[str]]:
        """
        Absolute paths file location
        """
        return pulumi.get(self, "log_directories")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class LocationSpecResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningStatus":
            suggest = "provisioning_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: Optional[str] = None,
                 provisioning_status: Optional[str] = None):
        """
        :param str location: Name of location.
        :param str provisioning_status: The resource provisioning state in this location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Name of location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional[str]:
        """
        The resource provisioning state in this location.
        """
        return pulumi.get(self, "provisioning_status")


@pulumi.output_type
class LogAnalyticsDestinationResponse(dict):
    """
    Log Analytics destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"
        elif key == "workspaceResourceId":
            suggest = "workspace_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: str,
                 name: Optional[str] = None,
                 workspace_resource_id: Optional[str] = None):
        """
        Log Analytics destination.
        :param str workspace_id: The Customer ID of the Log Analytics workspace.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param str workspace_resource_id: The resource ID of the Log Analytics workspace.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if workspace_resource_id is not None:
            pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The Customer ID of the Log Analytics workspace.
        """
        return pulumi.get(self, "workspace_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[str]:
        """
        The resource ID of the Log Analytics workspace.
        """
        return pulumi.get(self, "workspace_resource_id")


@pulumi.output_type
class LogFileSettingsResponseText(dict):
    """
    Text settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordStartTimestampFormat":
            suggest = "record_start_timestamp_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogFileSettingsResponseText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogFileSettingsResponseText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogFileSettingsResponseText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_start_timestamp_format: str):
        """
        Text settings
        :param str record_start_timestamp_format: One of the supported timestamp formats
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> str:
        """
        One of the supported timestamp formats
        """
        return pulumi.get(self, "record_start_timestamp_format")


@pulumi.output_type
class LogFilesDataSourceResponse(dict):
    """
    Definition of which custom log files will be collected by this data collection rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePatterns":
            suggest = "file_patterns"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogFilesDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogFilesDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogFilesDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_patterns: Sequence[str],
                 format: str,
                 streams: Sequence[str],
                 name: Optional[str] = None,
                 settings: Optional['outputs.LogFilesDataSourceResponseSettings'] = None,
                 transform_kql: Optional[str] = None):
        """
        Definition of which custom log files will be collected by this data collection rule
        :param Sequence[str] file_patterns: File Patterns where the log files are located
        :param str format: The data format of the log files
        :param Sequence[str] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data source
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param 'LogFilesDataSourceResponseSettings' settings: The log files specific settings.
        :param str transform_kql: The KQL query to transform the data source.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> Sequence[str]:
        """
        File Patterns where the log files are located
        """
        return pulumi.get(self, "file_patterns")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The data format of the log files
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data source
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.LogFilesDataSourceResponseSettings']:
        """
        The log files specific settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class LogFilesDataSourceResponseSettings(dict):
    """
    The log files specific settings.
    """
    def __init__(__self__, *,
                 text: Optional['outputs.LogFileSettingsResponseText'] = None):
        """
        The log files specific settings.
        :param 'LogFileSettingsResponseText' text: Text settings
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.LogFileSettingsResponseText']:
        """
        Text settings
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class MicrosoftFabricDestinationResponse(dict):
    """
    Microsoft Fabric destination (non-Azure).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactId":
            suggest = "artifact_id"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "ingestionUri":
            suggest = "ingestion_uri"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MicrosoftFabricDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MicrosoftFabricDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MicrosoftFabricDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_id: Optional[str] = None,
                 database_name: Optional[str] = None,
                 ingestion_uri: Optional[str] = None,
                 name: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Microsoft Fabric destination (non-Azure).
        :param str artifact_id: The artifact id of the Microsoft Fabric resource.
        :param str database_name: The name of the database to which data will be ingested.
        :param str ingestion_uri: The ingestion uri of the Microsoft Fabric resource.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param str tenant_id: The tenant id of the Microsoft Fabric resource.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if ingestion_uri is not None:
            pulumi.set(__self__, "ingestion_uri", ingestion_uri)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[str]:
        """
        The artifact id of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "artifact_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of the database to which data will be ingested.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="ingestionUri")
    def ingestion_uri(self) -> Optional[str]:
        """
        The ingestion uri of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "ingestion_uri")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant id of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class MonitoringAccountDestinationResponse(dict):
    """
    Monitoring account destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "accountResourceId":
            suggest = "account_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringAccountDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringAccountDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringAccountDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 account_resource_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Monitoring account destination.
        :param str account_id: The immutable ID  of the account.
        :param str account_resource_id: The resource ID of the monitoring account.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "account_id", account_id)
        if account_resource_id is not None:
            pulumi.set(__self__, "account_resource_id", account_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The immutable ID  of the account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="accountResourceId")
    def account_resource_id(self) -> Optional[str]:
        """
        The resource ID of the monitoring account.
        """
        return pulumi.get(self, "account_resource_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PerfCounterDataSourceResponse(dict):
    """
    Definition of which performance counters will be collected and how they will be collected by this data collection rule.
    Collected from both Windows and Linux machines where the counter is present.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterSpecifiers":
            suggest = "counter_specifiers"
        elif key == "samplingFrequencyInSeconds":
            suggest = "sampling_frequency_in_seconds"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PerfCounterDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PerfCounterDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PerfCounterDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_specifiers: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 sampling_frequency_in_seconds: Optional[int] = None,
                 streams: Optional[Sequence[str]] = None,
                 transform_kql: Optional[str] = None):
        """
        Definition of which performance counters will be collected and how they will be collected by this data collection rule.
        Collected from both Windows and Linux machines where the counter is present.
        :param Sequence[str] counter_specifiers: A list of specifier names of the performance counters you want to collect.
               Use a wildcard (*) to collect a counter for all instances.
               To get a list of performance counters on Windows, run the command 'typeperf'.
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param int sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples).
        :param Sequence[str] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param str transform_kql: The KQL query to transform the data source.
        """
        if counter_specifiers is not None:
            pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sampling_frequency_in_seconds is not None:
            pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> Optional[Sequence[str]]:
        """
        A list of specifier names of the performance counters you want to collect.
        Use a wildcard (*) to collect a counter for all instances.
        To get a list of performance counters on Windows, run the command 'typeperf'.
        """
        return pulumi.get(self, "counter_specifiers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> Optional[int]:
        """
        The number of seconds between consecutive counter measurements (samples).
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class PlatformTelemetryDataSourceResponse(dict):
    """
    Definition of platform telemetry data source configuration
    """
    def __init__(__self__, *,
                 streams: Sequence[str],
                 name: Optional[str] = None):
        """
        Definition of platform telemetry data source configuration
        :param Sequence[str] streams: List of platform telemetry streams to collect
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        List of platform telemetry streams to collect
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PrivateLinkScopedResourceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "scopeId":
            suggest = "scope_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkScopedResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkScopedResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkScopedResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: Optional[str] = None,
                 scope_id: Optional[str] = None):
        """
        :param str resource_id: The resourceId of the Azure Monitor Private Link Scope Scoped Resource through which this DCE is associated with a Azure Monitor Private Link Scope.
        :param str scope_id: The immutableId of the Azure Monitor Private Link Scope Resource to which the association is.
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if scope_id is not None:
            pulumi.set(__self__, "scope_id", scope_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The resourceId of the Azure Monitor Private Link Scope Scoped Resource through which this DCE is associated with a Azure Monitor Private Link Scope.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="scopeId")
    def scope_id(self) -> Optional[str]:
        """
        The immutableId of the Azure Monitor Private Link Scope Resource to which the association is.
        """
        return pulumi.get(self, "scope_id")


@pulumi.output_type
class PrometheusForwarderDataSourceResponse(dict):
    """
    Definition of Prometheus metrics forwarding configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelIncludeFilter":
            suggest = "label_include_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusForwarderDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusForwarderDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusForwarderDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_include_filter: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 streams: Optional[Sequence[str]] = None):
        """
        Definition of Prometheus metrics forwarding configuration.
        :param Mapping[str, str] label_include_filter: The list of label inclusion filters in the form of label "name-value" pairs.
               Currently only one label is supported: 'microsoft_metrics_include_label'.
               Label values are matched case-insensitively.
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param Sequence[str] streams: List of streams that this data source will be sent to.
        """
        if label_include_filter is not None:
            pulumi.set(__self__, "label_include_filter", label_include_filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="labelIncludeFilter")
    def label_include_filter(self) -> Optional[Mapping[str, str]]:
        """
        The list of label inclusion filters in the form of label "name-value" pairs.
        Currently only one label is supported: 'microsoft_metrics_include_label'.
        Label values are matched case-insensitively.
        """
        return pulumi.get(self, "label_include_filter")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams that this data source will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class ReferencesSpecResponseEnrichmentData(dict):
    """
    All the enrichment data sources referenced in data flows
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageBlobs":
            suggest = "storage_blobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReferencesSpecResponseEnrichmentData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReferencesSpecResponseEnrichmentData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReferencesSpecResponseEnrichmentData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_blobs: Optional[Sequence['outputs.StorageBlobResponse']] = None):
        """
        All the enrichment data sources referenced in data flows
        :param Sequence['StorageBlobResponse'] storage_blobs: All the storage blobs used as enrichment data sources
        """
        if storage_blobs is not None:
            pulumi.set(__self__, "storage_blobs", storage_blobs)

    @property
    @pulumi.getter(name="storageBlobs")
    def storage_blobs(self) -> Optional[Sequence['outputs.StorageBlobResponse']]:
        """
        All the storage blobs used as enrichment data sources
        """
        return pulumi.get(self, "storage_blobs")


@pulumi.output_type
class StorageBlobDestinationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountResourceId":
            suggest = "storage_account_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBlobDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBlobDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBlobDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 name: Optional[str] = None,
                 storage_account_resource_id: Optional[str] = None):
        """
        :param str container_name: The container name of the Storage Blob.
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param str storage_account_resource_id: The resource ID of the storage account.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The container name of the Storage Blob.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[str]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")


@pulumi.output_type
class StorageBlobResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobUrl":
            suggest = "blob_url"
        elif key == "lookupType":
            suggest = "lookup_type"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBlobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBlobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBlobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_url: Optional[str] = None,
                 lookup_type: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        :param str blob_url: Url of the storage blob
        :param str lookup_type: The type of lookup to perform on the blob
        :param str name: The name of the enrichment data source used as an alias when referencing this data source in data flows
        :param str resource_id: Resource Id of the storage account that hosts the blob
        """
        if blob_url is not None:
            pulumi.set(__self__, "blob_url", blob_url)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="blobUrl")
    def blob_url(self) -> Optional[str]:
        """
        Url of the storage blob
        """
        return pulumi.get(self, "blob_url")

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[str]:
        """
        The type of lookup to perform on the blob
        """
        return pulumi.get(self, "lookup_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the enrichment data source used as an alias when referencing this data source in data flows
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Resource Id of the storage account that hosts the blob
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class StorageTableDestinationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountResourceId":
            suggest = "storage_account_resource_id"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageTableDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageTableDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageTableDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 storage_account_resource_id: Optional[str] = None,
                 table_name: Optional[str] = None):
        """
        :param str name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param str storage_account_resource_id: The resource ID of the storage account.
        :param str table_name: The name of the Storage Table.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[str]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[str]:
        """
        The name of the Storage Table.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class StreamDeclarationResponse(dict):
    """
    Declaration of a custom stream.
    """
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.ColumnDefinitionResponse']] = None):
        """
        Declaration of a custom stream.
        :param Sequence['ColumnDefinitionResponse'] columns: List of columns used by data in this stream.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.ColumnDefinitionResponse']]:
        """
        List of columns used by data in this stream.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class SyslogDataSourceResponse(dict):
    """
    Definition of which syslog data will be collected and how it will be collected.
    Only collected from Linux machines.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "facilityNames":
            suggest = "facility_names"
        elif key == "logLevels":
            suggest = "log_levels"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyslogDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyslogDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyslogDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facility_names: Optional[Sequence[str]] = None,
                 log_levels: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 streams: Optional[Sequence[str]] = None,
                 transform_kql: Optional[str] = None):
        """
        Definition of which syslog data will be collected and how it will be collected.
        Only collected from Linux machines.
        :param Sequence[str] facility_names: The list of facility names.
        :param Sequence[str] log_levels: The log levels to collect.
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param Sequence[str] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param str transform_kql: The KQL query to transform the data source.
        """
        if facility_names is not None:
            pulumi.set(__self__, "facility_names", facility_names)
        if log_levels is not None:
            pulumi.set(__self__, "log_levels", log_levels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> Optional[Sequence[str]]:
        """
        The list of facility names.
        """
        return pulumi.get(self, "facility_names")

    @property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> Optional[Sequence[str]]:
        """
        The log levels to collect.
        """
        return pulumi.get(self, "log_levels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class WindowsEventLogDataSourceResponse(dict):
    """
    Definition of which Windows Event Log events will be collected and how they will be collected.
    Only collected from Windows machines.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformKql":
            suggest = "transform_kql"
        elif key == "xPathQueries":
            suggest = "x_path_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsEventLogDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsEventLogDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsEventLogDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 streams: Optional[Sequence[str]] = None,
                 transform_kql: Optional[str] = None,
                 x_path_queries: Optional[Sequence[str]] = None):
        """
        Definition of which Windows Event Log events will be collected and how they will be collected.
        Only collected from Windows machines.
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param Sequence[str] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param str transform_kql: The KQL query to transform the data source.
        :param Sequence[str] x_path_queries: A list of Windows Event Log queries in XPATH format.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)
        if x_path_queries is not None:
            pulumi.set(__self__, "x_path_queries", x_path_queries)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence[str]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> Optional[Sequence[str]]:
        """
        A list of Windows Event Log queries in XPATH format.
        """
        return pulumi.get(self, "x_path_queries")


@pulumi.output_type
class WindowsFirewallLogsDataSourceResponse(dict):
    """
    Enables Firewall logs to be collected by this data collection rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileFilter":
            suggest = "profile_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsFirewallLogsDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsFirewallLogsDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsFirewallLogsDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 streams: Sequence[str],
                 name: Optional[str] = None,
                 profile_filter: Optional[Sequence[str]] = None):
        """
        Enables Firewall logs to be collected by this data collection rule.
        :param Sequence[str] streams: Firewall logs streams
        :param str name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param Sequence[str] profile_filter: Firewall logs profile filter
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if profile_filter is not None:
            pulumi.set(__self__, "profile_filter", profile_filter)

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Firewall logs streams
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="profileFilter")
    def profile_filter(self) -> Optional[Sequence[str]]:
        """
        Firewall logs profile filter
        """
        return pulumi.get(self, "profile_filter")


