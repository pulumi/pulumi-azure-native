# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AccessModeSettingsExclusionArgs',
    'AccessModeSettingsExclusionArgsDict',
    'AccessModeSettingsArgs',
    'AccessModeSettingsArgsDict',
    'ActionGroupArgs',
    'ActionGroupArgsDict',
    'ActionListArgs',
    'ActionListArgsDict',
    'ActionsArgs',
    'ActionsArgsDict',
    'AlertConfigurationArgs',
    'AlertConfigurationArgsDict',
    'AlertRuleAllOfConditionArgs',
    'AlertRuleAllOfConditionArgsDict',
    'AlertRuleAnyOfOrLeafConditionArgs',
    'AlertRuleAnyOfOrLeafConditionArgsDict',
    'AlertRuleLeafConditionArgs',
    'AlertRuleLeafConditionArgsDict',
    'ApplicationInsightsTopologyDiscoveryRulePropertiesArgs',
    'ApplicationInsightsTopologyDiscoveryRulePropertiesArgsDict',
    'ArmRoleReceiverArgs',
    'ArmRoleReceiverArgsDict',
    'AutomationRunbookReceiverArgs',
    'AutomationRunbookReceiverArgsDict',
    'AutoscaleNotificationArgs',
    'AutoscaleNotificationArgsDict',
    'AutoscaleProfileArgs',
    'AutoscaleProfileArgsDict',
    'AzureAppPushReceiverArgs',
    'AzureAppPushReceiverArgsDict',
    'AzureFunctionReceiverArgs',
    'AzureFunctionReceiverArgsDict',
    'AzureMonitorWorkspaceLogsApiConfigArgs',
    'AzureMonitorWorkspaceLogsApiConfigArgsDict',
    'AzureMonitorWorkspaceLogsExporterArgs',
    'AzureMonitorWorkspaceLogsExporterArgsDict',
    'AzureMonitorWorkspaceSignalGroupArgs',
    'AzureMonitorWorkspaceSignalGroupArgsDict',
    'AzureResourceManagerCommonTypesExtendedLocationArgs',
    'AzureResourceManagerCommonTypesExtendedLocationArgsDict',
    'AzureResourceSignalGroupArgs',
    'AzureResourceSignalGroupArgsDict',
    'BatchProcessorArgs',
    'BatchProcessorArgsDict',
    'CacheConfigurationArgs',
    'CacheConfigurationArgsDict',
    'ColumnDefinitionArgs',
    'ColumnDefinitionArgsDict',
    'ConcurrencyConfigurationArgs',
    'ConcurrencyConfigurationArgsDict',
    'ConditionFailingPeriodsArgs',
    'ConditionFailingPeriodsArgsDict',
    'ConditionArgs',
    'ConditionArgsDict',
    'DataCollectionEndpointNetworkAclsArgs',
    'DataCollectionEndpointNetworkAclsArgsDict',
    'DataCollectionEndpointResourceIdentityArgs',
    'DataCollectionEndpointResourceIdentityArgsDict',
    'DataCollectionRuleDataSourcesArgs',
    'DataCollectionRuleDataSourcesArgsDict',
    'DataCollectionRuleDestinationsArgs',
    'DataCollectionRuleDestinationsArgsDict',
    'DataCollectionRuleResourceIdentityArgs',
    'DataCollectionRuleResourceIdentityArgsDict',
    'DataFlowArgs',
    'DataFlowArgsDict',
    'DataImportSourcesEventHubArgs',
    'DataImportSourcesEventHubArgsDict',
    'DataSourcesSpecDataImportsArgs',
    'DataSourcesSpecDataImportsArgsDict',
    'DependenciesSignalGroupArgs',
    'DependenciesSignalGroupArgsDict',
    'DestinationsSpecAzureMonitorMetricsArgs',
    'DestinationsSpecAzureMonitorMetricsArgsDict',
    'DimensionArgs',
    'DimensionArgsDict',
    'DynamicDetectionRuleArgs',
    'DynamicDetectionRuleArgsDict',
    'DynamicMetricCriteriaArgs',
    'DynamicMetricCriteriaArgsDict',
    'DynamicThresholdFailingPeriodsArgs',
    'DynamicThresholdFailingPeriodsArgsDict',
    'EmailNotificationArgs',
    'EmailNotificationArgsDict',
    'EmailReceiverArgs',
    'EmailReceiverArgsDict',
    'EntityAlertsArgs',
    'EntityAlertsArgsDict',
    'EntityCoordinatesArgs',
    'EntityCoordinatesArgsDict',
    'EntityPropertiesArgs',
    'EntityPropertiesArgsDict',
    'EvaluationRuleArgs',
    'EvaluationRuleArgsDict',
    'EventHubDestinationArgs',
    'EventHubDestinationArgsDict',
    'EventHubDirectDestinationArgs',
    'EventHubDirectDestinationArgsDict',
    'EventHubReceiverArgs',
    'EventHubReceiverArgsDict',
    'ExporterArgs',
    'ExporterArgsDict',
    'ExtensionDataSourceArgs',
    'ExtensionDataSourceArgsDict',
    'HealthModelPropertiesArgs',
    'HealthModelPropertiesArgsDict',
    'IconDefinitionArgs',
    'IconDefinitionArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'IisLogsDataSourceArgs',
    'IisLogsDataSourceArgsDict',
    'IncidentReceiverArgs',
    'IncidentReceiverArgsDict',
    'IncidentServiceConnectionArgs',
    'IncidentServiceConnectionArgsDict',
    'IssuePropertiesArgs',
    'IssuePropertiesArgsDict',
    'ItsmReceiverArgs',
    'ItsmReceiverArgsDict',
    'JsonArrayMapperArgs',
    'JsonArrayMapperArgsDict',
    'JsonMapperDestinationFieldArgs',
    'JsonMapperDestinationFieldArgsDict',
    'JsonMapperSourceFieldArgs',
    'JsonMapperSourceFieldArgsDict',
    'LogAnalyticsDestinationArgs',
    'LogAnalyticsDestinationArgsDict',
    'LogAnalyticsQuerySignalDefinitionPropertiesArgs',
    'LogAnalyticsQuerySignalDefinitionPropertiesArgsDict',
    'LogAnalyticsSignalGroupArgs',
    'LogAnalyticsSignalGroupArgsDict',
    'LogFileSettingsTextArgs',
    'LogFileSettingsTextArgsDict',
    'LogFilesDataSourceSettingsArgs',
    'LogFilesDataSourceSettingsArgsDict',
    'LogFilesDataSourceArgs',
    'LogFilesDataSourceArgsDict',
    'LogSettingsArgs',
    'LogSettingsArgsDict',
    'LogicAppReceiverArgs',
    'LogicAppReceiverArgsDict',
    'ManagedIdentityAuthenticationSettingPropertiesArgs',
    'ManagedIdentityAuthenticationSettingPropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'ManagementGroupLogSettingsArgs',
    'ManagementGroupLogSettingsArgsDict',
    'MetricAlertActionArgs',
    'MetricAlertActionArgsDict',
    'MetricAlertMultipleResourceMultipleMetricCriteriaArgs',
    'MetricAlertMultipleResourceMultipleMetricCriteriaArgsDict',
    'MetricAlertSingleResourceMultipleMetricCriteriaArgs',
    'MetricAlertSingleResourceMultipleMetricCriteriaArgsDict',
    'MetricCriteriaArgs',
    'MetricCriteriaArgsDict',
    'MetricDimensionArgs',
    'MetricDimensionArgsDict',
    'MetricSettingsArgs',
    'MetricSettingsArgsDict',
    'MetricTriggerArgs',
    'MetricTriggerArgsDict',
    'ModelDiscoverySettingsArgs',
    'ModelDiscoverySettingsArgsDict',
    'MonitoringAccountDestinationArgs',
    'MonitoringAccountDestinationArgsDict',
    'NetworkingConfigurationArgs',
    'NetworkingConfigurationArgsDict',
    'NetworkingRouteArgs',
    'NetworkingRouteArgsDict',
    'OtlpReceiverArgs',
    'OtlpReceiverArgsDict',
    'PerfCounterDataSourceArgs',
    'PerfCounterDataSourceArgsDict',
    'PersistenceConfigurationsArgs',
    'PersistenceConfigurationsArgsDict',
    'PipelineGroupPropertiesArgs',
    'PipelineGroupPropertiesArgsDict',
    'PipelineArgs',
    'PipelineArgsDict',
    'PlatformTelemetryDataSourceArgs',
    'PlatformTelemetryDataSourceArgsDict',
    'PredictiveAutoscalePolicyArgs',
    'PredictiveAutoscalePolicyArgsDict',
    'PrivateLinkServiceConnectionStateArgs',
    'PrivateLinkServiceConnectionStateArgsDict',
    'ProcessorArgs',
    'ProcessorArgsDict',
    'PrometheusForwarderDataSourceArgs',
    'PrometheusForwarderDataSourceArgsDict',
    'PrometheusMetricsSignalDefinitionPropertiesArgs',
    'PrometheusMetricsSignalDefinitionPropertiesArgsDict',
    'ReceiverArgs',
    'ReceiverArgsDict',
    'RecordMapArgs',
    'RecordMapArgsDict',
    'RecurrenceArgs',
    'RecurrenceArgsDict',
    'RecurrentScheduleArgs',
    'RecurrentScheduleArgsDict',
    'RelationshipPropertiesArgs',
    'RelationshipPropertiesArgsDict',
    'ResourceGraphQueryDiscoveryRulePropertiesArgs',
    'ResourceGraphQueryDiscoveryRulePropertiesArgsDict',
    'ResourceMapArgs',
    'ResourceMapArgsDict',
    'ResourceMetricSignalDefinitionPropertiesArgs',
    'ResourceMetricSignalDefinitionPropertiesArgsDict',
    'RetentionPolicyArgs',
    'RetentionPolicyArgsDict',
    'RuleResolveConfigurationArgs',
    'RuleResolveConfigurationArgsDict',
    'ScaleActionArgs',
    'ScaleActionArgsDict',
    'ScaleCapacityArgs',
    'ScaleCapacityArgsDict',
    'ScaleRuleMetricDimensionArgs',
    'ScaleRuleMetricDimensionArgsDict',
    'ScaleRuleArgs',
    'ScaleRuleArgsDict',
    'ScheduledQueryRuleCriteriaArgs',
    'ScheduledQueryRuleCriteriaArgsDict',
    'SchemaMapArgs',
    'SchemaMapArgsDict',
    'ScopeMapArgs',
    'ScopeMapArgsDict',
    'ServiceArgs',
    'ServiceArgsDict',
    'SignalAssignmentArgs',
    'SignalAssignmentArgsDict',
    'SignalGroupArgs',
    'SignalGroupArgsDict',
    'SmsReceiverArgs',
    'SmsReceiverArgsDict',
    'StorageBlobDestinationArgs',
    'StorageBlobDestinationArgsDict',
    'StorageTableDestinationArgs',
    'StorageTableDestinationArgsDict',
    'StreamDeclarationArgs',
    'StreamDeclarationArgsDict',
    'SubscriptionLogSettingsArgs',
    'SubscriptionLogSettingsArgsDict',
    'SyslogDataSourceArgs',
    'SyslogDataSourceArgsDict',
    'SyslogReceiverArgs',
    'SyslogReceiverArgsDict',
    'TcpExporterArgs',
    'TcpExporterArgsDict',
    'ThresholdRuleArgs',
    'ThresholdRuleArgsDict',
    'TimeWindowArgs',
    'TimeWindowArgsDict',
    'UdpReceiverArgs',
    'UdpReceiverArgsDict',
    'VoiceReceiverArgs',
    'VoiceReceiverArgsDict',
    'WebhookNotificationArgs',
    'WebhookNotificationArgsDict',
    'WebhookReceiverArgs',
    'WebhookReceiverArgsDict',
    'WebtestLocationAvailabilityCriteriaArgs',
    'WebtestLocationAvailabilityCriteriaArgsDict',
    'WindowsEventLogDataSourceArgs',
    'WindowsEventLogDataSourceArgsDict',
    'WindowsFirewallLogsDataSourceArgs',
    'WindowsFirewallLogsDataSourceArgsDict',
]

MYPY = False

if not MYPY:
    class AccessModeSettingsExclusionArgsDict(TypedDict):
        """
        Properties that define the scope private link mode settings exclusion item. This setting applies to a specific private endpoint connection and overrides the default settings for that private endpoint connection.
        """
        ingestion_access_mode: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessMode']]]
        """
        Specifies the access mode of ingestion through the specified private endpoint connection in the exclusion.
        """
        private_endpoint_connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private endpoint connection name associated to the private endpoint on which we want to apply the specific access mode settings.
        """
        query_access_mode: NotRequired[pulumi.Input[Union[_builtins.str, 'AccessMode']]]
        """
        Specifies the access mode of queries through the specified private endpoint connection in the exclusion.
        """
elif False:
    AccessModeSettingsExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessModeSettingsExclusionArgs:
    def __init__(__self__, *,
                 ingestion_access_mode: Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]] = None,
                 private_endpoint_connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 query_access_mode: Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]] = None):
        """
        Properties that define the scope private link mode settings exclusion item. This setting applies to a specific private endpoint connection and overrides the default settings for that private endpoint connection.
        :param pulumi.Input[Union[_builtins.str, 'AccessMode']] ingestion_access_mode: Specifies the access mode of ingestion through the specified private endpoint connection in the exclusion.
        :param pulumi.Input[_builtins.str] private_endpoint_connection_name: The private endpoint connection name associated to the private endpoint on which we want to apply the specific access mode settings.
        :param pulumi.Input[Union[_builtins.str, 'AccessMode']] query_access_mode: Specifies the access mode of queries through the specified private endpoint connection in the exclusion.
        """
        if ingestion_access_mode is not None:
            pulumi.set(__self__, "ingestion_access_mode", ingestion_access_mode)
        if private_endpoint_connection_name is not None:
            pulumi.set(__self__, "private_endpoint_connection_name", private_endpoint_connection_name)
        if query_access_mode is not None:
            pulumi.set(__self__, "query_access_mode", query_access_mode)

    @_builtins.property
    @pulumi.getter(name="ingestionAccessMode")
    def ingestion_access_mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]]:
        """
        Specifies the access mode of ingestion through the specified private endpoint connection in the exclusion.
        """
        return pulumi.get(self, "ingestion_access_mode")

    @ingestion_access_mode.setter
    def ingestion_access_mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]]):
        pulumi.set(self, "ingestion_access_mode", value)

    @_builtins.property
    @pulumi.getter(name="privateEndpointConnectionName")
    def private_endpoint_connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private endpoint connection name associated to the private endpoint on which we want to apply the specific access mode settings.
        """
        return pulumi.get(self, "private_endpoint_connection_name")

    @private_endpoint_connection_name.setter
    def private_endpoint_connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_endpoint_connection_name", value)

    @_builtins.property
    @pulumi.getter(name="queryAccessMode")
    def query_access_mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]]:
        """
        Specifies the access mode of queries through the specified private endpoint connection in the exclusion.
        """
        return pulumi.get(self, "query_access_mode")

    @query_access_mode.setter
    def query_access_mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AccessMode']]]):
        pulumi.set(self, "query_access_mode", value)


if not MYPY:
    class AccessModeSettingsArgsDict(TypedDict):
        """
        Properties that define the scope private link mode settings.
        """
        ingestion_access_mode: pulumi.Input[Union[_builtins.str, 'AccessMode']]
        """
        Specifies the default access mode of ingestion through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        """
        query_access_mode: pulumi.Input[Union[_builtins.str, 'AccessMode']]
        """
        Specifies the default access mode of queries through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        """
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessModeSettingsExclusionArgsDict']]]]
        """
        List of exclusions that override the default access mode settings for specific private endpoint connections.
        """
elif False:
    AccessModeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessModeSettingsArgs:
    def __init__(__self__, *,
                 ingestion_access_mode: pulumi.Input[Union[_builtins.str, 'AccessMode']],
                 query_access_mode: pulumi.Input[Union[_builtins.str, 'AccessMode']],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['AccessModeSettingsExclusionArgs']]]] = None):
        """
        Properties that define the scope private link mode settings.
        :param pulumi.Input[Union[_builtins.str, 'AccessMode']] ingestion_access_mode: Specifies the default access mode of ingestion through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        :param pulumi.Input[Union[_builtins.str, 'AccessMode']] query_access_mode: Specifies the default access mode of queries through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        :param pulumi.Input[Sequence[pulumi.Input['AccessModeSettingsExclusionArgs']]] exclusions: List of exclusions that override the default access mode settings for specific private endpoint connections.
        """
        pulumi.set(__self__, "ingestion_access_mode", ingestion_access_mode)
        pulumi.set(__self__, "query_access_mode", query_access_mode)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="ingestionAccessMode")
    def ingestion_access_mode(self) -> pulumi.Input[Union[_builtins.str, 'AccessMode']]:
        """
        Specifies the default access mode of ingestion through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        """
        return pulumi.get(self, "ingestion_access_mode")

    @ingestion_access_mode.setter
    def ingestion_access_mode(self, value: pulumi.Input[Union[_builtins.str, 'AccessMode']]):
        pulumi.set(self, "ingestion_access_mode", value)

    @_builtins.property
    @pulumi.getter(name="queryAccessMode")
    def query_access_mode(self) -> pulumi.Input[Union[_builtins.str, 'AccessMode']]:
        """
        Specifies the default access mode of queries through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
        """
        return pulumi.get(self, "query_access_mode")

    @query_access_mode.setter
    def query_access_mode(self, value: pulumi.Input[Union[_builtins.str, 'AccessMode']]):
        pulumi.set(self, "query_access_mode", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessModeSettingsExclusionArgs']]]]:
        """
        List of exclusions that override the default access mode settings for specific private endpoint connections.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessModeSettingsExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class ActionGroupArgsDict(TypedDict):
        """
        A pointer to an Azure Action Group.
        """
        action_group_id: pulumi.Input[_builtins.str]
        """
        The resource ID of the Action Group. This cannot be null or empty.
        """
        webhook_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
        """
elif False:
    ActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupArgs:
    def __init__(__self__, *,
                 action_group_id: pulumi.Input[_builtins.str],
                 webhook_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        A pointer to an Azure Action Group.
        :param pulumi.Input[_builtins.str] action_group_id: The resource ID of the Action Group. This cannot be null or empty.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] webhook_properties: the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if webhook_properties is not None:
            pulumi.set(__self__, "webhook_properties", webhook_properties)

    @_builtins.property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        The resource ID of the Action Group. This cannot be null or empty.
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_group_id", value)

    @_builtins.property
    @pulumi.getter(name="webhookProperties")
    def webhook_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
        """
        return pulumi.get(self, "webhook_properties")

    @webhook_properties.setter
    def webhook_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "webhook_properties", value)


if not MYPY:
    class ActionListArgsDict(TypedDict):
        """
        A list of Activity Log Alert rule actions.
        """
        action_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ActionGroupArgsDict']]]]
        """
        The list of the Action Groups.
        """
elif False:
    ActionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionListArgs:
    def __init__(__self__, *,
                 action_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ActionGroupArgs']]]] = None):
        """
        A list of Activity Log Alert rule actions.
        :param pulumi.Input[Sequence[pulumi.Input['ActionGroupArgs']]] action_groups: The list of the Action Groups.
        """
        if action_groups is not None:
            pulumi.set(__self__, "action_groups", action_groups)

    @_builtins.property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActionGroupArgs']]]]:
        """
        The list of the Action Groups.
        """
        return pulumi.get(self, "action_groups")

    @action_groups.setter
    def action_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActionGroupArgs']]]]):
        pulumi.set(self, "action_groups", value)


if not MYPY:
    class ActionsArgsDict(TypedDict):
        """
        Actions to invoke when the alert fires.
        """
        action_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Action Group resource Ids to invoke when the alert fires.
        """
        action_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The properties of an action properties.
        """
        custom_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The properties of an alert payload.
        """
elif False:
    ActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionsArgs:
    def __init__(__self__, *,
                 action_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 action_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 custom_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Actions to invoke when the alert fires.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] action_groups: Action Group resource Ids to invoke when the alert fires.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] action_properties: The properties of an action properties.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_properties: The properties of an alert payload.
        """
        if action_groups is not None:
            pulumi.set(__self__, "action_groups", action_groups)
        if action_properties is not None:
            pulumi.set(__self__, "action_properties", action_properties)
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)

    @_builtins.property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Action Group resource Ids to invoke when the alert fires.
        """
        return pulumi.get(self, "action_groups")

    @action_groups.setter
    def action_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "action_groups", value)

    @_builtins.property
    @pulumi.getter(name="actionProperties")
    def action_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The properties of an action properties.
        """
        return pulumi.get(self, "action_properties")

    @action_properties.setter
    def action_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "action_properties", value)

    @_builtins.property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The properties of an alert payload.
        """
        return pulumi.get(self, "custom_properties")

    @custom_properties.setter
    def custom_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_properties", value)


if not MYPY:
    class AlertConfigurationArgsDict(TypedDict):
        """
        Alert configuration details
        """
        severity: pulumi.Input[Union[_builtins.str, 'AlertSeverity']]
        """
        The severity of triggered alert.
        """
        action_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Optional list of action group resource IDs to be notified when the alert is triggered.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The alert rule description.
        """
elif False:
    AlertConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationArgs:
    def __init__(__self__, *,
                 severity: pulumi.Input[Union[_builtins.str, 'AlertSeverity']],
                 action_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Alert configuration details
        :param pulumi.Input[Union[_builtins.str, 'AlertSeverity']] severity: The severity of triggered alert.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] action_group_ids: Optional list of action group resource IDs to be notified when the alert is triggered.
        :param pulumi.Input[_builtins.str] description: The alert rule description.
        """
        pulumi.set(__self__, "severity", severity)
        if action_group_ids is not None:
            pulumi.set(__self__, "action_group_ids", action_group_ids)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> pulumi.Input[Union[_builtins.str, 'AlertSeverity']]:
        """
        The severity of triggered alert.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[Union[_builtins.str, 'AlertSeverity']]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter(name="actionGroupIds")
    def action_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Optional list of action group resource IDs to be notified when the alert is triggered.
        """
        return pulumi.get(self, "action_group_ids")

    @action_group_ids.setter
    def action_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "action_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The alert rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AlertRuleAllOfConditionArgsDict(TypedDict):
        """
        An Activity Log Alert rule condition that is met when all its member conditions are met.
        """
        all_of: pulumi.Input[Sequence[pulumi.Input['AlertRuleAnyOfOrLeafConditionArgsDict']]]
        """
        The list of Activity Log Alert rule conditions.
        """
elif False:
    AlertRuleAllOfConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleAllOfConditionArgs:
    def __init__(__self__, *,
                 all_of: pulumi.Input[Sequence[pulumi.Input['AlertRuleAnyOfOrLeafConditionArgs']]]):
        """
        An Activity Log Alert rule condition that is met when all its member conditions are met.
        :param pulumi.Input[Sequence[pulumi.Input['AlertRuleAnyOfOrLeafConditionArgs']]] all_of: The list of Activity Log Alert rule conditions.
        """
        pulumi.set(__self__, "all_of", all_of)

    @_builtins.property
    @pulumi.getter(name="allOf")
    def all_of(self) -> pulumi.Input[Sequence[pulumi.Input['AlertRuleAnyOfOrLeafConditionArgs']]]:
        """
        The list of Activity Log Alert rule conditions.
        """
        return pulumi.get(self, "all_of")

    @all_of.setter
    def all_of(self, value: pulumi.Input[Sequence[pulumi.Input['AlertRuleAnyOfOrLeafConditionArgs']]]):
        pulumi.set(self, "all_of", value)


if not MYPY:
    class AlertRuleAnyOfOrLeafConditionArgsDict(TypedDict):
        """
        An Activity Log Alert rule condition that is met when all its member conditions are met.
        Each condition can be of one of the following types:
        __Important__: Each type has its unique subset of properties. Properties from different types CANNOT exist in one condition.
           * __Leaf Condition -__ must contain 'field' and either 'equals' or 'containsAny'.
          _Please note, 'anyOf' should __not__ be set in a Leaf Condition._
          * __AnyOf Condition -__ must contain __only__ 'anyOf' (which is an array of Leaf Conditions).
          _Please note, 'field', 'equals' and 'containsAny' should __not__ be set in an AnyOf Condition._
        """
        any_of: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertRuleLeafConditionArgsDict']]]]
        """
        An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met.
        """
        contains_any: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        """
        equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Activity Log event's field that this condition will examine.
        The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
elif False:
    AlertRuleAnyOfOrLeafConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleAnyOfOrLeafConditionArgs:
    def __init__(__self__, *,
                 any_of: Optional[pulumi.Input[Sequence[pulumi.Input['AlertRuleLeafConditionArgs']]]] = None,
                 contains_any: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 equals: Optional[pulumi.Input[_builtins.str]] = None,
                 field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An Activity Log Alert rule condition that is met when all its member conditions are met.
        Each condition can be of one of the following types:
        __Important__: Each type has its unique subset of properties. Properties from different types CANNOT exist in one condition.
           * __Leaf Condition -__ must contain 'field' and either 'equals' or 'containsAny'.
          _Please note, 'anyOf' should __not__ be set in a Leaf Condition._
          * __AnyOf Condition -__ must contain __only__ 'anyOf' (which is an array of Leaf Conditions).
          _Please note, 'field', 'equals' and 'containsAny' should __not__ be set in an AnyOf Condition._

        :param pulumi.Input[Sequence[pulumi.Input['AlertRuleLeafConditionArgs']]] any_of: An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] contains_any: The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        :param pulumi.Input[_builtins.str] equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        :param pulumi.Input[_builtins.str] field: The name of the Activity Log event's field that this condition will examine.
               The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if contains_any is not None:
            pulumi.set(__self__, "contains_any", contains_any)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertRuleLeafConditionArgs']]]]:
        """
        An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertRuleLeafConditionArgs']]]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter(name="containsAny")
    def contains_any(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        """
        return pulumi.get(self, "contains_any")

    @contains_any.setter
    def contains_any(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "contains_any", value)

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        """
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equals", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Activity Log event's field that this condition will examine.
        The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class AlertRuleLeafConditionArgsDict(TypedDict):
        """
        An Activity Log Alert rule condition that is met by comparing the field and value of an Activity Log event.
        This condition must contain 'field' and either 'equals' or 'containsAny'.
        """
        contains_any: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        """
        equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Activity Log event's field that this condition will examine.
        The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
elif False:
    AlertRuleLeafConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertRuleLeafConditionArgs:
    def __init__(__self__, *,
                 contains_any: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 equals: Optional[pulumi.Input[_builtins.str]] = None,
                 field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An Activity Log Alert rule condition that is met by comparing the field and value of an Activity Log event.
        This condition must contain 'field' and either 'equals' or 'containsAny'.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] contains_any: The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        :param pulumi.Input[_builtins.str] equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        :param pulumi.Input[_builtins.str] field: The name of the Activity Log event's field that this condition will examine.
               The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
        if contains_any is not None:
            pulumi.set(__self__, "contains_any", contains_any)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter(name="containsAny")
    def contains_any(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The value of the event's field will be compared to the values in this array (case-insensitive) to determine if the condition is met.
        """
        return pulumi.get(self, "contains_any")

    @contains_any.setter
    def contains_any(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "contains_any", value)

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the event's field will be compared to this value (case-insensitive) to determine if the condition is met.
        """
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "equals", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Activity Log event's field that this condition will examine.
        The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class ApplicationInsightsTopologyDiscoveryRulePropertiesArgsDict(TypedDict):
        """
        Discovery rule properties for an Application Insights topology query
        """
        add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]
        """
        Whether to add all recommended signals to the discovered entities.
        """
        application_insights_resource_id: pulumi.Input[_builtins.str]
        """
        Application Insights resource ID
        """
        authentication_setting: pulumi.Input[_builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        discover_relationships: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        discovery_rule_kind: pulumi.Input[_builtins.str]
        """
        Discovery rule relationship discovery behavior
        Expected value is 'ApplicationInsightsTopology'.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
elif False:
    ApplicationInsightsTopologyDiscoveryRulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInsightsTopologyDiscoveryRulePropertiesArgs:
    def __init__(__self__, *,
                 add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']],
                 application_insights_resource_id: pulumi.Input[_builtins.str],
                 authentication_setting: pulumi.Input[_builtins.str],
                 discover_relationships: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']],
                 discovery_rule_kind: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Discovery rule properties for an Application Insights topology query
        :param pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']] add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param pulumi.Input[_builtins.str] application_insights_resource_id: Application Insights resource ID
        :param pulumi.Input[_builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        :param pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']] discover_relationships: Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        :param pulumi.Input[_builtins.str] discovery_rule_kind: Discovery rule relationship discovery behavior
               Expected value is 'ApplicationInsightsTopology'.
        :param pulumi.Input[_builtins.str] display_name: Display name
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "application_insights_resource_id", application_insights_resource_id)
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "discover_relationships", discover_relationships)
        pulumi.set(__self__, "discovery_rule_kind", 'ApplicationInsightsTopology')
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @add_recommended_signals.setter
    def add_recommended_signals(self, value: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]):
        pulumi.set(self, "add_recommended_signals", value)

    @_builtins.property
    @pulumi.getter(name="applicationInsightsResourceId")
    def application_insights_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Application Insights resource ID
        """
        return pulumi.get(self, "application_insights_resource_id")

    @application_insights_resource_id.setter
    def application_insights_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "application_insights_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @_builtins.property
    @pulumi.getter(name="discoverRelationships")
    def discover_relationships(self) -> pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]:
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        return pulumi.get(self, "discover_relationships")

    @discover_relationships.setter
    def discover_relationships(self, value: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]):
        pulumi.set(self, "discover_relationships", value)

    @_builtins.property
    @pulumi.getter(name="discoveryRuleKind")
    def discovery_rule_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Discovery rule relationship discovery behavior
        Expected value is 'ApplicationInsightsTopology'.
        """
        return pulumi.get(self, "discovery_rule_kind")

    @discovery_rule_kind.setter
    def discovery_rule_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_rule_kind", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ArmRoleReceiverArgsDict(TypedDict):
        """
        An arm role receiver.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the arm role receiver. Names must be unique across all receivers within an action group.
        """
        role_id: pulumi.Input[_builtins.str]
        """
        The arm role id.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    ArmRoleReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArmRoleReceiverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 role_id: pulumi.Input[_builtins.str],
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        An arm role receiver.
        :param pulumi.Input[_builtins.str] name: The name of the arm role receiver. Names must be unique across all receivers within an action group.
        :param pulumi.Input[_builtins.str] role_id: The arm role id.
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_id", role_id)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the arm role receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[_builtins.str]:
        """
        The arm role id.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class AutomationRunbookReceiverArgsDict(TypedDict):
        """
        The Azure Automation Runbook notification receiver.
        """
        automation_account_id: pulumi.Input[_builtins.str]
        """
        The Azure automation account Id which holds this runbook and authenticate to Azure resource.
        """
        is_global_runbook: pulumi.Input[_builtins.bool]
        """
        Indicates whether this instance is global runbook.
        """
        runbook_name: pulumi.Input[_builtins.str]
        """
        The name for this runbook.
        """
        webhook_resource_id: pulumi.Input[_builtins.str]
        """
        The resource id for webhook linked to this runbook.
        """
        managed_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates name of the webhook.
        """
        service_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI where webhooks should be sent.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    AutomationRunbookReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRunbookReceiverArgs:
    def __init__(__self__, *,
                 automation_account_id: pulumi.Input[_builtins.str],
                 is_global_runbook: pulumi.Input[_builtins.bool],
                 runbook_name: pulumi.Input[_builtins.str],
                 webhook_resource_id: pulumi.Input[_builtins.str],
                 managed_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 service_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The Azure Automation Runbook notification receiver.
        :param pulumi.Input[_builtins.str] automation_account_id: The Azure automation account Id which holds this runbook and authenticate to Azure resource.
        :param pulumi.Input[_builtins.bool] is_global_runbook: Indicates whether this instance is global runbook.
        :param pulumi.Input[_builtins.str] runbook_name: The name for this runbook.
        :param pulumi.Input[_builtins.str] webhook_resource_id: The resource id for webhook linked to this runbook.
        :param pulumi.Input[_builtins.str] managed_identity: The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        :param pulumi.Input[_builtins.str] name: Indicates name of the webhook.
        :param pulumi.Input[_builtins.str] service_uri: The URI where webhooks should be sent.
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "automation_account_id", automation_account_id)
        pulumi.set(__self__, "is_global_runbook", is_global_runbook)
        pulumi.set(__self__, "runbook_name", runbook_name)
        pulumi.set(__self__, "webhook_resource_id", webhook_resource_id)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter(name="automationAccountId")
    def automation_account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Azure automation account Id which holds this runbook and authenticate to Azure resource.
        """
        return pulumi.get(self, "automation_account_id")

    @automation_account_id.setter
    def automation_account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "automation_account_id", value)

    @_builtins.property
    @pulumi.getter(name="isGlobalRunbook")
    def is_global_runbook(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether this instance is global runbook.
        """
        return pulumi.get(self, "is_global_runbook")

    @is_global_runbook.setter
    def is_global_runbook(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_global_runbook", value)

    @_builtins.property
    @pulumi.getter(name="runbookName")
    def runbook_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name for this runbook.
        """
        return pulumi.get(self, "runbook_name")

    @runbook_name.setter
    def runbook_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runbook_name", value)

    @_builtins.property
    @pulumi.getter(name="webhookResourceId")
    def webhook_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The resource id for webhook linked to this runbook.
        """
        return pulumi.get(self, "webhook_resource_id")

    @webhook_resource_id.setter
    def webhook_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "webhook_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_identity", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates name of the webhook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_uri", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class AutoscaleNotificationArgsDict(TypedDict):
        """
        Autoscale notification.
        """
        operation: pulumi.Input['OperationType']
        """
        the operation associated with the notification and its value must be "scale"
        """
        email: NotRequired[pulumi.Input['EmailNotificationArgsDict']]
        """
        the email notification.
        """
        webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebhookNotificationArgsDict']]]]
        """
        the collection of webhook notifications.
        """
elif False:
    AutoscaleNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleNotificationArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input['OperationType'],
                 email: Optional[pulumi.Input['EmailNotificationArgs']] = None,
                 webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookNotificationArgs']]]] = None):
        """
        Autoscale notification.
        :param pulumi.Input['OperationType'] operation: the operation associated with the notification and its value must be "scale"
        :param pulumi.Input['EmailNotificationArgs'] email: the email notification.
        :param pulumi.Input[Sequence[pulumi.Input['WebhookNotificationArgs']]] webhooks: the collection of webhook notifications.
        """
        pulumi.set(__self__, "operation", operation)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input['OperationType']:
        """
        the operation associated with the notification and its value must be "scale"
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input['OperationType']):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['EmailNotificationArgs']]:
        """
        the email notification.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['EmailNotificationArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookNotificationArgs']]]]:
        """
        the collection of webhook notifications.
        """
        return pulumi.get(self, "webhooks")

    @webhooks.setter
    def webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookNotificationArgs']]]]):
        pulumi.set(self, "webhooks", value)


if not MYPY:
    class AutoscaleProfileArgsDict(TypedDict):
        """
        Autoscale profile.
        """
        capacity: pulumi.Input['ScaleCapacityArgsDict']
        """
        the number of instances that can be used during this profile.
        """
        name: pulumi.Input[_builtins.str]
        """
        the name of the profile.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgsDict']]]
        """
        the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
        """
        fixed_date: NotRequired[pulumi.Input['TimeWindowArgsDict']]
        """
        the specific date-time for the profile. This element is not used if the Recurrence element is used.
        """
        recurrence: NotRequired[pulumi.Input['RecurrenceArgsDict']]
        """
        the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
        """
elif False:
    AutoscaleProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleProfileArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input['ScaleCapacityArgs'],
                 name: pulumi.Input[_builtins.str],
                 rules: pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]],
                 fixed_date: Optional[pulumi.Input['TimeWindowArgs']] = None,
                 recurrence: Optional[pulumi.Input['RecurrenceArgs']] = None):
        """
        Autoscale profile.
        :param pulumi.Input['ScaleCapacityArgs'] capacity: the number of instances that can be used during this profile.
        :param pulumi.Input[_builtins.str] name: the name of the profile.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]] rules: the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
        :param pulumi.Input['TimeWindowArgs'] fixed_date: the specific date-time for the profile. This element is not used if the Recurrence element is used.
        :param pulumi.Input['RecurrenceArgs'] recurrence: the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rules", rules)
        if fixed_date is not None:
            pulumi.set(__self__, "fixed_date", fixed_date)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> pulumi.Input['ScaleCapacityArgs']:
        """
        the number of instances that can be used during this profile.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input['ScaleCapacityArgs']):
        pulumi.set(self, "capacity", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        the name of the profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]:
        """
        the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="fixedDate")
    def fixed_date(self) -> Optional[pulumi.Input['TimeWindowArgs']]:
        """
        the specific date-time for the profile. This element is not used if the Recurrence element is used.
        """
        return pulumi.get(self, "fixed_date")

    @fixed_date.setter
    def fixed_date(self, value: Optional[pulumi.Input['TimeWindowArgs']]):
        pulumi.set(self, "fixed_date", value)

    @_builtins.property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['RecurrenceArgs']]:
        """
        the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['RecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)


if not MYPY:
    class AzureAppPushReceiverArgsDict(TypedDict):
        """
        The Azure mobile App push notification receiver.
        """
        email_address: pulumi.Input[_builtins.str]
        """
        The email address registered for the Azure mobile app.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Azure mobile app push receiver. Names must be unique across all receivers within a tenant action group.
        """
elif False:
    AzureAppPushReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureAppPushReceiverArgs:
    def __init__(__self__, *,
                 email_address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        The Azure mobile App push notification receiver.
        :param pulumi.Input[_builtins.str] email_address: The email address registered for the Azure mobile app.
        :param pulumi.Input[_builtins.str] name: The name of the Azure mobile app push receiver. Names must be unique across all receivers within a tenant action group.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> pulumi.Input[_builtins.str]:
        """
        The email address registered for the Azure mobile app.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Azure mobile app push receiver. Names must be unique across all receivers within a tenant action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AzureFunctionReceiverArgsDict(TypedDict):
        """
        An azure function receiver.
        """
        function_app_resource_id: pulumi.Input[_builtins.str]
        """
        The azure resource id of the function app.
        """
        function_name: pulumi.Input[_builtins.str]
        """
        The function name in the function app.
        """
        http_trigger_url: pulumi.Input[_builtins.str]
        """
        The http trigger url where http request sent to.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the azure function receiver. Names must be unique across all receivers within an action group.
        """
        managed_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    AzureFunctionReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureFunctionReceiverArgs:
    def __init__(__self__, *,
                 function_app_resource_id: pulumi.Input[_builtins.str],
                 function_name: pulumi.Input[_builtins.str],
                 http_trigger_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 managed_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        An azure function receiver.
        :param pulumi.Input[_builtins.str] function_app_resource_id: The azure resource id of the function app.
        :param pulumi.Input[_builtins.str] function_name: The function name in the function app.
        :param pulumi.Input[_builtins.str] http_trigger_url: The http trigger url where http request sent to.
        :param pulumi.Input[_builtins.str] name: The name of the azure function receiver. Names must be unique across all receivers within an action group.
        :param pulumi.Input[_builtins.str] managed_identity: The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "function_app_resource_id", function_app_resource_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "http_trigger_url", http_trigger_url)
        pulumi.set(__self__, "name", name)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The azure resource id of the function app.
        """
        return pulumi.get(self, "function_app_resource_id")

    @function_app_resource_id.setter
    def function_app_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_app_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> pulumi.Input[_builtins.str]:
        """
        The function name in the function app.
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_name", value)

    @_builtins.property
    @pulumi.getter(name="httpTriggerUrl")
    def http_trigger_url(self) -> pulumi.Input[_builtins.str]:
        """
        The http trigger url where http request sent to.
        """
        return pulumi.get(self, "http_trigger_url")

    @http_trigger_url.setter
    def http_trigger_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_trigger_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the azure function receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_identity", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class AzureMonitorWorkspaceLogsApiConfigArgsDict(TypedDict):
        """
        Azure Monitor Workspace Logs Api configurations.
        """
        data_collection_endpoint_url: pulumi.Input[_builtins.str]
        """
        Data collection endpoint ingestion url.
        """
        data_collection_rule: pulumi.Input[_builtins.str]
        """
        Data Collection Rule (DCR) immutable id.
        """
        schema: pulumi.Input['SchemaMapArgsDict']
        """
        The schema mapping for incoming data.
        """
        stream: pulumi.Input[_builtins.str]
        """
        Stream name in destination. Azure Monitor stream is related to the destination table.
        """
elif False:
    AzureMonitorWorkspaceLogsApiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorWorkspaceLogsApiConfigArgs:
    def __init__(__self__, *,
                 data_collection_endpoint_url: pulumi.Input[_builtins.str],
                 data_collection_rule: pulumi.Input[_builtins.str],
                 schema: pulumi.Input['SchemaMapArgs'],
                 stream: pulumi.Input[_builtins.str]):
        """
        Azure Monitor Workspace Logs Api configurations.
        :param pulumi.Input[_builtins.str] data_collection_endpoint_url: Data collection endpoint ingestion url.
        :param pulumi.Input[_builtins.str] data_collection_rule: Data Collection Rule (DCR) immutable id.
        :param pulumi.Input['SchemaMapArgs'] schema: The schema mapping for incoming data.
        :param pulumi.Input[_builtins.str] stream: Stream name in destination. Azure Monitor stream is related to the destination table.
        """
        pulumi.set(__self__, "data_collection_endpoint_url", data_collection_endpoint_url)
        pulumi.set(__self__, "data_collection_rule", data_collection_rule)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "stream", stream)

    @_builtins.property
    @pulumi.getter(name="dataCollectionEndpointUrl")
    def data_collection_endpoint_url(self) -> pulumi.Input[_builtins.str]:
        """
        Data collection endpoint ingestion url.
        """
        return pulumi.get(self, "data_collection_endpoint_url")

    @data_collection_endpoint_url.setter
    def data_collection_endpoint_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_collection_endpoint_url", value)

    @_builtins.property
    @pulumi.getter(name="dataCollectionRule")
    def data_collection_rule(self) -> pulumi.Input[_builtins.str]:
        """
        Data Collection Rule (DCR) immutable id.
        """
        return pulumi.get(self, "data_collection_rule")

    @data_collection_rule.setter
    def data_collection_rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_collection_rule", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input['SchemaMapArgs']:
        """
        The schema mapping for incoming data.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['SchemaMapArgs']):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def stream(self) -> pulumi.Input[_builtins.str]:
        """
        Stream name in destination. Azure Monitor stream is related to the destination table.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream", value)


if not MYPY:
    class AzureMonitorWorkspaceLogsExporterArgsDict(TypedDict):
        """
        Azure Monitor Workspace Logs specific configurations.
        """
        api: pulumi.Input['AzureMonitorWorkspaceLogsApiConfigArgsDict']
        """
        API configurations for Azure Monitor workspace exporter.
        """
        cache: NotRequired[pulumi.Input['CacheConfigurationArgsDict']]
        """
        Cache configurations.
        """
        concurrency: NotRequired[pulumi.Input['ConcurrencyConfigurationArgsDict']]
        """
        Concurrency configuration for the exporter.
        """
elif False:
    AzureMonitorWorkspaceLogsExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorWorkspaceLogsExporterArgs:
    def __init__(__self__, *,
                 api: pulumi.Input['AzureMonitorWorkspaceLogsApiConfigArgs'],
                 cache: Optional[pulumi.Input['CacheConfigurationArgs']] = None,
                 concurrency: Optional[pulumi.Input['ConcurrencyConfigurationArgs']] = None):
        """
        Azure Monitor Workspace Logs specific configurations.
        :param pulumi.Input['AzureMonitorWorkspaceLogsApiConfigArgs'] api: API configurations for Azure Monitor workspace exporter.
        :param pulumi.Input['CacheConfigurationArgs'] cache: Cache configurations.
        :param pulumi.Input['ConcurrencyConfigurationArgs'] concurrency: Concurrency configuration for the exporter.
        """
        pulumi.set(__self__, "api", api)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)

    @_builtins.property
    @pulumi.getter
    def api(self) -> pulumi.Input['AzureMonitorWorkspaceLogsApiConfigArgs']:
        """
        API configurations for Azure Monitor workspace exporter.
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: pulumi.Input['AzureMonitorWorkspaceLogsApiConfigArgs']):
        pulumi.set(self, "api", value)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input['CacheConfigurationArgs']]:
        """
        Cache configurations.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input['CacheConfigurationArgs']]):
        pulumi.set(self, "cache", value)

    @_builtins.property
    @pulumi.getter
    def concurrency(self) -> Optional[pulumi.Input['ConcurrencyConfigurationArgs']]:
        """
        Concurrency configuration for the exporter.
        """
        return pulumi.get(self, "concurrency")

    @concurrency.setter
    def concurrency(self, value: Optional[pulumi.Input['ConcurrencyConfigurationArgs']]):
        pulumi.set(self, "concurrency", value)


if not MYPY:
    class AzureMonitorWorkspaceSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for a Azure Monitor Workspace
        """
        authentication_setting: pulumi.Input[_builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        azure_monitor_workspace_resource_id: pulumi.Input[_builtins.str]
        """
        Azure Monitor workspace resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    AzureMonitorWorkspaceSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorWorkspaceSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[_builtins.str],
                 azure_monitor_workspace_resource_id: pulumi.Input[_builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for a Azure Monitor Workspace
        :param pulumi.Input[_builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[_builtins.str] azure_monitor_workspace_resource_id: Azure Monitor workspace resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_monitor_workspace_resource_id", azure_monitor_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @_builtins.property
    @pulumi.getter(name="azureMonitorWorkspaceResourceId")
    def azure_monitor_workspace_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Azure Monitor workspace resource ID
        """
        return pulumi.get(self, "azure_monitor_workspace_resource_id")

    @azure_monitor_workspace_resource_id.setter
    def azure_monitor_workspace_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "azure_monitor_workspace_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class AzureResourceManagerCommonTypesExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the extended location.
        """
        type: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]
        """
        The type of the extended location.
        """
elif False:
    AzureResourceManagerCommonTypesExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureResourceManagerCommonTypesExtendedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]):
        """
        The complex type of the extended location.
        :param pulumi.Input[_builtins.str] name: The name of the extended location.
        :param pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']] type: The type of the extended location.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AzureResourceSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for an Azure resource
        """
        authentication_setting: pulumi.Input[_builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        azure_resource_id: pulumi.Input[_builtins.str]
        """
        Azure resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    AzureResourceSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureResourceSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[_builtins.str],
                 azure_resource_id: pulumi.Input[_builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for an Azure resource
        :param pulumi.Input[_builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[_builtins.str] azure_resource_id: Azure resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Azure resource ID
        """
        return pulumi.get(self, "azure_resource_id")

    @azure_resource_id.setter
    def azure_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "azure_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class BatchProcessorArgsDict(TypedDict):
        """
        Batch processor.
        """
        batch_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the batch.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in milliseconds.
        """
elif False:
    BatchProcessorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchProcessorArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Batch processor.
        :param pulumi.Input[_builtins.int] batch_size: Size of the batch.
        :param pulumi.Input[_builtins.int] timeout: Timeout in milliseconds.
        """
        if batch_size is None:
            batch_size = 8192
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if timeout is None:
            timeout = 200
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the batch.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_size", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in milliseconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class CacheConfigurationArgsDict(TypedDict):
        """
        Cache configurations.
        """
        max_storage_usage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max storage usage in megabytes.
        """
        retention_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retention period in minutes.
        """
elif False:
    CacheConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheConfigurationArgs:
    def __init__(__self__, *,
                 max_storage_usage: Optional[pulumi.Input[_builtins.int]] = None,
                 retention_period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Cache configurations.
        :param pulumi.Input[_builtins.int] max_storage_usage: Max storage usage in megabytes.
        :param pulumi.Input[_builtins.int] retention_period: Retention period in minutes.
        """
        if max_storage_usage is not None:
            pulumi.set(__self__, "max_storage_usage", max_storage_usage)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="maxStorageUsage")
    def max_storage_usage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max storage usage in megabytes.
        """
        return pulumi.get(self, "max_storage_usage")

    @max_storage_usage.setter
    def max_storage_usage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_storage_usage", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retention period in minutes.
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_period", value)


if not MYPY:
    class ColumnDefinitionArgsDict(TypedDict):
        """
        Definition of custom data column.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the column.
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'KnownColumnDefinitionType']]]
        """
        The type of the column data.
        """
elif False:
    ColumnDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ColumnDefinitionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'KnownColumnDefinitionType']]] = None):
        """
        Definition of custom data column.
        :param pulumi.Input[_builtins.str] name: The name of the column.
        :param pulumi.Input[Union[_builtins.str, 'KnownColumnDefinitionType']] type: The type of the column data.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'KnownColumnDefinitionType']]]:
        """
        The type of the column data.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'KnownColumnDefinitionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConcurrencyConfigurationArgsDict(TypedDict):
        """
        Concurrent publishing configuration.
        """
        batch_queue_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size of the queue for log batches.
        """
        worker_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of parallel workers processing the log queues.
        """
elif False:
    ConcurrencyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 batch_queue_size: Optional[pulumi.Input[_builtins.int]] = None,
                 worker_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Concurrent publishing configuration.
        :param pulumi.Input[_builtins.int] batch_queue_size: Size of the queue for log batches.
        :param pulumi.Input[_builtins.int] worker_count: Number of parallel workers processing the log queues.
        """
        if batch_queue_size is None:
            batch_queue_size = 100
        if batch_queue_size is not None:
            pulumi.set(__self__, "batch_queue_size", batch_queue_size)
        if worker_count is None:
            worker_count = 4
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @_builtins.property
    @pulumi.getter(name="batchQueueSize")
    def batch_queue_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size of the queue for log batches.
        """
        return pulumi.get(self, "batch_queue_size")

    @batch_queue_size.setter
    def batch_queue_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_queue_size", value)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of parallel workers processing the log queues.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class ConditionFailingPeriodsArgsDict(TypedDict):
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert.
        """
        min_failing_periods_to_alert: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods. Default value is 1
        """
        number_of_evaluation_periods: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points. Default value is 1
        """
elif False:
    ConditionFailingPeriodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionFailingPeriodsArgs:
    def __init__(__self__, *,
                 min_failing_periods_to_alert: Optional[pulumi.Input[_builtins.float]] = None,
                 number_of_evaluation_periods: Optional[pulumi.Input[_builtins.float]] = None):
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.float] min_failing_periods_to_alert: The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods. Default value is 1
        :param pulumi.Input[_builtins.float] number_of_evaluation_periods: The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points. Default value is 1
        """
        if min_failing_periods_to_alert is None:
            min_failing_periods_to_alert = 1
        if min_failing_periods_to_alert is not None:
            pulumi.set(__self__, "min_failing_periods_to_alert", min_failing_periods_to_alert)
        if number_of_evaluation_periods is None:
            number_of_evaluation_periods = 1
        if number_of_evaluation_periods is not None:
            pulumi.set(__self__, "number_of_evaluation_periods", number_of_evaluation_periods)

    @_builtins.property
    @pulumi.getter(name="minFailingPeriodsToAlert")
    def min_failing_periods_to_alert(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods. Default value is 1
        """
        return pulumi.get(self, "min_failing_periods_to_alert")

    @min_failing_periods_to_alert.setter
    def min_failing_periods_to_alert(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_failing_periods_to_alert", value)

    @_builtins.property
    @pulumi.getter(name="numberOfEvaluationPeriods")
    def number_of_evaluation_periods(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points. Default value is 1
        """
        return pulumi.get(self, "number_of_evaluation_periods")

    @number_of_evaluation_periods.setter
    def number_of_evaluation_periods(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "number_of_evaluation_periods", value)


if not MYPY:
    class ConditionArgsDict(TypedDict):
        """
        A condition of the scheduled query rule.
        """
        alert_sensitivity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The extent of deviation required to trigger an alert. Allowed values are 'Low', 'Medium' and 'High'. This will affect how tight the threshold is to the metric series pattern. Relevant only for dynamic threshold rules of the kind LogAlert.
        """
        criterion_type: NotRequired[pulumi.Input[Union[_builtins.str, 'CriterionType']]]
        """
        Specifies the type of threshold criteria
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DimensionArgsDict']]]]
        """
        List of Dimensions conditions
        """
        failing_periods: NotRequired[pulumi.Input['ConditionFailingPeriodsArgsDict']]
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert.
        """
        ignore_data_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format). Relevant only for dynamic threshold rules of the kind LogAlert.
        """
        metric_measure_column: NotRequired[pulumi.Input[_builtins.str]]
        """
        The column containing the metric measure number. Relevant only for rules of the kind LogAlert.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the metric to be sent. Relevant and required only for rules of the kind LogToMetric.
        """
        min_recurrence_count: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum results count that should be found for triggering an alert. Relevant only for rules of the kind SimpleLogAlert.
        """
        operator: NotRequired[pulumi.Input[Union[_builtins.str, 'ConditionOperator']]]
        """
        The criteria operator. Relevant and required only for rules of the kind LogAlert.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log query alert
        """
        resource_id_column: NotRequired[pulumi.Input[_builtins.str]]
        """
        The column containing the resource id. The content of the column must be a uri formatted as resource id. Relevant only for rules of the kind LogAlert.
        """
        threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        the criteria threshold value that activates the alert. Relevant and required only for static threshold rules of the kind LogAlert.
        """
        time_aggregation: NotRequired[pulumi.Input[Union[_builtins.str, 'TimeAggregation']]]
        """
        Aggregation type. Relevant and required only for rules of the kind LogAlert.
        """
elif False:
    ConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionArgs:
    def __init__(__self__, *,
                 alert_sensitivity: Optional[pulumi.Input[_builtins.str]] = None,
                 criterion_type: Optional[pulumi.Input[Union[_builtins.str, 'CriterionType']]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]] = None,
                 failing_periods: Optional[pulumi.Input['ConditionFailingPeriodsArgs']] = None,
                 ignore_data_before: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_measure_column: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 min_recurrence_count: Optional[pulumi.Input[_builtins.float]] = None,
                 operator: Optional[pulumi.Input[Union[_builtins.str, 'ConditionOperator']]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id_column: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 time_aggregation: Optional[pulumi.Input[Union[_builtins.str, 'TimeAggregation']]] = None):
        """
        A condition of the scheduled query rule.
        :param pulumi.Input[_builtins.str] alert_sensitivity: The extent of deviation required to trigger an alert. Allowed values are 'Low', 'Medium' and 'High'. This will affect how tight the threshold is to the metric series pattern. Relevant only for dynamic threshold rules of the kind LogAlert.
        :param pulumi.Input[Union[_builtins.str, 'CriterionType']] criterion_type: Specifies the type of threshold criteria
        :param pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]] dimensions: List of Dimensions conditions
        :param pulumi.Input['ConditionFailingPeriodsArgs'] failing_periods: The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.str] ignore_data_before: Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format). Relevant only for dynamic threshold rules of the kind LogAlert.
        :param pulumi.Input[_builtins.str] metric_measure_column: The column containing the metric measure number. Relevant only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.str] metric_name: The name of the metric to be sent. Relevant and required only for rules of the kind LogToMetric.
        :param pulumi.Input[_builtins.float] min_recurrence_count: The minimum results count that should be found for triggering an alert. Relevant only for rules of the kind SimpleLogAlert.
        :param pulumi.Input[Union[_builtins.str, 'ConditionOperator']] operator: The criteria operator. Relevant and required only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.str] query: Log query alert
        :param pulumi.Input[_builtins.str] resource_id_column: The column containing the resource id. The content of the column must be a uri formatted as resource id. Relevant only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.float] threshold: the criteria threshold value that activates the alert. Relevant and required only for static threshold rules of the kind LogAlert.
        :param pulumi.Input[Union[_builtins.str, 'TimeAggregation']] time_aggregation: Aggregation type. Relevant and required only for rules of the kind LogAlert.
        """
        if alert_sensitivity is not None:
            pulumi.set(__self__, "alert_sensitivity", alert_sensitivity)
        if criterion_type is not None:
            pulumi.set(__self__, "criterion_type", criterion_type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if failing_periods is not None:
            pulumi.set(__self__, "failing_periods", failing_periods)
        if ignore_data_before is not None:
            pulumi.set(__self__, "ignore_data_before", ignore_data_before)
        if metric_measure_column is not None:
            pulumi.set(__self__, "metric_measure_column", metric_measure_column)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if min_recurrence_count is not None:
            pulumi.set(__self__, "min_recurrence_count", min_recurrence_count)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if resource_id_column is not None:
            pulumi.set(__self__, "resource_id_column", resource_id_column)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if time_aggregation is not None:
            pulumi.set(__self__, "time_aggregation", time_aggregation)

    @_builtins.property
    @pulumi.getter(name="alertSensitivity")
    def alert_sensitivity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The extent of deviation required to trigger an alert. Allowed values are 'Low', 'Medium' and 'High'. This will affect how tight the threshold is to the metric series pattern. Relevant only for dynamic threshold rules of the kind LogAlert.
        """
        return pulumi.get(self, "alert_sensitivity")

    @alert_sensitivity.setter
    def alert_sensitivity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alert_sensitivity", value)

    @_builtins.property
    @pulumi.getter(name="criterionType")
    def criterion_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'CriterionType']]]:
        """
        Specifies the type of threshold criteria
        """
        return pulumi.get(self, "criterion_type")

    @criterion_type.setter
    def criterion_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'CriterionType']]]):
        pulumi.set(self, "criterion_type", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]]:
        """
        List of Dimensions conditions
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="failingPeriods")
    def failing_periods(self) -> Optional[pulumi.Input['ConditionFailingPeriodsArgs']]:
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert.
        """
        return pulumi.get(self, "failing_periods")

    @failing_periods.setter
    def failing_periods(self, value: Optional[pulumi.Input['ConditionFailingPeriodsArgs']]):
        pulumi.set(self, "failing_periods", value)

    @_builtins.property
    @pulumi.getter(name="ignoreDataBefore")
    def ignore_data_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format). Relevant only for dynamic threshold rules of the kind LogAlert.
        """
        return pulumi.get(self, "ignore_data_before")

    @ignore_data_before.setter
    def ignore_data_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ignore_data_before", value)

    @_builtins.property
    @pulumi.getter(name="metricMeasureColumn")
    def metric_measure_column(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The column containing the metric measure number. Relevant only for rules of the kind LogAlert.
        """
        return pulumi.get(self, "metric_measure_column")

    @metric_measure_column.setter
    def metric_measure_column(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_measure_column", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the metric to be sent. Relevant and required only for rules of the kind LogToMetric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="minRecurrenceCount")
    def min_recurrence_count(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum results count that should be found for triggering an alert. Relevant only for rules of the kind SimpleLogAlert.
        """
        return pulumi.get(self, "min_recurrence_count")

    @min_recurrence_count.setter
    def min_recurrence_count(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_recurrence_count", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ConditionOperator']]]:
        """
        The criteria operator. Relevant and required only for rules of the kind LogAlert.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ConditionOperator']]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log query alert
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="resourceIdColumn")
    def resource_id_column(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The column containing the resource id. The content of the column must be a uri formatted as resource id. Relevant only for rules of the kind LogAlert.
        """
        return pulumi.get(self, "resource_id_column")

    @resource_id_column.setter
    def resource_id_column(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id_column", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        the criteria threshold value that activates the alert. Relevant and required only for static threshold rules of the kind LogAlert.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> Optional[pulumi.Input[Union[_builtins.str, 'TimeAggregation']]]:
        """
        Aggregation type. Relevant and required only for rules of the kind LogAlert.
        """
        return pulumi.get(self, "time_aggregation")

    @time_aggregation.setter
    def time_aggregation(self, value: Optional[pulumi.Input[Union[_builtins.str, 'TimeAggregation']]]):
        pulumi.set(self, "time_aggregation", value)


if not MYPY:
    class DataCollectionEndpointNetworkAclsArgsDict(TypedDict):
        """
        Network access control rules for the endpoints.
        """
        public_network_access: NotRequired[pulumi.Input[Union[_builtins.str, 'KnownPublicNetworkAccessOptions']]]
        """
        The configuration to set whether network access from public internet to the endpoints are allowed.
        """
elif False:
    DataCollectionEndpointNetworkAclsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionEndpointNetworkAclsArgs:
    def __init__(__self__, *,
                 public_network_access: Optional[pulumi.Input[Union[_builtins.str, 'KnownPublicNetworkAccessOptions']]] = None):
        """
        Network access control rules for the endpoints.
        :param pulumi.Input[Union[_builtins.str, 'KnownPublicNetworkAccessOptions']] public_network_access: The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @_builtins.property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[_builtins.str, 'KnownPublicNetworkAccessOptions']]]:
        """
        The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[_builtins.str, 'KnownPublicNetworkAccessOptions']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class DataCollectionEndpointResourceIdentityArgsDict(TypedDict):
        """
        Managed service identity of the resource.
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    DataCollectionEndpointResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionEndpointResourceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity of the resource.
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class DataCollectionRuleDataSourcesArgsDict(TypedDict):
        """
        The specification of data sources. 
        This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        """
        data_imports: NotRequired[pulumi.Input['DataSourcesSpecDataImportsArgsDict']]
        """
        Specifications of pull based data sources
        """
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgsDict']]]]
        """
        The list of Azure VM extension data source configurations.
        """
        iis_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgsDict']]]]
        """
        The list of IIS logs source configurations.
        """
        log_files: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgsDict']]]]
        """
        The list of Log files source configurations.
        """
        performance_counters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgsDict']]]]
        """
        The list of performance counter data source configurations.
        """
        platform_telemetry: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgsDict']]]]
        """
        The list of platform telemetry configurations
        """
        prometheus_forwarder: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgsDict']]]]
        """
        The list of Prometheus forwarder data source configurations.
        """
        syslog: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgsDict']]]]
        """
        The list of Syslog data source configurations.
        """
        windows_event_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgsDict']]]]
        """
        The list of Windows Event Log data source configurations.
        """
        windows_firewall_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgsDict']]]]
        """
        The list of Windows Firewall logs source configurations.
        """
elif False:
    DataCollectionRuleDataSourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesArgs:
    def __init__(__self__, *,
                 data_imports: Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]] = None,
                 iis_logs: Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]] = None,
                 log_files: Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]] = None,
                 performance_counters: Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]] = None,
                 platform_telemetry: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]] = None,
                 prometheus_forwarder: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]] = None,
                 syslog: Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]] = None,
                 windows_event_logs: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]] = None,
                 windows_firewall_logs: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]] = None):
        """
        The specification of data sources. 
        This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        :param pulumi.Input['DataSourcesSpecDataImportsArgs'] data_imports: Specifications of pull based data sources
        :param pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]] extensions: The list of Azure VM extension data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]] iis_logs: The list of IIS logs source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]] log_files: The list of Log files source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]] performance_counters: The list of performance counter data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]] platform_telemetry: The list of platform telemetry configurations
        :param pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]] prometheus_forwarder: The list of Prometheus forwarder data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]] syslog: The list of Syslog data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]] windows_event_logs: The list of Windows Event Log data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]] windows_firewall_logs: The list of Windows Firewall logs source configurations.
        """
        if data_imports is not None:
            pulumi.set(__self__, "data_imports", data_imports)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if iis_logs is not None:
            pulumi.set(__self__, "iis_logs", iis_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if performance_counters is not None:
            pulumi.set(__self__, "performance_counters", performance_counters)
        if platform_telemetry is not None:
            pulumi.set(__self__, "platform_telemetry", platform_telemetry)
        if prometheus_forwarder is not None:
            pulumi.set(__self__, "prometheus_forwarder", prometheus_forwarder)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)
        if windows_event_logs is not None:
            pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        if windows_firewall_logs is not None:
            pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)

    @_builtins.property
    @pulumi.getter(name="dataImports")
    def data_imports(self) -> Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']]:
        """
        Specifications of pull based data sources
        """
        return pulumi.get(self, "data_imports")

    @data_imports.setter
    def data_imports(self, value: Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']]):
        pulumi.set(self, "data_imports", value)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]]:
        """
        The list of Azure VM extension data source configurations.
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]]):
        pulumi.set(self, "extensions", value)

    @_builtins.property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]]:
        """
        The list of IIS logs source configurations.
        """
        return pulumi.get(self, "iis_logs")

    @iis_logs.setter
    def iis_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]]):
        pulumi.set(self, "iis_logs", value)

    @_builtins.property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]]:
        """
        The list of Log files source configurations.
        """
        return pulumi.get(self, "log_files")

    @log_files.setter
    def log_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]]):
        pulumi.set(self, "log_files", value)

    @_builtins.property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]]:
        """
        The list of performance counter data source configurations.
        """
        return pulumi.get(self, "performance_counters")

    @performance_counters.setter
    def performance_counters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]]):
        pulumi.set(self, "performance_counters", value)

    @_builtins.property
    @pulumi.getter(name="platformTelemetry")
    def platform_telemetry(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]]:
        """
        The list of platform telemetry configurations
        """
        return pulumi.get(self, "platform_telemetry")

    @platform_telemetry.setter
    def platform_telemetry(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]]):
        pulumi.set(self, "platform_telemetry", value)

    @_builtins.property
    @pulumi.getter(name="prometheusForwarder")
    def prometheus_forwarder(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]]:
        """
        The list of Prometheus forwarder data source configurations.
        """
        return pulumi.get(self, "prometheus_forwarder")

    @prometheus_forwarder.setter
    def prometheus_forwarder(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]]):
        pulumi.set(self, "prometheus_forwarder", value)

    @_builtins.property
    @pulumi.getter
    def syslog(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]]:
        """
        The list of Syslog data source configurations.
        """
        return pulumi.get(self, "syslog")

    @syslog.setter
    def syslog(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]]):
        pulumi.set(self, "syslog", value)

    @_builtins.property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]]:
        """
        The list of Windows Event Log data source configurations.
        """
        return pulumi.get(self, "windows_event_logs")

    @windows_event_logs.setter
    def windows_event_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]]):
        pulumi.set(self, "windows_event_logs", value)

    @_builtins.property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]]:
        """
        The list of Windows Firewall logs source configurations.
        """
        return pulumi.get(self, "windows_firewall_logs")

    @windows_firewall_logs.setter
    def windows_firewall_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]]):
        pulumi.set(self, "windows_firewall_logs", value)


if not MYPY:
    class DataCollectionRuleDestinationsArgsDict(TypedDict):
        """
        The specification of destinations.
        """
        azure_monitor_metrics: NotRequired[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgsDict']]
        """
        Azure Monitor Metrics destination.
        """
        event_hubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgsDict']]]]
        """
        List of Event Hubs destinations.
        """
        event_hubs_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgsDict']]]]
        """
        List of Event Hubs Direct destinations.
        """
        log_analytics: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgsDict']]]]
        """
        List of Log Analytics destinations.
        """
        monitoring_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgsDict']]]]
        """
        List of monitoring account destinations.
        """
        storage_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgsDict']]]]
        """
        List of storage accounts destinations.
        """
        storage_blobs_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgsDict']]]]
        """
        List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        """
        storage_tables_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgsDict']]]]
        """
        List of Storage Table Direct destinations.
        """
elif False:
    DataCollectionRuleDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsArgs:
    def __init__(__self__, *,
                 azure_monitor_metrics: Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']] = None,
                 event_hubs: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]] = None,
                 event_hubs_direct: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]] = None,
                 log_analytics: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]] = None,
                 monitoring_accounts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]] = None,
                 storage_accounts: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]] = None,
                 storage_blobs_direct: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]] = None,
                 storage_tables_direct: Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]] = None):
        """
        The specification of destinations.
        :param pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs'] azure_monitor_metrics: Azure Monitor Metrics destination.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]] event_hubs: List of Event Hubs destinations.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]] event_hubs_direct: List of Event Hubs Direct destinations.
        :param pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]] log_analytics: List of Log Analytics destinations.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]] monitoring_accounts: List of monitoring account destinations.
        :param pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]] storage_accounts: List of storage accounts destinations.
        :param pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]] storage_blobs_direct: List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        :param pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]] storage_tables_direct: List of Storage Table Direct destinations.
        """
        if azure_monitor_metrics is not None:
            pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        if event_hubs is not None:
            pulumi.set(__self__, "event_hubs", event_hubs)
        if event_hubs_direct is not None:
            pulumi.set(__self__, "event_hubs_direct", event_hubs_direct)
        if log_analytics is not None:
            pulumi.set(__self__, "log_analytics", log_analytics)
        if monitoring_accounts is not None:
            pulumi.set(__self__, "monitoring_accounts", monitoring_accounts)
        if storage_accounts is not None:
            pulumi.set(__self__, "storage_accounts", storage_accounts)
        if storage_blobs_direct is not None:
            pulumi.set(__self__, "storage_blobs_direct", storage_blobs_direct)
        if storage_tables_direct is not None:
            pulumi.set(__self__, "storage_tables_direct", storage_tables_direct)

    @_builtins.property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']]:
        """
        Azure Monitor Metrics destination.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @azure_monitor_metrics.setter
    def azure_monitor_metrics(self, value: Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']]):
        pulumi.set(self, "azure_monitor_metrics", value)

    @_builtins.property
    @pulumi.getter(name="eventHubs")
    def event_hubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]]:
        """
        List of Event Hubs destinations.
        """
        return pulumi.get(self, "event_hubs")

    @event_hubs.setter
    def event_hubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]]):
        pulumi.set(self, "event_hubs", value)

    @_builtins.property
    @pulumi.getter(name="eventHubsDirect")
    def event_hubs_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]]:
        """
        List of Event Hubs Direct destinations.
        """
        return pulumi.get(self, "event_hubs_direct")

    @event_hubs_direct.setter
    def event_hubs_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]]):
        pulumi.set(self, "event_hubs_direct", value)

    @_builtins.property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]]:
        """
        List of Log Analytics destinations.
        """
        return pulumi.get(self, "log_analytics")

    @log_analytics.setter
    def log_analytics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]]):
        pulumi.set(self, "log_analytics", value)

    @_builtins.property
    @pulumi.getter(name="monitoringAccounts")
    def monitoring_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]]:
        """
        List of monitoring account destinations.
        """
        return pulumi.get(self, "monitoring_accounts")

    @monitoring_accounts.setter
    def monitoring_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]]):
        pulumi.set(self, "monitoring_accounts", value)

    @_builtins.property
    @pulumi.getter(name="storageAccounts")
    def storage_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]:
        """
        List of storage accounts destinations.
        """
        return pulumi.get(self, "storage_accounts")

    @storage_accounts.setter
    def storage_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]):
        pulumi.set(self, "storage_accounts", value)

    @_builtins.property
    @pulumi.getter(name="storageBlobsDirect")
    def storage_blobs_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]:
        """
        List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        """
        return pulumi.get(self, "storage_blobs_direct")

    @storage_blobs_direct.setter
    def storage_blobs_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]):
        pulumi.set(self, "storage_blobs_direct", value)

    @_builtins.property
    @pulumi.getter(name="storageTablesDirect")
    def storage_tables_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]]:
        """
        List of Storage Table Direct destinations.
        """
        return pulumi.get(self, "storage_tables_direct")

    @storage_tables_direct.setter
    def storage_tables_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]]):
        pulumi.set(self, "storage_tables_direct", value)


if not MYPY:
    class DataCollectionRuleResourceIdentityArgsDict(TypedDict):
        """
        Managed service identity of the resource.
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    DataCollectionRuleResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleResourceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity of the resource.
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class DataFlowArgsDict(TypedDict):
        """
        Definition of which streams are sent to which destinations.
        """
        built_in_transform: NotRequired[pulumi.Input[_builtins.str]]
        """
        The builtIn transform to transform stream data
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of destinations for this data flow.
        """
        output_stream: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output stream of the transform. Only required if the transform changes data to a different stream.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownDataFlowStreams']]]]]
        """
        List of streams for this data flow.
        """
        transform_kql: NotRequired[pulumi.Input[_builtins.str]]
        """
        The KQL query to transform stream data.
        """
elif False:
    DataFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowArgs:
    def __init__(__self__, *,
                 built_in_transform: Optional[pulumi.Input[_builtins.str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 output_stream: Optional[pulumi.Input[_builtins.str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownDataFlowStreams']]]]] = None,
                 transform_kql: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Definition of which streams are sent to which destinations.
        :param pulumi.Input[_builtins.str] built_in_transform: The builtIn transform to transform stream data
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destinations: List of destinations for this data flow.
        :param pulumi.Input[_builtins.str] output_stream: The output stream of the transform. Only required if the transform changes data to a different stream.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownDataFlowStreams']]]] streams: List of streams for this data flow.
        :param pulumi.Input[_builtins.str] transform_kql: The KQL query to transform stream data.
        """
        if built_in_transform is not None:
            pulumi.set(__self__, "built_in_transform", built_in_transform)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if output_stream is not None:
            pulumi.set(__self__, "output_stream", output_stream)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @_builtins.property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The builtIn transform to transform stream data
        """
        return pulumi.get(self, "built_in_transform")

    @built_in_transform.setter
    def built_in_transform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "built_in_transform", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of destinations for this data flow.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output stream of the transform. Only required if the transform changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @output_stream.setter
    def output_stream(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_stream", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownDataFlowStreams']]]]]:
        """
        List of streams for this data flow.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownDataFlowStreams']]]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class DataImportSourcesEventHubArgsDict(TypedDict):
        """
        Definition of Event Hub configuration.
        """
        consumer_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Event Hub consumer group name
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        stream: NotRequired[pulumi.Input[_builtins.str]]
        """
        The stream to collect from EventHub
        """
elif False:
    DataImportSourcesEventHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataImportSourcesEventHubArgs:
    def __init__(__self__, *,
                 consumer_group: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 stream: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Definition of Event Hub configuration.
        :param pulumi.Input[_builtins.str] consumer_group: Event Hub consumer group name
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[_builtins.str] stream: The stream to collect from EventHub
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Event Hub consumer group name
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The stream to collect from EventHub
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream", value)


if not MYPY:
    class DataSourcesSpecDataImportsArgsDict(TypedDict):
        """
        Specifications of pull based data sources
        """
        event_hub: NotRequired[pulumi.Input['DataImportSourcesEventHubArgsDict']]
        """
        Definition of Event Hub configuration.
        """
elif False:
    DataSourcesSpecDataImportsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcesSpecDataImportsArgs:
    def __init__(__self__, *,
                 event_hub: Optional[pulumi.Input['DataImportSourcesEventHubArgs']] = None):
        """
        Specifications of pull based data sources
        :param pulumi.Input['DataImportSourcesEventHubArgs'] event_hub: Definition of Event Hub configuration.
        """
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)

    @_builtins.property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional[pulumi.Input['DataImportSourcesEventHubArgs']]:
        """
        Definition of Event Hub configuration.
        """
        return pulumi.get(self, "event_hub")

    @event_hub.setter
    def event_hub(self, value: Optional[pulumi.Input['DataImportSourcesEventHubArgs']]):
        pulumi.set(self, "event_hub", value)


if not MYPY:
    class DependenciesSignalGroupArgsDict(TypedDict):
        """
        Properties for dependent entities, i.e. child entities
        """
        aggregation_type: pulumi.Input[Union[_builtins.str, 'DependenciesAggregationType']]
        """
        Aggregation type for child dependencies.
        """
        degraded_threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
elif False:
    DependenciesSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DependenciesSignalGroupArgs:
    def __init__(__self__, *,
                 aggregation_type: Optional[pulumi.Input[Union[_builtins.str, 'DependenciesAggregationType']]] = None,
                 degraded_threshold: Optional[pulumi.Input[_builtins.str]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Properties for dependent entities, i.e. child entities
        :param pulumi.Input[Union[_builtins.str, 'DependenciesAggregationType']] aggregation_type: Aggregation type for child dependencies.
        :param pulumi.Input[_builtins.str] degraded_threshold: Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        :param pulumi.Input[_builtins.str] unhealthy_threshold: Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        if aggregation_type is None:
            aggregation_type = 'WorstOf'
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if degraded_threshold is not None:
            pulumi.set(__self__, "degraded_threshold", degraded_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[Union[_builtins.str, 'DependenciesAggregationType']]:
        """
        Aggregation type for child dependencies.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[Union[_builtins.str, 'DependenciesAggregationType']]):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="degradedThreshold")
    def degraded_threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Degraded threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered degraded when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "degraded_threshold")

    @degraded_threshold.setter
    def degraded_threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "degraded_threshold", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unhealthy threshold for aggregating the propagated health state of child dependencies. Can be either an absolute number that is greater than 0, or a percentage between 1-100%. The entity will be considered unhealthy when the number of not healthy child dependents (unhealthy, degraded, unknown) is equal to or above the threshold value. Must only be set when AggregationType is 'Thresholds'.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class DestinationsSpecAzureMonitorMetricsArgsDict(TypedDict):
        """
        Azure Monitor Metrics destination.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    DestinationsSpecAzureMonitorMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationsSpecAzureMonitorMetricsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Azure Monitor Metrics destination.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DimensionArgsDict(TypedDict):
        """
        Dimension splitting and filtering definition
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the dimension
        """
        operator: pulumi.Input[Union[_builtins.str, 'DimensionOperator']]
        """
        Operator for dimension values
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of dimension values
        """
elif False:
    DimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[Union[_builtins.str, 'DimensionOperator']],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Dimension splitting and filtering definition
        :param pulumi.Input[_builtins.str] name: Name of the dimension
        :param pulumi.Input[Union[_builtins.str, 'DimensionOperator']] operator: Operator for dimension values
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of dimension values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the dimension
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'DimensionOperator']]:
        """
        Operator for dimension values
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'DimensionOperator']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of dimension values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DynamicDetectionRuleArgsDict(TypedDict):
        """
        ML-based evaluation rule for a signal definition
        """
        dynamic_threshold_direction: pulumi.Input[Union[_builtins.str, 'DynamicThresholdDirection']]
        """
        Threshold direction
        """
        dynamic_threshold_model: pulumi.Input[Union[_builtins.str, 'DynamicThresholdModel']]
        """
        ML model to use for dynamic thresholds
        """
        model_sensitivity: pulumi.Input[_builtins.float]
        """
        ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        """
        training_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time of the training in UTC.
        """
elif False:
    DynamicDetectionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DynamicDetectionRuleArgs:
    def __init__(__self__, *,
                 dynamic_threshold_direction: pulumi.Input[Union[_builtins.str, 'DynamicThresholdDirection']],
                 dynamic_threshold_model: pulumi.Input[Union[_builtins.str, 'DynamicThresholdModel']],
                 model_sensitivity: pulumi.Input[_builtins.float],
                 training_start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        ML-based evaluation rule for a signal definition
        :param pulumi.Input[Union[_builtins.str, 'DynamicThresholdDirection']] dynamic_threshold_direction: Threshold direction
        :param pulumi.Input[Union[_builtins.str, 'DynamicThresholdModel']] dynamic_threshold_model: ML model to use for dynamic thresholds
        :param pulumi.Input[_builtins.float] model_sensitivity: ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        :param pulumi.Input[_builtins.str] training_start_time: Start time of the training in UTC.
        """
        pulumi.set(__self__, "dynamic_threshold_direction", dynamic_threshold_direction)
        pulumi.set(__self__, "dynamic_threshold_model", dynamic_threshold_model)
        pulumi.set(__self__, "model_sensitivity", model_sensitivity)
        if training_start_time is not None:
            pulumi.set(__self__, "training_start_time", training_start_time)

    @_builtins.property
    @pulumi.getter(name="dynamicThresholdDirection")
    def dynamic_threshold_direction(self) -> pulumi.Input[Union[_builtins.str, 'DynamicThresholdDirection']]:
        """
        Threshold direction
        """
        return pulumi.get(self, "dynamic_threshold_direction")

    @dynamic_threshold_direction.setter
    def dynamic_threshold_direction(self, value: pulumi.Input[Union[_builtins.str, 'DynamicThresholdDirection']]):
        pulumi.set(self, "dynamic_threshold_direction", value)

    @_builtins.property
    @pulumi.getter(name="dynamicThresholdModel")
    def dynamic_threshold_model(self) -> pulumi.Input[Union[_builtins.str, 'DynamicThresholdModel']]:
        """
        ML model to use for dynamic thresholds
        """
        return pulumi.get(self, "dynamic_threshold_model")

    @dynamic_threshold_model.setter
    def dynamic_threshold_model(self, value: pulumi.Input[Union[_builtins.str, 'DynamicThresholdModel']]):
        pulumi.set(self, "dynamic_threshold_model", value)

    @_builtins.property
    @pulumi.getter(name="modelSensitivity")
    def model_sensitivity(self) -> pulumi.Input[_builtins.float]:
        """
        ML model sensitivity. Lowest value = high sensitivity. Supported step size = 0.5
        """
        return pulumi.get(self, "model_sensitivity")

    @model_sensitivity.setter
    def model_sensitivity(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "model_sensitivity", value)

    @_builtins.property
    @pulumi.getter(name="trainingStartTime")
    def training_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time of the training in UTC.
        """
        return pulumi.get(self, "training_start_time")

    @training_start_time.setter
    def training_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "training_start_time", value)


if not MYPY:
    class DynamicMetricCriteriaArgsDict(TypedDict):
        """
        Criterion for dynamic threshold.
        """
        alert_sensitivity: pulumi.Input[Union[_builtins.str, 'DynamicThresholdSensitivity']]
        """
        The extent of deviation required to trigger an alert. This will affect how tight the threshold is to the metric series pattern.
        """
        criterion_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of threshold criteria
        Expected value is 'DynamicThresholdCriterion'.
        """
        failing_periods: pulumi.Input['DynamicThresholdFailingPeriodsArgsDict']
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Name of the metric.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the criteria.
        """
        operator: pulumi.Input[Union[_builtins.str, 'DynamicThresholdOperator']]
        """
        The operator used to compare the metric value against the threshold.
        """
        time_aggregation: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]
        """
        the criteria time aggregation types.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgsDict']]]]
        """
        List of dimension conditions.
        """
        ignore_data_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format)
        """
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace of the metric.
        """
        skip_metric_validation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
elif False:
    DynamicMetricCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DynamicMetricCriteriaArgs:
    def __init__(__self__, *,
                 alert_sensitivity: pulumi.Input[Union[_builtins.str, 'DynamicThresholdSensitivity']],
                 criterion_type: pulumi.Input[_builtins.str],
                 failing_periods: pulumi.Input['DynamicThresholdFailingPeriodsArgs'],
                 metric_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[Union[_builtins.str, 'DynamicThresholdOperator']],
                 time_aggregation: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]] = None,
                 ignore_data_before: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 skip_metric_validation: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Criterion for dynamic threshold.
        :param pulumi.Input[Union[_builtins.str, 'DynamicThresholdSensitivity']] alert_sensitivity: The extent of deviation required to trigger an alert. This will affect how tight the threshold is to the metric series pattern.
        :param pulumi.Input[_builtins.str] criterion_type: Specifies the type of threshold criteria
               Expected value is 'DynamicThresholdCriterion'.
        :param pulumi.Input['DynamicThresholdFailingPeriodsArgs'] failing_periods: The minimum number of violations required within the selected lookback time window required to raise an alert.
        :param pulumi.Input[_builtins.str] metric_name: Name of the metric.
        :param pulumi.Input[_builtins.str] name: Name of the criteria.
        :param pulumi.Input[Union[_builtins.str, 'DynamicThresholdOperator']] operator: The operator used to compare the metric value against the threshold.
        :param pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']] time_aggregation: the criteria time aggregation types.
        :param pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]] dimensions: List of dimension conditions.
        :param pulumi.Input[_builtins.str] ignore_data_before: Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format)
        :param pulumi.Input[_builtins.str] metric_namespace: Namespace of the metric.
        :param pulumi.Input[_builtins.bool] skip_metric_validation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
        pulumi.set(__self__, "alert_sensitivity", alert_sensitivity)
        pulumi.set(__self__, "criterion_type", 'DynamicThresholdCriterion')
        pulumi.set(__self__, "failing_periods", failing_periods)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "time_aggregation", time_aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if ignore_data_before is not None:
            pulumi.set(__self__, "ignore_data_before", ignore_data_before)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @_builtins.property
    @pulumi.getter(name="alertSensitivity")
    def alert_sensitivity(self) -> pulumi.Input[Union[_builtins.str, 'DynamicThresholdSensitivity']]:
        """
        The extent of deviation required to trigger an alert. This will affect how tight the threshold is to the metric series pattern.
        """
        return pulumi.get(self, "alert_sensitivity")

    @alert_sensitivity.setter
    def alert_sensitivity(self, value: pulumi.Input[Union[_builtins.str, 'DynamicThresholdSensitivity']]):
        pulumi.set(self, "alert_sensitivity", value)

    @_builtins.property
    @pulumi.getter(name="criterionType")
    def criterion_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of threshold criteria
        Expected value is 'DynamicThresholdCriterion'.
        """
        return pulumi.get(self, "criterion_type")

    @criterion_type.setter
    def criterion_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "criterion_type", value)

    @_builtins.property
    @pulumi.getter(name="failingPeriods")
    def failing_periods(self) -> pulumi.Input['DynamicThresholdFailingPeriodsArgs']:
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert.
        """
        return pulumi.get(self, "failing_periods")

    @failing_periods.setter
    def failing_periods(self, value: pulumi.Input['DynamicThresholdFailingPeriodsArgs']):
        pulumi.set(self, "failing_periods", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the criteria.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'DynamicThresholdOperator']]:
        """
        The operator used to compare the metric value against the threshold.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'DynamicThresholdOperator']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]:
        """
        the criteria time aggregation types.
        """
        return pulumi.get(self, "time_aggregation")

    @time_aggregation.setter
    def time_aggregation(self, value: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]):
        pulumi.set(self, "time_aggregation", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]]:
        """
        List of dimension conditions.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="ignoreDataBefore")
    def ignore_data_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format)
        """
        return pulumi.get(self, "ignore_data_before")

    @ignore_data_before.setter
    def ignore_data_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ignore_data_before", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
        return pulumi.get(self, "skip_metric_validation")

    @skip_metric_validation.setter
    def skip_metric_validation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_metric_validation", value)


if not MYPY:
    class DynamicThresholdFailingPeriodsArgsDict(TypedDict):
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert.
        """
        min_failing_periods_to_alert: pulumi.Input[_builtins.float]
        """
        The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods.
        """
        number_of_evaluation_periods: pulumi.Input[_builtins.float]
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points.
        """
elif False:
    DynamicThresholdFailingPeriodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DynamicThresholdFailingPeriodsArgs:
    def __init__(__self__, *,
                 min_failing_periods_to_alert: pulumi.Input[_builtins.float],
                 number_of_evaluation_periods: pulumi.Input[_builtins.float]):
        """
        The minimum number of violations required within the selected lookback time window required to raise an alert.
        :param pulumi.Input[_builtins.float] min_failing_periods_to_alert: The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods.
        :param pulumi.Input[_builtins.float] number_of_evaluation_periods: The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points.
        """
        pulumi.set(__self__, "min_failing_periods_to_alert", min_failing_periods_to_alert)
        pulumi.set(__self__, "number_of_evaluation_periods", number_of_evaluation_periods)

    @_builtins.property
    @pulumi.getter(name="minFailingPeriodsToAlert")
    def min_failing_periods_to_alert(self) -> pulumi.Input[_builtins.float]:
        """
        The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods.
        """
        return pulumi.get(self, "min_failing_periods_to_alert")

    @min_failing_periods_to_alert.setter
    def min_failing_periods_to_alert(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min_failing_periods_to_alert", value)

    @_builtins.property
    @pulumi.getter(name="numberOfEvaluationPeriods")
    def number_of_evaluation_periods(self) -> pulumi.Input[_builtins.float]:
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points.
        """
        return pulumi.get(self, "number_of_evaluation_periods")

    @number_of_evaluation_periods.setter
    def number_of_evaluation_periods(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "number_of_evaluation_periods", value)


if not MYPY:
    class EmailNotificationArgsDict(TypedDict):
        """
        Email notification of an autoscale event.
        """
        custom_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
        """
        send_to_subscription_administrator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        a value indicating whether to send email to subscription administrator.
        """
        send_to_subscription_co_administrators: NotRequired[pulumi.Input[_builtins.bool]]
        """
        a value indicating whether to send email to subscription co-administrators.
        """
elif False:
    EmailNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailNotificationArgs:
    def __init__(__self__, *,
                 custom_emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 send_to_subscription_administrator: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_to_subscription_co_administrators: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Email notification of an autoscale event.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_emails: the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
        :param pulumi.Input[_builtins.bool] send_to_subscription_administrator: a value indicating whether to send email to subscription administrator.
        :param pulumi.Input[_builtins.bool] send_to_subscription_co_administrators: a value indicating whether to send email to subscription co-administrators.
        """
        if custom_emails is not None:
            pulumi.set(__self__, "custom_emails", custom_emails)
        if send_to_subscription_administrator is None:
            send_to_subscription_administrator = False
        if send_to_subscription_administrator is not None:
            pulumi.set(__self__, "send_to_subscription_administrator", send_to_subscription_administrator)
        if send_to_subscription_co_administrators is None:
            send_to_subscription_co_administrators = False
        if send_to_subscription_co_administrators is not None:
            pulumi.set(__self__, "send_to_subscription_co_administrators", send_to_subscription_co_administrators)

    @_builtins.property
    @pulumi.getter(name="customEmails")
    def custom_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
        """
        return pulumi.get(self, "custom_emails")

    @custom_emails.setter
    def custom_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_emails", value)

    @_builtins.property
    @pulumi.getter(name="sendToSubscriptionAdministrator")
    def send_to_subscription_administrator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        a value indicating whether to send email to subscription administrator.
        """
        return pulumi.get(self, "send_to_subscription_administrator")

    @send_to_subscription_administrator.setter
    def send_to_subscription_administrator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_to_subscription_administrator", value)

    @_builtins.property
    @pulumi.getter(name="sendToSubscriptionCoAdministrators")
    def send_to_subscription_co_administrators(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        a value indicating whether to send email to subscription co-administrators.
        """
        return pulumi.get(self, "send_to_subscription_co_administrators")

    @send_to_subscription_co_administrators.setter
    def send_to_subscription_co_administrators(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_to_subscription_co_administrators", value)


if not MYPY:
    class EmailReceiverArgsDict(TypedDict):
        """
        An email receiver.
        """
        email_address: pulumi.Input[_builtins.str]
        """
        The email address of this receiver.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the email receiver. Names must be unique across all receivers within a tenant action group.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    EmailReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailReceiverArgs:
    def __init__(__self__, *,
                 email_address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        An email receiver.
        :param pulumi.Input[_builtins.str] email_address: The email address of this receiver.
        :param pulumi.Input[_builtins.str] name: The name of the email receiver. Names must be unique across all receivers within a tenant action group.
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of this receiver.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email receiver. Names must be unique across all receivers within a tenant action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class EntityAlertsArgsDict(TypedDict):
        """
        Alert configuration for an entity
        """
        degraded: NotRequired[pulumi.Input['AlertConfigurationArgsDict']]
        """
        Alert to be triggered on state change to degraded
        """
        unhealthy: NotRequired[pulumi.Input['AlertConfigurationArgsDict']]
        """
        Alert to be triggered on state change to unhealthy
        """
elif False:
    EntityAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityAlertsArgs:
    def __init__(__self__, *,
                 degraded: Optional[pulumi.Input['AlertConfigurationArgs']] = None,
                 unhealthy: Optional[pulumi.Input['AlertConfigurationArgs']] = None):
        """
        Alert configuration for an entity
        :param pulumi.Input['AlertConfigurationArgs'] degraded: Alert to be triggered on state change to degraded
        :param pulumi.Input['AlertConfigurationArgs'] unhealthy: Alert to be triggered on state change to unhealthy
        """
        if degraded is not None:
            pulumi.set(__self__, "degraded", degraded)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @_builtins.property
    @pulumi.getter
    def degraded(self) -> Optional[pulumi.Input['AlertConfigurationArgs']]:
        """
        Alert to be triggered on state change to degraded
        """
        return pulumi.get(self, "degraded")

    @degraded.setter
    def degraded(self, value: Optional[pulumi.Input['AlertConfigurationArgs']]):
        pulumi.set(self, "degraded", value)

    @_builtins.property
    @pulumi.getter
    def unhealthy(self) -> Optional[pulumi.Input['AlertConfigurationArgs']]:
        """
        Alert to be triggered on state change to unhealthy
        """
        return pulumi.get(self, "unhealthy")

    @unhealthy.setter
    def unhealthy(self, value: Optional[pulumi.Input['AlertConfigurationArgs']]):
        pulumi.set(self, "unhealthy", value)


if not MYPY:
    class EntityCoordinatesArgsDict(TypedDict):
        """
        Visual position of the entity
        """
        x: pulumi.Input[_builtins.float]
        """
        X Coordinate
        """
        y: pulumi.Input[_builtins.float]
        """
        Y Coordinate
        """
elif False:
    EntityCoordinatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityCoordinatesArgs:
    def __init__(__self__, *,
                 x: pulumi.Input[_builtins.float],
                 y: pulumi.Input[_builtins.float]):
        """
        Visual position of the entity
        :param pulumi.Input[_builtins.float] x: X Coordinate
        :param pulumi.Input[_builtins.float] y: Y Coordinate
        """
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter
    def x(self) -> pulumi.Input[_builtins.float]:
        """
        X Coordinate
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> pulumi.Input[_builtins.float]:
        """
        Y Coordinate
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "y", value)


if not MYPY:
    class EntityPropertiesArgsDict(TypedDict):
        """
        Properties which are common across all kinds of entities
        """
        alerts: NotRequired[pulumi.Input['EntityAlertsArgsDict']]
        """
        Alert configuration for this entity
        """
        canvas_position: NotRequired[pulumi.Input['EntityCoordinatesArgsDict']]
        """
        Positioning of the entity on the model canvas
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
        health_objective: NotRequired[pulumi.Input[_builtins.float]]
        """
        Health objective as a percentage of time the entity should be healthy.
        """
        icon: NotRequired[pulumi.Input['IconDefinitionArgsDict']]
        """
        Visual icon definition. If not set, a default icon is used.
        """
        impact: NotRequired[pulumi.Input[Union[_builtins.str, 'EntityImpact']]]
        """
        Impact of the entity in health state propagation
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Entity kind
        """
        signals: NotRequired[pulumi.Input['SignalGroupArgsDict']]
        """
        Signal groups which are assigned to this entity
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
elif False:
    EntityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityPropertiesArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input['EntityAlertsArgs']] = None,
                 canvas_position: Optional[pulumi.Input['EntityCoordinatesArgs']] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 health_objective: Optional[pulumi.Input[_builtins.float]] = None,
                 icon: Optional[pulumi.Input['IconDefinitionArgs']] = None,
                 impact: Optional[pulumi.Input[Union[_builtins.str, 'EntityImpact']]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 signals: Optional[pulumi.Input['SignalGroupArgs']] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Properties which are common across all kinds of entities
        :param pulumi.Input['EntityAlertsArgs'] alerts: Alert configuration for this entity
        :param pulumi.Input['EntityCoordinatesArgs'] canvas_position: Positioning of the entity on the model canvas
        :param pulumi.Input[_builtins.str] display_name: Display name
        :param pulumi.Input[_builtins.float] health_objective: Health objective as a percentage of time the entity should be healthy.
        :param pulumi.Input['IconDefinitionArgs'] icon: Visual icon definition. If not set, a default icon is used.
        :param pulumi.Input[Union[_builtins.str, 'EntityImpact']] impact: Impact of the entity in health state propagation
        :param pulumi.Input[_builtins.str] kind: Entity kind
        :param pulumi.Input['SignalGroupArgs'] signals: Signal groups which are assigned to this entity
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Optional set of labels (key-value pairs)
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if canvas_position is not None:
            pulumi.set(__self__, "canvas_position", canvas_position)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if health_objective is not None:
            pulumi.set(__self__, "health_objective", health_objective)
        if icon is not None:
            pulumi.set(__self__, "icon", icon)
        if impact is None:
            impact = 'Standard'
        if impact is not None:
            pulumi.set(__self__, "impact", impact)
        if kind is None:
            kind = 'Default'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if signals is not None:
            pulumi.set(__self__, "signals", signals)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input['EntityAlertsArgs']]:
        """
        Alert configuration for this entity
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input['EntityAlertsArgs']]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter(name="canvasPosition")
    def canvas_position(self) -> Optional[pulumi.Input['EntityCoordinatesArgs']]:
        """
        Positioning of the entity on the model canvas
        """
        return pulumi.get(self, "canvas_position")

    @canvas_position.setter
    def canvas_position(self, value: Optional[pulumi.Input['EntityCoordinatesArgs']]):
        pulumi.set(self, "canvas_position", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="healthObjective")
    def health_objective(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Health objective as a percentage of time the entity should be healthy.
        """
        return pulumi.get(self, "health_objective")

    @health_objective.setter
    def health_objective(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "health_objective", value)

    @_builtins.property
    @pulumi.getter
    def icon(self) -> Optional[pulumi.Input['IconDefinitionArgs']]:
        """
        Visual icon definition. If not set, a default icon is used.
        """
        return pulumi.get(self, "icon")

    @icon.setter
    def icon(self, value: Optional[pulumi.Input['IconDefinitionArgs']]):
        pulumi.set(self, "icon", value)

    @_builtins.property
    @pulumi.getter
    def impact(self) -> Optional[pulumi.Input[Union[_builtins.str, 'EntityImpact']]]:
        """
        Impact of the entity in health state propagation
        """
        return pulumi.get(self, "impact")

    @impact.setter
    def impact(self, value: Optional[pulumi.Input[Union[_builtins.str, 'EntityImpact']]]):
        pulumi.set(self, "impact", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Entity kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def signals(self) -> Optional[pulumi.Input['SignalGroupArgs']]:
        """
        Signal groups which are assigned to this entity
        """
        return pulumi.get(self, "signals")

    @signals.setter
    def signals(self, value: Optional[pulumi.Input['SignalGroupArgs']]):
        pulumi.set(self, "signals", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class EvaluationRuleArgsDict(TypedDict):
        """
        Evaluation rule for a signal definition
        """
        degraded_rule: NotRequired[pulumi.Input['ThresholdRuleArgsDict']]
        """
        Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        dynamic_detection_rule: NotRequired[pulumi.Input['DynamicDetectionRuleArgsDict']]
        """
        Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        """
        unhealthy_rule: NotRequired[pulumi.Input['ThresholdRuleArgsDict']]
        """
        Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
elif False:
    EvaluationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationRuleArgs:
    def __init__(__self__, *,
                 degraded_rule: Optional[pulumi.Input['ThresholdRuleArgs']] = None,
                 dynamic_detection_rule: Optional[pulumi.Input['DynamicDetectionRuleArgs']] = None,
                 unhealthy_rule: Optional[pulumi.Input['ThresholdRuleArgs']] = None):
        """
        Evaluation rule for a signal definition
        :param pulumi.Input['ThresholdRuleArgs'] degraded_rule: Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        :param pulumi.Input['DynamicDetectionRuleArgs'] dynamic_detection_rule: Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        :param pulumi.Input['ThresholdRuleArgs'] unhealthy_rule: Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        if degraded_rule is not None:
            pulumi.set(__self__, "degraded_rule", degraded_rule)
        if dynamic_detection_rule is not None:
            pulumi.set(__self__, "dynamic_detection_rule", dynamic_detection_rule)
        if unhealthy_rule is not None:
            pulumi.set(__self__, "unhealthy_rule", unhealthy_rule)

    @_builtins.property
    @pulumi.getter(name="degradedRule")
    def degraded_rule(self) -> Optional[pulumi.Input['ThresholdRuleArgs']]:
        """
        Degraded rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "degraded_rule")

    @degraded_rule.setter
    def degraded_rule(self, value: Optional[pulumi.Input['ThresholdRuleArgs']]):
        pulumi.set(self, "degraded_rule", value)

    @_builtins.property
    @pulumi.getter(name="dynamicDetectionRule")
    def dynamic_detection_rule(self) -> Optional[pulumi.Input['DynamicDetectionRuleArgs']]:
        """
        Configure to use ML-based dynamic thresholds. When used, degradedRule and unhealthyRule must not be set.
        """
        return pulumi.get(self, "dynamic_detection_rule")

    @dynamic_detection_rule.setter
    def dynamic_detection_rule(self, value: Optional[pulumi.Input['DynamicDetectionRuleArgs']]):
        pulumi.set(self, "dynamic_detection_rule", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyRule")
    def unhealthy_rule(self) -> Optional[pulumi.Input['ThresholdRuleArgs']]:
        """
        Unhealthy rule with static threshold. When used, dynamicDetectionRule must not be set.
        """
        return pulumi.get(self, "unhealthy_rule")

    @unhealthy_rule.setter
    def unhealthy_rule(self, value: Optional[pulumi.Input['ThresholdRuleArgs']]):
        pulumi.set(self, "unhealthy_rule", value)


if not MYPY:
    class EventHubDestinationArgsDict(TypedDict):
        event_hub_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the event hub.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    EventHubDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventHubDestinationArgs:
    def __init__(__self__, *,
                 event_hub_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] event_hub_resource_id: The resource ID of the event hub.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @event_hub_resource_id.setter
    def event_hub_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_hub_resource_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EventHubDirectDestinationArgsDict(TypedDict):
        event_hub_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the event hub.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    EventHubDirectDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventHubDirectDestinationArgs:
    def __init__(__self__, *,
                 event_hub_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] event_hub_resource_id: The resource ID of the event hub.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @event_hub_resource_id.setter
    def event_hub_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_hub_resource_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EventHubReceiverArgsDict(TypedDict):
        """
        An Event hub receiver.
        """
        event_hub_name: pulumi.Input[_builtins.str]
        """
        The name of the specific Event Hub queue
        """
        event_hub_name_space: pulumi.Input[_builtins.str]
        """
        The Event Hub namespace
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Event hub receiver. Names must be unique across all receivers within an action group.
        """
        subscription_id: pulumi.Input[_builtins.str]
        """
        The Id for the subscription containing this event hub
        """
        managed_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenant Id for the subscription containing this event hub
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    EventHubReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventHubReceiverArgs:
    def __init__(__self__, *,
                 event_hub_name: pulumi.Input[_builtins.str],
                 event_hub_name_space: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subscription_id: pulumi.Input[_builtins.str],
                 managed_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        An Event hub receiver.
        :param pulumi.Input[_builtins.str] event_hub_name: The name of the specific Event Hub queue
        :param pulumi.Input[_builtins.str] event_hub_name_space: The Event Hub namespace
        :param pulumi.Input[_builtins.str] name: The name of the Event hub receiver. Names must be unique across all receivers within an action group.
        :param pulumi.Input[_builtins.str] subscription_id: The Id for the subscription containing this event hub
        :param pulumi.Input[_builtins.str] managed_identity: The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        :param pulumi.Input[_builtins.str] tenant_id: The tenant Id for the subscription containing this event hub
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "event_hub_name", event_hub_name)
        pulumi.set(__self__, "event_hub_name_space", event_hub_name_space)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the specific Event Hub queue
        """
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_hub_name", value)

    @_builtins.property
    @pulumi.getter(name="eventHubNameSpace")
    def event_hub_name_space(self) -> pulumi.Input[_builtins.str]:
        """
        The Event Hub namespace
        """
        return pulumi.get(self, "event_hub_name_space")

    @event_hub_name_space.setter
    def event_hub_name_space(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_hub_name_space", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Event hub receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Id for the subscription containing this event hub
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subscription_id", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_identity", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenant Id for the subscription containing this event hub
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ExporterArgsDict(TypedDict):
        """
        Exporter Info.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of exporter.
        """
        type: pulumi.Input[Union[_builtins.str, 'ExporterType']]
        """
        The type of exporter.
        """
        azure_monitor_workspace_logs: NotRequired[pulumi.Input['AzureMonitorWorkspaceLogsExporterArgsDict']]
        """
        Azure Monitor Workspace Logs specific configurations.
        """
        tcp: NotRequired[pulumi.Input['TcpExporterArgsDict']]
        """
        TCP based exporter. Used for pipelineGroup exporter.
        """
elif False:
    ExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExporterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'ExporterType']],
                 azure_monitor_workspace_logs: Optional[pulumi.Input['AzureMonitorWorkspaceLogsExporterArgs']] = None,
                 tcp: Optional[pulumi.Input['TcpExporterArgs']] = None):
        """
        Exporter Info.
        :param pulumi.Input[_builtins.str] name: The name of exporter.
        :param pulumi.Input[Union[_builtins.str, 'ExporterType']] type: The type of exporter.
        :param pulumi.Input['AzureMonitorWorkspaceLogsExporterArgs'] azure_monitor_workspace_logs: Azure Monitor Workspace Logs specific configurations.
        :param pulumi.Input['TcpExporterArgs'] tcp: TCP based exporter. Used for pipelineGroup exporter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if azure_monitor_workspace_logs is not None:
            pulumi.set(__self__, "azure_monitor_workspace_logs", azure_monitor_workspace_logs)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of exporter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ExporterType']]:
        """
        The type of exporter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ExporterType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="azureMonitorWorkspaceLogs")
    def azure_monitor_workspace_logs(self) -> Optional[pulumi.Input['AzureMonitorWorkspaceLogsExporterArgs']]:
        """
        Azure Monitor Workspace Logs specific configurations.
        """
        return pulumi.get(self, "azure_monitor_workspace_logs")

    @azure_monitor_workspace_logs.setter
    def azure_monitor_workspace_logs(self, value: Optional[pulumi.Input['AzureMonitorWorkspaceLogsExporterArgs']]):
        pulumi.set(self, "azure_monitor_workspace_logs", value)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['TcpExporterArgs']]:
        """
        TCP based exporter. Used for pipelineGroup exporter.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['TcpExporterArgs']]):
        pulumi.set(self, "tcp", value)


if not MYPY:
    class ExtensionDataSourceArgsDict(TypedDict):
        """
        Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
        Collected from either Windows and Linux machines, depending on which extension is defined.
        """
        extension_name: pulumi.Input[_builtins.str]
        """
        The name of the VM extension.
        """
        extension_settings: NotRequired[Any]
        """
        The extension settings. The format is specific for particular extension.
        """
        input_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of data sources this extension needs data from.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownExtensionDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
elif False:
    ExtensionDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtensionDataSourceArgs:
    def __init__(__self__, *,
                 extension_name: pulumi.Input[_builtins.str],
                 extension_settings: Optional[Any] = None,
                 input_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownExtensionDataSourceStreams']]]]] = None):
        """
        Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
        Collected from either Windows and Linux machines, depending on which extension is defined.
        :param pulumi.Input[_builtins.str] extension_name: The name of the VM extension.
        :param Any extension_settings: The extension settings. The format is specific for particular extension.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] input_data_sources: The list of data sources this extension needs data from.
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownExtensionDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "extension_name", extension_name)
        if extension_settings is not None:
            pulumi.set(__self__, "extension_settings", extension_settings)
        if input_data_sources is not None:
            pulumi.set(__self__, "input_data_sources", input_data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @_builtins.property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @extension_name.setter
    def extension_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "extension_name", value)

    @_builtins.property
    @pulumi.getter(name="extensionSettings")
    def extension_settings(self) -> Optional[Any]:
        """
        The extension settings. The format is specific for particular extension.
        """
        return pulumi.get(self, "extension_settings")

    @extension_settings.setter
    def extension_settings(self, value: Optional[Any]):
        pulumi.set(self, "extension_settings", value)

    @_builtins.property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of data sources this extension needs data from.
        """
        return pulumi.get(self, "input_data_sources")

    @input_data_sources.setter
    def input_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_data_sources", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownExtensionDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownExtensionDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class HealthModelPropertiesArgsDict(TypedDict):
        """
        HealthModel properties
        """
        discovery: NotRequired[pulumi.Input['ModelDiscoverySettingsArgsDict']]
        """
        Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
elif False:
    HealthModelPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthModelPropertiesArgs:
    def __init__(__self__, *,
                 discovery: Optional[pulumi.Input['ModelDiscoverySettingsArgs']] = None):
        """
        HealthModel properties
        :param pulumi.Input['ModelDiscoverySettingsArgs'] discovery: Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        if discovery is not None:
            pulumi.set(__self__, "discovery", discovery)

    @_builtins.property
    @pulumi.getter
    def discovery(self) -> Optional[pulumi.Input['ModelDiscoverySettingsArgs']]:
        """
        Configure to automatically discover entities from a given scope, such as a Service Group. The discovered entities will be linked to the root entity of the health model.
        """
        return pulumi.get(self, "discovery")

    @discovery.setter
    def discovery(self, value: Optional[pulumi.Input['ModelDiscoverySettingsArgs']]):
        pulumi.set(self, "discovery", value)


if not MYPY:
    class IconDefinitionArgsDict(TypedDict):
        """
        Visual icon definition of an entity
        """
        icon_name: pulumi.Input[_builtins.str]
        """
        Name of the built-in icon, or 'Custom' to use customData
        """
        custom_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
elif False:
    IconDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IconDefinitionArgs:
    def __init__(__self__, *,
                 icon_name: pulumi.Input[_builtins.str],
                 custom_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Visual icon definition of an entity
        :param pulumi.Input[_builtins.str] icon_name: Name of the built-in icon, or 'Custom' to use customData
        :param pulumi.Input[_builtins.str] custom_data: Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        pulumi.set(__self__, "icon_name", icon_name)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @_builtins.property
    @pulumi.getter(name="iconName")
    def icon_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the built-in icon, or 'Custom' to use customData
        """
        return pulumi.get(self, "icon_name")

    @icon_name.setter
    def icon_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "icon_name", value)

    @_builtins.property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom data. Base64-encoded SVG data. If set, this overrides the built-in icon.
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_data", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: pulumi.Input['IdentityType']
        """
        Type of managed service identity.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['IdentityType'],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['IdentityType'] type: Type of managed service identity.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['IdentityType']:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['IdentityType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class IisLogsDataSourceArgsDict(TypedDict):
        """
        Enables IIS logs to be collected by this data collection rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        IIS streams
        """
        log_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Absolute paths file location
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
elif False:
    IisLogsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IisLogsDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 log_directories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Enables IIS logs to be collected by this data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] streams: IIS streams
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] log_directories: Absolute paths file location
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "streams", streams)
        if log_directories is not None:
            pulumi.set(__self__, "log_directories", log_directories)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        IIS streams
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Absolute paths file location
        """
        return pulumi.get(self, "log_directories")

    @log_directories.setter
    def log_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_directories", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IncidentReceiverArgsDict(TypedDict):
        """
        An Incident receiver.
        """
        connection: pulumi.Input['IncidentServiceConnectionArgsDict']
        """
        The incident service connection
        """
        incident_management_service: pulumi.Input[Union[_builtins.str, 'IncidentManagementService']]
        """
        The incident management service type
        """
        mappings: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Field mappings for the incident service
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Incident receiver. Names must be unique across all receivers within an action group.
        """
elif False:
    IncidentReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentReceiverArgs:
    def __init__(__self__, *,
                 connection: pulumi.Input['IncidentServiceConnectionArgs'],
                 incident_management_service: pulumi.Input[Union[_builtins.str, 'IncidentManagementService']],
                 mappings: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str]):
        """
        An Incident receiver.
        :param pulumi.Input['IncidentServiceConnectionArgs'] connection: The incident service connection
        :param pulumi.Input[Union[_builtins.str, 'IncidentManagementService']] incident_management_service: The incident management service type
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] mappings: Field mappings for the incident service
        :param pulumi.Input[_builtins.str] name: The name of the Incident receiver. Names must be unique across all receivers within an action group.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "incident_management_service", incident_management_service)
        pulumi.set(__self__, "mappings", mappings)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> pulumi.Input['IncidentServiceConnectionArgs']:
        """
        The incident service connection
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: pulumi.Input['IncidentServiceConnectionArgs']):
        pulumi.set(self, "connection", value)

    @_builtins.property
    @pulumi.getter(name="incidentManagementService")
    def incident_management_service(self) -> pulumi.Input[Union[_builtins.str, 'IncidentManagementService']]:
        """
        The incident management service type
        """
        return pulumi.get(self, "incident_management_service")

    @incident_management_service.setter
    def incident_management_service(self, value: pulumi.Input[Union[_builtins.str, 'IncidentManagementService']]):
        pulumi.set(self, "incident_management_service", value)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Field mappings for the incident service
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "mappings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Incident receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IncidentServiceConnectionArgsDict(TypedDict):
        """
        The connection info for Incident Receiver.
        """
        id: pulumi.Input[_builtins.str]
        """
        GUID value representing the connection ID for the incident management service.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the connection.
        """
elif False:
    IncidentServiceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentServiceConnectionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        The connection info for Incident Receiver.
        :param pulumi.Input[_builtins.str] id: GUID value representing the connection ID for the incident management service.
        :param pulumi.Input[_builtins.str] name: The name of the connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        GUID value representing the connection ID for the incident management service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IssuePropertiesArgsDict(TypedDict):
        """
        The issue properties
        """
        impact_time: pulumi.Input[_builtins.str]
        """
        The issue impact time (in UTC)
        """
        severity: pulumi.Input[_builtins.str]
        """
        The issue severity
        """
        status: pulumi.Input[Union[_builtins.str, 'Status']]
        """
        The issue status
        """
        title: pulumi.Input[_builtins.str]
        """
        The issue title
        """
elif False:
    IssuePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IssuePropertiesArgs:
    def __init__(__self__, *,
                 impact_time: pulumi.Input[_builtins.str],
                 severity: pulumi.Input[_builtins.str],
                 status: pulumi.Input[Union[_builtins.str, 'Status']],
                 title: pulumi.Input[_builtins.str]):
        """
        The issue properties
        :param pulumi.Input[_builtins.str] impact_time: The issue impact time (in UTC)
        :param pulumi.Input[_builtins.str] severity: The issue severity
        :param pulumi.Input[Union[_builtins.str, 'Status']] status: The issue status
        :param pulumi.Input[_builtins.str] title: The issue title
        """
        pulumi.set(__self__, "impact_time", impact_time)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="impactTime")
    def impact_time(self) -> pulumi.Input[_builtins.str]:
        """
        The issue impact time (in UTC)
        """
        return pulumi.get(self, "impact_time")

    @impact_time.setter
    def impact_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "impact_time", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> pulumi.Input[_builtins.str]:
        """
        The issue severity
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[_builtins.str, 'Status']]:
        """
        The issue status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[_builtins.str, 'Status']]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ItsmReceiverArgsDict(TypedDict):
        """
        An Itsm receiver.
        """
        connection_id: pulumi.Input[_builtins.str]
        """
        Unique identification of ITSM connection among multiple defined in above workspace.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Itsm receiver. Names must be unique across all receivers within an action group.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region in which workspace resides. Supported values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'
        """
        ticket_configuration: pulumi.Input[_builtins.str]
        """
        JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        workspace_id: pulumi.Input[_builtins.str]
        """
        OMS LA instance identifier.
        """
elif False:
    ItsmReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ItsmReceiverArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 ticket_configuration: pulumi.Input[_builtins.str],
                 workspace_id: pulumi.Input[_builtins.str]):
        """
        An Itsm receiver.
        :param pulumi.Input[_builtins.str] connection_id: Unique identification of ITSM connection among multiple defined in above workspace.
        :param pulumi.Input[_builtins.str] name: The name of the Itsm receiver. Names must be unique across all receivers within an action group.
        :param pulumi.Input[_builtins.str] region: Region in which workspace resides. Supported values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'
        :param pulumi.Input[_builtins.str] ticket_configuration: JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        :param pulumi.Input[_builtins.str] workspace_id: OMS LA instance identifier.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ticket_configuration", ticket_configuration)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identification of ITSM connection among multiple defined in above workspace.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Itsm receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region in which workspace resides. Supported values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="ticketConfiguration")
    def ticket_configuration(self) -> pulumi.Input[_builtins.str]:
        """
        JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        return pulumi.get(self, "ticket_configuration")

    @ticket_configuration.setter
    def ticket_configuration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ticket_configuration", value)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[_builtins.str]:
        """
        OMS LA instance identifier.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class JsonArrayMapperArgsDict(TypedDict):
        """
        A component that allows parsing a value from sourceField as a json array, match a key to each parsed value from keys, and output the key-value map to destinationField field.
        """
        keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Define the names of the keys in the resulting map. The input json array elements are mapped in order, one for every key.
        """
        destination_field: NotRequired[pulumi.Input['JsonMapperDestinationFieldArgsDict']]
        """
        Define a destination field to which the parsed output will be written. The output is a map, it's keys is the given keys array and the matching values are the parsed json array elements.
        """
        source_field: NotRequired[pulumi.Input['JsonMapperSourceFieldArgsDict']]
        """
        Define a source field from which a json array will be read and parsed to it's elements. The number of elements in the json array is expected to be the same as the length of keys.
        """
elif False:
    JsonArrayMapperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JsonArrayMapperArgs:
    def __init__(__self__, *,
                 keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 destination_field: Optional[pulumi.Input['JsonMapperDestinationFieldArgs']] = None,
                 source_field: Optional[pulumi.Input['JsonMapperSourceFieldArgs']] = None):
        """
        A component that allows parsing a value from sourceField as a json array, match a key to each parsed value from keys, and output the key-value map to destinationField field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Define the names of the keys in the resulting map. The input json array elements are mapped in order, one for every key.
        :param pulumi.Input['JsonMapperDestinationFieldArgs'] destination_field: Define a destination field to which the parsed output will be written. The output is a map, it's keys is the given keys array and the matching values are the parsed json array elements.
        :param pulumi.Input['JsonMapperSourceFieldArgs'] source_field: Define a source field from which a json array will be read and parsed to it's elements. The number of elements in the json array is expected to be the same as the length of keys.
        """
        pulumi.set(__self__, "keys", keys)
        if destination_field is not None:
            pulumi.set(__self__, "destination_field", destination_field)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Define the names of the keys in the resulting map. The input json array elements are mapped in order, one for every key.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="destinationField")
    def destination_field(self) -> Optional[pulumi.Input['JsonMapperDestinationFieldArgs']]:
        """
        Define a destination field to which the parsed output will be written. The output is a map, it's keys is the given keys array and the matching values are the parsed json array elements.
        """
        return pulumi.get(self, "destination_field")

    @destination_field.setter
    def destination_field(self, value: Optional[pulumi.Input['JsonMapperDestinationFieldArgs']]):
        pulumi.set(self, "destination_field", value)

    @_builtins.property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input['JsonMapperSourceFieldArgs']]:
        """
        Define a source field from which a json array will be read and parsed to it's elements. The number of elements in the json array is expected to be the same as the length of keys.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input['JsonMapperSourceFieldArgs']]):
        pulumi.set(self, "source_field", value)


if not MYPY:
    class JsonMapperDestinationFieldArgsDict(TypedDict):
        """
        JsonArrayMapper destination field used to describe the field to which the parsed output will be written.
        """
        destination: NotRequired[pulumi.Input[Union[_builtins.str, 'JsonMapperElement']]]
        """
        Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Define a destination field name under the given element. Leaving this empty, means the root of the element. In case element=attributes and fieldName is empty, the object's attributes themselves will contain the key value output pairs.
        """
elif False:
    JsonMapperDestinationFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JsonMapperDestinationFieldArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[Union[_builtins.str, 'JsonMapperElement']]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        JsonArrayMapper destination field used to describe the field to which the parsed output will be written.
        :param pulumi.Input[Union[_builtins.str, 'JsonMapperElement']] destination: Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
        :param pulumi.Input[_builtins.str] field_name: Define a destination field name under the given element. Leaving this empty, means the root of the element. In case element=attributes and fieldName is empty, the object's attributes themselves will contain the key value output pairs.
        """
        if destination is None:
            destination = 'attributes'
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[Union[_builtins.str, 'JsonMapperElement']]]:
        """
        Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[Union[_builtins.str, 'JsonMapperElement']]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Define a destination field name under the given element. Leaving this empty, means the root of the element. In case element=attributes and fieldName is empty, the object's attributes themselves will contain the key value output pairs.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)


if not MYPY:
    class JsonMapperSourceFieldArgsDict(TypedDict):
        """
        JsonArrayMapper source field used to describe the field from which the json array will be read.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Define a source field name from which the json array mapper will read the json array. Leaving this empty, means reading the body of the message itself.
        """
elif False:
    JsonMapperSourceFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JsonMapperSourceFieldArgs:
    def __init__(__self__, *,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        JsonArrayMapper source field used to describe the field from which the json array will be read.
        :param pulumi.Input[_builtins.str] field_name: Define a source field name from which the json array mapper will read the json array. Leaving this empty, means reading the body of the message itself.
        """
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Define a source field name from which the json array mapper will read the json array. Leaving this empty, means reading the body of the message itself.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)


if not MYPY:
    class LogAnalyticsDestinationArgsDict(TypedDict):
        """
        Log Analytics destination.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        workspace_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the Log Analytics workspace.
        """
elif False:
    LogAnalyticsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 workspace_resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Log Analytics destination.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[_builtins.str] workspace_resource_id: The resource ID of the Log Analytics workspace.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if workspace_resource_id is not None:
            pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the Log Analytics workspace.
        """
        return pulumi.get(self, "workspace_resource_id")

    @workspace_resource_id.setter
    def workspace_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workspace_resource_id", value)


if not MYPY:
    class LogAnalyticsQuerySignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Log Analytics Query Signal Definition properties
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        query_text: pulumi.Input[_builtins.str]
        """
        Query text in KQL syntax
        """
        signal_kind: pulumi.Input[_builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'LogAnalyticsQuery'.
        """
        data_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
        refresh_interval: NotRequired[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        time_grain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        """
        value_column_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
elif False:
    LogAnalyticsQuerySignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsQuerySignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 query_text: pulumi.Input[_builtins.str],
                 signal_kind: pulumi.Input[_builtins.str],
                 data_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 time_grain: Optional[pulumi.Input[_builtins.str]] = None,
                 value_column_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Log Analytics Query Signal Definition properties
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[_builtins.str] query_text: Query text in KQL syntax
        :param pulumi.Input[_builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'LogAnalyticsQuery'.
        :param pulumi.Input[_builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[_builtins.str] display_name: Display name
        :param pulumi.Input[Union[_builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Optional set of labels (key-value pairs)
        :param pulumi.Input[_builtins.str] time_grain: Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        :param pulumi.Input[_builtins.str] value_column_name: Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'LogAnalyticsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)
        if value_column_name is not None:
            pulumi.set(__self__, "value_column_name", value_column_name)

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @_builtins.property
    @pulumi.getter(name="queryText")
    def query_text(self) -> pulumi.Input[_builtins.str]:
        """
        Query text in KQL syntax
        """
        return pulumi.get(self, "query_text")

    @query_text.setter
    def query_text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query_text", value)

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'LogAnalyticsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time range of signal. ISO duration format like PT10M. If not specified, the KQL query must define a time range.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_grain", value)

    @_builtins.property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the column in the result set to evaluate against the thresholds. Defaults to the first column in the result set if not specified. The column must be numeric.
        """
        return pulumi.get(self, "value_column_name")

    @value_column_name.setter
    def value_column_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_column_name", value)


if not MYPY:
    class LogAnalyticsSignalGroupArgsDict(TypedDict):
        """
        A grouping of signal assignments for a Log Analytics Workspace
        """
        authentication_setting: pulumi.Input[_builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        log_analytics_workspace_resource_id: pulumi.Input[_builtins.str]
        """
        Log Analytics Workspace resource ID
        """
        signal_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgsDict']]]]
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
elif False:
    LogAnalyticsSignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsSignalGroupArgs:
    def __init__(__self__, *,
                 authentication_setting: pulumi.Input[_builtins.str],
                 log_analytics_workspace_resource_id: pulumi.Input[_builtins.str],
                 signal_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]] = None):
        """
        A grouping of signal assignments for a Log Analytics Workspace
        :param pulumi.Input[_builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying the data source
        :param pulumi.Input[_builtins.str] log_analytics_workspace_resource_id: Log Analytics Workspace resource ID
        :param pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]] signal_assignments: Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "log_analytics_workspace_resource_id", log_analytics_workspace_resource_id)
        if signal_assignments is not None:
            pulumi.set(__self__, "signal_assignments", signal_assignments)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying the data source
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceResourceId")
    def log_analytics_workspace_resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Log Analytics Workspace resource ID
        """
        return pulumi.get(self, "log_analytics_workspace_resource_id")

    @log_analytics_workspace_resource_id.setter
    def log_analytics_workspace_resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_analytics_workspace_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="signalAssignments")
    def signal_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]:
        """
        Signal definitions which are assigned to this signal group. All assignments are combined with an OR operator.
        """
        return pulumi.get(self, "signal_assignments")

    @signal_assignments.setter
    def signal_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SignalAssignmentArgs']]]]):
        pulumi.set(self, "signal_assignments", value)


if not MYPY:
    class LogFileSettingsTextArgsDict(TypedDict):
        """
        Text settings
        """
        record_start_timestamp_format: pulumi.Input[Union[_builtins.str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]
        """
        One of the supported timestamp formats
        """
elif False:
    LogFileSettingsTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFileSettingsTextArgs:
    def __init__(__self__, *,
                 record_start_timestamp_format: pulumi.Input[Union[_builtins.str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]):
        """
        Text settings
        :param pulumi.Input[Union[_builtins.str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']] record_start_timestamp_format: One of the supported timestamp formats
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @_builtins.property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> pulumi.Input[Union[_builtins.str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]:
        """
        One of the supported timestamp formats
        """
        return pulumi.get(self, "record_start_timestamp_format")

    @record_start_timestamp_format.setter
    def record_start_timestamp_format(self, value: pulumi.Input[Union[_builtins.str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]):
        pulumi.set(self, "record_start_timestamp_format", value)


if not MYPY:
    class LogFilesDataSourceSettingsArgsDict(TypedDict):
        """
        The log files specific settings.
        """
        text: NotRequired[pulumi.Input['LogFileSettingsTextArgsDict']]
        """
        Text settings
        """
elif False:
    LogFilesDataSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFilesDataSourceSettingsArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['LogFileSettingsTextArgs']] = None):
        """
        The log files specific settings.
        :param pulumi.Input['LogFileSettingsTextArgs'] text: Text settings
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['LogFileSettingsTextArgs']]:
        """
        Text settings
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['LogFileSettingsTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class LogFilesDataSourceArgsDict(TypedDict):
        """
        Definition of which custom log files will be collected by this data collection rule
        """
        file_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        File Patterns where the log files are located
        """
        format: pulumi.Input[Union[_builtins.str, 'KnownLogFilesDataSourceFormat']]
        """
        The data format of the log files
        """
        streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data source
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        settings: NotRequired[pulumi.Input['LogFilesDataSourceSettingsArgsDict']]
        """
        The log files specific settings.
        """
elif False:
    LogFilesDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFilesDataSourceArgs:
    def __init__(__self__, *,
                 file_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 format: pulumi.Input[Union[_builtins.str, 'KnownLogFilesDataSourceFormat']],
                 streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']] = None):
        """
        Definition of which custom log files will be collected by this data collection rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] file_patterns: File Patterns where the log files are located
        :param pulumi.Input[Union[_builtins.str, 'KnownLogFilesDataSourceFormat']] format: The data format of the log files
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data source
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input['LogFilesDataSourceSettingsArgs'] settings: The log files specific settings.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        File Patterns where the log files are located
        """
        return pulumi.get(self, "file_patterns")

    @file_patterns.setter
    def file_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "file_patterns", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[Union[_builtins.str, 'KnownLogFilesDataSourceFormat']]:
        """
        The data format of the log files
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[Union[_builtins.str, 'KnownLogFilesDataSourceFormat']]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data source
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']]:
        """
        The log files specific settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class LogSettingsArgsDict(TypedDict):
        """
        Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular log.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        a value indicating whether this log is enabled.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        """
        category_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Diagnostic Log category group for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        """
        retention_policy: NotRequired[pulumi.Input['RetentionPolicyArgsDict']]
        """
        the retention policy for this log.
        """
elif False:
    LogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 category_group: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_policy: Optional[pulumi.Input['RetentionPolicyArgs']] = None):
        """
        Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular log.
        :param pulumi.Input[_builtins.bool] enabled: a value indicating whether this log is enabled.
        :param pulumi.Input[_builtins.str] category: Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        :param pulumi.Input[_builtins.str] category_group: Name of a Diagnostic Log category group for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        :param pulumi.Input['RetentionPolicyArgs'] retention_policy: the retention policy for this log.
        """
        pulumi.set(__self__, "enabled", enabled)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if category_group is not None:
            pulumi.set(__self__, "category_group", category_group)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        a value indicating whether this log is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="categoryGroup")
    def category_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Diagnostic Log category group for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation.
        """
        return pulumi.get(self, "category_group")

    @category_group.setter
    def category_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category_group", value)

    @_builtins.property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[pulumi.Input['RetentionPolicyArgs']]:
        """
        the retention policy for this log.
        """
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input['RetentionPolicyArgs']]):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class LogicAppReceiverArgsDict(TypedDict):
        """
        A logic app receiver.
        """
        callback_url: pulumi.Input[_builtins.str]
        """
        The callback url where http request sent to.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the logic app receiver. Names must be unique across all receivers within an action group.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        The azure resource id of the logic app receiver.
        """
        managed_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    LogicAppReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicAppReceiverArgs:
    def __init__(__self__, *,
                 callback_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 managed_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A logic app receiver.
        :param pulumi.Input[_builtins.str] callback_url: The callback url where http request sent to.
        :param pulumi.Input[_builtins.str] name: The name of the logic app receiver. Names must be unique across all receivers within an action group.
        :param pulumi.Input[_builtins.str] resource_id: The azure resource id of the logic app receiver.
        :param pulumi.Input[_builtins.str] managed_identity: The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "callback_url", callback_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_id", resource_id)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> pulumi.Input[_builtins.str]:
        """
        The callback url where http request sent to.
        """
        return pulumi.get(self, "callback_url")

    @callback_url.setter
    def callback_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "callback_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the logic app receiver. Names must be unique across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The azure resource id of the logic app receiver.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_identity", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ManagedIdentityAuthenticationSettingPropertiesArgsDict(TypedDict):
        """
        Authentication setting properties for Azure Managed Identity
        """
        authentication_kind: pulumi.Input[_builtins.str]
        """
        Supported kinds of authentication settings as discriminator
        Expected value is 'ManagedIdentity'.
        """
        managed_identity_name: pulumi.Input[_builtins.str]
        """
        Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
elif False:
    ManagedIdentityAuthenticationSettingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentityAuthenticationSettingPropertiesArgs:
    def __init__(__self__, *,
                 authentication_kind: pulumi.Input[_builtins.str],
                 managed_identity_name: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Authentication setting properties for Azure Managed Identity
        :param pulumi.Input[_builtins.str] authentication_kind: Supported kinds of authentication settings as discriminator
               Expected value is 'ManagedIdentity'.
        :param pulumi.Input[_builtins.str] managed_identity_name: Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        :param pulumi.Input[_builtins.str] display_name: Display name
        """
        pulumi.set(__self__, "authentication_kind", 'ManagedIdentity')
        pulumi.set(__self__, "managed_identity_name", managed_identity_name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="authenticationKind")
    def authentication_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Supported kinds of authentication settings as discriminator
        Expected value is 'ManagedIdentity'.
        """
        return pulumi.get(self, "authentication_kind")

    @authentication_kind.setter
    def authentication_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_kind", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentityName")
    def managed_identity_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the managed identity to use. Either 'SystemAssigned' or the resourceId of a user-assigned identity.
        """
        return pulumi.get(self, "managed_identity_name")

    @managed_identity_name.setter
    def managed_identity_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "managed_identity_name", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ManagementGroupLogSettingsArgsDict(TypedDict):
        """
        Part of Management Group diagnostic setting. Specifies the settings for a particular log.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        a value indicating whether this log is enabled.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Management Group Diagnostic Log category for a resource type this setting is applied to.
        """
        category_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Management Group Diagnostic Log category group for a resource type this setting is applied to.
        """
elif False:
    ManagementGroupLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementGroupLogSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 category_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Part of Management Group diagnostic setting. Specifies the settings for a particular log.
        :param pulumi.Input[_builtins.bool] enabled: a value indicating whether this log is enabled.
        :param pulumi.Input[_builtins.str] category: Name of a Management Group Diagnostic Log category for a resource type this setting is applied to.
        :param pulumi.Input[_builtins.str] category_group: Name of a Management Group Diagnostic Log category group for a resource type this setting is applied to.
        """
        pulumi.set(__self__, "enabled", enabled)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if category_group is not None:
            pulumi.set(__self__, "category_group", category_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        a value indicating whether this log is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Management Group Diagnostic Log category for a resource type this setting is applied to.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="categoryGroup")
    def category_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Management Group Diagnostic Log category group for a resource type this setting is applied to.
        """
        return pulumi.get(self, "category_group")

    @category_group.setter
    def category_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category_group", value)


if not MYPY:
    class MetricAlertActionArgsDict(TypedDict):
        """
        An alert action.
        """
        action_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        the id of the action group to use.
        """
        web_hook_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        This field allows specifying custom properties, which would be appended to the alert payload sent as input to the webhook.
        """
elif False:
    MetricAlertActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertActionArgs:
    def __init__(__self__, *,
                 action_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_hook_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        An alert action.
        :param pulumi.Input[_builtins.str] action_group_id: the id of the action group to use.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] web_hook_properties: This field allows specifying custom properties, which would be appended to the alert payload sent as input to the webhook.
        """
        if action_group_id is not None:
            pulumi.set(__self__, "action_group_id", action_group_id)
        if web_hook_properties is not None:
            pulumi.set(__self__, "web_hook_properties", web_hook_properties)

    @_builtins.property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the id of the action group to use.
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_group_id", value)

    @_builtins.property
    @pulumi.getter(name="webHookProperties")
    def web_hook_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        This field allows specifying custom properties, which would be appended to the alert payload sent as input to the webhook.
        """
        return pulumi.get(self, "web_hook_properties")

    @web_hook_properties.setter
    def web_hook_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "web_hook_properties", value)


if not MYPY:
    class MetricAlertMultipleResourceMultipleMetricCriteriaArgsDict(TypedDict):
        """
        Specifies the metric alert criteria for multiple resource that has multiple metric criteria.
        """
        odata_type: pulumi.Input[_builtins.str]
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria'.
        """
        all_of: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['DynamicMetricCriteriaArgsDict', 'MetricCriteriaArgsDict']]]]]
        """
        the list of multiple metric criteria for this 'all of' operation. 
        """
elif False:
    MetricAlertMultipleResourceMultipleMetricCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertMultipleResourceMultipleMetricCriteriaArgs:
    def __init__(__self__, *,
                 odata_type: pulumi.Input[_builtins.str],
                 all_of: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicMetricCriteriaArgs', 'MetricCriteriaArgs']]]]] = None):
        """
        Specifies the metric alert criteria for multiple resource that has multiple metric criteria.
        :param pulumi.Input[_builtins.str] odata_type: specifies the type of the alert criteria.
               Expected value is 'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicMetricCriteriaArgs', 'MetricCriteriaArgs']]]] all_of: the list of multiple metric criteria for this 'all of' operation. 
        """
        pulumi.set(__self__, "odata_type", 'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria')
        if all_of is not None:
            pulumi.set(__self__, "all_of", all_of)

    @_builtins.property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> pulumi.Input[_builtins.str]:
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria'.
        """
        return pulumi.get(self, "odata_type")

    @odata_type.setter
    def odata_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "odata_type", value)

    @_builtins.property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicMetricCriteriaArgs', 'MetricCriteriaArgs']]]]]:
        """
        the list of multiple metric criteria for this 'all of' operation. 
        """
        return pulumi.get(self, "all_of")

    @all_of.setter
    def all_of(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicMetricCriteriaArgs', 'MetricCriteriaArgs']]]]]):
        pulumi.set(self, "all_of", value)


if not MYPY:
    class MetricAlertSingleResourceMultipleMetricCriteriaArgsDict(TypedDict):
        """
        Specifies the metric alert criteria for a single resource that has multiple metric criteria.
        """
        odata_type: pulumi.Input[_builtins.str]
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria'.
        """
        all_of: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricCriteriaArgsDict']]]]
        """
        The list of metric criteria for this 'all of' operation. 
        """
elif False:
    MetricAlertSingleResourceMultipleMetricCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertSingleResourceMultipleMetricCriteriaArgs:
    def __init__(__self__, *,
                 odata_type: pulumi.Input[_builtins.str],
                 all_of: Optional[pulumi.Input[Sequence[pulumi.Input['MetricCriteriaArgs']]]] = None):
        """
        Specifies the metric alert criteria for a single resource that has multiple metric criteria.
        :param pulumi.Input[_builtins.str] odata_type: specifies the type of the alert criteria.
               Expected value is 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria'.
        :param pulumi.Input[Sequence[pulumi.Input['MetricCriteriaArgs']]] all_of: The list of metric criteria for this 'all of' operation. 
        """
        pulumi.set(__self__, "odata_type", 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria')
        if all_of is not None:
            pulumi.set(__self__, "all_of", all_of)

    @_builtins.property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> pulumi.Input[_builtins.str]:
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria'.
        """
        return pulumi.get(self, "odata_type")

    @odata_type.setter
    def odata_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "odata_type", value)

    @_builtins.property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricCriteriaArgs']]]]:
        """
        The list of metric criteria for this 'all of' operation. 
        """
        return pulumi.get(self, "all_of")

    @all_of.setter
    def all_of(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricCriteriaArgs']]]]):
        pulumi.set(self, "all_of", value)


if not MYPY:
    class MetricCriteriaArgsDict(TypedDict):
        """
        Criterion to filter metrics.
        """
        criterion_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of threshold criteria
        Expected value is 'StaticThresholdCriterion'.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Name of the metric.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the criteria.
        """
        operator: pulumi.Input[Union[_builtins.str, 'Operator']]
        """
        the criteria operator.
        """
        threshold: pulumi.Input[_builtins.float]
        """
        the criteria threshold value that activates the alert.
        """
        time_aggregation: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]
        """
        the criteria time aggregation types.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgsDict']]]]
        """
        List of dimension conditions.
        """
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace of the metric.
        """
        skip_metric_validation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
elif False:
    MetricCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricCriteriaArgs:
    def __init__(__self__, *,
                 criterion_type: pulumi.Input[_builtins.str],
                 metric_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[Union[_builtins.str, 'Operator']],
                 threshold: pulumi.Input[_builtins.float],
                 time_aggregation: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 skip_metric_validation: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Criterion to filter metrics.
        :param pulumi.Input[_builtins.str] criterion_type: Specifies the type of threshold criteria
               Expected value is 'StaticThresholdCriterion'.
        :param pulumi.Input[_builtins.str] metric_name: Name of the metric.
        :param pulumi.Input[_builtins.str] name: Name of the criteria.
        :param pulumi.Input[Union[_builtins.str, 'Operator']] operator: the criteria operator.
        :param pulumi.Input[_builtins.float] threshold: the criteria threshold value that activates the alert.
        :param pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']] time_aggregation: the criteria time aggregation types.
        :param pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]] dimensions: List of dimension conditions.
        :param pulumi.Input[_builtins.str] metric_namespace: Namespace of the metric.
        :param pulumi.Input[_builtins.bool] skip_metric_validation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
        pulumi.set(__self__, "criterion_type", 'StaticThresholdCriterion')
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation", time_aggregation)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @_builtins.property
    @pulumi.getter(name="criterionType")
    def criterion_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of threshold criteria
        Expected value is 'StaticThresholdCriterion'.
        """
        return pulumi.get(self, "criterion_type")

    @criterion_type.setter
    def criterion_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "criterion_type", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the criteria.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'Operator']]:
        """
        the criteria operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'Operator']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        the criteria threshold value that activates the alert.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]:
        """
        the criteria time aggregation types.
        """
        return pulumi.get(self, "time_aggregation")

    @time_aggregation.setter
    def time_aggregation(self, value: pulumi.Input[Union[_builtins.str, 'AggregationTypeEnum']]):
        pulumi.set(self, "time_aggregation", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]]:
        """
        List of dimension conditions.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace of the metric.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric validation to be skipped.
        """
        return pulumi.get(self, "skip_metric_validation")

    @skip_metric_validation.setter
    def skip_metric_validation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_metric_validation", value)


if not MYPY:
    class MetricDimensionArgsDict(TypedDict):
        """
        Specifies a metric dimension.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the dimension.
        """
        operator: pulumi.Input[_builtins.str]
        """
        the dimension operator. Only 'Include' and 'Exclude' are supported
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        list of dimension values.
        """
elif False:
    MetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Specifies a metric dimension.
        :param pulumi.Input[_builtins.str] name: Name of the dimension.
        :param pulumi.Input[_builtins.str] operator: the dimension operator. Only 'Include' and 'Exclude' are supported
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        the dimension operator. Only 'Include' and 'Exclude' are supported
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        list of dimension values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MetricSettingsArgsDict(TypedDict):
        """
        Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular metric.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        a value indicating whether this category is enabled.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain the list of Diagnostic metric categories for a resource, first perform a GET diagnostic settings operation.
        """
        retention_policy: NotRequired[pulumi.Input['RetentionPolicyArgsDict']]
        """
        the retention policy for this category.
        """
        time_grain: NotRequired[pulumi.Input[_builtins.str]]
        """
        the timegrain of the metric in ISO8601 format.
        """
elif False:
    MetricSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_policy: Optional[pulumi.Input['RetentionPolicyArgs']] = None,
                 time_grain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular metric.
        :param pulumi.Input[_builtins.bool] enabled: a value indicating whether this category is enabled.
        :param pulumi.Input[_builtins.str] category: Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain the list of Diagnostic metric categories for a resource, first perform a GET diagnostic settings operation.
        :param pulumi.Input['RetentionPolicyArgs'] retention_policy: the retention policy for this category.
        :param pulumi.Input[_builtins.str] time_grain: the timegrain of the metric in ISO8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        a value indicating whether this category is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain the list of Diagnostic metric categories for a resource, first perform a GET diagnostic settings operation.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[pulumi.Input['RetentionPolicyArgs']]:
        """
        the retention policy for this category.
        """
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input['RetentionPolicyArgs']]):
        pulumi.set(self, "retention_policy", value)

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the timegrain of the metric in ISO8601 format.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_grain", value)


if not MYPY:
    class MetricTriggerArgsDict(TypedDict):
        """
        The trigger that results in a scaling action.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        the name of the metric that defines what the rule monitors.
        """
        metric_resource_uri: pulumi.Input[_builtins.str]
        """
        the resource identifier of the resource the rule monitors.
        """
        operator: pulumi.Input['ComparisonOperationType']
        """
        the operator that is used to compare the metric data and the threshold.
        """
        statistic: pulumi.Input['MetricStatisticType']
        """
        the metric statistic type. How the metrics from multiple instances are combined.
        """
        threshold: pulumi.Input[_builtins.float]
        """
        the threshold of the metric that triggers the scale action.
        """
        time_aggregation: pulumi.Input['TimeAggregationType']
        """
        time aggregation type. How the data that is collected should be combined over time. The default value is Average.
        """
        time_grain: pulumi.Input[_builtins.str]
        """
        the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
        """
        time_window: pulumi.Input[_builtins.str]
        """
        the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleMetricDimensionArgsDict']]]]
        """
        List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
        """
        divide_per_instance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        a value indicating whether metric should divide per instance.
        """
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        the namespace of the metric that defines what the rule monitors.
        """
        metric_resource_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        the location of the resource the rule monitors.
        """
elif False:
    MetricTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricTriggerArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 metric_resource_uri: pulumi.Input[_builtins.str],
                 operator: pulumi.Input['ComparisonOperationType'],
                 statistic: pulumi.Input['MetricStatisticType'],
                 threshold: pulumi.Input[_builtins.float],
                 time_aggregation: pulumi.Input['TimeAggregationType'],
                 time_grain: pulumi.Input[_builtins.str],
                 time_window: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleMetricDimensionArgs']]]] = None,
                 divide_per_instance: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_resource_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The trigger that results in a scaling action.
        :param pulumi.Input[_builtins.str] metric_name: the name of the metric that defines what the rule monitors.
        :param pulumi.Input[_builtins.str] metric_resource_uri: the resource identifier of the resource the rule monitors.
        :param pulumi.Input['ComparisonOperationType'] operator: the operator that is used to compare the metric data and the threshold.
        :param pulumi.Input['MetricStatisticType'] statistic: the metric statistic type. How the metrics from multiple instances are combined.
        :param pulumi.Input[_builtins.float] threshold: the threshold of the metric that triggers the scale action.
        :param pulumi.Input['TimeAggregationType'] time_aggregation: time aggregation type. How the data that is collected should be combined over time. The default value is Average.
        :param pulumi.Input[_builtins.str] time_grain: the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
        :param pulumi.Input[_builtins.str] time_window: the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleMetricDimensionArgs']]] dimensions: List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
        :param pulumi.Input[_builtins.bool] divide_per_instance: a value indicating whether metric should divide per instance.
        :param pulumi.Input[_builtins.str] metric_namespace: the namespace of the metric that defines what the rule monitors.
        :param pulumi.Input[_builtins.str] metric_resource_location: the location of the resource the rule monitors.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_resource_uri", metric_resource_uri)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation", time_aggregation)
        pulumi.set(__self__, "time_grain", time_grain)
        pulumi.set(__self__, "time_window", time_window)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if divide_per_instance is not None:
            pulumi.set(__self__, "divide_per_instance", divide_per_instance)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_resource_location is not None:
            pulumi.set(__self__, "metric_resource_location", metric_resource_location)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        the name of the metric that defines what the rule monitors.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricResourceUri")
    def metric_resource_uri(self) -> pulumi.Input[_builtins.str]:
        """
        the resource identifier of the resource the rule monitors.
        """
        return pulumi.get(self, "metric_resource_uri")

    @metric_resource_uri.setter
    def metric_resource_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_resource_uri", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input['ComparisonOperationType']:
        """
        the operator that is used to compare the metric data and the threshold.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['ComparisonOperationType']):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> pulumi.Input['MetricStatisticType']:
        """
        the metric statistic type. How the metrics from multiple instances are combined.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input['MetricStatisticType']):
        pulumi.set(self, "statistic", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        the threshold of the metric that triggers the scale action.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> pulumi.Input['TimeAggregationType']:
        """
        time aggregation type. How the data that is collected should be combined over time. The default value is Average.
        """
        return pulumi.get(self, "time_aggregation")

    @time_aggregation.setter
    def time_aggregation(self, value: pulumi.Input['TimeAggregationType']):
        pulumi.set(self, "time_aggregation", value)

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> pulumi.Input[_builtins.str]:
        """
        the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_grain", value)

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> pulumi.Input[_builtins.str]:
        """
        the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_window", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleMetricDimensionArgs']]]]:
        """
        List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleMetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="dividePerInstance")
    def divide_per_instance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        a value indicating whether metric should divide per instance.
        """
        return pulumi.get(self, "divide_per_instance")

    @divide_per_instance.setter
    def divide_per_instance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "divide_per_instance", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the namespace of the metric that defines what the rule monitors.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricResourceLocation")
    def metric_resource_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the location of the resource the rule monitors.
        """
        return pulumi.get(self, "metric_resource_location")

    @metric_resource_location.setter
    def metric_resource_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_resource_location", value)


if not MYPY:
    class ModelDiscoverySettingsArgsDict(TypedDict):
        """
        Settings for automatically discovering entities for the health model.
        """
        add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]
        """
        Whether to add all recommended signals to the discovered entities.
        """
        scope: pulumi.Input[_builtins.str]
        """
        The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        """
        identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
elif False:
    ModelDiscoverySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDiscoverySettingsArgs:
    def __init__(__self__, *,
                 add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']],
                 scope: pulumi.Input[_builtins.str],
                 identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Settings for automatically discovering entities for the health model.
        :param pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']] add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param pulumi.Input[_builtins.str] scope: The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        :param pulumi.Input[_builtins.str] identity: Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "scope", scope)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @_builtins.property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @add_recommended_signals.setter
    def add_recommended_signals(self, value: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]):
        pulumi.set(self, "add_recommended_signals", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        The scope from which entities should be automatically discovered. For example, the resource id of a Service Group.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which Managed Identity of the health model to use for discovery. Defaults to SystemAssigned, if not set. Can be set to 'SystemAssigned' or to the resource id of a user-assigned managed identity which is linked to the health model.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity", value)


if not MYPY:
    class MonitoringAccountDestinationArgsDict(TypedDict):
        """
        Monitoring account destination.
        """
        account_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the monitoring account.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    MonitoringAccountDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringAccountDestinationArgs:
    def __init__(__self__, *,
                 account_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Monitoring account destination.
        :param pulumi.Input[_builtins.str] account_resource_id: The resource ID of the monitoring account.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if account_resource_id is not None:
            pulumi.set(__self__, "account_resource_id", account_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="accountResourceId")
    def account_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the monitoring account.
        """
        return pulumi.get(self, "account_resource_id")

    @account_resource_id.setter
    def account_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_resource_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NetworkingConfigurationArgsDict(TypedDict):
        """
        Networking configuration for the pipeline group instance.
        """
        external_networking_mode: pulumi.Input[Union[_builtins.str, 'ExternalNetworkingMode']]
        """
        External networking mode.
        """
        routes: pulumi.Input[Sequence[pulumi.Input['NetworkingRouteArgsDict']]]
        """
        Networking routes configuration.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address exposed on the cluster. Example: azuremonitorpipeline.contoso.com.
        """
elif False:
    NetworkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkingConfigurationArgs:
    def __init__(__self__, *,
                 external_networking_mode: pulumi.Input[Union[_builtins.str, 'ExternalNetworkingMode']],
                 routes: pulumi.Input[Sequence[pulumi.Input['NetworkingRouteArgs']]],
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Networking configuration for the pipeline group instance.
        :param pulumi.Input[Union[_builtins.str, 'ExternalNetworkingMode']] external_networking_mode: External networking mode.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkingRouteArgs']]] routes: Networking routes configuration.
        :param pulumi.Input[_builtins.str] host: The address exposed on the cluster. Example: azuremonitorpipeline.contoso.com.
        """
        pulumi.set(__self__, "external_networking_mode", external_networking_mode)
        pulumi.set(__self__, "routes", routes)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter(name="externalNetworkingMode")
    def external_networking_mode(self) -> pulumi.Input[Union[_builtins.str, 'ExternalNetworkingMode']]:
        """
        External networking mode.
        """
        return pulumi.get(self, "external_networking_mode")

    @external_networking_mode.setter
    def external_networking_mode(self, value: pulumi.Input[Union[_builtins.str, 'ExternalNetworkingMode']]):
        pulumi.set(self, "external_networking_mode", value)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkingRouteArgs']]]:
        """
        Networking routes configuration.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkingRouteArgs']]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address exposed on the cluster. Example: azuremonitorpipeline.contoso.com.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class NetworkingRouteArgsDict(TypedDict):
        """
        Networking route configuration.
        """
        receiver: pulumi.Input[_builtins.str]
        """
        The name of the previously defined receiver.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route path.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port that will be configured externally. If not specified, it will use the port from the receiver definition.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route subdomain.
        """
elif False:
    NetworkingRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkingRouteArgs:
    def __init__(__self__, *,
                 receiver: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Networking route configuration.
        :param pulumi.Input[_builtins.str] receiver: The name of the previously defined receiver.
        :param pulumi.Input[_builtins.str] path: Route path.
        :param pulumi.Input[_builtins.int] port: The port that will be configured externally. If not specified, it will use the port from the receiver definition.
        :param pulumi.Input[_builtins.str] subdomain: Route subdomain.
        """
        pulumi.set(__self__, "receiver", receiver)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)

    @_builtins.property
    @pulumi.getter
    def receiver(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the previously defined receiver.
        """
        return pulumi.get(self, "receiver")

    @receiver.setter
    def receiver(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "receiver", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port that will be configured externally. If not specified, it will use the port from the receiver definition.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)


if not MYPY:
    class OtlpReceiverArgsDict(TypedDict):
        """
        OTLP Receiver.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        OTLP GRPC endpoint definition. Example: 0.0.0.0:<port>.
        """
elif False:
    OtlpReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OtlpReceiverArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        OTLP Receiver.
        :param pulumi.Input[_builtins.str] endpoint: OTLP GRPC endpoint definition. Example: 0.0.0.0:<port>.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OTLP GRPC endpoint definition. Example: 0.0.0.0:<port>.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class PerfCounterDataSourceArgsDict(TypedDict):
        """
        Definition of which performance counters will be collected and how they will be collected by this data collection rule.
        Collected from both Windows and Linux machines where the counter is present.
        """
        counter_specifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of specifier names of the performance counters you want to collect.
        Use a wildcard (*) to collect a counter for all instances.
        To get a list of performance counters on Windows, run the command 'typeperf'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        sampling_frequency_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds between consecutive counter measurements (samples).
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPerfCounterDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
elif False:
    PerfCounterDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PerfCounterDataSourceArgs:
    def __init__(__self__, *,
                 counter_specifiers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sampling_frequency_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPerfCounterDataSourceStreams']]]]] = None):
        """
        Definition of which performance counters will be collected and how they will be collected by this data collection rule.
        Collected from both Windows and Linux machines where the counter is present.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] counter_specifiers: A list of specifier names of the performance counters you want to collect.
               Use a wildcard (*) to collect a counter for all instances.
               To get a list of performance counters on Windows, run the command 'typeperf'.
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[_builtins.int] sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples).
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPerfCounterDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        if counter_specifiers is not None:
            pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sampling_frequency_in_seconds is not None:
            pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @_builtins.property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of specifier names of the performance counters you want to collect.
        Use a wildcard (*) to collect a counter for all instances.
        To get a list of performance counters on Windows, run the command 'typeperf'.
        """
        return pulumi.get(self, "counter_specifiers")

    @counter_specifiers.setter
    def counter_specifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "counter_specifiers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds between consecutive counter measurements (samples).
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @sampling_frequency_in_seconds.setter
    def sampling_frequency_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sampling_frequency_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPerfCounterDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPerfCounterDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class PersistenceConfigurationsArgsDict(TypedDict):
        """
        Persistence options to all pipelines in the instance.
        """
        persistent_volume_name: pulumi.Input[_builtins.str]
        """
        The name of the mounted persistent volume.
        """
elif False:
    PersistenceConfigurationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistenceConfigurationsArgs:
    def __init__(__self__, *,
                 persistent_volume_name: pulumi.Input[_builtins.str]):
        """
        Persistence options to all pipelines in the instance.
        :param pulumi.Input[_builtins.str] persistent_volume_name: The name of the mounted persistent volume.
        """
        pulumi.set(__self__, "persistent_volume_name", persistent_volume_name)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeName")
    def persistent_volume_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the mounted persistent volume.
        """
        return pulumi.get(self, "persistent_volume_name")

    @persistent_volume_name.setter
    def persistent_volume_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "persistent_volume_name", value)


if not MYPY:
    class PipelineGroupPropertiesArgsDict(TypedDict):
        """
        Properties that need to be specified to create a new pipeline group instance.
        """
        exporters: pulumi.Input[Sequence[pulumi.Input['ExporterArgsDict']]]
        """
        The exporters specified for a pipeline group instance.
        """
        processors: pulumi.Input[Sequence[pulumi.Input['ProcessorArgsDict']]]
        """
        The processors specified for a pipeline group instance.
        """
        receivers: pulumi.Input[Sequence[pulumi.Input['ReceiverArgsDict']]]
        """
        The receivers specified for a pipeline group instance.
        """
        service: pulumi.Input['ServiceArgsDict']
        """
        The service section for a given pipeline group instance.
        """
        networking_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkingConfigurationArgsDict']]]]
        """
        Networking configurations for the pipeline group instance.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        Defines the amount of replicas of the pipeline group instance.
        """
elif False:
    PipelineGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineGroupPropertiesArgs:
    def __init__(__self__, *,
                 exporters: pulumi.Input[Sequence[pulumi.Input['ExporterArgs']]],
                 processors: pulumi.Input[Sequence[pulumi.Input['ProcessorArgs']]],
                 receivers: pulumi.Input[Sequence[pulumi.Input['ReceiverArgs']]],
                 service: pulumi.Input['ServiceArgs'],
                 networking_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkingConfigurationArgs']]]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Properties that need to be specified to create a new pipeline group instance.
        :param pulumi.Input[Sequence[pulumi.Input['ExporterArgs']]] exporters: The exporters specified for a pipeline group instance.
        :param pulumi.Input[Sequence[pulumi.Input['ProcessorArgs']]] processors: The processors specified for a pipeline group instance.
        :param pulumi.Input[Sequence[pulumi.Input['ReceiverArgs']]] receivers: The receivers specified for a pipeline group instance.
        :param pulumi.Input['ServiceArgs'] service: The service section for a given pipeline group instance.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkingConfigurationArgs']]] networking_configurations: Networking configurations for the pipeline group instance.
        :param pulumi.Input[_builtins.int] replicas: Defines the amount of replicas of the pipeline group instance.
        """
        pulumi.set(__self__, "exporters", exporters)
        pulumi.set(__self__, "processors", processors)
        pulumi.set(__self__, "receivers", receivers)
        pulumi.set(__self__, "service", service)
        if networking_configurations is not None:
            pulumi.set(__self__, "networking_configurations", networking_configurations)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter
    def exporters(self) -> pulumi.Input[Sequence[pulumi.Input['ExporterArgs']]]:
        """
        The exporters specified for a pipeline group instance.
        """
        return pulumi.get(self, "exporters")

    @exporters.setter
    def exporters(self, value: pulumi.Input[Sequence[pulumi.Input['ExporterArgs']]]):
        pulumi.set(self, "exporters", value)

    @_builtins.property
    @pulumi.getter
    def processors(self) -> pulumi.Input[Sequence[pulumi.Input['ProcessorArgs']]]:
        """
        The processors specified for a pipeline group instance.
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: pulumi.Input[Sequence[pulumi.Input['ProcessorArgs']]]):
        pulumi.set(self, "processors", value)

    @_builtins.property
    @pulumi.getter
    def receivers(self) -> pulumi.Input[Sequence[pulumi.Input['ReceiverArgs']]]:
        """
        The receivers specified for a pipeline group instance.
        """
        return pulumi.get(self, "receivers")

    @receivers.setter
    def receivers(self, value: pulumi.Input[Sequence[pulumi.Input['ReceiverArgs']]]):
        pulumi.set(self, "receivers", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input['ServiceArgs']:
        """
        The service section for a given pipeline group instance.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input['ServiceArgs']):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="networkingConfigurations")
    def networking_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkingConfigurationArgs']]]]:
        """
        Networking configurations for the pipeline group instance.
        """
        return pulumi.get(self, "networking_configurations")

    @networking_configurations.setter
    def networking_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkingConfigurationArgs']]]]):
        pulumi.set(self, "networking_configurations", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Defines the amount of replicas of the pipeline group instance.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class PipelineArgsDict(TypedDict):
        """
        Pipeline Info.
        """
        exporters: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Reference to exporters configured for the pipeline.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the pipeline.
        """
        receivers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Reference to receivers configured for the pipeline.
        """
        type: pulumi.Input[Union[_builtins.str, 'PipelineType']]
        """
        The type of pipeline
        """
        processors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Reference to processors configured for the pipeline.
        """
elif False:
    PipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineArgs:
    def __init__(__self__, *,
                 exporters: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str],
                 receivers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[Union[_builtins.str, 'PipelineType']],
                 processors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Pipeline Info.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exporters: Reference to exporters configured for the pipeline.
        :param pulumi.Input[_builtins.str] name: Name of the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receivers: Reference to receivers configured for the pipeline.
        :param pulumi.Input[Union[_builtins.str, 'PipelineType']] type: The type of pipeline
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] processors: Reference to processors configured for the pipeline.
        """
        pulumi.set(__self__, "exporters", exporters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "receivers", receivers)
        pulumi.set(__self__, "type", type)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @_builtins.property
    @pulumi.getter
    def exporters(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Reference to exporters configured for the pipeline.
        """
        return pulumi.get(self, "exporters")

    @exporters.setter
    def exporters(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "exporters", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def receivers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Reference to receivers configured for the pipeline.
        """
        return pulumi.get(self, "receivers")

    @receivers.setter
    def receivers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "receivers", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'PipelineType']]:
        """
        The type of pipeline
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'PipelineType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Reference to processors configured for the pipeline.
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "processors", value)


if not MYPY:
    class PlatformTelemetryDataSourceArgsDict(TypedDict):
        """
        Definition of platform telemetry data source configuration
        """
        streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of platform telemetry streams to collect
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
elif False:
    PlatformTelemetryDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformTelemetryDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Definition of platform telemetry data source configuration
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] streams: List of platform telemetry streams to collect
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of platform telemetry streams to collect
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PredictiveAutoscalePolicyArgsDict(TypedDict):
        """
        The parameters for enabling predictive autoscale.
        """
        scale_mode: pulumi.Input['PredictiveAutoscalePolicyScaleMode']
        """
        the predictive autoscale mode
        """
        scale_look_ahead_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        the amount of time to specify by which instances are launched in advance. It must be between 1 minute and 60 minutes in ISO 8601 format.
        """
elif False:
    PredictiveAutoscalePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PredictiveAutoscalePolicyArgs:
    def __init__(__self__, *,
                 scale_mode: pulumi.Input['PredictiveAutoscalePolicyScaleMode'],
                 scale_look_ahead_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The parameters for enabling predictive autoscale.
        :param pulumi.Input['PredictiveAutoscalePolicyScaleMode'] scale_mode: the predictive autoscale mode
        :param pulumi.Input[_builtins.str] scale_look_ahead_time: the amount of time to specify by which instances are launched in advance. It must be between 1 minute and 60 minutes in ISO 8601 format.
        """
        pulumi.set(__self__, "scale_mode", scale_mode)
        if scale_look_ahead_time is not None:
            pulumi.set(__self__, "scale_look_ahead_time", scale_look_ahead_time)

    @_builtins.property
    @pulumi.getter(name="scaleMode")
    def scale_mode(self) -> pulumi.Input['PredictiveAutoscalePolicyScaleMode']:
        """
        the predictive autoscale mode
        """
        return pulumi.get(self, "scale_mode")

    @scale_mode.setter
    def scale_mode(self, value: pulumi.Input['PredictiveAutoscalePolicyScaleMode']):
        pulumi.set(self, "scale_mode", value)

    @_builtins.property
    @pulumi.getter(name="scaleLookAheadTime")
    def scale_look_ahead_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the amount of time to specify by which instances are launched in advance. It must be between 1 minute and 60 minutes in ISO 8601 format.
        """
        return pulumi.get(self, "scale_look_ahead_time")

    @scale_look_ahead_time.setter
    def scale_look_ahead_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scale_look_ahead_time", value)


if not MYPY:
    class PrivateLinkServiceConnectionStateArgsDict(TypedDict):
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        actions_required: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reason for approval/rejection of the connection.
        """
        status: NotRequired[pulumi.Input[Union[_builtins.str, 'PrivateEndpointServiceConnectionStatus']]]
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
elif False:
    PrivateLinkServiceConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[_builtins.str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param pulumi.Input[_builtins.str] actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param pulumi.Input[_builtins.str] description: The reason for approval/rejection of the connection.
        :param pulumi.Input[Union[_builtins.str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "actions_required", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[_builtins.str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[_builtins.str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ProcessorArgsDict(TypedDict):
        """
        Processor Info.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of processor.
        """
        type: pulumi.Input[Union[_builtins.str, 'ProcessorType']]
        """
        The type of processor.
        """
        batch: NotRequired[pulumi.Input['BatchProcessorArgsDict']]
        """
        Batch processor configurations.
        """
elif False:
    ProcessorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProcessorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'ProcessorType']],
                 batch: Optional[pulumi.Input['BatchProcessorArgs']] = None):
        """
        Processor Info.
        :param pulumi.Input[_builtins.str] name: The name of processor.
        :param pulumi.Input[Union[_builtins.str, 'ProcessorType']] type: The type of processor.
        :param pulumi.Input['BatchProcessorArgs'] batch: Batch processor configurations.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if batch is not None:
            pulumi.set(__self__, "batch", batch)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ProcessorType']]:
        """
        The type of processor.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ProcessorType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['BatchProcessorArgs']]:
        """
        Batch processor configurations.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['BatchProcessorArgs']]):
        pulumi.set(self, "batch", value)


if not MYPY:
    class PrometheusForwarderDataSourceArgsDict(TypedDict):
        """
        Definition of Prometheus metrics forwarding configuration.
        """
        label_include_filter: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The list of label inclusion filters in the form of label "name-value" pairs.
        Currently only one label is supported: 'microsoft_metrics_include_label'.
        Label values are matched case-insensitively.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPrometheusForwarderDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        """
elif False:
    PrometheusForwarderDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusForwarderDataSourceArgs:
    def __init__(__self__, *,
                 label_include_filter: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPrometheusForwarderDataSourceStreams']]]]] = None):
        """
        Definition of Prometheus metrics forwarding configuration.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] label_include_filter: The list of label inclusion filters in the form of label "name-value" pairs.
               Currently only one label is supported: 'microsoft_metrics_include_label'.
               Label values are matched case-insensitively.
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPrometheusForwarderDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
        """
        if label_include_filter is not None:
            pulumi.set(__self__, "label_include_filter", label_include_filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @_builtins.property
    @pulumi.getter(name="labelIncludeFilter")
    def label_include_filter(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The list of label inclusion filters in the form of label "name-value" pairs.
        Currently only one label is supported: 'microsoft_metrics_include_label'.
        Label values are matched case-insensitively.
        """
        return pulumi.get(self, "label_include_filter")

    @label_include_filter.setter
    def label_include_filter(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "label_include_filter", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPrometheusForwarderDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownPrometheusForwarderDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class PrometheusMetricsSignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Prometheus Metrics Signal Definition properties
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        query_text: pulumi.Input[_builtins.str]
        """
        Query text in PromQL syntax
        """
        signal_kind: pulumi.Input[_builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'PrometheusMetricsQuery'.
        """
        data_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
        refresh_interval: NotRequired[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
        time_grain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time range of signal. ISO duration format like PT10M.
        """
elif False:
    PrometheusMetricsSignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusMetricsSignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 query_text: pulumi.Input[_builtins.str],
                 signal_kind: pulumi.Input[_builtins.str],
                 data_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 time_grain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Prometheus Metrics Signal Definition properties
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[_builtins.str] query_text: Query text in PromQL syntax
        :param pulumi.Input[_builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'PrometheusMetricsQuery'.
        :param pulumi.Input[_builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[_builtins.str] display_name: Display name
        :param pulumi.Input[Union[_builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Optional set of labels (key-value pairs)
        :param pulumi.Input[_builtins.str] time_grain: Time range of signal. ISO duration format like PT10M.
        """
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "signal_kind", 'PrometheusMetricsQuery')
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_grain is not None:
            pulumi.set(__self__, "time_grain", time_grain)

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @_builtins.property
    @pulumi.getter(name="queryText")
    def query_text(self) -> pulumi.Input[_builtins.str]:
        """
        Query text in PromQL syntax
        """
        return pulumi.get(self, "query_text")

    @query_text.setter
    def query_text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query_text", value)

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'PrometheusMetricsQuery'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_grain", value)


if not MYPY:
    class ReceiverArgsDict(TypedDict):
        """
        Receiver Info.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of receiver.
        """
        type: pulumi.Input[Union[_builtins.str, 'ReceiverType']]
        """
        The type of receiver.
        """
        otlp: NotRequired[pulumi.Input['OtlpReceiverArgsDict']]
        """
        OTLP receiver configurations. This field is mandatory for OTLP and pipelineGroup receivers.
        """
        syslog: NotRequired[pulumi.Input['SyslogReceiverArgsDict']]
        """
        Syslog configurations. This field is mandatory for syslog type receivers.
        """
        udp: NotRequired[pulumi.Input['UdpReceiverArgsDict']]
        """
        UDP receiver configurations. This field is mandatory for UDP receivers.
        """
elif False:
    ReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReceiverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'ReceiverType']],
                 otlp: Optional[pulumi.Input['OtlpReceiverArgs']] = None,
                 syslog: Optional[pulumi.Input['SyslogReceiverArgs']] = None,
                 udp: Optional[pulumi.Input['UdpReceiverArgs']] = None):
        """
        Receiver Info.
        :param pulumi.Input[_builtins.str] name: The name of receiver.
        :param pulumi.Input[Union[_builtins.str, 'ReceiverType']] type: The type of receiver.
        :param pulumi.Input['OtlpReceiverArgs'] otlp: OTLP receiver configurations. This field is mandatory for OTLP and pipelineGroup receivers.
        :param pulumi.Input['SyslogReceiverArgs'] syslog: Syslog configurations. This field is mandatory for syslog type receivers.
        :param pulumi.Input['UdpReceiverArgs'] udp: UDP receiver configurations. This field is mandatory for UDP receivers.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if otlp is not None:
            pulumi.set(__self__, "otlp", otlp)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ReceiverType']]:
        """
        The type of receiver.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ReceiverType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def otlp(self) -> Optional[pulumi.Input['OtlpReceiverArgs']]:
        """
        OTLP receiver configurations. This field is mandatory for OTLP and pipelineGroup receivers.
        """
        return pulumi.get(self, "otlp")

    @otlp.setter
    def otlp(self, value: Optional[pulumi.Input['OtlpReceiverArgs']]):
        pulumi.set(self, "otlp", value)

    @_builtins.property
    @pulumi.getter
    def syslog(self) -> Optional[pulumi.Input['SyslogReceiverArgs']]:
        """
        Syslog configurations. This field is mandatory for syslog type receivers.
        """
        return pulumi.get(self, "syslog")

    @syslog.setter
    def syslog(self, value: Optional[pulumi.Input['SyslogReceiverArgs']]):
        pulumi.set(self, "syslog", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['UdpReceiverArgs']]:
        """
        UDP receiver configurations. This field is mandatory for UDP receivers.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['UdpReceiverArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class RecordMapArgsDict(TypedDict):
        """
        Record map for schema in azure monitor.
        """
        from_: pulumi.Input[_builtins.str]
        """
        Record Map Key.
        """
        to: pulumi.Input[_builtins.str]
        """
        Record Map Value.
        """
elif False:
    RecordMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordMapArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        Record map for schema in azure monitor.
        :param pulumi.Input[_builtins.str] from_: Record Map Key.
        :param pulumi.Input[_builtins.str] to: Record Map Value.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        Record Map Key.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        Record Map Value.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RecurrenceArgsDict(TypedDict):
        """
        The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
        """
        frequency: pulumi.Input['RecurrenceFrequency']
        """
        the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
        """
        schedule: pulumi.Input['RecurrentScheduleArgsDict']
        """
        the scheduling constraints for when the profile begins.
        """
elif False:
    RecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecurrenceArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input['RecurrenceFrequency'],
                 schedule: pulumi.Input['RecurrentScheduleArgs']):
        """
        The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
        :param pulumi.Input['RecurrenceFrequency'] frequency: the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
        :param pulumi.Input['RecurrentScheduleArgs'] schedule: the scheduling constraints for when the profile begins.
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> pulumi.Input['RecurrenceFrequency']:
        """
        the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input['RecurrenceFrequency']):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['RecurrentScheduleArgs']:
        """
        the scheduling constraints for when the profile begins.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['RecurrentScheduleArgs']):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class RecurrentScheduleArgsDict(TypedDict):
        """
        The scheduling constraints for when the profile begins.
        """
        days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
        """
        hours: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        A collection of minutes at which the profile takes effect at.
        """
        time_zone: pulumi.Input[_builtins.str]
        """
        the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
elif False:
    RecurrentScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecurrentScheduleArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 hours: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 time_zone: pulumi.Input[_builtins.str]):
        """
        The scheduling constraints for when the profile begins.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] days: the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] hours: A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] minutes: A collection of minutes at which the profile takes effect at.
        :param pulumi.Input[_builtins.str] time_zone: the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        A collection of minutes at which the profile takes effect at.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        """
        the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class RelationshipPropertiesArgsDict(TypedDict):
        """
        Relationship properties
        """
        child_entity_name: pulumi.Input[_builtins.str]
        """
        Resource name of the child entity
        """
        parent_entity_name: pulumi.Input[_builtins.str]
        """
        Resource name of the parent entity
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
elif False:
    RelationshipPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RelationshipPropertiesArgs:
    def __init__(__self__, *,
                 child_entity_name: pulumi.Input[_builtins.str],
                 parent_entity_name: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Relationship properties
        :param pulumi.Input[_builtins.str] child_entity_name: Resource name of the child entity
        :param pulumi.Input[_builtins.str] parent_entity_name: Resource name of the parent entity
        :param pulumi.Input[_builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Optional set of labels (key-value pairs)
        """
        pulumi.set(__self__, "child_entity_name", child_entity_name)
        pulumi.set(__self__, "parent_entity_name", parent_entity_name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="childEntityName")
    def child_entity_name(self) -> pulumi.Input[_builtins.str]:
        """
        Resource name of the child entity
        """
        return pulumi.get(self, "child_entity_name")

    @child_entity_name.setter
    def child_entity_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "child_entity_name", value)

    @_builtins.property
    @pulumi.getter(name="parentEntityName")
    def parent_entity_name(self) -> pulumi.Input[_builtins.str]:
        """
        Resource name of the parent entity
        """
        return pulumi.get(self, "parent_entity_name")

    @parent_entity_name.setter
    def parent_entity_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parent_entity_name", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGraphQueryDiscoveryRulePropertiesArgsDict(TypedDict):
        """
        Discovery rule properties for an Azure Resource Graph query
        """
        add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]
        """
        Whether to add all recommended signals to the discovered entities.
        """
        authentication_setting: pulumi.Input[_builtins.str]
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        discover_relationships: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        discovery_rule_kind: pulumi.Input[_builtins.str]
        """
        Discovery rule relationship discovery behavior
        Expected value is 'ResourceGraphQuery'.
        """
        resource_graph_query: pulumi.Input[_builtins.str]
        """
        Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
elif False:
    ResourceGraphQueryDiscoveryRulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGraphQueryDiscoveryRulePropertiesArgs:
    def __init__(__self__, *,
                 add_recommended_signals: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']],
                 authentication_setting: pulumi.Input[_builtins.str],
                 discover_relationships: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']],
                 discovery_rule_kind: pulumi.Input[_builtins.str],
                 resource_graph_query: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Discovery rule properties for an Azure Resource Graph query
        :param pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']] add_recommended_signals: Whether to add all recommended signals to the discovered entities.
        :param pulumi.Input[_builtins.str] authentication_setting: Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        :param pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']] discover_relationships: Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        :param pulumi.Input[_builtins.str] discovery_rule_kind: Discovery rule relationship discovery behavior
               Expected value is 'ResourceGraphQuery'.
        :param pulumi.Input[_builtins.str] resource_graph_query: Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        :param pulumi.Input[_builtins.str] display_name: Display name
        """
        pulumi.set(__self__, "add_recommended_signals", add_recommended_signals)
        pulumi.set(__self__, "authentication_setting", authentication_setting)
        pulumi.set(__self__, "discover_relationships", discover_relationships)
        pulumi.set(__self__, "discovery_rule_kind", 'ResourceGraphQuery')
        pulumi.set(__self__, "resource_graph_query", resource_graph_query)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="addRecommendedSignals")
    def add_recommended_signals(self) -> pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]:
        """
        Whether to add all recommended signals to the discovered entities.
        """
        return pulumi.get(self, "add_recommended_signals")

    @add_recommended_signals.setter
    def add_recommended_signals(self, value: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRecommendedSignalsBehavior']]):
        pulumi.set(self, "add_recommended_signals", value)

    @_builtins.property
    @pulumi.getter(name="authenticationSetting")
    def authentication_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the name of the authentication setting which is used for querying Azure Resource Graph. The same authentication setting will also be assigned to any discovered entities.
        """
        return pulumi.get(self, "authentication_setting")

    @authentication_setting.setter
    def authentication_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_setting", value)

    @_builtins.property
    @pulumi.getter(name="discoverRelationships")
    def discover_relationships(self) -> pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]:
        """
        Whether to create relationships between the discovered entities based on a set of built-in rules. These relationships cannot be manually deleted.
        """
        return pulumi.get(self, "discover_relationships")

    @discover_relationships.setter
    def discover_relationships(self, value: pulumi.Input[Union[_builtins.str, 'DiscoveryRuleRelationshipDiscoveryBehavior']]):
        pulumi.set(self, "discover_relationships", value)

    @_builtins.property
    @pulumi.getter(name="discoveryRuleKind")
    def discovery_rule_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Discovery rule relationship discovery behavior
        Expected value is 'ResourceGraphQuery'.
        """
        return pulumi.get(self, "discovery_rule_kind")

    @discovery_rule_kind.setter
    def discovery_rule_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_rule_kind", value)

    @_builtins.property
    @pulumi.getter(name="resourceGraphQuery")
    def resource_graph_query(self) -> pulumi.Input[_builtins.str]:
        """
        Azure Resource Graph query text in KQL syntax. The query must return at least a column named 'id' which contains the resource ID of the discovered resources.
        """
        return pulumi.get(self, "resource_graph_query")

    @resource_graph_query.setter
    def resource_graph_query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_graph_query", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ResourceMapArgsDict(TypedDict):
        """
        Resource map for schema in azure monitor.
        """
        from_: pulumi.Input[_builtins.str]
        """
        Resource Map Key.
        """
        to: pulumi.Input[_builtins.str]
        """
        Resource Map Value.
        """
elif False:
    ResourceMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMapArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        Resource map for schema in azure monitor.
        :param pulumi.Input[_builtins.str] from_: Resource Map Key.
        :param pulumi.Input[_builtins.str] to: Resource Map Value.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Map Key.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Map Value.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class ResourceMetricSignalDefinitionPropertiesArgsDict(TypedDict):
        """
        Azure Resource Metric Signal Definition properties
        """
        aggregation_type: pulumi.Input[Union[_builtins.str, 'MetricAggregationType']]
        """
        Type of aggregation to apply to the metric
        """
        evaluation_rules: pulumi.Input['EvaluationRuleArgsDict']
        """
        Evaluation rules for the signal definition
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Name of the metric
        """
        metric_namespace: pulumi.Input[_builtins.str]
        """
        Metric namespace
        """
        signal_kind: pulumi.Input[_builtins.str]
        """
        Supported signal kinds as discriminator
        Expected value is 'AzureResourceMetric'.
        """
        time_grain: pulumi.Input[_builtins.str]
        """
        Time range of signal. ISO duration format like PT10M.
        """
        data_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        dimension: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional: Dimension to split by
        """
        dimension_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name
        """
        refresh_interval: NotRequired[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional set of labels (key-value pairs)
        """
elif False:
    ResourceMetricSignalDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMetricSignalDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 aggregation_type: pulumi.Input[Union[_builtins.str, 'MetricAggregationType']],
                 evaluation_rules: pulumi.Input['EvaluationRuleArgs'],
                 metric_name: pulumi.Input[_builtins.str],
                 metric_namespace: pulumi.Input[_builtins.str],
                 signal_kind: pulumi.Input[_builtins.str],
                 time_grain: pulumi.Input[_builtins.str],
                 data_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_interval: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Azure Resource Metric Signal Definition properties
        :param pulumi.Input[Union[_builtins.str, 'MetricAggregationType']] aggregation_type: Type of aggregation to apply to the metric
        :param pulumi.Input['EvaluationRuleArgs'] evaluation_rules: Evaluation rules for the signal definition
        :param pulumi.Input[_builtins.str] metric_name: Name of the metric
        :param pulumi.Input[_builtins.str] metric_namespace: Metric namespace
        :param pulumi.Input[_builtins.str] signal_kind: Supported signal kinds as discriminator
               Expected value is 'AzureResourceMetric'.
        :param pulumi.Input[_builtins.str] time_grain: Time range of signal. ISO duration format like PT10M.
        :param pulumi.Input[_builtins.str] data_unit: Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        :param pulumi.Input[_builtins.str] dimension: Optional: Dimension to split by
        :param pulumi.Input[_builtins.str] dimension_filter: Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        :param pulumi.Input[_builtins.str] display_name: Display name
        :param pulumi.Input[Union[_builtins.str, 'RefreshInterval']] refresh_interval: Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Optional set of labels (key-value pairs)
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "evaluation_rules", evaluation_rules)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "signal_kind", 'AzureResourceMetric')
        pulumi.set(__self__, "time_grain", time_grain)
        if data_unit is not None:
            pulumi.set(__self__, "data_unit", data_unit)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if refresh_interval is None:
            refresh_interval = 'PT1M'
        if refresh_interval is not None:
            pulumi.set(__self__, "refresh_interval", refresh_interval)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[Union[_builtins.str, 'MetricAggregationType']]:
        """
        Type of aggregation to apply to the metric
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[Union[_builtins.str, 'MetricAggregationType']]):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="evaluationRules")
    def evaluation_rules(self) -> pulumi.Input['EvaluationRuleArgs']:
        """
        Evaluation rules for the signal definition
        """
        return pulumi.get(self, "evaluation_rules")

    @evaluation_rules.setter
    def evaluation_rules(self, value: pulumi.Input['EvaluationRuleArgs']):
        pulumi.set(self, "evaluation_rules", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the metric
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Metric namespace
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="signalKind")
    def signal_kind(self) -> pulumi.Input[_builtins.str]:
        """
        Supported signal kinds as discriminator
        Expected value is 'AzureResourceMetric'.
        """
        return pulumi.get(self, "signal_kind")

    @signal_kind.setter
    def signal_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signal_kind", value)

    @_builtins.property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> pulumi.Input[_builtins.str]:
        """
        Time range of signal. ISO duration format like PT10M.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_grain", value)

    @_builtins.property
    @pulumi.getter(name="dataUnit")
    def data_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit of the signal result (e.g. Bytes, MilliSeconds, Percent, Count))
        """
        return pulumi.get(self, "data_unit")

    @data_unit.setter
    def data_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_unit", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional: Dimension to split by
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional: Dimension filter to apply to the dimension. Must only be set if also Dimension is set.
        """
        return pulumi.get(self, "dimension_filter")

    @dimension_filter.setter
    def dimension_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension_filter", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]:
        """
        Interval in which the signal is being evaluated. Defaults to PT1M (1 minute).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: Optional[pulumi.Input[Union[_builtins.str, 'RefreshInterval']]]):
        pulumi.set(self, "refresh_interval", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional set of labels (key-value pairs)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class RetentionPolicyArgsDict(TypedDict):
        """
        Specifies the retention policy for the log.
        """
        days: pulumi.Input[_builtins.int]
        """
        the number of days for the retention in days. A value of 0 will retain the events indefinitely.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        a value indicating whether the retention policy is enabled.
        """
elif False:
    RetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetentionPolicyArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[_builtins.int],
                 enabled: pulumi.Input[_builtins.bool]):
        """
        Specifies the retention policy for the log.
        :param pulumi.Input[_builtins.int] days: the number of days for the retention in days. A value of 0 will retain the events indefinitely.
        :param pulumi.Input[_builtins.bool] enabled: a value indicating whether the retention policy is enabled.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[_builtins.int]:
        """
        the number of days for the retention in days. A value of 0 will retain the events indefinitely.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        a value indicating whether the retention policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class RuleResolveConfigurationArgsDict(TypedDict):
        """
        TBD. Relevant only for rules of the kind LogAlert.
        """
        auto_resolved: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The flag that indicates whether or not to auto resolve a fired alert.
        """
        time_to_resolve: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration a rule must evaluate as healthy before the fired alert is automatically resolved represented in ISO 8601 duration format.
        """
elif False:
    RuleResolveConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleResolveConfigurationArgs:
    def __init__(__self__, *,
                 auto_resolved: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_to_resolve: Optional[pulumi.Input[_builtins.str]] = None):
        """
        TBD. Relevant only for rules of the kind LogAlert.
        :param pulumi.Input[_builtins.bool] auto_resolved: The flag that indicates whether or not to auto resolve a fired alert.
        :param pulumi.Input[_builtins.str] time_to_resolve: The duration a rule must evaluate as healthy before the fired alert is automatically resolved represented in ISO 8601 duration format.
        """
        if auto_resolved is not None:
            pulumi.set(__self__, "auto_resolved", auto_resolved)
        if time_to_resolve is not None:
            pulumi.set(__self__, "time_to_resolve", time_to_resolve)

    @_builtins.property
    @pulumi.getter(name="autoResolved")
    def auto_resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The flag that indicates whether or not to auto resolve a fired alert.
        """
        return pulumi.get(self, "auto_resolved")

    @auto_resolved.setter
    def auto_resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_resolved", value)

    @_builtins.property
    @pulumi.getter(name="timeToResolve")
    def time_to_resolve(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration a rule must evaluate as healthy before the fired alert is automatically resolved represented in ISO 8601 duration format.
        """
        return pulumi.get(self, "time_to_resolve")

    @time_to_resolve.setter
    def time_to_resolve(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_to_resolve", value)


if not MYPY:
    class ScaleActionArgsDict(TypedDict):
        """
        The parameters for the scaling action.
        """
        cooldown: pulumi.Input[_builtins.str]
        """
        the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
        """
        direction: pulumi.Input['ScaleDirection']
        """
        the scale direction. Whether the scaling action increases or decreases the number of instances.
        """
        type: pulumi.Input['ScaleType']
        """
        the type of action that should occur when the scale rule fires.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
        """
elif False:
    ScaleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleActionArgs:
    def __init__(__self__, *,
                 cooldown: pulumi.Input[_builtins.str],
                 direction: pulumi.Input['ScaleDirection'],
                 type: pulumi.Input['ScaleType'],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The parameters for the scaling action.
        :param pulumi.Input[_builtins.str] cooldown: the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
        :param pulumi.Input['ScaleDirection'] direction: the scale direction. Whether the scaling action increases or decreases the number of instances.
        :param pulumi.Input['ScaleType'] type: the type of action that should occur when the scale rule fires.
        :param pulumi.Input[_builtins.str] value: the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
        """
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "type", type)
        if value is None:
            value = '1'
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> pulumi.Input[_builtins.str]:
        """
        the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cooldown", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> pulumi.Input['ScaleDirection']:
        """
        the scale direction. Whether the scaling action increases or decreases the number of instances.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input['ScaleDirection']):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ScaleType']:
        """
        the type of action that should occur when the scale rule fires.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ScaleType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScaleCapacityArgsDict(TypedDict):
        """
        The number of instances that can be used during this profile.
        """
        default: pulumi.Input[_builtins.str]
        """
        the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
        """
        maximum: pulumi.Input[_builtins.str]
        """
        the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
        """
        minimum: pulumi.Input[_builtins.str]
        """
        the minimum number of instances for the resource.
        """
elif False:
    ScaleCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleCapacityArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[_builtins.str],
                 maximum: pulumi.Input[_builtins.str],
                 minimum: pulumi.Input[_builtins.str]):
        """
        The number of instances that can be used during this profile.
        :param pulumi.Input[_builtins.str] default: the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
        :param pulumi.Input[_builtins.str] maximum: the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
        :param pulumi.Input[_builtins.str] minimum: the minimum number of instances for the resource.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def default(self) -> pulumi.Input[_builtins.str]:
        """
        the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> pulumi.Input[_builtins.str]:
        """
        the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> pulumi.Input[_builtins.str]:
        """
        the minimum number of instances for the resource.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ScaleRuleMetricDimensionArgsDict(TypedDict):
        """
        Specifies an auto scale rule metric dimension.
        """
        dimension_name: pulumi.Input[_builtins.str]
        """
        Name of the dimension.
        """
        operator: pulumi.Input[Union[_builtins.str, 'ScaleRuleMetricDimensionOperationType']]
        """
        the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        list of dimension values. For example: ["App1","App2"].
        """
elif False:
    ScaleRuleMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleMetricDimensionArgs:
    def __init__(__self__, *,
                 dimension_name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[Union[_builtins.str, 'ScaleRuleMetricDimensionOperationType']],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Specifies an auto scale rule metric dimension.
        :param pulumi.Input[_builtins.str] dimension_name: Name of the dimension.
        :param pulumi.Input[Union[_builtins.str, 'ScaleRuleMetricDimensionOperationType']] operator: the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: list of dimension values. For example: ["App1","App2"].
        """
        pulumi.set(__self__, "dimension_name", dimension_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dimension_name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'ScaleRuleMetricDimensionOperationType']]:
        """
        the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'ScaleRuleMetricDimensionOperationType']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        list of dimension values. For example: ["App1","App2"].
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ScaleRuleArgsDict(TypedDict):
        """
        A rule that provide the triggers and parameters for the scaling action.
        """
        metric_trigger: pulumi.Input['MetricTriggerArgsDict']
        """
        the trigger that results in a scaling action.
        """
        scale_action: pulumi.Input['ScaleActionArgsDict']
        """
        the parameters for the scaling action.
        """
elif False:
    ScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleArgs:
    def __init__(__self__, *,
                 metric_trigger: pulumi.Input['MetricTriggerArgs'],
                 scale_action: pulumi.Input['ScaleActionArgs']):
        """
        A rule that provide the triggers and parameters for the scaling action.
        :param pulumi.Input['MetricTriggerArgs'] metric_trigger: the trigger that results in a scaling action.
        :param pulumi.Input['ScaleActionArgs'] scale_action: the parameters for the scaling action.
        """
        pulumi.set(__self__, "metric_trigger", metric_trigger)
        pulumi.set(__self__, "scale_action", scale_action)

    @_builtins.property
    @pulumi.getter(name="metricTrigger")
    def metric_trigger(self) -> pulumi.Input['MetricTriggerArgs']:
        """
        the trigger that results in a scaling action.
        """
        return pulumi.get(self, "metric_trigger")

    @metric_trigger.setter
    def metric_trigger(self, value: pulumi.Input['MetricTriggerArgs']):
        pulumi.set(self, "metric_trigger", value)

    @_builtins.property
    @pulumi.getter(name="scaleAction")
    def scale_action(self) -> pulumi.Input['ScaleActionArgs']:
        """
        the parameters for the scaling action.
        """
        return pulumi.get(self, "scale_action")

    @scale_action.setter
    def scale_action(self, value: pulumi.Input['ScaleActionArgs']):
        pulumi.set(self, "scale_action", value)


if not MYPY:
    class ScheduledQueryRuleCriteriaArgsDict(TypedDict):
        """
        The rule criteria that defines the conditions of the scheduled query rule.
        """
        all_of: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConditionArgsDict']]]]
        """
        A list of conditions to evaluate against the specified scopes
        """
elif False:
    ScheduledQueryRuleCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRuleCriteriaArgs:
    def __init__(__self__, *,
                 all_of: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]] = None):
        """
        The rule criteria that defines the conditions of the scheduled query rule.
        :param pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]] all_of: A list of conditions to evaluate against the specified scopes
        """
        if all_of is not None:
            pulumi.set(__self__, "all_of", all_of)

    @_builtins.property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]]:
        """
        A list of conditions to evaluate against the specified scopes
        """
        return pulumi.get(self, "all_of")

    @all_of.setter
    def all_of(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]]):
        pulumi.set(self, "all_of", value)


if not MYPY:
    class SchemaMapArgsDict(TypedDict):
        """
        Schema map for azure monitor for logs.
        """
        record_map: pulumi.Input[Sequence[pulumi.Input['RecordMapArgsDict']]]
        """
        Record Map.
        """
        resource_map: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceMapArgsDict']]]]
        """
        Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.
        """
        scope_map: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScopeMapArgsDict']]]]
        """
        A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
        """
elif False:
    SchemaMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaMapArgs:
    def __init__(__self__, *,
                 record_map: pulumi.Input[Sequence[pulumi.Input['RecordMapArgs']]],
                 resource_map: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceMapArgs']]]] = None,
                 scope_map: Optional[pulumi.Input[Sequence[pulumi.Input['ScopeMapArgs']]]] = None):
        """
        Schema map for azure monitor for logs.
        :param pulumi.Input[Sequence[pulumi.Input['RecordMapArgs']]] record_map: Record Map.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceMapArgs']]] resource_map: Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.
        :param pulumi.Input[Sequence[pulumi.Input['ScopeMapArgs']]] scope_map: A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
        """
        pulumi.set(__self__, "record_map", record_map)
        if resource_map is not None:
            pulumi.set(__self__, "resource_map", resource_map)
        if scope_map is not None:
            pulumi.set(__self__, "scope_map", scope_map)

    @_builtins.property
    @pulumi.getter(name="recordMap")
    def record_map(self) -> pulumi.Input[Sequence[pulumi.Input['RecordMapArgs']]]:
        """
        Record Map.
        """
        return pulumi.get(self, "record_map")

    @record_map.setter
    def record_map(self, value: pulumi.Input[Sequence[pulumi.Input['RecordMapArgs']]]):
        pulumi.set(self, "record_map", value)

    @_builtins.property
    @pulumi.getter(name="resourceMap")
    def resource_map(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceMapArgs']]]]:
        """
        Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.
        """
        return pulumi.get(self, "resource_map")

    @resource_map.setter
    def resource_map(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceMapArgs']]]]):
        pulumi.set(self, "resource_map", value)

    @_builtins.property
    @pulumi.getter(name="scopeMap")
    def scope_map(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScopeMapArgs']]]]:
        """
        A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
        """
        return pulumi.get(self, "scope_map")

    @scope_map.setter
    def scope_map(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScopeMapArgs']]]]):
        pulumi.set(self, "scope_map", value)


if not MYPY:
    class ScopeMapArgsDict(TypedDict):
        """
        Scope map for schema in azure monitor.
        """
        from_: pulumi.Input[_builtins.str]
        """
        Scope Map Key.
        """
        to: pulumi.Input[_builtins.str]
        """
        Scope Map Value.
        """
elif False:
    ScopeMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeMapArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        Scope map for schema in azure monitor.
        :param pulumi.Input[_builtins.str] from_: Scope Map Key.
        :param pulumi.Input[_builtins.str] to: Scope Map Value.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        Scope Map Key.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        Scope Map Value.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class ServiceArgsDict(TypedDict):
        """
        Service Info.
        """
        pipelines: pulumi.Input[Sequence[pulumi.Input['PipelineArgsDict']]]
        """
        Pipelines belonging to a given pipeline group.
        """
        persistence: NotRequired[pulumi.Input['PersistenceConfigurationsArgsDict']]
        """
        Persistence options to all pipelines in the instance.
        """
elif False:
    ServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceArgs:
    def __init__(__self__, *,
                 pipelines: pulumi.Input[Sequence[pulumi.Input['PipelineArgs']]],
                 persistence: Optional[pulumi.Input['PersistenceConfigurationsArgs']] = None):
        """
        Service Info.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineArgs']]] pipelines: Pipelines belonging to a given pipeline group.
        :param pulumi.Input['PersistenceConfigurationsArgs'] persistence: Persistence options to all pipelines in the instance.
        """
        pulumi.set(__self__, "pipelines", pipelines)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)

    @_builtins.property
    @pulumi.getter
    def pipelines(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineArgs']]]:
        """
        Pipelines belonging to a given pipeline group.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineArgs']]]):
        pulumi.set(self, "pipelines", value)

    @_builtins.property
    @pulumi.getter
    def persistence(self) -> Optional[pulumi.Input['PersistenceConfigurationsArgs']]:
        """
        Persistence options to all pipelines in the instance.
        """
        return pulumi.get(self, "persistence")

    @persistence.setter
    def persistence(self, value: Optional[pulumi.Input['PersistenceConfigurationsArgs']]):
        pulumi.set(self, "persistence", value)


if not MYPY:
    class SignalAssignmentArgsDict(TypedDict):
        """
        Group of signal definition assignments
        """
        signal_definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
elif False:
    SignalAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SignalAssignmentArgs:
    def __init__(__self__, *,
                 signal_definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Group of signal definition assignments
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] signal_definitions: Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        pulumi.set(__self__, "signal_definitions", signal_definitions)

    @_builtins.property
    @pulumi.getter(name="signalDefinitions")
    def signal_definitions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Signal definitions referenced by their names. All definitions are combined with an AND operator.
        """
        return pulumi.get(self, "signal_definitions")

    @signal_definitions.setter
    def signal_definitions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "signal_definitions", value)


if not MYPY:
    class SignalGroupArgsDict(TypedDict):
        """
        Contains various signal groups that can be assigned to an entity
        """
        azure_log_analytics: NotRequired[pulumi.Input['LogAnalyticsSignalGroupArgsDict']]
        """
        Log Analytics Signal Group
        """
        azure_monitor_workspace: NotRequired[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgsDict']]
        """
        Azure Monitor Workspace Signal Group
        """
        azure_resource: NotRequired[pulumi.Input['AzureResourceSignalGroupArgsDict']]
        """
        Azure Resource Signal Group
        """
        dependencies: NotRequired[pulumi.Input['DependenciesSignalGroupArgsDict']]
        """
        Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
elif False:
    SignalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SignalGroupArgs:
    def __init__(__self__, *,
                 azure_log_analytics: Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']] = None,
                 azure_monitor_workspace: Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']] = None,
                 azure_resource: Optional[pulumi.Input['AzureResourceSignalGroupArgs']] = None,
                 dependencies: Optional[pulumi.Input['DependenciesSignalGroupArgs']] = None):
        """
        Contains various signal groups that can be assigned to an entity
        :param pulumi.Input['LogAnalyticsSignalGroupArgs'] azure_log_analytics: Log Analytics Signal Group
        :param pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs'] azure_monitor_workspace: Azure Monitor Workspace Signal Group
        :param pulumi.Input['AzureResourceSignalGroupArgs'] azure_resource: Azure Resource Signal Group
        :param pulumi.Input['DependenciesSignalGroupArgs'] dependencies: Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        if azure_log_analytics is not None:
            pulumi.set(__self__, "azure_log_analytics", azure_log_analytics)
        if azure_monitor_workspace is not None:
            pulumi.set(__self__, "azure_monitor_workspace", azure_monitor_workspace)
        if azure_resource is not None:
            pulumi.set(__self__, "azure_resource", azure_resource)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter(name="azureLogAnalytics")
    def azure_log_analytics(self) -> Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']]:
        """
        Log Analytics Signal Group
        """
        return pulumi.get(self, "azure_log_analytics")

    @azure_log_analytics.setter
    def azure_log_analytics(self, value: Optional[pulumi.Input['LogAnalyticsSignalGroupArgs']]):
        pulumi.set(self, "azure_log_analytics", value)

    @_builtins.property
    @pulumi.getter(name="azureMonitorWorkspace")
    def azure_monitor_workspace(self) -> Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']]:
        """
        Azure Monitor Workspace Signal Group
        """
        return pulumi.get(self, "azure_monitor_workspace")

    @azure_monitor_workspace.setter
    def azure_monitor_workspace(self, value: Optional[pulumi.Input['AzureMonitorWorkspaceSignalGroupArgs']]):
        pulumi.set(self, "azure_monitor_workspace", value)

    @_builtins.property
    @pulumi.getter(name="azureResource")
    def azure_resource(self) -> Optional[pulumi.Input['AzureResourceSignalGroupArgs']]:
        """
        Azure Resource Signal Group
        """
        return pulumi.get(self, "azure_resource")

    @azure_resource.setter
    def azure_resource(self, value: Optional[pulumi.Input['AzureResourceSignalGroupArgs']]):
        pulumi.set(self, "azure_resource", value)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input['DependenciesSignalGroupArgs']]:
        """
        Settings for dependency signals to control how the health state of child entities influences the health state of the parent entity.
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input['DependenciesSignalGroupArgs']]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class SmsReceiverArgsDict(TypedDict):
        """
        An SMS receiver.
        """
        country_code: pulumi.Input[_builtins.str]
        """
        The country code of the SMS receiver.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the SMS receiver. Names must be unique across all receivers within a tenant action group.
        """
        phone_number: pulumi.Input[_builtins.str]
        """
        The phone number of the SMS receiver.
        """
elif False:
    SmsReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmsReceiverArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 phone_number: pulumi.Input[_builtins.str]):
        """
        An SMS receiver.
        :param pulumi.Input[_builtins.str] country_code: The country code of the SMS receiver.
        :param pulumi.Input[_builtins.str] name: The name of the SMS receiver. Names must be unique across all receivers within a tenant action group.
        :param pulumi.Input[_builtins.str] phone_number: The phone number of the SMS receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code of the SMS receiver.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SMS receiver. Names must be unique across all receivers within a tenant action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        The phone number of the SMS receiver.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class StorageBlobDestinationArgsDict(TypedDict):
        container_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The container name of the Storage Blob.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        storage_account_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the storage account.
        """
elif False:
    StorageBlobDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBlobDestinationArgs:
    def __init__(__self__, *,
                 container_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container_name: The container name of the Storage Blob.
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[_builtins.str] storage_account_resource_id: The resource ID of the storage account.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The container name of the Storage Blob.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_account_resource_id", value)


if not MYPY:
    class StorageTableDestinationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        storage_account_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the storage account.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Storage Table.
        """
elif False:
    StorageTableDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageTableDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[_builtins.str] storage_account_resource_id: The resource ID of the storage account.
        :param pulumi.Input[_builtins.str] table_name: The name of the Storage Table.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_account_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Storage Table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class StreamDeclarationArgsDict(TypedDict):
        """
        Declaration of a custom stream.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgsDict']]]]
        """
        List of columns used by data in this stream.
        """
elif False:
    StreamDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDeclarationArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]] = None):
        """
        Declaration of a custom stream.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]] columns: List of columns used by data in this stream.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]]:
        """
        List of columns used by data in this stream.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class SubscriptionLogSettingsArgsDict(TypedDict):
        """
        Part of Subscription diagnostic setting. Specifies the settings for a particular log.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        a value indicating whether this log is enabled.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Subscription Diagnostic Log category for a resource type this setting is applied to.
        """
        category_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Subscription Diagnostic Log category group for a resource type this setting is applied to.
        """
elif False:
    SubscriptionLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionLogSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 category_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Part of Subscription diagnostic setting. Specifies the settings for a particular log.
        :param pulumi.Input[_builtins.bool] enabled: a value indicating whether this log is enabled.
        :param pulumi.Input[_builtins.str] category: Name of a Subscription Diagnostic Log category for a resource type this setting is applied to.
        :param pulumi.Input[_builtins.str] category_group: Name of a Subscription Diagnostic Log category group for a resource type this setting is applied to.
        """
        pulumi.set(__self__, "enabled", enabled)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if category_group is not None:
            pulumi.set(__self__, "category_group", category_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        a value indicating whether this log is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Subscription Diagnostic Log category for a resource type this setting is applied to.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="categoryGroup")
    def category_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Subscription Diagnostic Log category group for a resource type this setting is applied to.
        """
        return pulumi.get(self, "category_group")

    @category_group.setter
    def category_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category_group", value)


if not MYPY:
    class SyslogDataSourceArgsDict(TypedDict):
        """
        Definition of which syslog data will be collected and how it will be collected.
        Only collected from Linux machines.
        """
        facility_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceFacilityNames']]]]]
        """
        The list of facility names.
        """
        log_levels: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceLogLevels']]]]]
        """
        The log levels to collect.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
elif False:
    SyslogDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogDataSourceArgs:
    def __init__(__self__, *,
                 facility_names: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceFacilityNames']]]]] = None,
                 log_levels: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceLogLevels']]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceStreams']]]]] = None):
        """
        Definition of which syslog data will be collected and how it will be collected.
        Only collected from Linux machines.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceFacilityNames']]]] facility_names: The list of facility names.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceLogLevels']]]] log_levels: The log levels to collect.
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        if facility_names is not None:
            pulumi.set(__self__, "facility_names", facility_names)
        if log_levels is not None:
            pulumi.set(__self__, "log_levels", log_levels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @_builtins.property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceFacilityNames']]]]]:
        """
        The list of facility names.
        """
        return pulumi.get(self, "facility_names")

    @facility_names.setter
    def facility_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceFacilityNames']]]]]):
        pulumi.set(self, "facility_names", value)

    @_builtins.property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceLogLevels']]]]]:
        """
        The log levels to collect.
        """
        return pulumi.get(self, "log_levels")

    @log_levels.setter
    def log_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceLogLevels']]]]]):
        pulumi.set(self, "log_levels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownSyslogDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class SyslogReceiverArgsDict(TypedDict):
        """
        Base receiver using TCP as transport protocol.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Syslog receiver endpoint definition. Example: 0.0.0.0:<port>.
        """
        protocol: NotRequired[pulumi.Input[Union[_builtins.str, 'SyslogProtocol']]]
        """
        Protocol to parse syslog messages. Default rfc3164
        """
elif False:
    SyslogReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogReceiverArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 protocol: Optional[pulumi.Input[Union[_builtins.str, 'SyslogProtocol']]] = None):
        """
        Base receiver using TCP as transport protocol.
        :param pulumi.Input[_builtins.str] endpoint: Syslog receiver endpoint definition. Example: 0.0.0.0:<port>.
        :param pulumi.Input[Union[_builtins.str, 'SyslogProtocol']] protocol: Protocol to parse syslog messages. Default rfc3164
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if protocol is None:
            protocol = 'rfc3164'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Syslog receiver endpoint definition. Example: 0.0.0.0:<port>.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SyslogProtocol']]]:
        """
        Protocol to parse syslog messages. Default rfc3164
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SyslogProtocol']]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class TcpExporterArgsDict(TypedDict):
        """
        Base exporter using TCP as transport protocol.
        """
        url: pulumi.Input[_builtins.str]
        """
        TCP url to export.
        """
elif False:
    TcpExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpExporterArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str]):
        """
        Base exporter using TCP as transport protocol.
        :param pulumi.Input[_builtins.str] url: TCP url to export.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        TCP url to export.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ThresholdRuleArgsDict(TypedDict):
        """
        Threshold-based evaluation rule for a signal definition
        """
        operator: pulumi.Input[Union[_builtins.str, 'SignalOperator']]
        """
        Operator how to compare the signal value with the threshold
        """
        threshold: pulumi.Input[_builtins.str]
        """
        Threshold value
        """
elif False:
    ThresholdRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThresholdRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[_builtins.str, 'SignalOperator']],
                 threshold: pulumi.Input[_builtins.str]):
        """
        Threshold-based evaluation rule for a signal definition
        :param pulumi.Input[Union[_builtins.str, 'SignalOperator']] operator: Operator how to compare the signal value with the threshold
        :param pulumi.Input[_builtins.str] threshold: Threshold value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'SignalOperator']]:
        """
        Operator how to compare the signal value with the threshold
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'SignalOperator']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.str]:
        """
        Threshold value
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class TimeWindowArgsDict(TypedDict):
        """
        A specific date-time for the profile.
        """
        end: pulumi.Input[_builtins.str]
        """
        the end time for the profile in ISO 8601 format.
        """
        start: pulumi.Input[_builtins.str]
        """
        the start time for the profile in ISO 8601 format.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
elif False:
    TimeWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimeWindowArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[_builtins.str],
                 start: pulumi.Input[_builtins.str],
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A specific date-time for the profile.
        :param pulumi.Input[_builtins.str] end: the end time for the profile in ISO 8601 format.
        :param pulumi.Input[_builtins.str] start: the start time for the profile in ISO 8601 format.
        :param pulumi.Input[_builtins.str] time_zone: the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter
    def end(self) -> pulumi.Input[_builtins.str]:
        """
        the end time for the profile in ISO 8601 format.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> pulumi.Input[_builtins.str]:
        """
        the start time for the profile in ISO 8601 format.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class UdpReceiverArgsDict(TypedDict):
        """
        Receiver using UDP as transport protocol.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        TCP endpoint definition. Example: 0.0.0.0:<port>.
        """
        encoding: NotRequired[pulumi.Input[Union[_builtins.str, 'StreamEncodingType']]]
        """
        The encoding of the stream being received.
        """
        json_array_mapper: NotRequired[pulumi.Input['JsonArrayMapperArgsDict']]
        """
        Json array mapper - allows this udp receiver to parse a value from a given source field as a json array, match a key to each parsed value and output the key-value map to a given output field.
        """
        read_queue_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max read queue length.
        """
elif False:
    UdpReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UdpReceiverArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 encoding: Optional[pulumi.Input[Union[_builtins.str, 'StreamEncodingType']]] = None,
                 json_array_mapper: Optional[pulumi.Input['JsonArrayMapperArgs']] = None,
                 read_queue_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Receiver using UDP as transport protocol.
        :param pulumi.Input[_builtins.str] endpoint: TCP endpoint definition. Example: 0.0.0.0:<port>.
        :param pulumi.Input[Union[_builtins.str, 'StreamEncodingType']] encoding: The encoding of the stream being received.
        :param pulumi.Input['JsonArrayMapperArgs'] json_array_mapper: Json array mapper - allows this udp receiver to parse a value from a given source field as a json array, match a key to each parsed value and output the key-value map to a given output field.
        :param pulumi.Input[_builtins.int] read_queue_length: Max read queue length.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if encoding is None:
            encoding = 'nop'
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if json_array_mapper is not None:
            pulumi.set(__self__, "json_array_mapper", json_array_mapper)
        if read_queue_length is None:
            read_queue_length = 1000
        if read_queue_length is not None:
            pulumi.set(__self__, "read_queue_length", read_queue_length)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        TCP endpoint definition. Example: 0.0.0.0:<port>.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[Union[_builtins.str, 'StreamEncodingType']]]:
        """
        The encoding of the stream being received.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[Union[_builtins.str, 'StreamEncodingType']]]):
        pulumi.set(self, "encoding", value)

    @_builtins.property
    @pulumi.getter(name="jsonArrayMapper")
    def json_array_mapper(self) -> Optional[pulumi.Input['JsonArrayMapperArgs']]:
        """
        Json array mapper - allows this udp receiver to parse a value from a given source field as a json array, match a key to each parsed value and output the key-value map to a given output field.
        """
        return pulumi.get(self, "json_array_mapper")

    @json_array_mapper.setter
    def json_array_mapper(self, value: Optional[pulumi.Input['JsonArrayMapperArgs']]):
        pulumi.set(self, "json_array_mapper", value)

    @_builtins.property
    @pulumi.getter(name="readQueueLength")
    def read_queue_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max read queue length.
        """
        return pulumi.get(self, "read_queue_length")

    @read_queue_length.setter
    def read_queue_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_queue_length", value)


if not MYPY:
    class VoiceReceiverArgsDict(TypedDict):
        """
        A voice receiver.
        """
        country_code: pulumi.Input[_builtins.str]
        """
        The country code of the voice receiver.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the voice receiver. Names must be unique across all receivers within a tenant action group.
        """
        phone_number: pulumi.Input[_builtins.str]
        """
        The phone number of the voice receiver.
        """
elif False:
    VoiceReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VoiceReceiverArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 phone_number: pulumi.Input[_builtins.str]):
        """
        A voice receiver.
        :param pulumi.Input[_builtins.str] country_code: The country code of the voice receiver.
        :param pulumi.Input[_builtins.str] name: The name of the voice receiver. Names must be unique across all receivers within a tenant action group.
        :param pulumi.Input[_builtins.str] phone_number: The phone number of the voice receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code of the voice receiver.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the voice receiver. Names must be unique across all receivers within a tenant action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        The phone number of the voice receiver.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class WebhookNotificationArgsDict(TypedDict):
        """
        Webhook notification of an autoscale event.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        a property bag of settings. This value can be empty.
        """
        service_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        the service address to receive the notification.
        """
elif False:
    WebhookNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookNotificationArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 service_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Webhook notification of an autoscale event.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] properties: a property bag of settings. This value can be empty.
        :param pulumi.Input[_builtins.str] service_uri: the service address to receive the notification.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        a property bag of settings. This value can be empty.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the service address to receive the notification.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_uri", value)


if not MYPY:
    class WebhookReceiverArgsDict(TypedDict):
        """
        A webhook receiver.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the webhook receiver. Names must be unique across all receivers within a tenant action group.
        """
        service_uri: pulumi.Input[_builtins.str]
        """
        The URI where webhooks should be sent.
        """
        identifier_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the identifier uri for aad auth.
        """
        managed_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        object_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the webhook app object Id for aad auth.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the tenant id for aad auth.
        """
        use_aad_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether or not use AAD authentication.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    WebhookReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookReceiverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 service_uri: pulumi.Input[_builtins.str],
                 identifier_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 object_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_aad_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A webhook receiver.
        :param pulumi.Input[_builtins.str] name: The name of the webhook receiver. Names must be unique across all receivers within a tenant action group.
        :param pulumi.Input[_builtins.str] service_uri: The URI where webhooks should be sent.
        :param pulumi.Input[_builtins.str] identifier_uri: Indicates the identifier uri for aad auth.
        :param pulumi.Input[_builtins.str] managed_identity: The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        :param pulumi.Input[_builtins.str] object_id: Indicates the webhook app object Id for aad auth.
        :param pulumi.Input[_builtins.str] tenant_id: Indicates the tenant id for aad auth.
        :param pulumi.Input[_builtins.bool] use_aad_auth: Indicates whether or not use AAD authentication.
        :param pulumi.Input[_builtins.bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_uri", service_uri)
        if identifier_uri is not None:
            pulumi.set(__self__, "identifier_uri", identifier_uri)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if use_aad_auth is None:
            use_aad_auth = False
        if use_aad_auth is not None:
            pulumi.set(__self__, "use_aad_auth", use_aad_auth)
        if use_common_alert_schema is None:
            use_common_alert_schema = False
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the webhook receiver. Names must be unique across all receivers within a tenant action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_uri", value)

    @_builtins.property
    @pulumi.getter(name="identifierUri")
    def identifier_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the identifier uri for aad auth.
        """
        return pulumi.get(self, "identifier_uri")

    @identifier_uri.setter
    def identifier_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier_uri", value)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The principal id of the managed identity. The value can be "None", "SystemAssigned" 
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_identity", value)

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the webhook app object Id for aad auth.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the tenant id for aad auth.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="useAadAuth")
    def use_aad_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether or not use AAD authentication.
        """
        return pulumi.get(self, "use_aad_auth")

    @use_aad_auth.setter
    def use_aad_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_aad_auth", value)

    @_builtins.property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class WebtestLocationAvailabilityCriteriaArgsDict(TypedDict):
        """
        Specifies the metric alert rule criteria for a web test resource.
        """
        component_id: pulumi.Input[_builtins.str]
        """
        The Application Insights resource Id.
        """
        failed_location_count: pulumi.Input[_builtins.float]
        """
        The number of failed locations.
        """
        odata_type: pulumi.Input[_builtins.str]
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
        """
        web_test_id: pulumi.Input[_builtins.str]
        """
        The Application Insights web test Id.
        """
elif False:
    WebtestLocationAvailabilityCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebtestLocationAvailabilityCriteriaArgs:
    def __init__(__self__, *,
                 component_id: pulumi.Input[_builtins.str],
                 failed_location_count: pulumi.Input[_builtins.float],
                 odata_type: pulumi.Input[_builtins.str],
                 web_test_id: pulumi.Input[_builtins.str]):
        """
        Specifies the metric alert rule criteria for a web test resource.
        :param pulumi.Input[_builtins.str] component_id: The Application Insights resource Id.
        :param pulumi.Input[_builtins.float] failed_location_count: The number of failed locations.
        :param pulumi.Input[_builtins.str] odata_type: specifies the type of the alert criteria.
               Expected value is 'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
        :param pulumi.Input[_builtins.str] web_test_id: The Application Insights web test Id.
        """
        pulumi.set(__self__, "component_id", component_id)
        pulumi.set(__self__, "failed_location_count", failed_location_count)
        pulumi.set(__self__, "odata_type", 'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria')
        pulumi.set(__self__, "web_test_id", web_test_id)

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Application Insights resource Id.
        """
        return pulumi.get(self, "component_id")

    @component_id.setter
    def component_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "component_id", value)

    @_builtins.property
    @pulumi.getter(name="failedLocationCount")
    def failed_location_count(self) -> pulumi.Input[_builtins.float]:
        """
        The number of failed locations.
        """
        return pulumi.get(self, "failed_location_count")

    @failed_location_count.setter
    def failed_location_count(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "failed_location_count", value)

    @_builtins.property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> pulumi.Input[_builtins.str]:
        """
        specifies the type of the alert criteria.
        Expected value is 'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
        """
        return pulumi.get(self, "odata_type")

    @odata_type.setter
    def odata_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "odata_type", value)

    @_builtins.property
    @pulumi.getter(name="webTestId")
    def web_test_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Application Insights web test Id.
        """
        return pulumi.get(self, "web_test_id")

    @web_test_id.setter
    def web_test_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "web_test_id", value)


if not MYPY:
    class WindowsEventLogDataSourceArgsDict(TypedDict):
        """
        Definition of which Windows Event Log events will be collected and how they will be collected.
        Only collected from Windows machines.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownWindowsEventLogDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        x_path_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of Windows Event Log queries in XPATH format.
        """
elif False:
    WindowsEventLogDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsEventLogDataSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownWindowsEventLogDataSourceStreams']]]]] = None,
                 x_path_queries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Definition of which Windows Event Log events will be collected and how they will be collected.
        Only collected from Windows machines.
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownWindowsEventLogDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] x_path_queries: A list of Windows Event Log queries in XPATH format.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if x_path_queries is not None:
            pulumi.set(__self__, "x_path_queries", x_path_queries)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownWindowsEventLogDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'KnownWindowsEventLogDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of Windows Event Log queries in XPATH format.
        """
        return pulumi.get(self, "x_path_queries")

    @x_path_queries.setter
    def x_path_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "x_path_queries", value)


if not MYPY:
    class WindowsFirewallLogsDataSourceArgsDict(TypedDict):
        """
        Enables Firewall logs to be collected by this data collection rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Firewall logs streams
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
elif False:
    WindowsFirewallLogsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFirewallLogsDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Enables Firewall logs to be collected by this data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] streams: Firewall logs streams
        :param pulumi.Input[_builtins.str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Firewall logs streams
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "streams", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


