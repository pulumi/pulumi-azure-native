# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccessControlRecordPropertiesResponse',
    'AsymmetricEncryptedSecretResponse',
    'BackupPolicyPropertiesResponse',
    'BackupSchedulePropertiesResponse',
    'BandwidthRateSettingPropertiesResponse',
    'BandwidthScheduleResponse',
    'FailoverSetEligibilityResultResponse',
    'FailoverSetResponse',
    'FailoverTargetResponse',
    'ManagerIntrinsicSettingsResponse',
    'ManagerSkuResponse',
    'ScheduleRecurrenceResponse',
    'StorageAccountCredentialPropertiesResponse',
    'TargetEligibilityErrorMessageResponse',
    'TargetEligibilityResultResponse',
    'TimeResponse',
    'VolumeContainerFailoverMetadataResponse',
    'VolumeContainerPropertiesResponse',
    'VolumeFailoverMetadataResponse',
    'VolumePropertiesResponse',
]

@pulumi.output_type
class AccessControlRecordPropertiesResponse(dict):
    """
    The properties of access control record.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initiatorName":
            suggest = "initiator_name"
        elif key == "volumeCount":
            suggest = "volume_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlRecordPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlRecordPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlRecordPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initiator_name: str,
                 volume_count: int):
        """
        The properties of access control record.
        :param str initiator_name: The iSCSI initiator name (IQN).
        :param int volume_count: The number of volumes using the access control record.
        """
        pulumi.set(__self__, "initiator_name", initiator_name)
        pulumi.set(__self__, "volume_count", volume_count)

    @property
    @pulumi.getter(name="initiatorName")
    def initiator_name(self) -> str:
        """
        The iSCSI initiator name (IQN).
        """
        return pulumi.get(self, "initiator_name")

    @property
    @pulumi.getter(name="volumeCount")
    def volume_count(self) -> int:
        """
        The number of volumes using the access control record.
        """
        return pulumi.get(self, "volume_count")


@pulumi.output_type
class AsymmetricEncryptedSecretResponse(dict):
    """
    Represent the secrets intended for encryption with asymmetric key pair.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionCertThumbprint":
            suggest = "encryption_cert_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AsymmetricEncryptedSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: str,
                 value: str,
                 encryption_cert_thumbprint: Optional[str] = None):
        """
        Represent the secrets intended for encryption with asymmetric key pair.
        :param str encryption_algorithm: The algorithm used to encrypt "Value".
        :param str value: The value of the secret.
        :param str encryption_cert_thumbprint: Thumbprint certificate that was used to encrypt "Value". If the value in unencrypted, it will be null.
        """
        pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        pulumi.set(__self__, "value", value)
        if encryption_cert_thumbprint is not None:
            pulumi.set(__self__, "encryption_cert_thumbprint", encryption_cert_thumbprint)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> str:
        """
        The algorithm used to encrypt "Value".
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="encryptionCertThumbprint")
    def encryption_cert_thumbprint(self) -> Optional[str]:
        """
        Thumbprint certificate that was used to encrypt "Value". If the value in unencrypted, it will be null.
        """
        return pulumi.get(self, "encryption_cert_thumbprint")


@pulumi.output_type
class BackupPolicyPropertiesResponse(dict):
    """
    The properties of the backup policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupPolicyCreationType":
            suggest = "backup_policy_creation_type"
        elif key == "lastBackupTime":
            suggest = "last_backup_time"
        elif key == "nextBackupTime":
            suggest = "next_backup_time"
        elif key == "scheduledBackupStatus":
            suggest = "scheduled_backup_status"
        elif key == "schedulesCount":
            suggest = "schedules_count"
        elif key == "ssmHostName":
            suggest = "ssm_host_name"
        elif key == "volumeIds":
            suggest = "volume_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_policy_creation_type: str,
                 last_backup_time: str,
                 next_backup_time: str,
                 scheduled_backup_status: str,
                 schedules_count: float,
                 ssm_host_name: str,
                 volume_ids: Sequence[str]):
        """
        The properties of the backup policy.
        :param str backup_policy_creation_type: The backup policy creation type. Indicates whether this was created through SaaS or through StorSimple Snapshot Manager.
        :param str last_backup_time: The time of the last backup for the backup policy.
        :param str next_backup_time: The time of the next backup for the backup policy.
        :param str scheduled_backup_status: Indicates whether at least one of the schedules in the backup policy is active or not.
        :param float schedules_count: The count of schedules the backup policy contains.
        :param str ssm_host_name: If the backup policy was created by StorSimple Snapshot Manager, then this field indicates the hostname of the StorSimple Snapshot Manager.
        :param Sequence[str] volume_ids: The path IDs of the volumes which are part of the backup policy.
        """
        pulumi.set(__self__, "backup_policy_creation_type", backup_policy_creation_type)
        pulumi.set(__self__, "last_backup_time", last_backup_time)
        pulumi.set(__self__, "next_backup_time", next_backup_time)
        pulumi.set(__self__, "scheduled_backup_status", scheduled_backup_status)
        pulumi.set(__self__, "schedules_count", schedules_count)
        pulumi.set(__self__, "ssm_host_name", ssm_host_name)
        pulumi.set(__self__, "volume_ids", volume_ids)

    @property
    @pulumi.getter(name="backupPolicyCreationType")
    def backup_policy_creation_type(self) -> str:
        """
        The backup policy creation type. Indicates whether this was created through SaaS or through StorSimple Snapshot Manager.
        """
        return pulumi.get(self, "backup_policy_creation_type")

    @property
    @pulumi.getter(name="lastBackupTime")
    def last_backup_time(self) -> str:
        """
        The time of the last backup for the backup policy.
        """
        return pulumi.get(self, "last_backup_time")

    @property
    @pulumi.getter(name="nextBackupTime")
    def next_backup_time(self) -> str:
        """
        The time of the next backup for the backup policy.
        """
        return pulumi.get(self, "next_backup_time")

    @property
    @pulumi.getter(name="scheduledBackupStatus")
    def scheduled_backup_status(self) -> str:
        """
        Indicates whether at least one of the schedules in the backup policy is active or not.
        """
        return pulumi.get(self, "scheduled_backup_status")

    @property
    @pulumi.getter(name="schedulesCount")
    def schedules_count(self) -> float:
        """
        The count of schedules the backup policy contains.
        """
        return pulumi.get(self, "schedules_count")

    @property
    @pulumi.getter(name="ssmHostName")
    def ssm_host_name(self) -> str:
        """
        If the backup policy was created by StorSimple Snapshot Manager, then this field indicates the hostname of the StorSimple Snapshot Manager.
        """
        return pulumi.get(self, "ssm_host_name")

    @property
    @pulumi.getter(name="volumeIds")
    def volume_ids(self) -> Sequence[str]:
        """
        The path IDs of the volumes which are part of the backup policy.
        """
        return pulumi.get(self, "volume_ids")


@pulumi.output_type
class BackupSchedulePropertiesResponse(dict):
    """
    The properties of the backup schedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupType":
            suggest = "backup_type"
        elif key == "lastSuccessfulRun":
            suggest = "last_successful_run"
        elif key == "retentionCount":
            suggest = "retention_count"
        elif key == "scheduleRecurrence":
            suggest = "schedule_recurrence"
        elif key == "scheduleStatus":
            suggest = "schedule_status"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupSchedulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupSchedulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupSchedulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_type: str,
                 last_successful_run: str,
                 retention_count: float,
                 schedule_recurrence: 'outputs.ScheduleRecurrenceResponse',
                 schedule_status: str,
                 start_time: str):
        """
        The properties of the backup schedule.
        :param str backup_type: The type of backup which needs to be taken.
        :param str last_successful_run: The last successful backup run which was triggered for the schedule.
        :param float retention_count: The number of backups to be retained.
        :param 'ScheduleRecurrenceResponse' schedule_recurrence: The schedule recurrence.
        :param str schedule_status: The schedule status.
        :param str start_time: The start time of the schedule.
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "last_successful_run", last_successful_run)
        pulumi.set(__self__, "retention_count", retention_count)
        pulumi.set(__self__, "schedule_recurrence", schedule_recurrence)
        pulumi.set(__self__, "schedule_status", schedule_status)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> str:
        """
        The type of backup which needs to be taken.
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="lastSuccessfulRun")
    def last_successful_run(self) -> str:
        """
        The last successful backup run which was triggered for the schedule.
        """
        return pulumi.get(self, "last_successful_run")

    @property
    @pulumi.getter(name="retentionCount")
    def retention_count(self) -> float:
        """
        The number of backups to be retained.
        """
        return pulumi.get(self, "retention_count")

    @property
    @pulumi.getter(name="scheduleRecurrence")
    def schedule_recurrence(self) -> 'outputs.ScheduleRecurrenceResponse':
        """
        The schedule recurrence.
        """
        return pulumi.get(self, "schedule_recurrence")

    @property
    @pulumi.getter(name="scheduleStatus")
    def schedule_status(self) -> str:
        """
        The schedule status.
        """
        return pulumi.get(self, "schedule_status")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the schedule.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class BandwidthRateSettingPropertiesResponse(dict):
    """
    The properties of the bandwidth setting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeCount":
            suggest = "volume_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BandwidthRateSettingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BandwidthRateSettingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BandwidthRateSettingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedules: Sequence['outputs.BandwidthScheduleResponse'],
                 volume_count: int):
        """
        The properties of the bandwidth setting.
        :param Sequence['BandwidthScheduleResponse'] schedules: The schedules.
        :param int volume_count: The number of volumes that uses the bandwidth setting.
        """
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "volume_count", volume_count)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.BandwidthScheduleResponse']:
        """
        The schedules.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="volumeCount")
    def volume_count(self) -> int:
        """
        The number of volumes that uses the bandwidth setting.
        """
        return pulumi.get(self, "volume_count")


@pulumi.output_type
class BandwidthScheduleResponse(dict):
    """
    The schedule for bandwidth setting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rateInMbps":
            suggest = "rate_in_mbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BandwidthScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BandwidthScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BandwidthScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[str],
                 rate_in_mbps: int,
                 start: 'outputs.TimeResponse',
                 stop: 'outputs.TimeResponse'):
        """
        The schedule for bandwidth setting.
        :param Sequence[str] days: The days of the week when this schedule is applicable.
        :param int rate_in_mbps: The rate in Mbps.
        :param 'TimeResponse' start: The start time of the schedule.
        :param 'TimeResponse' stop: The stop time of the schedule.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "rate_in_mbps", rate_in_mbps)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "stop", stop)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        The days of the week when this schedule is applicable.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="rateInMbps")
    def rate_in_mbps(self) -> int:
        """
        The rate in Mbps.
        """
        return pulumi.get(self, "rate_in_mbps")

    @property
    @pulumi.getter
    def start(self) -> 'outputs.TimeResponse':
        """
        The start time of the schedule.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def stop(self) -> 'outputs.TimeResponse':
        """
        The stop time of the schedule.
        """
        return pulumi.get(self, "stop")


@pulumi.output_type
class FailoverSetEligibilityResultResponse(dict):
    """
    The eligibility result of failover set, for failover.
    """
    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 is_eligible_for_failover: Optional[bool] = None):
        """
        The eligibility result of failover set, for failover.
        :param str error_message: The error message, if the failover set is not eligible for failover.
        :param bool is_eligible_for_failover: Represents if this failover set is eligible for failover or not.
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if is_eligible_for_failover is not None:
            pulumi.set(__self__, "is_eligible_for_failover", is_eligible_for_failover)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        The error message, if the failover set is not eligible for failover.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="isEligibleForFailover")
    def is_eligible_for_failover(self) -> Optional[bool]:
        """
        Represents if this failover set is eligible for failover or not.
        """
        return pulumi.get(self, "is_eligible_for_failover")


@pulumi.output_type
class FailoverSetResponse(dict):
    """
    The failover set on a device.
    """
    def __init__(__self__, *,
                 eligibility_result: Optional['outputs.FailoverSetEligibilityResultResponse'] = None,
                 volume_containers: Optional[Sequence['outputs.VolumeContainerFailoverMetadataResponse']] = None):
        """
        The failover set on a device.
        :param 'FailoverSetEligibilityResultResponse' eligibility_result: The eligibility result of the failover set, for failover.
        :param Sequence['VolumeContainerFailoverMetadataResponse'] volume_containers: The list of meta data of volume containers, which are part of the failover set.
        """
        if eligibility_result is not None:
            pulumi.set(__self__, "eligibility_result", eligibility_result)
        if volume_containers is not None:
            pulumi.set(__self__, "volume_containers", volume_containers)

    @property
    @pulumi.getter(name="eligibilityResult")
    def eligibility_result(self) -> Optional['outputs.FailoverSetEligibilityResultResponse']:
        """
        The eligibility result of the failover set, for failover.
        """
        return pulumi.get(self, "eligibility_result")

    @property
    @pulumi.getter(name="volumeContainers")
    def volume_containers(self) -> Optional[Sequence['outputs.VolumeContainerFailoverMetadataResponse']]:
        """
        The list of meta data of volume containers, which are part of the failover set.
        """
        return pulumi.get(self, "volume_containers")


@pulumi.output_type
class FailoverTargetResponse(dict):
    """
    Represents the eligibility of a device as a failover target device.
    """
    def __init__(__self__, *,
                 available_local_storage_in_bytes: Optional[float] = None,
                 available_tiered_storage_in_bytes: Optional[float] = None,
                 data_containers_count: Optional[int] = None,
                 device_id: Optional[str] = None,
                 device_location: Optional[str] = None,
                 device_software_version: Optional[str] = None,
                 device_status: Optional[str] = None,
                 eligibility_result: Optional['outputs.TargetEligibilityResultResponse'] = None,
                 friendly_device_software_version: Optional[str] = None,
                 model_description: Optional[str] = None,
                 volumes_count: Optional[int] = None):
        """
        Represents the eligibility of a device as a failover target device.
        :param float available_local_storage_in_bytes: The amount of free local storage available on the device in bytes.
        :param float available_tiered_storage_in_bytes: The amount of free tiered storage available for the device in bytes.
        :param int data_containers_count: The count of data containers on the device.
        :param str device_id: The path ID of the device.
        :param str device_location: The geo location (applicable only for cloud appliances) of the device.
        :param str device_software_version: The software version of the device.
        :param str device_status: The status of the device.
        :param 'TargetEligibilityResultResponse' eligibility_result: The eligibility result of the device, as a failover target device.
        :param str friendly_device_software_version: The friendly name for the current version of software on the device.
        :param str model_description: The model number of the device.
        :param int volumes_count: The count of volumes on the device.
        """
        if available_local_storage_in_bytes is not None:
            pulumi.set(__self__, "available_local_storage_in_bytes", available_local_storage_in_bytes)
        if available_tiered_storage_in_bytes is not None:
            pulumi.set(__self__, "available_tiered_storage_in_bytes", available_tiered_storage_in_bytes)
        if data_containers_count is not None:
            pulumi.set(__self__, "data_containers_count", data_containers_count)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if device_location is not None:
            pulumi.set(__self__, "device_location", device_location)
        if device_software_version is not None:
            pulumi.set(__self__, "device_software_version", device_software_version)
        if device_status is not None:
            pulumi.set(__self__, "device_status", device_status)
        if eligibility_result is not None:
            pulumi.set(__self__, "eligibility_result", eligibility_result)
        if friendly_device_software_version is not None:
            pulumi.set(__self__, "friendly_device_software_version", friendly_device_software_version)
        if model_description is not None:
            pulumi.set(__self__, "model_description", model_description)
        if volumes_count is not None:
            pulumi.set(__self__, "volumes_count", volumes_count)

    @property
    @pulumi.getter(name="availableLocalStorageInBytes")
    def available_local_storage_in_bytes(self) -> Optional[float]:
        """
        The amount of free local storage available on the device in bytes.
        """
        return pulumi.get(self, "available_local_storage_in_bytes")

    @property
    @pulumi.getter(name="availableTieredStorageInBytes")
    def available_tiered_storage_in_bytes(self) -> Optional[float]:
        """
        The amount of free tiered storage available for the device in bytes.
        """
        return pulumi.get(self, "available_tiered_storage_in_bytes")

    @property
    @pulumi.getter(name="dataContainersCount")
    def data_containers_count(self) -> Optional[int]:
        """
        The count of data containers on the device.
        """
        return pulumi.get(self, "data_containers_count")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[str]:
        """
        The path ID of the device.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="deviceLocation")
    def device_location(self) -> Optional[str]:
        """
        The geo location (applicable only for cloud appliances) of the device.
        """
        return pulumi.get(self, "device_location")

    @property
    @pulumi.getter(name="deviceSoftwareVersion")
    def device_software_version(self) -> Optional[str]:
        """
        The software version of the device.
        """
        return pulumi.get(self, "device_software_version")

    @property
    @pulumi.getter(name="deviceStatus")
    def device_status(self) -> Optional[str]:
        """
        The status of the device.
        """
        return pulumi.get(self, "device_status")

    @property
    @pulumi.getter(name="eligibilityResult")
    def eligibility_result(self) -> Optional['outputs.TargetEligibilityResultResponse']:
        """
        The eligibility result of the device, as a failover target device.
        """
        return pulumi.get(self, "eligibility_result")

    @property
    @pulumi.getter(name="friendlyDeviceSoftwareVersion")
    def friendly_device_software_version(self) -> Optional[str]:
        """
        The friendly name for the current version of software on the device.
        """
        return pulumi.get(self, "friendly_device_software_version")

    @property
    @pulumi.getter(name="modelDescription")
    def model_description(self) -> Optional[str]:
        """
        The model number of the device.
        """
        return pulumi.get(self, "model_description")

    @property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> Optional[int]:
        """
        The count of volumes on the device.
        """
        return pulumi.get(self, "volumes_count")


@pulumi.output_type
class ManagerIntrinsicSettingsResponse(dict):
    """
    Intrinsic settings which refers to the type of the StorSimple Manager.
    """
    def __init__(__self__, *,
                 type: str):
        """
        Intrinsic settings which refers to the type of the StorSimple Manager.
        :param str type: The type of StorSimple Manager.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of StorSimple Manager.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagerSkuResponse(dict):
    """
    The Sku.
    """
    def __init__(__self__, *,
                 name: str):
        """
        The Sku.
        :param str name: Refers to the sku name which should be "Standard"
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Refers to the sku name which should be "Standard"
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ScheduleRecurrenceResponse(dict):
    """
    The schedule recurrence.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "weeklyDaysList":
            suggest = "weekly_days_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_type: str,
                 recurrence_value: int,
                 weekly_days_list: Optional[Sequence[str]] = None):
        """
        The schedule recurrence.
        :param str recurrence_type: The recurrence type.
        :param int recurrence_value: The recurrence value.
        :param Sequence[str] weekly_days_list: The week days list. Applicable only for schedules of recurrence type 'weekly'.
        """
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "recurrence_value", recurrence_value)
        if weekly_days_list is not None:
            pulumi.set(__self__, "weekly_days_list", weekly_days_list)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        The recurrence type.
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> int:
        """
        The recurrence value.
        """
        return pulumi.get(self, "recurrence_value")

    @property
    @pulumi.getter(name="weeklyDaysList")
    def weekly_days_list(self) -> Optional[Sequence[str]]:
        """
        The week days list. Applicable only for schedules of recurrence type 'weekly'.
        """
        return pulumi.get(self, "weekly_days_list")


@pulumi.output_type
class StorageAccountCredentialPropertiesResponse(dict):
    """
    The storage account credential properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPoint":
            suggest = "end_point"
        elif key == "sslStatus":
            suggest = "ssl_status"
        elif key == "volumesCount":
            suggest = "volumes_count"
        elif key == "accessKey":
            suggest = "access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageAccountCredentialPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageAccountCredentialPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageAccountCredentialPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_point: str,
                 ssl_status: str,
                 volumes_count: int,
                 access_key: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None):
        """
        The storage account credential properties.
        :param str end_point: The storage endpoint
        :param str ssl_status: Signifies whether SSL needs to be enabled or not.
        :param int volumes_count: The count of volumes using this storage account credential.
        :param 'AsymmetricEncryptedSecretResponse' access_key: The details of the storage account password.
        """
        pulumi.set(__self__, "end_point", end_point)
        pulumi.set(__self__, "ssl_status", ssl_status)
        pulumi.set(__self__, "volumes_count", volumes_count)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)

    @property
    @pulumi.getter(name="endPoint")
    def end_point(self) -> str:
        """
        The storage endpoint
        """
        return pulumi.get(self, "end_point")

    @property
    @pulumi.getter(name="sslStatus")
    def ssl_status(self) -> str:
        """
        Signifies whether SSL needs to be enabled or not.
        """
        return pulumi.get(self, "ssl_status")

    @property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> int:
        """
        The count of volumes using this storage account credential.
        """
        return pulumi.get(self, "volumes_count")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional['outputs.AsymmetricEncryptedSecretResponse']:
        """
        The details of the storage account password.
        """
        return pulumi.get(self, "access_key")


@pulumi.output_type
class TargetEligibilityErrorMessageResponse(dict):
    """
    The error/warning message due to which the device is ineligible as a failover target device.
    """
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 resolution: Optional[str] = None,
                 result_code: Optional[str] = None):
        """
        The error/warning message due to which the device is ineligible as a failover target device.
        :param str message: The localized error message stating the reason why the device is not eligible as a target device.
        :param str resolution: The localized resolution message for the error.
        :param str result_code: The result code for the error, due to which the device does not qualify as a failover target device.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if result_code is not None:
            pulumi.set(__self__, "result_code", result_code)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The localized error message stating the reason why the device is not eligible as a target device.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        """
        The localized resolution message for the error.
        """
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="resultCode")
    def result_code(self) -> Optional[str]:
        """
        The result code for the error, due to which the device does not qualify as a failover target device.
        """
        return pulumi.get(self, "result_code")


@pulumi.output_type
class TargetEligibilityResultResponse(dict):
    """
    The eligibility result of device, as a failover target device.
    """
    def __init__(__self__, *,
                 eligibility_status: Optional[str] = None,
                 messages: Optional[Sequence['outputs.TargetEligibilityErrorMessageResponse']] = None):
        """
        The eligibility result of device, as a failover target device.
        :param str eligibility_status: The eligibility status of device, as a failover target device.
        :param Sequence['TargetEligibilityErrorMessageResponse'] messages: The list of error messages, if a device does not qualify as a failover target device.
        """
        if eligibility_status is not None:
            pulumi.set(__self__, "eligibility_status", eligibility_status)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)

    @property
    @pulumi.getter(name="eligibilityStatus")
    def eligibility_status(self) -> Optional[str]:
        """
        The eligibility status of device, as a failover target device.
        """
        return pulumi.get(self, "eligibility_status")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.TargetEligibilityErrorMessageResponse']]:
        """
        The list of error messages, if a device does not qualify as a failover target device.
        """
        return pulumi.get(self, "messages")


@pulumi.output_type
class TimeResponse(dict):
    """
    The time.
    """
    def __init__(__self__, *,
                 hours: int,
                 minutes: int,
                 seconds: int):
        """
        The time.
        :param int hours: The hour.
        :param int minutes: The minute.
        :param int seconds: The second.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        The hour.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        The minute.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        The second.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class VolumeContainerFailoverMetadataResponse(dict):
    """
    The metadata of the volume container, that is being considered as part of a failover set.
    """
    def __init__(__self__, *,
                 volume_container_id: Optional[str] = None,
                 volumes: Optional[Sequence['outputs.VolumeFailoverMetadataResponse']] = None):
        """
        The metadata of the volume container, that is being considered as part of a failover set.
        :param str volume_container_id: The path ID of the volume container.
        :param Sequence['VolumeFailoverMetadataResponse'] volumes: The list of metadata of volumes inside the volume container, which contains valid cloud snapshots.
        """
        if volume_container_id is not None:
            pulumi.set(__self__, "volume_container_id", volume_container_id)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="volumeContainerId")
    def volume_container_id(self) -> Optional[str]:
        """
        The path ID of the volume container.
        """
        return pulumi.get(self, "volume_container_id")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeFailoverMetadataResponse']]:
        """
        The list of metadata of volumes inside the volume container, which contains valid cloud snapshots.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class VolumeContainerPropertiesResponse(dict):
    """
    The properties of volume container.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionStatus":
            suggest = "encryption_status"
        elif key == "ownerShipStatus":
            suggest = "owner_ship_status"
        elif key == "storageAccountCredentialId":
            suggest = "storage_account_credential_id"
        elif key == "totalCloudStorageUsageInBytes":
            suggest = "total_cloud_storage_usage_in_bytes"
        elif key == "volumeCount":
            suggest = "volume_count"
        elif key == "bandWidthRateInMbps":
            suggest = "band_width_rate_in_mbps"
        elif key == "bandwidthSettingId":
            suggest = "bandwidth_setting_id"
        elif key == "encryptionKey":
            suggest = "encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeContainerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeContainerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeContainerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_status: str,
                 owner_ship_status: str,
                 storage_account_credential_id: str,
                 total_cloud_storage_usage_in_bytes: float,
                 volume_count: int,
                 band_width_rate_in_mbps: Optional[int] = None,
                 bandwidth_setting_id: Optional[str] = None,
                 encryption_key: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None):
        """
        The properties of volume container.
        :param str encryption_status: The flag to denote whether encryption is enabled or not.
        :param str owner_ship_status: The owner ship status of the volume container. Only when the status is "NotOwned", the delete operation on the volume container is permitted.
        :param str storage_account_credential_id: The path ID of storage account associated with the volume container.
        :param float total_cloud_storage_usage_in_bytes: The total cloud storage for the volume container.
        :param int volume_count: The number of volumes in the volume Container.
        :param int band_width_rate_in_mbps: The bandwidth-rate set on the volume container.
        :param str bandwidth_setting_id: The ID of the bandwidth setting associated with the volume container.
        :param 'AsymmetricEncryptedSecretResponse' encryption_key: The key used to encrypt data in the volume container. It is required when property 'EncryptionStatus' is "Enabled".
        """
        pulumi.set(__self__, "encryption_status", encryption_status)
        pulumi.set(__self__, "owner_ship_status", owner_ship_status)
        pulumi.set(__self__, "storage_account_credential_id", storage_account_credential_id)
        pulumi.set(__self__, "total_cloud_storage_usage_in_bytes", total_cloud_storage_usage_in_bytes)
        pulumi.set(__self__, "volume_count", volume_count)
        if band_width_rate_in_mbps is not None:
            pulumi.set(__self__, "band_width_rate_in_mbps", band_width_rate_in_mbps)
        if bandwidth_setting_id is not None:
            pulumi.set(__self__, "bandwidth_setting_id", bandwidth_setting_id)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)

    @property
    @pulumi.getter(name="encryptionStatus")
    def encryption_status(self) -> str:
        """
        The flag to denote whether encryption is enabled or not.
        """
        return pulumi.get(self, "encryption_status")

    @property
    @pulumi.getter(name="ownerShipStatus")
    def owner_ship_status(self) -> str:
        """
        The owner ship status of the volume container. Only when the status is "NotOwned", the delete operation on the volume container is permitted.
        """
        return pulumi.get(self, "owner_ship_status")

    @property
    @pulumi.getter(name="storageAccountCredentialId")
    def storage_account_credential_id(self) -> str:
        """
        The path ID of storage account associated with the volume container.
        """
        return pulumi.get(self, "storage_account_credential_id")

    @property
    @pulumi.getter(name="totalCloudStorageUsageInBytes")
    def total_cloud_storage_usage_in_bytes(self) -> float:
        """
        The total cloud storage for the volume container.
        """
        return pulumi.get(self, "total_cloud_storage_usage_in_bytes")

    @property
    @pulumi.getter(name="volumeCount")
    def volume_count(self) -> int:
        """
        The number of volumes in the volume Container.
        """
        return pulumi.get(self, "volume_count")

    @property
    @pulumi.getter(name="bandWidthRateInMbps")
    def band_width_rate_in_mbps(self) -> Optional[int]:
        """
        The bandwidth-rate set on the volume container.
        """
        return pulumi.get(self, "band_width_rate_in_mbps")

    @property
    @pulumi.getter(name="bandwidthSettingId")
    def bandwidth_setting_id(self) -> Optional[str]:
        """
        The ID of the bandwidth setting associated with the volume container.
        """
        return pulumi.get(self, "bandwidth_setting_id")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional['outputs.AsymmetricEncryptedSecretResponse']:
        """
        The key used to encrypt data in the volume container. It is required when property 'EncryptionStatus' is "Enabled".
        """
        return pulumi.get(self, "encryption_key")


@pulumi.output_type
class VolumeFailoverMetadataResponse(dict):
    """
    The metadata of a volume that has valid cloud snapshot.
    """
    def __init__(__self__, *,
                 backup_created_date: Optional[str] = None,
                 backup_element_id: Optional[str] = None,
                 backup_id: Optional[str] = None,
                 backup_policy_id: Optional[str] = None,
                 size_in_bytes: Optional[float] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        The metadata of a volume that has valid cloud snapshot.
        :param str backup_created_date: The date at which the snapshot was taken.
        :param str backup_element_id: The path ID of the backup-element for this volume, inside the backup set.
        :param str backup_id: The path ID of the backup set.
        :param str backup_policy_id: The path ID of the backup policy using which the snapshot was taken.
        :param float size_in_bytes: The size of the volume in bytes at the time the snapshot was taken.
        :param str volume_id: The path ID of the volume.
        :param str volume_type: The type of the volume.
        """
        if backup_created_date is not None:
            pulumi.set(__self__, "backup_created_date", backup_created_date)
        if backup_element_id is not None:
            pulumi.set(__self__, "backup_element_id", backup_element_id)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_policy_id is not None:
            pulumi.set(__self__, "backup_policy_id", backup_policy_id)
        if size_in_bytes is not None:
            pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="backupCreatedDate")
    def backup_created_date(self) -> Optional[str]:
        """
        The date at which the snapshot was taken.
        """
        return pulumi.get(self, "backup_created_date")

    @property
    @pulumi.getter(name="backupElementId")
    def backup_element_id(self) -> Optional[str]:
        """
        The path ID of the backup-element for this volume, inside the backup set.
        """
        return pulumi.get(self, "backup_element_id")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        The path ID of the backup set.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[str]:
        """
        The path ID of the backup policy using which the snapshot was taken.
        """
        return pulumi.get(self, "backup_policy_id")

    @property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> Optional[float]:
        """
        The size of the volume in bytes at the time the snapshot was taken.
        """
        return pulumi.get(self, "size_in_bytes")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        The path ID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class VolumePropertiesResponse(dict):
    """
    The properties of volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessControlRecordIds":
            suggest = "access_control_record_ids"
        elif key == "backupPolicyIds":
            suggest = "backup_policy_ids"
        elif key == "backupStatus":
            suggest = "backup_status"
        elif key == "monitoringStatus":
            suggest = "monitoring_status"
        elif key == "operationStatus":
            suggest = "operation_status"
        elif key == "sizeInBytes":
            suggest = "size_in_bytes"
        elif key == "volumeContainerId":
            suggest = "volume_container_id"
        elif key == "volumeStatus":
            suggest = "volume_status"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_control_record_ids: Sequence[str],
                 backup_policy_ids: Sequence[str],
                 backup_status: str,
                 monitoring_status: str,
                 operation_status: str,
                 size_in_bytes: float,
                 volume_container_id: str,
                 volume_status: str,
                 volume_type: str):
        """
        The properties of volume.
        :param Sequence[str] access_control_record_ids: The IDs of the access control records, associated with the volume.
        :param Sequence[str] backup_policy_ids: The IDs of the backup policies, in which this volume is part of.
        :param str backup_status: The backup status of the volume.
        :param str monitoring_status: The monitoring status of the volume.
        :param str operation_status: The operation status on the volume.
        :param float size_in_bytes: The size of the volume in bytes.
        :param str volume_container_id: The ID of the volume container, in which this volume is created.
        :param str volume_status: The volume status.
        :param str volume_type: The type of the volume.
        """
        pulumi.set(__self__, "access_control_record_ids", access_control_record_ids)
        pulumi.set(__self__, "backup_policy_ids", backup_policy_ids)
        pulumi.set(__self__, "backup_status", backup_status)
        pulumi.set(__self__, "monitoring_status", monitoring_status)
        pulumi.set(__self__, "operation_status", operation_status)
        pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        pulumi.set(__self__, "volume_container_id", volume_container_id)
        pulumi.set(__self__, "volume_status", volume_status)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="accessControlRecordIds")
    def access_control_record_ids(self) -> Sequence[str]:
        """
        The IDs of the access control records, associated with the volume.
        """
        return pulumi.get(self, "access_control_record_ids")

    @property
    @pulumi.getter(name="backupPolicyIds")
    def backup_policy_ids(self) -> Sequence[str]:
        """
        The IDs of the backup policies, in which this volume is part of.
        """
        return pulumi.get(self, "backup_policy_ids")

    @property
    @pulumi.getter(name="backupStatus")
    def backup_status(self) -> str:
        """
        The backup status of the volume.
        """
        return pulumi.get(self, "backup_status")

    @property
    @pulumi.getter(name="monitoringStatus")
    def monitoring_status(self) -> str:
        """
        The monitoring status of the volume.
        """
        return pulumi.get(self, "monitoring_status")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> str:
        """
        The operation status on the volume.
        """
        return pulumi.get(self, "operation_status")

    @property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> float:
        """
        The size of the volume in bytes.
        """
        return pulumi.get(self, "size_in_bytes")

    @property
    @pulumi.getter(name="volumeContainerId")
    def volume_container_id(self) -> str:
        """
        The ID of the volume container, in which this volume is created.
        """
        return pulumi.get(self, "volume_container_id")

    @property
    @pulumi.getter(name="volumeStatus")
    def volume_status(self) -> str:
        """
        The volume status.
        """
        return pulumi.get(self, "volume_status")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        The type of the volume.
        """
        return pulumi.get(self, "volume_type")


