# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AzureMonitorAlertSettingsArgs',
    'AzureMonitorAlertSettingsArgsDict',
    'ClassicAlertSettingsArgs',
    'ClassicAlertSettingsArgsDict',
    'CmkKekIdentityArgs',
    'CmkKekIdentityArgsDict',
    'CmkKeyVaultPropertiesArgs',
    'CmkKeyVaultPropertiesArgsDict',
    'CrossSubscriptionRestoreSettingsArgs',
    'CrossSubscriptionRestoreSettingsArgsDict',
    'IdentityDataArgs',
    'IdentityDataArgsDict',
    'ImmutabilitySettingsArgs',
    'ImmutabilitySettingsArgsDict',
    'MonitoringSettingsArgs',
    'MonitoringSettingsArgsDict',
    'RestoreSettingsArgs',
    'RestoreSettingsArgsDict',
    'SecuritySettingsArgs',
    'SecuritySettingsArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'SoftDeleteSettingsArgs',
    'SoftDeleteSettingsArgsDict',
    'VaultPropertiesEncryptionArgs',
    'VaultPropertiesEncryptionArgsDict',
    'VaultPropertiesRedundancySettingsArgs',
    'VaultPropertiesRedundancySettingsArgsDict',
    'VaultPropertiesArgs',
    'VaultPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class AzureMonitorAlertSettingsArgsDict(TypedDict):
        """
        Settings for Azure Monitor based alerts
        """
        alerts_for_all_failover_issues: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
        alerts_for_all_job_failures: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
        alerts_for_all_replication_issues: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
elif False:
    AzureMonitorAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorAlertSettingsArgs:
    def __init__(__self__, *,
                 alerts_for_all_failover_issues: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None,
                 alerts_for_all_job_failures: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None,
                 alerts_for_all_replication_issues: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None):
        """
        Settings for Azure Monitor based alerts
        """
        if alerts_for_all_failover_issues is not None:
            pulumi.set(__self__, "alerts_for_all_failover_issues", alerts_for_all_failover_issues)
        if alerts_for_all_job_failures is not None:
            pulumi.set(__self__, "alerts_for_all_job_failures", alerts_for_all_job_failures)
        if alerts_for_all_replication_issues is not None:
            pulumi.set(__self__, "alerts_for_all_replication_issues", alerts_for_all_replication_issues)

    @property
    @pulumi.getter(name="alertsForAllFailoverIssues")
    def alerts_for_all_failover_issues(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "alerts_for_all_failover_issues")

    @alerts_for_all_failover_issues.setter
    def alerts_for_all_failover_issues(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "alerts_for_all_failover_issues", value)

    @property
    @pulumi.getter(name="alertsForAllJobFailures")
    def alerts_for_all_job_failures(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "alerts_for_all_job_failures")

    @alerts_for_all_job_failures.setter
    def alerts_for_all_job_failures(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "alerts_for_all_job_failures", value)

    @property
    @pulumi.getter(name="alertsForAllReplicationIssues")
    def alerts_for_all_replication_issues(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "alerts_for_all_replication_issues")

    @alerts_for_all_replication_issues.setter
    def alerts_for_all_replication_issues(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "alerts_for_all_replication_issues", value)


if not MYPY:
    class ClassicAlertSettingsArgsDict(TypedDict):
        """
        Settings for classic alerts
        """
        alerts_for_critical_operations: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
        email_notifications_for_site_recovery: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
elif False:
    ClassicAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClassicAlertSettingsArgs:
    def __init__(__self__, *,
                 alerts_for_critical_operations: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None,
                 email_notifications_for_site_recovery: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None):
        """
        Settings for classic alerts
        """
        if alerts_for_critical_operations is not None:
            pulumi.set(__self__, "alerts_for_critical_operations", alerts_for_critical_operations)
        if email_notifications_for_site_recovery is not None:
            pulumi.set(__self__, "email_notifications_for_site_recovery", email_notifications_for_site_recovery)

    @property
    @pulumi.getter(name="alertsForCriticalOperations")
    def alerts_for_critical_operations(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "alerts_for_critical_operations")

    @alerts_for_critical_operations.setter
    def alerts_for_critical_operations(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "alerts_for_critical_operations", value)

    @property
    @pulumi.getter(name="emailNotificationsForSiteRecovery")
    def email_notifications_for_site_recovery(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "email_notifications_for_site_recovery")

    @email_notifications_for_site_recovery.setter
    def email_notifications_for_site_recovery(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "email_notifications_for_site_recovery", value)


if not MYPY:
    class CmkKekIdentityArgsDict(TypedDict):
        """
        The details of the identity used for CMK
        """
        use_system_assigned_identity: NotRequired[pulumi.Input[bool]]
        """
        Indicate that system assigned identity should be used. Mutually exclusive with 'userAssignedIdentity' field
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The user assigned identity to be used to grant permissions in case the type of identity used is UserAssigned
        """
elif False:
    CmkKekIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmkKekIdentityArgs:
    def __init__(__self__, *,
                 use_system_assigned_identity: Optional[pulumi.Input[bool]] = None,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        The details of the identity used for CMK
        :param pulumi.Input[bool] use_system_assigned_identity: Indicate that system assigned identity should be used. Mutually exclusive with 'userAssignedIdentity' field
        :param pulumi.Input[str] user_assigned_identity: The user assigned identity to be used to grant permissions in case the type of identity used is UserAssigned
        """
        if use_system_assigned_identity is not None:
            pulumi.set(__self__, "use_system_assigned_identity", use_system_assigned_identity)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="useSystemAssignedIdentity")
    def use_system_assigned_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate that system assigned identity should be used. Mutually exclusive with 'userAssignedIdentity' field
        """
        return pulumi.get(self, "use_system_assigned_identity")

    @use_system_assigned_identity.setter
    def use_system_assigned_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_system_assigned_identity", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user assigned identity to be used to grant permissions in case the type of identity used is UserAssigned
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class CmkKeyVaultPropertiesArgsDict(TypedDict):
        """
        The properties of the Key Vault which hosts CMK
        """
        key_uri: NotRequired[pulumi.Input[str]]
        """
        The key uri of the Customer Managed Key
        """
elif False:
    CmkKeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmkKeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_uri: Optional[pulumi.Input[str]] = None):
        """
        The properties of the Key Vault which hosts CMK
        :param pulumi.Input[str] key_uri: The key uri of the Customer Managed Key
        """
        if key_uri is not None:
            pulumi.set(__self__, "key_uri", key_uri)

    @property
    @pulumi.getter(name="keyUri")
    def key_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The key uri of the Customer Managed Key
        """
        return pulumi.get(self, "key_uri")

    @key_uri.setter
    def key_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_uri", value)


if not MYPY:
    class CrossSubscriptionRestoreSettingsArgsDict(TypedDict):
        """
        Settings for Cross Subscription Restore Settings
        """
        cross_subscription_restore_state: NotRequired[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]
elif False:
    CrossSubscriptionRestoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrossSubscriptionRestoreSettingsArgs:
    def __init__(__self__, *,
                 cross_subscription_restore_state: Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]] = None):
        """
        Settings for Cross Subscription Restore Settings
        """
        if cross_subscription_restore_state is not None:
            pulumi.set(__self__, "cross_subscription_restore_state", cross_subscription_restore_state)

    @property
    @pulumi.getter(name="crossSubscriptionRestoreState")
    def cross_subscription_restore_state(self) -> Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]:
        return pulumi.get(self, "cross_subscription_restore_state")

    @cross_subscription_restore_state.setter
    def cross_subscription_restore_state(self, value: Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]):
        pulumi.set(self, "cross_subscription_restore_state", value)


if not MYPY:
    class IdentityDataArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: pulumi.Input[Union[str, 'ResourceIdentityType']]
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identities.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user-assigned identities associated with the resource. The user-assigned identity dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityDataArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ResourceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input[Union[str, 'ResourceIdentityType']] type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user-assigned identities associated with the resource. The user-assigned identity dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ResourceIdentityType']]:
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user-assigned identities associated with the resource. The user-assigned identity dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ImmutabilitySettingsArgsDict(TypedDict):
        """
        Immutability Settings of vault
        """
        state: NotRequired[pulumi.Input[Union[str, 'ImmutabilityState']]]
elif False:
    ImmutabilitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImmutabilitySettingsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'ImmutabilityState']]] = None):
        """
        Immutability Settings of vault
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'ImmutabilityState']]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'ImmutabilityState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MonitoringSettingsArgsDict(TypedDict):
        """
        Monitoring Settings of the vault
        """
        azure_monitor_alert_settings: NotRequired[pulumi.Input['AzureMonitorAlertSettingsArgsDict']]
        """
        Settings for Azure Monitor based alerts
        """
        classic_alert_settings: NotRequired[pulumi.Input['ClassicAlertSettingsArgsDict']]
        """
        Settings for classic alerts
        """
elif False:
    MonitoringSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringSettingsArgs:
    def __init__(__self__, *,
                 azure_monitor_alert_settings: Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']] = None,
                 classic_alert_settings: Optional[pulumi.Input['ClassicAlertSettingsArgs']] = None):
        """
        Monitoring Settings of the vault
        :param pulumi.Input['AzureMonitorAlertSettingsArgs'] azure_monitor_alert_settings: Settings for Azure Monitor based alerts
        :param pulumi.Input['ClassicAlertSettingsArgs'] classic_alert_settings: Settings for classic alerts
        """
        if azure_monitor_alert_settings is not None:
            pulumi.set(__self__, "azure_monitor_alert_settings", azure_monitor_alert_settings)
        if classic_alert_settings is not None:
            pulumi.set(__self__, "classic_alert_settings", classic_alert_settings)

    @property
    @pulumi.getter(name="azureMonitorAlertSettings")
    def azure_monitor_alert_settings(self) -> Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']]:
        """
        Settings for Azure Monitor based alerts
        """
        return pulumi.get(self, "azure_monitor_alert_settings")

    @azure_monitor_alert_settings.setter
    def azure_monitor_alert_settings(self, value: Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']]):
        pulumi.set(self, "azure_monitor_alert_settings", value)

    @property
    @pulumi.getter(name="classicAlertSettings")
    def classic_alert_settings(self) -> Optional[pulumi.Input['ClassicAlertSettingsArgs']]:
        """
        Settings for classic alerts
        """
        return pulumi.get(self, "classic_alert_settings")

    @classic_alert_settings.setter
    def classic_alert_settings(self, value: Optional[pulumi.Input['ClassicAlertSettingsArgs']]):
        pulumi.set(self, "classic_alert_settings", value)


if not MYPY:
    class RestoreSettingsArgsDict(TypedDict):
        """
        Restore Settings  of the vault
        """
        cross_subscription_restore_settings: NotRequired[pulumi.Input['CrossSubscriptionRestoreSettingsArgsDict']]
        """
        Settings for CrossSubscriptionRestore
        """
elif False:
    RestoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestoreSettingsArgs:
    def __init__(__self__, *,
                 cross_subscription_restore_settings: Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']] = None):
        """
        Restore Settings  of the vault
        :param pulumi.Input['CrossSubscriptionRestoreSettingsArgs'] cross_subscription_restore_settings: Settings for CrossSubscriptionRestore
        """
        if cross_subscription_restore_settings is not None:
            pulumi.set(__self__, "cross_subscription_restore_settings", cross_subscription_restore_settings)

    @property
    @pulumi.getter(name="crossSubscriptionRestoreSettings")
    def cross_subscription_restore_settings(self) -> Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']]:
        """
        Settings for CrossSubscriptionRestore
        """
        return pulumi.get(self, "cross_subscription_restore_settings")

    @cross_subscription_restore_settings.setter
    def cross_subscription_restore_settings(self, value: Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']]):
        pulumi.set(self, "cross_subscription_restore_settings", value)


if not MYPY:
    class SecuritySettingsArgsDict(TypedDict):
        """
        Security Settings of the vault
        """
        immutability_settings: NotRequired[pulumi.Input['ImmutabilitySettingsArgsDict']]
        """
        Immutability Settings of a vault
        """
        soft_delete_settings: NotRequired[pulumi.Input['SoftDeleteSettingsArgsDict']]
        """
        Soft delete Settings of a vault
        """
elif False:
    SecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecuritySettingsArgs:
    def __init__(__self__, *,
                 immutability_settings: Optional[pulumi.Input['ImmutabilitySettingsArgs']] = None,
                 soft_delete_settings: Optional[pulumi.Input['SoftDeleteSettingsArgs']] = None):
        """
        Security Settings of the vault
        :param pulumi.Input['ImmutabilitySettingsArgs'] immutability_settings: Immutability Settings of a vault
        :param pulumi.Input['SoftDeleteSettingsArgs'] soft_delete_settings: Soft delete Settings of a vault
        """
        if immutability_settings is not None:
            pulumi.set(__self__, "immutability_settings", immutability_settings)
        if soft_delete_settings is not None:
            pulumi.set(__self__, "soft_delete_settings", soft_delete_settings)

    @property
    @pulumi.getter(name="immutabilitySettings")
    def immutability_settings(self) -> Optional[pulumi.Input['ImmutabilitySettingsArgs']]:
        """
        Immutability Settings of a vault
        """
        return pulumi.get(self, "immutability_settings")

    @immutability_settings.setter
    def immutability_settings(self, value: Optional[pulumi.Input['ImmutabilitySettingsArgs']]):
        pulumi.set(self, "immutability_settings", value)

    @property
    @pulumi.getter(name="softDeleteSettings")
    def soft_delete_settings(self) -> Optional[pulumi.Input['SoftDeleteSettingsArgs']]:
        """
        Soft delete Settings of a vault
        """
        return pulumi.get(self, "soft_delete_settings")

    @soft_delete_settings.setter
    def soft_delete_settings(self, value: Optional[pulumi.Input['SoftDeleteSettingsArgs']]):
        pulumi.set(self, "soft_delete_settings", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        Identifies the unique system identifier for each Azure resource.
        """
        name: pulumi.Input[Union[str, 'SkuName']]
        """
        Name of SKU is RS0 (Recovery Services 0th version) and the tier is standard tier. They do not have affect on backend storage redundancy or any other vault settings. To manage storage redundancy, use the backupstorageconfig
        """
        capacity: NotRequired[pulumi.Input[str]]
        """
        The sku capacity
        """
        family: NotRequired[pulumi.Input[str]]
        """
        The sku family
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The sku size
        """
        tier: NotRequired[pulumi.Input[str]]
        """
        The Sku tier.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[str, 'SkuName']],
                 capacity: Optional[pulumi.Input[str]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        Identifies the unique system identifier for each Azure resource.
        :param pulumi.Input[Union[str, 'SkuName']] name: Name of SKU is RS0 (Recovery Services 0th version) and the tier is standard tier. They do not have affect on backend storage redundancy or any other vault settings. To manage storage redundancy, use the backupstorageconfig
        :param pulumi.Input[str] capacity: The sku capacity
        :param pulumi.Input[str] family: The sku family
        :param pulumi.Input[str] size: The sku size
        :param pulumi.Input[str] tier: The Sku tier.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'SkuName']]:
        """
        Name of SKU is RS0 (Recovery Services 0th version) and the tier is standard tier. They do not have affect on backend storage redundancy or any other vault settings. To manage storage redundancy, use the backupstorageconfig
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'SkuName']]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The sku capacity
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The sku family
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The sku size
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        The Sku tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SoftDeleteSettingsArgsDict(TypedDict):
        """
        Soft delete Settings of vault
        """
        enhanced_security_state: NotRequired[pulumi.Input[Union[str, 'EnhancedSecurityState']]]
        soft_delete_retention_period_in_days: NotRequired[pulumi.Input[int]]
        """
        Soft delete retention period in days
        """
        soft_delete_state: NotRequired[pulumi.Input[Union[str, 'SoftDeleteState']]]
elif False:
    SoftDeleteSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftDeleteSettingsArgs:
    def __init__(__self__, *,
                 enhanced_security_state: Optional[pulumi.Input[Union[str, 'EnhancedSecurityState']]] = None,
                 soft_delete_retention_period_in_days: Optional[pulumi.Input[int]] = None,
                 soft_delete_state: Optional[pulumi.Input[Union[str, 'SoftDeleteState']]] = None):
        """
        Soft delete Settings of vault
        :param pulumi.Input[int] soft_delete_retention_period_in_days: Soft delete retention period in days
        """
        if enhanced_security_state is not None:
            pulumi.set(__self__, "enhanced_security_state", enhanced_security_state)
        if soft_delete_retention_period_in_days is not None:
            pulumi.set(__self__, "soft_delete_retention_period_in_days", soft_delete_retention_period_in_days)
        if soft_delete_state is not None:
            pulumi.set(__self__, "soft_delete_state", soft_delete_state)

    @property
    @pulumi.getter(name="enhancedSecurityState")
    def enhanced_security_state(self) -> Optional[pulumi.Input[Union[str, 'EnhancedSecurityState']]]:
        return pulumi.get(self, "enhanced_security_state")

    @enhanced_security_state.setter
    def enhanced_security_state(self, value: Optional[pulumi.Input[Union[str, 'EnhancedSecurityState']]]):
        pulumi.set(self, "enhanced_security_state", value)

    @property
    @pulumi.getter(name="softDeleteRetentionPeriodInDays")
    def soft_delete_retention_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Soft delete retention period in days
        """
        return pulumi.get(self, "soft_delete_retention_period_in_days")

    @soft_delete_retention_period_in_days.setter
    def soft_delete_retention_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "soft_delete_retention_period_in_days", value)

    @property
    @pulumi.getter(name="softDeleteState")
    def soft_delete_state(self) -> Optional[pulumi.Input[Union[str, 'SoftDeleteState']]]:
        return pulumi.get(self, "soft_delete_state")

    @soft_delete_state.setter
    def soft_delete_state(self, value: Optional[pulumi.Input[Union[str, 'SoftDeleteState']]]):
        pulumi.set(self, "soft_delete_state", value)


if not MYPY:
    class VaultPropertiesEncryptionArgsDict(TypedDict):
        """
        Customer Managed Key details of the resource.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]
        """
        Enabling/Disabling the Double Encryption state
        """
        kek_identity: NotRequired[pulumi.Input['CmkKekIdentityArgsDict']]
        """
        The details of the identity used for CMK
        """
        key_vault_properties: NotRequired[pulumi.Input['CmkKeyVaultPropertiesArgsDict']]
        """
        The properties of the Key Vault which hosts CMK
        """
elif False:
    VaultPropertiesEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPropertiesEncryptionArgs:
    def __init__(__self__, *,
                 infrastructure_encryption: Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]] = None,
                 kek_identity: Optional[pulumi.Input['CmkKekIdentityArgs']] = None,
                 key_vault_properties: Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']] = None):
        """
        Customer Managed Key details of the resource.
        :param pulumi.Input[Union[str, 'InfrastructureEncryptionState']] infrastructure_encryption: Enabling/Disabling the Double Encryption state
        :param pulumi.Input['CmkKekIdentityArgs'] kek_identity: The details of the identity used for CMK
        :param pulumi.Input['CmkKeyVaultPropertiesArgs'] key_vault_properties: The properties of the Key Vault which hosts CMK
        """
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if kek_identity is not None:
            pulumi.set(__self__, "kek_identity", kek_identity)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]:
        """
        Enabling/Disabling the Double Encryption state
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="kekIdentity")
    def kek_identity(self) -> Optional[pulumi.Input['CmkKekIdentityArgs']]:
        """
        The details of the identity used for CMK
        """
        return pulumi.get(self, "kek_identity")

    @kek_identity.setter
    def kek_identity(self, value: Optional[pulumi.Input['CmkKekIdentityArgs']]):
        pulumi.set(self, "kek_identity", value)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']]:
        """
        The properties of the Key Vault which hosts CMK
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']]):
        pulumi.set(self, "key_vault_properties", value)


if not MYPY:
    class VaultPropertiesRedundancySettingsArgsDict(TypedDict):
        """
        The redundancy Settings of a Vault
        """
        cross_region_restore: NotRequired[pulumi.Input[Union[str, 'CrossRegionRestore']]]
        """
        Flag to show if Cross Region Restore is enabled on the Vault or not
        """
        standard_tier_storage_redundancy: NotRequired[pulumi.Input[Union[str, 'StandardTierStorageRedundancy']]]
        """
        The storage redundancy setting of a vault
        """
elif False:
    VaultPropertiesRedundancySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPropertiesRedundancySettingsArgs:
    def __init__(__self__, *,
                 cross_region_restore: Optional[pulumi.Input[Union[str, 'CrossRegionRestore']]] = None,
                 standard_tier_storage_redundancy: Optional[pulumi.Input[Union[str, 'StandardTierStorageRedundancy']]] = None):
        """
        The redundancy Settings of a Vault
        :param pulumi.Input[Union[str, 'CrossRegionRestore']] cross_region_restore: Flag to show if Cross Region Restore is enabled on the Vault or not
        :param pulumi.Input[Union[str, 'StandardTierStorageRedundancy']] standard_tier_storage_redundancy: The storage redundancy setting of a vault
        """
        if cross_region_restore is not None:
            pulumi.set(__self__, "cross_region_restore", cross_region_restore)
        if standard_tier_storage_redundancy is not None:
            pulumi.set(__self__, "standard_tier_storage_redundancy", standard_tier_storage_redundancy)

    @property
    @pulumi.getter(name="crossRegionRestore")
    def cross_region_restore(self) -> Optional[pulumi.Input[Union[str, 'CrossRegionRestore']]]:
        """
        Flag to show if Cross Region Restore is enabled on the Vault or not
        """
        return pulumi.get(self, "cross_region_restore")

    @cross_region_restore.setter
    def cross_region_restore(self, value: Optional[pulumi.Input[Union[str, 'CrossRegionRestore']]]):
        pulumi.set(self, "cross_region_restore", value)

    @property
    @pulumi.getter(name="standardTierStorageRedundancy")
    def standard_tier_storage_redundancy(self) -> Optional[pulumi.Input[Union[str, 'StandardTierStorageRedundancy']]]:
        """
        The storage redundancy setting of a vault
        """
        return pulumi.get(self, "standard_tier_storage_redundancy")

    @standard_tier_storage_redundancy.setter
    def standard_tier_storage_redundancy(self, value: Optional[pulumi.Input[Union[str, 'StandardTierStorageRedundancy']]]):
        pulumi.set(self, "standard_tier_storage_redundancy", value)


if not MYPY:
    class VaultPropertiesArgsDict(TypedDict):
        """
        Properties of the vault.
        """
        encryption: NotRequired[pulumi.Input['VaultPropertiesEncryptionArgsDict']]
        """
        Customer Managed Key details of the resource.
        """
        monitoring_settings: NotRequired[pulumi.Input['MonitoringSettingsArgsDict']]
        """
        Monitoring Settings of the vault
        """
        public_network_access: NotRequired[pulumi.Input[Union[str, 'PublicNetworkAccess']]]
        """
        property to enable or disable resource provider inbound network traffic from public clients
        """
        redundancy_settings: NotRequired[pulumi.Input['VaultPropertiesRedundancySettingsArgsDict']]
        """
        The redundancy Settings of a Vault
        """
        resource_guard_operation_requests: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        ResourceGuardOperationRequests on which LAC check will be performed
        """
        restore_settings: NotRequired[pulumi.Input['RestoreSettingsArgsDict']]
        """
        Restore Settings of the vault
        """
        security_settings: NotRequired[pulumi.Input['SecuritySettingsArgsDict']]
        """
        Security Settings of the vault
        """
elif False:
    VaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPropertiesArgs:
    def __init__(__self__, *,
                 encryption: Optional[pulumi.Input['VaultPropertiesEncryptionArgs']] = None,
                 monitoring_settings: Optional[pulumi.Input['MonitoringSettingsArgs']] = None,
                 public_network_access: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]] = None,
                 redundancy_settings: Optional[pulumi.Input['VaultPropertiesRedundancySettingsArgs']] = None,
                 resource_guard_operation_requests: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 restore_settings: Optional[pulumi.Input['RestoreSettingsArgs']] = None,
                 security_settings: Optional[pulumi.Input['SecuritySettingsArgs']] = None):
        """
        Properties of the vault.
        :param pulumi.Input['VaultPropertiesEncryptionArgs'] encryption: Customer Managed Key details of the resource.
        :param pulumi.Input['MonitoringSettingsArgs'] monitoring_settings: Monitoring Settings of the vault
        :param pulumi.Input[Union[str, 'PublicNetworkAccess']] public_network_access: property to enable or disable resource provider inbound network traffic from public clients
        :param pulumi.Input['VaultPropertiesRedundancySettingsArgs'] redundancy_settings: The redundancy Settings of a Vault
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will be performed
        :param pulumi.Input['RestoreSettingsArgs'] restore_settings: Restore Settings of the vault
        :param pulumi.Input['SecuritySettingsArgs'] security_settings: Security Settings of the vault
        """
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if monitoring_settings is not None:
            pulumi.set(__self__, "monitoring_settings", monitoring_settings)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if redundancy_settings is not None:
            pulumi.set(__self__, "redundancy_settings", redundancy_settings)
        if resource_guard_operation_requests is not None:
            pulumi.set(__self__, "resource_guard_operation_requests", resource_guard_operation_requests)
        if restore_settings is not None:
            pulumi.set(__self__, "restore_settings", restore_settings)
        if security_settings is not None:
            pulumi.set(__self__, "security_settings", security_settings)

    @property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['VaultPropertiesEncryptionArgs']]:
        """
        Customer Managed Key details of the resource.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['VaultPropertiesEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @property
    @pulumi.getter(name="monitoringSettings")
    def monitoring_settings(self) -> Optional[pulumi.Input['MonitoringSettingsArgs']]:
        """
        Monitoring Settings of the vault
        """
        return pulumi.get(self, "monitoring_settings")

    @monitoring_settings.setter
    def monitoring_settings(self, value: Optional[pulumi.Input['MonitoringSettingsArgs']]):
        pulumi.set(self, "monitoring_settings", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]:
        """
        property to enable or disable resource provider inbound network traffic from public clients
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="redundancySettings")
    def redundancy_settings(self) -> Optional[pulumi.Input['VaultPropertiesRedundancySettingsArgs']]:
        """
        The redundancy Settings of a Vault
        """
        return pulumi.get(self, "redundancy_settings")

    @redundancy_settings.setter
    def redundancy_settings(self, value: Optional[pulumi.Input['VaultPropertiesRedundancySettingsArgs']]):
        pulumi.set(self, "redundancy_settings", value)

    @property
    @pulumi.getter(name="resourceGuardOperationRequests")
    def resource_guard_operation_requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ResourceGuardOperationRequests on which LAC check will be performed
        """
        return pulumi.get(self, "resource_guard_operation_requests")

    @resource_guard_operation_requests.setter
    def resource_guard_operation_requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_guard_operation_requests", value)

    @property
    @pulumi.getter(name="restoreSettings")
    def restore_settings(self) -> Optional[pulumi.Input['RestoreSettingsArgs']]:
        """
        Restore Settings of the vault
        """
        return pulumi.get(self, "restore_settings")

    @restore_settings.setter
    def restore_settings(self, value: Optional[pulumi.Input['RestoreSettingsArgs']]):
        pulumi.set(self, "restore_settings", value)

    @property
    @pulumi.getter(name="securitySettings")
    def security_settings(self) -> Optional[pulumi.Input['SecuritySettingsArgs']]:
        """
        Security Settings of the vault
        """
        return pulumi.get(self, "security_settings")

    @security_settings.setter
    def security_settings(self, value: Optional[pulumi.Input['SecuritySettingsArgs']]):
        pulumi.set(self, "security_settings", value)


