# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AdxDestinationArgs',
    'AdxDestinationArgsDict',
    'AgentSettingArgs',
    'AgentSettingArgsDict',
    'ColumnDefinitionArgs',
    'ColumnDefinitionArgsDict',
    'DataCollectionEndpointNetworkAclsArgs',
    'DataCollectionEndpointNetworkAclsArgsDict',
    'DataCollectionEndpointResourceIdentityArgs',
    'DataCollectionEndpointResourceIdentityArgsDict',
    'DataCollectionRuleAgentSettingsArgs',
    'DataCollectionRuleAgentSettingsArgsDict',
    'DataCollectionRuleDataSourcesArgs',
    'DataCollectionRuleDataSourcesArgsDict',
    'DataCollectionRuleDestinationsArgs',
    'DataCollectionRuleDestinationsArgsDict',
    'DataCollectionRuleReferencesArgs',
    'DataCollectionRuleReferencesArgsDict',
    'DataCollectionRuleResourceIdentityArgs',
    'DataCollectionRuleResourceIdentityArgsDict',
    'DataFlowArgs',
    'DataFlowArgsDict',
    'DataImportSourcesEventHubArgs',
    'DataImportSourcesEventHubArgsDict',
    'DataSourcesSpecDataImportsArgs',
    'DataSourcesSpecDataImportsArgsDict',
    'DestinationsSpecAzureMonitorMetricsArgs',
    'DestinationsSpecAzureMonitorMetricsArgsDict',
    'EventHubDestinationArgs',
    'EventHubDestinationArgsDict',
    'EventHubDirectDestinationArgs',
    'EventHubDirectDestinationArgsDict',
    'ExtensionDataSourceArgs',
    'ExtensionDataSourceArgsDict',
    'IisLogsDataSourceArgs',
    'IisLogsDataSourceArgsDict',
    'LogAnalyticsDestinationArgs',
    'LogAnalyticsDestinationArgsDict',
    'LogFileSettingsTextArgs',
    'LogFileSettingsTextArgsDict',
    'LogFilesDataSourceSettingsArgs',
    'LogFilesDataSourceSettingsArgsDict',
    'LogFilesDataSourceArgs',
    'LogFilesDataSourceArgsDict',
    'MicrosoftFabricDestinationArgs',
    'MicrosoftFabricDestinationArgsDict',
    'MonitoringAccountDestinationArgs',
    'MonitoringAccountDestinationArgsDict',
    'PerfCounterDataSourceArgs',
    'PerfCounterDataSourceArgsDict',
    'PlatformTelemetryDataSourceArgs',
    'PlatformTelemetryDataSourceArgsDict',
    'PrometheusForwarderDataSourceArgs',
    'PrometheusForwarderDataSourceArgsDict',
    'ReferencesSpecEnrichmentDataArgs',
    'ReferencesSpecEnrichmentDataArgsDict',
    'StorageBlobDestinationArgs',
    'StorageBlobDestinationArgsDict',
    'StorageBlobArgs',
    'StorageBlobArgsDict',
    'StorageTableDestinationArgs',
    'StorageTableDestinationArgsDict',
    'StreamDeclarationArgs',
    'StreamDeclarationArgsDict',
    'SyslogDataSourceArgs',
    'SyslogDataSourceArgsDict',
    'WindowsEventLogDataSourceArgs',
    'WindowsEventLogDataSourceArgsDict',
    'WindowsFirewallLogsDataSourceArgs',
    'WindowsFirewallLogsDataSourceArgsDict',
]

MYPY = False

if not MYPY:
    class AdxDestinationArgsDict(TypedDict):
        """
        Azure Data Explorer (Adx) destination.
        """
        database_name: NotRequired[pulumi.Input[str]]
        """
        The name of the database to which data will be ingested.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The ARM resource id of the Adx resource.
        """
elif False:
    AdxDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdxDestinationArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Azure Data Explorer (Adx) destination.
        :param pulumi.Input[str] database_name: The name of the database to which data will be ingested.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[str] resource_id: The ARM resource id of the Adx resource.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database to which data will be ingested.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM resource id of the Adx resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class AgentSettingArgsDict(TypedDict):
        """
        A setting used to control an agent behavior on a host machine
        """
        name: NotRequired[pulumi.Input[Union[str, 'KnownAgentSettingName']]]
        """
        The name of the setting. 
        Must be part of the list of supported settings
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the setting
        """
elif False:
    AgentSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentSettingArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[str, 'KnownAgentSettingName']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        A setting used to control an agent behavior on a host machine
        :param pulumi.Input[Union[str, 'KnownAgentSettingName']] name: The name of the setting. 
               Must be part of the list of supported settings
        :param pulumi.Input[str] value: The value of the setting
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[str, 'KnownAgentSettingName']]]:
        """
        The name of the setting. 
        Must be part of the list of supported settings
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[str, 'KnownAgentSettingName']]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the setting
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ColumnDefinitionArgsDict(TypedDict):
        """
        Definition of custom data column.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the column.
        """
        type: NotRequired[pulumi.Input[Union[str, 'KnownColumnDefinitionType']]]
        """
        The type of the column data.
        """
elif False:
    ColumnDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ColumnDefinitionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'KnownColumnDefinitionType']]] = None):
        """
        Definition of custom data column.
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[Union[str, 'KnownColumnDefinitionType']] type: The type of the column data.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'KnownColumnDefinitionType']]]:
        """
        The type of the column data.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'KnownColumnDefinitionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataCollectionEndpointNetworkAclsArgsDict(TypedDict):
        """
        Network access control rules for the endpoints.
        """
        public_network_access: NotRequired[pulumi.Input[Union[str, 'KnownPublicNetworkAccessOptions']]]
        """
        The configuration to set whether network access from public internet to the endpoints are allowed.
        """
elif False:
    DataCollectionEndpointNetworkAclsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionEndpointNetworkAclsArgs:
    def __init__(__self__, *,
                 public_network_access: Optional[pulumi.Input[Union[str, 'KnownPublicNetworkAccessOptions']]] = None):
        """
        Network access control rules for the endpoints.
        :param pulumi.Input[Union[str, 'KnownPublicNetworkAccessOptions']] public_network_access: The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[str, 'KnownPublicNetworkAccessOptions']]]:
        """
        The configuration to set whether network access from public internet to the endpoints are allowed.
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[str, 'KnownPublicNetworkAccessOptions']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class DataCollectionEndpointResourceIdentityArgsDict(TypedDict):
        """
        Managed service identity of the resource.
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    DataCollectionEndpointResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionEndpointResourceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity of the resource.
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class DataCollectionRuleAgentSettingsArgsDict(TypedDict):
        """
        Agent settings used to modify agent behavior on a given host
        """
        logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentSettingArgsDict']]]]
        """
        All the settings that are applicable to the logs agent (AMA)
        """
elif False:
    DataCollectionRuleAgentSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleAgentSettingsArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentSettingArgs']]]] = None):
        """
        Agent settings used to modify agent behavior on a given host
        :param pulumi.Input[Sequence[pulumi.Input['AgentSettingArgs']]] logs: All the settings that are applicable to the logs agent (AMA)
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentSettingArgs']]]]:
        """
        All the settings that are applicable to the logs agent (AMA)
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentSettingArgs']]]]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class DataCollectionRuleDataSourcesArgsDict(TypedDict):
        """
        The specification of data sources. 
        This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        """
        data_imports: NotRequired[pulumi.Input['DataSourcesSpecDataImportsArgsDict']]
        """
        Specifications of pull based data sources
        """
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgsDict']]]]
        """
        The list of Azure VM extension data source configurations.
        """
        iis_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgsDict']]]]
        """
        The list of IIS logs source configurations.
        """
        log_files: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgsDict']]]]
        """
        The list of Log files source configurations.
        """
        performance_counters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgsDict']]]]
        """
        The list of performance counter data source configurations.
        """
        platform_telemetry: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgsDict']]]]
        """
        The list of platform telemetry configurations
        """
        prometheus_forwarder: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgsDict']]]]
        """
        The list of Prometheus forwarder data source configurations.
        """
        syslog: NotRequired[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgsDict']]]]
        """
        The list of Syslog data source configurations.
        """
        windows_event_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgsDict']]]]
        """
        The list of Windows Event Log data source configurations.
        """
        windows_firewall_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgsDict']]]]
        """
        The list of Windows Firewall logs source configurations.
        """
elif False:
    DataCollectionRuleDataSourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesArgs:
    def __init__(__self__, *,
                 data_imports: Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]] = None,
                 iis_logs: Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]] = None,
                 log_files: Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]] = None,
                 performance_counters: Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]] = None,
                 platform_telemetry: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]] = None,
                 prometheus_forwarder: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]] = None,
                 syslog: Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]] = None,
                 windows_event_logs: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]] = None,
                 windows_firewall_logs: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]] = None):
        """
        The specification of data sources. 
        This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        :param pulumi.Input['DataSourcesSpecDataImportsArgs'] data_imports: Specifications of pull based data sources
        :param pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]] extensions: The list of Azure VM extension data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]] iis_logs: The list of IIS logs source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]] log_files: The list of Log files source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]] performance_counters: The list of performance counter data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]] platform_telemetry: The list of platform telemetry configurations
        :param pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]] prometheus_forwarder: The list of Prometheus forwarder data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]] syslog: The list of Syslog data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]] windows_event_logs: The list of Windows Event Log data source configurations.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]] windows_firewall_logs: The list of Windows Firewall logs source configurations.
        """
        if data_imports is not None:
            pulumi.set(__self__, "data_imports", data_imports)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if iis_logs is not None:
            pulumi.set(__self__, "iis_logs", iis_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if performance_counters is not None:
            pulumi.set(__self__, "performance_counters", performance_counters)
        if platform_telemetry is not None:
            pulumi.set(__self__, "platform_telemetry", platform_telemetry)
        if prometheus_forwarder is not None:
            pulumi.set(__self__, "prometheus_forwarder", prometheus_forwarder)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)
        if windows_event_logs is not None:
            pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        if windows_firewall_logs is not None:
            pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)

    @property
    @pulumi.getter(name="dataImports")
    def data_imports(self) -> Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']]:
        """
        Specifications of pull based data sources
        """
        return pulumi.get(self, "data_imports")

    @data_imports.setter
    def data_imports(self, value: Optional[pulumi.Input['DataSourcesSpecDataImportsArgs']]):
        pulumi.set(self, "data_imports", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]]:
        """
        The list of Azure VM extension data source configurations.
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExtensionDataSourceArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]]:
        """
        The list of IIS logs source configurations.
        """
        return pulumi.get(self, "iis_logs")

    @iis_logs.setter
    def iis_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IisLogsDataSourceArgs']]]]):
        pulumi.set(self, "iis_logs", value)

    @property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]]:
        """
        The list of Log files source configurations.
        """
        return pulumi.get(self, "log_files")

    @log_files.setter
    def log_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogFilesDataSourceArgs']]]]):
        pulumi.set(self, "log_files", value)

    @property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]]:
        """
        The list of performance counter data source configurations.
        """
        return pulumi.get(self, "performance_counters")

    @performance_counters.setter
    def performance_counters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PerfCounterDataSourceArgs']]]]):
        pulumi.set(self, "performance_counters", value)

    @property
    @pulumi.getter(name="platformTelemetry")
    def platform_telemetry(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]]:
        """
        The list of platform telemetry configurations
        """
        return pulumi.get(self, "platform_telemetry")

    @platform_telemetry.setter
    def platform_telemetry(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlatformTelemetryDataSourceArgs']]]]):
        pulumi.set(self, "platform_telemetry", value)

    @property
    @pulumi.getter(name="prometheusForwarder")
    def prometheus_forwarder(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]]:
        """
        The list of Prometheus forwarder data source configurations.
        """
        return pulumi.get(self, "prometheus_forwarder")

    @prometheus_forwarder.setter
    def prometheus_forwarder(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusForwarderDataSourceArgs']]]]):
        pulumi.set(self, "prometheus_forwarder", value)

    @property
    @pulumi.getter
    def syslog(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]]:
        """
        The list of Syslog data source configurations.
        """
        return pulumi.get(self, "syslog")

    @syslog.setter
    def syslog(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyslogDataSourceArgs']]]]):
        pulumi.set(self, "syslog", value)

    @property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]]:
        """
        The list of Windows Event Log data source configurations.
        """
        return pulumi.get(self, "windows_event_logs")

    @windows_event_logs.setter
    def windows_event_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsEventLogDataSourceArgs']]]]):
        pulumi.set(self, "windows_event_logs", value)

    @property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]]:
        """
        The list of Windows Firewall logs source configurations.
        """
        return pulumi.get(self, "windows_firewall_logs")

    @windows_firewall_logs.setter
    def windows_firewall_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFirewallLogsDataSourceArgs']]]]):
        pulumi.set(self, "windows_firewall_logs", value)


if not MYPY:
    class DataCollectionRuleDestinationsArgsDict(TypedDict):
        """
        The specification of destinations.
        """
        azure_data_explorer: NotRequired[pulumi.Input[Sequence[pulumi.Input['AdxDestinationArgsDict']]]]
        """
        List of Azure Data Explorer destinations.
        """
        azure_monitor_metrics: NotRequired[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgsDict']]
        """
        Azure Monitor Metrics destination.
        """
        event_hubs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgsDict']]]]
        """
        List of Event Hubs destinations.
        """
        event_hubs_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgsDict']]]]
        """
        List of Event Hubs Direct destinations.
        """
        log_analytics: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgsDict']]]]
        """
        List of Log Analytics destinations.
        """
        microsoft_fabric: NotRequired[pulumi.Input[Sequence[pulumi.Input['MicrosoftFabricDestinationArgsDict']]]]
        """
        List of Microsoft Fabric destinations.
        """
        monitoring_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgsDict']]]]
        """
        List of monitoring account destinations.
        """
        storage_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgsDict']]]]
        """
        List of storage accounts destinations.
        """
        storage_blobs_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgsDict']]]]
        """
        List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        """
        storage_tables_direct: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgsDict']]]]
        """
        List of Storage Table Direct destinations.
        """
elif False:
    DataCollectionRuleDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsArgs:
    def __init__(__self__, *,
                 azure_data_explorer: Optional[pulumi.Input[Sequence[pulumi.Input['AdxDestinationArgs']]]] = None,
                 azure_monitor_metrics: Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']] = None,
                 event_hubs: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]] = None,
                 event_hubs_direct: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]] = None,
                 log_analytics: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]] = None,
                 microsoft_fabric: Optional[pulumi.Input[Sequence[pulumi.Input['MicrosoftFabricDestinationArgs']]]] = None,
                 monitoring_accounts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]] = None,
                 storage_accounts: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]] = None,
                 storage_blobs_direct: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]] = None,
                 storage_tables_direct: Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]] = None):
        """
        The specification of destinations.
        :param pulumi.Input[Sequence[pulumi.Input['AdxDestinationArgs']]] azure_data_explorer: List of Azure Data Explorer destinations.
        :param pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs'] azure_monitor_metrics: Azure Monitor Metrics destination.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]] event_hubs: List of Event Hubs destinations.
        :param pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]] event_hubs_direct: List of Event Hubs Direct destinations.
        :param pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]] log_analytics: List of Log Analytics destinations.
        :param pulumi.Input[Sequence[pulumi.Input['MicrosoftFabricDestinationArgs']]] microsoft_fabric: List of Microsoft Fabric destinations.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]] monitoring_accounts: List of monitoring account destinations.
        :param pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]] storage_accounts: List of storage accounts destinations.
        :param pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]] storage_blobs_direct: List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        :param pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]] storage_tables_direct: List of Storage Table Direct destinations.
        """
        if azure_data_explorer is not None:
            pulumi.set(__self__, "azure_data_explorer", azure_data_explorer)
        if azure_monitor_metrics is not None:
            pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        if event_hubs is not None:
            pulumi.set(__self__, "event_hubs", event_hubs)
        if event_hubs_direct is not None:
            pulumi.set(__self__, "event_hubs_direct", event_hubs_direct)
        if log_analytics is not None:
            pulumi.set(__self__, "log_analytics", log_analytics)
        if microsoft_fabric is not None:
            pulumi.set(__self__, "microsoft_fabric", microsoft_fabric)
        if monitoring_accounts is not None:
            pulumi.set(__self__, "monitoring_accounts", monitoring_accounts)
        if storage_accounts is not None:
            pulumi.set(__self__, "storage_accounts", storage_accounts)
        if storage_blobs_direct is not None:
            pulumi.set(__self__, "storage_blobs_direct", storage_blobs_direct)
        if storage_tables_direct is not None:
            pulumi.set(__self__, "storage_tables_direct", storage_tables_direct)

    @property
    @pulumi.getter(name="azureDataExplorer")
    def azure_data_explorer(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AdxDestinationArgs']]]]:
        """
        List of Azure Data Explorer destinations.
        """
        return pulumi.get(self, "azure_data_explorer")

    @azure_data_explorer.setter
    def azure_data_explorer(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AdxDestinationArgs']]]]):
        pulumi.set(self, "azure_data_explorer", value)

    @property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']]:
        """
        Azure Monitor Metrics destination.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @azure_monitor_metrics.setter
    def azure_monitor_metrics(self, value: Optional[pulumi.Input['DestinationsSpecAzureMonitorMetricsArgs']]):
        pulumi.set(self, "azure_monitor_metrics", value)

    @property
    @pulumi.getter(name="eventHubs")
    def event_hubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]]:
        """
        List of Event Hubs destinations.
        """
        return pulumi.get(self, "event_hubs")

    @event_hubs.setter
    def event_hubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDestinationArgs']]]]):
        pulumi.set(self, "event_hubs", value)

    @property
    @pulumi.getter(name="eventHubsDirect")
    def event_hubs_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]]:
        """
        List of Event Hubs Direct destinations.
        """
        return pulumi.get(self, "event_hubs_direct")

    @event_hubs_direct.setter
    def event_hubs_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventHubDirectDestinationArgs']]]]):
        pulumi.set(self, "event_hubs_direct", value)

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]]:
        """
        List of Log Analytics destinations.
        """
        return pulumi.get(self, "log_analytics")

    @log_analytics.setter
    def log_analytics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogAnalyticsDestinationArgs']]]]):
        pulumi.set(self, "log_analytics", value)

    @property
    @pulumi.getter(name="microsoftFabric")
    def microsoft_fabric(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MicrosoftFabricDestinationArgs']]]]:
        """
        List of Microsoft Fabric destinations.
        """
        return pulumi.get(self, "microsoft_fabric")

    @microsoft_fabric.setter
    def microsoft_fabric(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MicrosoftFabricDestinationArgs']]]]):
        pulumi.set(self, "microsoft_fabric", value)

    @property
    @pulumi.getter(name="monitoringAccounts")
    def monitoring_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]]:
        """
        List of monitoring account destinations.
        """
        return pulumi.get(self, "monitoring_accounts")

    @monitoring_accounts.setter
    def monitoring_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringAccountDestinationArgs']]]]):
        pulumi.set(self, "monitoring_accounts", value)

    @property
    @pulumi.getter(name="storageAccounts")
    def storage_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]:
        """
        List of storage accounts destinations.
        """
        return pulumi.get(self, "storage_accounts")

    @storage_accounts.setter
    def storage_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]):
        pulumi.set(self, "storage_accounts", value)

    @property
    @pulumi.getter(name="storageBlobsDirect")
    def storage_blobs_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]:
        """
        List of Storage Blob Direct destinations. To be used only for sending data directly to store from the agent.
        """
        return pulumi.get(self, "storage_blobs_direct")

    @storage_blobs_direct.setter
    def storage_blobs_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobDestinationArgs']]]]):
        pulumi.set(self, "storage_blobs_direct", value)

    @property
    @pulumi.getter(name="storageTablesDirect")
    def storage_tables_direct(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]]:
        """
        List of Storage Table Direct destinations.
        """
        return pulumi.get(self, "storage_tables_direct")

    @storage_tables_direct.setter
    def storage_tables_direct(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageTableDestinationArgs']]]]):
        pulumi.set(self, "storage_tables_direct", value)


if not MYPY:
    class DataCollectionRuleReferencesArgsDict(TypedDict):
        """
        Defines all the references that may be used in other sections of the DCR
        """
        enrichment_data: NotRequired[pulumi.Input['ReferencesSpecEnrichmentDataArgsDict']]
        """
        All the enrichment data sources referenced in data flows
        """
elif False:
    DataCollectionRuleReferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleReferencesArgs:
    def __init__(__self__, *,
                 enrichment_data: Optional[pulumi.Input['ReferencesSpecEnrichmentDataArgs']] = None):
        """
        Defines all the references that may be used in other sections of the DCR
        :param pulumi.Input['ReferencesSpecEnrichmentDataArgs'] enrichment_data: All the enrichment data sources referenced in data flows
        """
        if enrichment_data is not None:
            pulumi.set(__self__, "enrichment_data", enrichment_data)

    @property
    @pulumi.getter(name="enrichmentData")
    def enrichment_data(self) -> Optional[pulumi.Input['ReferencesSpecEnrichmentDataArgs']]:
        """
        All the enrichment data sources referenced in data flows
        """
        return pulumi.get(self, "enrichment_data")

    @enrichment_data.setter
    def enrichment_data(self, value: Optional[pulumi.Input['ReferencesSpecEnrichmentDataArgs']]):
        pulumi.set(self, "enrichment_data", value)


if not MYPY:
    class DataCollectionRuleResourceIdentityArgsDict(TypedDict):
        """
        Managed service identity of the resource.
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    DataCollectionRuleResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleResourceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity of the resource.
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class DataFlowArgsDict(TypedDict):
        """
        Definition of which streams are sent to which destinations.
        """
        built_in_transform: NotRequired[pulumi.Input[str]]
        """
        The builtIn transform to transform stream data
        """
        capture_overflow: NotRequired[pulumi.Input[bool]]
        """
        Flag to enable overflow column in LA destinations
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destinations for this data flow.
        """
        output_stream: NotRequired[pulumi.Input[str]]
        """
        The output stream of the transform. Only required if the transform changes data to a different stream.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownDataFlowStreams']]]]]
        """
        List of streams for this data flow.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform stream data.
        """
elif False:
    DataFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowArgs:
    def __init__(__self__, *,
                 built_in_transform: Optional[pulumi.Input[str]] = None,
                 capture_overflow: Optional[pulumi.Input[bool]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_stream: Optional[pulumi.Input[str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownDataFlowStreams']]]]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        Definition of which streams are sent to which destinations.
        :param pulumi.Input[str] built_in_transform: The builtIn transform to transform stream data
        :param pulumi.Input[bool] capture_overflow: Flag to enable overflow column in LA destinations
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destinations: List of destinations for this data flow.
        :param pulumi.Input[str] output_stream: The output stream of the transform. Only required if the transform changes data to a different stream.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownDataFlowStreams']]]] streams: List of streams for this data flow.
        :param pulumi.Input[str] transform_kql: The KQL query to transform stream data.
        """
        if built_in_transform is not None:
            pulumi.set(__self__, "built_in_transform", built_in_transform)
        if capture_overflow is not None:
            pulumi.set(__self__, "capture_overflow", capture_overflow)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if output_stream is not None:
            pulumi.set(__self__, "output_stream", output_stream)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> Optional[pulumi.Input[str]]:
        """
        The builtIn transform to transform stream data
        """
        return pulumi.get(self, "built_in_transform")

    @built_in_transform.setter
    def built_in_transform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "built_in_transform", value)

    @property
    @pulumi.getter(name="captureOverflow")
    def capture_overflow(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to enable overflow column in LA destinations
        """
        return pulumi.get(self, "capture_overflow")

    @capture_overflow.setter
    def capture_overflow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "capture_overflow", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destinations for this data flow.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> Optional[pulumi.Input[str]]:
        """
        The output stream of the transform. Only required if the transform changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @output_stream.setter
    def output_stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_stream", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownDataFlowStreams']]]]]:
        """
        List of streams for this data flow.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownDataFlowStreams']]]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class DataImportSourcesEventHubArgsDict(TypedDict):
        """
        Definition of Event Hub configuration.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        """
        Event Hub consumer group name
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        stream: NotRequired[pulumi.Input[str]]
        """
        The stream to collect from EventHub
        """
elif False:
    DataImportSourcesEventHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataImportSourcesEventHubArgs:
    def __init__(__self__, *,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 stream: Optional[pulumi.Input[str]] = None):
        """
        Definition of Event Hub configuration.
        :param pulumi.Input[str] consumer_group: Event Hub consumer group name
        :param pulumi.Input[str] name: A friendly name for the data source. 
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[str] stream: The stream to collect from EventHub
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        """
        Event Hub consumer group name
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source. 
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input[str]]:
        """
        The stream to collect from EventHub
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream", value)


if not MYPY:
    class DataSourcesSpecDataImportsArgsDict(TypedDict):
        """
        Specifications of pull based data sources
        """
        event_hub: NotRequired[pulumi.Input['DataImportSourcesEventHubArgsDict']]
        """
        Definition of Event Hub configuration.
        """
elif False:
    DataSourcesSpecDataImportsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcesSpecDataImportsArgs:
    def __init__(__self__, *,
                 event_hub: Optional[pulumi.Input['DataImportSourcesEventHubArgs']] = None):
        """
        Specifications of pull based data sources
        :param pulumi.Input['DataImportSourcesEventHubArgs'] event_hub: Definition of Event Hub configuration.
        """
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional[pulumi.Input['DataImportSourcesEventHubArgs']]:
        """
        Definition of Event Hub configuration.
        """
        return pulumi.get(self, "event_hub")

    @event_hub.setter
    def event_hub(self, value: Optional[pulumi.Input['DataImportSourcesEventHubArgs']]):
        pulumi.set(self, "event_hub", value)


if not MYPY:
    class DestinationsSpecAzureMonitorMetricsArgsDict(TypedDict):
        """
        Azure Monitor Metrics destination.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    DestinationsSpecAzureMonitorMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationsSpecAzureMonitorMetricsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Azure Monitor Metrics destination.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EventHubDestinationArgsDict(TypedDict):
        event_hub_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the event hub.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    EventHubDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventHubDestinationArgs:
    def __init__(__self__, *,
                 event_hub_resource_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_hub_resource_id: The resource ID of the event hub.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @event_hub_resource_id.setter
    def event_hub_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_resource_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EventHubDirectDestinationArgsDict(TypedDict):
        event_hub_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the event hub.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    EventHubDirectDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventHubDirectDestinationArgs:
    def __init__(__self__, *,
                 event_hub_resource_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_hub_resource_id: The resource ID of the event hub.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the event hub.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @event_hub_resource_id.setter
    def event_hub_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_resource_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExtensionDataSourceArgsDict(TypedDict):
        """
        Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
        Collected from either Windows and Linux machines, depending on which extension is defined.
        """
        extension_name: pulumi.Input[str]
        """
        The name of the VM extension.
        """
        extension_settings: NotRequired[Any]
        """
        The extension settings. The format is specific for particular extension.
        """
        input_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of data sources this extension needs data from.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownExtensionDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
elif False:
    ExtensionDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtensionDataSourceArgs:
    def __init__(__self__, *,
                 extension_name: pulumi.Input[str],
                 extension_settings: Optional[Any] = None,
                 input_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownExtensionDataSourceStreams']]]]] = None):
        """
        Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor Agent.
        Collected from either Windows and Linux machines, depending on which extension is defined.
        :param pulumi.Input[str] extension_name: The name of the VM extension.
        :param Any extension_settings: The extension settings. The format is specific for particular extension.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_data_sources: The list of data sources this extension needs data from.
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownExtensionDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "extension_name", extension_name)
        if extension_settings is not None:
            pulumi.set(__self__, "extension_settings", extension_settings)
        if input_data_sources is not None:
            pulumi.set(__self__, "input_data_sources", input_data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> pulumi.Input[str]:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @extension_name.setter
    def extension_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "extension_name", value)

    @property
    @pulumi.getter(name="extensionSettings")
    def extension_settings(self) -> Optional[Any]:
        """
        The extension settings. The format is specific for particular extension.
        """
        return pulumi.get(self, "extension_settings")

    @extension_settings.setter
    def extension_settings(self, value: Optional[Any]):
        pulumi.set(self, "extension_settings", value)

    @property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of data sources this extension needs data from.
        """
        return pulumi.get(self, "input_data_sources")

    @input_data_sources.setter
    def input_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_data_sources", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownExtensionDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownExtensionDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class IisLogsDataSourceArgsDict(TypedDict):
        """
        Enables IIS logs to be collected by this data collection rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        IIS streams
        """
        log_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Absolute paths file location
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform the data source.
        """
elif False:
    IisLogsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IisLogsDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 log_directories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        Enables IIS logs to be collected by this data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: IIS streams
        :param pulumi.Input[Sequence[pulumi.Input[str]]] log_directories: Absolute paths file location
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[str] transform_kql: The KQL query to transform the data source.
        """
        pulumi.set(__self__, "streams", streams)
        if log_directories is not None:
            pulumi.set(__self__, "log_directories", log_directories)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        IIS streams
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Absolute paths file location
        """
        return pulumi.get(self, "log_directories")

    @log_directories.setter
    def log_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "log_directories", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class LogAnalyticsDestinationArgsDict(TypedDict):
        """
        Log Analytics destination.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        workspace_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the Log Analytics workspace.
        """
elif False:
    LogAnalyticsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 workspace_resource_id: Optional[pulumi.Input[str]] = None):
        """
        Log Analytics destination.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[str] workspace_resource_id: The resource ID of the Log Analytics workspace.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if workspace_resource_id is not None:
            pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the Log Analytics workspace.
        """
        return pulumi.get(self, "workspace_resource_id")

    @workspace_resource_id.setter
    def workspace_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_resource_id", value)


if not MYPY:
    class LogFileSettingsTextArgsDict(TypedDict):
        """
        Text settings
        """
        record_start_timestamp_format: pulumi.Input[Union[str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]
        """
        One of the supported timestamp formats
        """
elif False:
    LogFileSettingsTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFileSettingsTextArgs:
    def __init__(__self__, *,
                 record_start_timestamp_format: pulumi.Input[Union[str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]):
        """
        Text settings
        :param pulumi.Input[Union[str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']] record_start_timestamp_format: One of the supported timestamp formats
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> pulumi.Input[Union[str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]:
        """
        One of the supported timestamp formats
        """
        return pulumi.get(self, "record_start_timestamp_format")

    @record_start_timestamp_format.setter
    def record_start_timestamp_format(self, value: pulumi.Input[Union[str, 'KnownLogFileTextSettingsRecordStartTimestampFormat']]):
        pulumi.set(self, "record_start_timestamp_format", value)


if not MYPY:
    class LogFilesDataSourceSettingsArgsDict(TypedDict):
        """
        The log files specific settings.
        """
        text: NotRequired[pulumi.Input['LogFileSettingsTextArgsDict']]
        """
        Text settings
        """
elif False:
    LogFilesDataSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFilesDataSourceSettingsArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['LogFileSettingsTextArgs']] = None):
        """
        The log files specific settings.
        :param pulumi.Input['LogFileSettingsTextArgs'] text: Text settings
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['LogFileSettingsTextArgs']]:
        """
        Text settings
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['LogFileSettingsTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class LogFilesDataSourceArgsDict(TypedDict):
        """
        Definition of which custom log files will be collected by this data collection rule
        """
        file_patterns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        File Patterns where the log files are located
        """
        format: pulumi.Input[Union[str, 'KnownLogFilesDataSourceFormat']]
        """
        The data format of the log files
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data source
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        settings: NotRequired[pulumi.Input['LogFilesDataSourceSettingsArgsDict']]
        """
        The log files specific settings.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform the data source.
        """
elif False:
    LogFilesDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogFilesDataSourceArgs:
    def __init__(__self__, *,
                 file_patterns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 format: pulumi.Input[Union[str, 'KnownLogFilesDataSourceFormat']],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        Definition of which custom log files will be collected by this data collection rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_patterns: File Patterns where the log files are located
        :param pulumi.Input[Union[str, 'KnownLogFilesDataSourceFormat']] format: The data format of the log files
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data source
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input['LogFilesDataSourceSettingsArgs'] settings: The log files specific settings.
        :param pulumi.Input[str] transform_kql: The KQL query to transform the data source.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        File Patterns where the log files are located
        """
        return pulumi.get(self, "file_patterns")

    @file_patterns.setter
    def file_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "file_patterns", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[Union[str, 'KnownLogFilesDataSourceFormat']]:
        """
        The data format of the log files
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[Union[str, 'KnownLogFilesDataSourceFormat']]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data source
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']]:
        """
        The log files specific settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['LogFilesDataSourceSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class MicrosoftFabricDestinationArgsDict(TypedDict):
        """
        Microsoft Fabric destination (non-Azure).
        """
        artifact_id: NotRequired[pulumi.Input[str]]
        """
        The artifact id of the Microsoft Fabric resource.
        """
        database_name: NotRequired[pulumi.Input[str]]
        """
        The name of the database to which data will be ingested.
        """
        ingestion_uri: NotRequired[pulumi.Input[str]]
        """
        The ingestion uri of the Microsoft Fabric resource.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant id of the Microsoft Fabric resource.
        """
elif False:
    MicrosoftFabricDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicrosoftFabricDestinationArgs:
    def __init__(__self__, *,
                 artifact_id: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None,
                 ingestion_uri: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        Microsoft Fabric destination (non-Azure).
        :param pulumi.Input[str] artifact_id: The artifact id of the Microsoft Fabric resource.
        :param pulumi.Input[str] database_name: The name of the database to which data will be ingested.
        :param pulumi.Input[str] ingestion_uri: The ingestion uri of the Microsoft Fabric resource.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[str] tenant_id: The tenant id of the Microsoft Fabric resource.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if ingestion_uri is not None:
            pulumi.set(__self__, "ingestion_uri", ingestion_uri)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The artifact id of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "artifact_id")

    @artifact_id.setter
    def artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database to which data will be ingested.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="ingestionUri")
    def ingestion_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The ingestion uri of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "ingestion_uri")

    @ingestion_uri.setter
    def ingestion_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingestion_uri", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of the Microsoft Fabric resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class MonitoringAccountDestinationArgsDict(TypedDict):
        """
        Monitoring account destination.
        """
        account_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the monitoring account.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
elif False:
    MonitoringAccountDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringAccountDestinationArgs:
    def __init__(__self__, *,
                 account_resource_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Monitoring account destination.
        :param pulumi.Input[str] account_resource_id: The resource ID of the monitoring account.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        if account_resource_id is not None:
            pulumi.set(__self__, "account_resource_id", account_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="accountResourceId")
    def account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the monitoring account.
        """
        return pulumi.get(self, "account_resource_id")

    @account_resource_id.setter
    def account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_resource_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PerfCounterDataSourceArgsDict(TypedDict):
        """
        Definition of which performance counters will be collected and how they will be collected by this data collection rule.
        Collected from both Windows and Linux machines where the counter is present.
        """
        counter_specifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of specifier names of the performance counters you want to collect.
        Use a wildcard (*) to collect a counter for all instances.
        To get a list of performance counters on Windows, run the command 'typeperf'.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        sampling_frequency_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds between consecutive counter measurements (samples).
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPerfCounterDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform the data source.
        """
elif False:
    PerfCounterDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PerfCounterDataSourceArgs:
    def __init__(__self__, *,
                 counter_specifiers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 sampling_frequency_in_seconds: Optional[pulumi.Input[int]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPerfCounterDataSourceStreams']]]]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        Definition of which performance counters will be collected and how they will be collected by this data collection rule.
        Collected from both Windows and Linux machines where the counter is present.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] counter_specifiers: A list of specifier names of the performance counters you want to collect.
               Use a wildcard (*) to collect a counter for all instances.
               To get a list of performance counters on Windows, run the command 'typeperf'.
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[int] sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples).
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPerfCounterDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param pulumi.Input[str] transform_kql: The KQL query to transform the data source.
        """
        if counter_specifiers is not None:
            pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sampling_frequency_in_seconds is not None:
            pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of specifier names of the performance counters you want to collect.
        Use a wildcard (*) to collect a counter for all instances.
        To get a list of performance counters on Windows, run the command 'typeperf'.
        """
        return pulumi.get(self, "counter_specifiers")

    @counter_specifiers.setter
    def counter_specifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "counter_specifiers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between consecutive counter measurements (samples).
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @sampling_frequency_in_seconds.setter
    def sampling_frequency_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sampling_frequency_in_seconds", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPerfCounterDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPerfCounterDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class PlatformTelemetryDataSourceArgsDict(TypedDict):
        """
        Definition of platform telemetry data source configuration
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of platform telemetry streams to collect
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
elif False:
    PlatformTelemetryDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformTelemetryDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        Definition of platform telemetry data source configuration
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: List of platform telemetry streams to collect
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of platform telemetry streams to collect
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PrometheusForwarderDataSourceArgsDict(TypedDict):
        """
        Definition of Prometheus metrics forwarding configuration.
        """
        label_include_filter: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The list of label inclusion filters in the form of label "name-value" pairs.
        Currently only one label is supported: 'microsoft_metrics_include_label'.
        Label values are matched case-insensitively.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPrometheusForwarderDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        """
elif False:
    PrometheusForwarderDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusForwarderDataSourceArgs:
    def __init__(__self__, *,
                 label_include_filter: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPrometheusForwarderDataSourceStreams']]]]] = None):
        """
        Definition of Prometheus metrics forwarding configuration.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] label_include_filter: The list of label inclusion filters in the form of label "name-value" pairs.
               Currently only one label is supported: 'microsoft_metrics_include_label'.
               Label values are matched case-insensitively.
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPrometheusForwarderDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
        """
        if label_include_filter is not None:
            pulumi.set(__self__, "label_include_filter", label_include_filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="labelIncludeFilter")
    def label_include_filter(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The list of label inclusion filters in the form of label "name-value" pairs.
        Currently only one label is supported: 'microsoft_metrics_include_label'.
        Label values are matched case-insensitively.
        """
        return pulumi.get(self, "label_include_filter")

    @label_include_filter.setter
    def label_include_filter(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "label_include_filter", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPrometheusForwarderDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownPrometheusForwarderDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class ReferencesSpecEnrichmentDataArgsDict(TypedDict):
        """
        All the enrichment data sources referenced in data flows
        """
        storage_blobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBlobArgsDict']]]]
        """
        All the storage blobs used as enrichment data sources
        """
elif False:
    ReferencesSpecEnrichmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReferencesSpecEnrichmentDataArgs:
    def __init__(__self__, *,
                 storage_blobs: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobArgs']]]] = None):
        """
        All the enrichment data sources referenced in data flows
        :param pulumi.Input[Sequence[pulumi.Input['StorageBlobArgs']]] storage_blobs: All the storage blobs used as enrichment data sources
        """
        if storage_blobs is not None:
            pulumi.set(__self__, "storage_blobs", storage_blobs)

    @property
    @pulumi.getter(name="storageBlobs")
    def storage_blobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobArgs']]]]:
        """
        All the storage blobs used as enrichment data sources
        """
        return pulumi.get(self, "storage_blobs")

    @storage_blobs.setter
    def storage_blobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBlobArgs']]]]):
        pulumi.set(self, "storage_blobs", value)


if not MYPY:
    class StorageBlobDestinationArgsDict(TypedDict):
        container_name: NotRequired[pulumi.Input[str]]
        """
        The container name of the Storage Blob.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        storage_account_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the storage account.
        """
elif False:
    StorageBlobDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBlobDestinationArgs:
    def __init__(__self__, *,
                 container_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_name: The container name of the Storage Blob.
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[str] storage_account_resource_id: The resource ID of the storage account.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        The container name of the Storage Blob.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_resource_id", value)


if not MYPY:
    class StorageBlobArgsDict(TypedDict):
        blob_url: NotRequired[pulumi.Input[str]]
        """
        Url of the storage blob
        """
        lookup_type: NotRequired[pulumi.Input[Union[str, 'KnownStorageBlobLookupType']]]
        """
        The type of lookup to perform on the blob
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the enrichment data source used as an alias when referencing this data source in data flows
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        Resource Id of the storage account that hosts the blob
        """
elif False:
    StorageBlobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBlobArgs:
    def __init__(__self__, *,
                 blob_url: Optional[pulumi.Input[str]] = None,
                 lookup_type: Optional[pulumi.Input[Union[str, 'KnownStorageBlobLookupType']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] blob_url: Url of the storage blob
        :param pulumi.Input[Union[str, 'KnownStorageBlobLookupType']] lookup_type: The type of lookup to perform on the blob
        :param pulumi.Input[str] name: The name of the enrichment data source used as an alias when referencing this data source in data flows
        :param pulumi.Input[str] resource_id: Resource Id of the storage account that hosts the blob
        """
        if blob_url is not None:
            pulumi.set(__self__, "blob_url", blob_url)
        if lookup_type is not None:
            pulumi.set(__self__, "lookup_type", lookup_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="blobUrl")
    def blob_url(self) -> Optional[pulumi.Input[str]]:
        """
        Url of the storage blob
        """
        return pulumi.get(self, "blob_url")

    @blob_url.setter
    def blob_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_url", value)

    @property
    @pulumi.getter(name="lookupType")
    def lookup_type(self) -> Optional[pulumi.Input[Union[str, 'KnownStorageBlobLookupType']]]:
        """
        The type of lookup to perform on the blob
        """
        return pulumi.get(self, "lookup_type")

    @lookup_type.setter
    def lookup_type(self, value: Optional[pulumi.Input[Union[str, 'KnownStorageBlobLookupType']]]):
        pulumi.set(self, "lookup_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the enrichment data source used as an alias when referencing this data source in data flows
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of the storage account that hosts the blob
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class StorageTableDestinationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        storage_account_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the storage account.
        """
        table_name: NotRequired[pulumi.Input[str]]
        """
        The name of the Storage Table.
        """
elif False:
    StorageTableDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageTableDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[str]] = None,
                 table_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: A friendly name for the destination. 
               This name should be unique across all destinations (regardless of type) within the data collection rule.
        :param pulumi.Input[str] storage_account_resource_id: The resource ID of the storage account.
        :param pulumi.Input[str] table_name: The name of the Storage Table.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the destination. 
        This name should be unique across all destinations (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the storage account.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_resource_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Storage Table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class StreamDeclarationArgsDict(TypedDict):
        """
        Declaration of a custom stream.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgsDict']]]]
        """
        List of columns used by data in this stream.
        """
elif False:
    StreamDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDeclarationArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]] = None):
        """
        Declaration of a custom stream.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]] columns: List of columns used by data in this stream.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]]:
        """
        List of columns used by data in this stream.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnDefinitionArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class SyslogDataSourceArgsDict(TypedDict):
        """
        Definition of which syslog data will be collected and how it will be collected.
        Only collected from Linux machines.
        """
        facility_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceFacilityNames']]]]]
        """
        The list of facility names.
        """
        log_levels: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceLogLevels']]]]]
        """
        The log levels to collect.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform the data source.
        """
elif False:
    SyslogDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogDataSourceArgs:
    def __init__(__self__, *,
                 facility_names: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceFacilityNames']]]]] = None,
                 log_levels: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceLogLevels']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceStreams']]]]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        Definition of which syslog data will be collected and how it will be collected.
        Only collected from Linux machines.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceFacilityNames']]]] facility_names: The list of facility names.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceLogLevels']]]] log_levels: The log levels to collect.
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param pulumi.Input[str] transform_kql: The KQL query to transform the data source.
        """
        if facility_names is not None:
            pulumi.set(__self__, "facility_names", facility_names)
        if log_levels is not None:
            pulumi.set(__self__, "log_levels", log_levels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceFacilityNames']]]]]:
        """
        The list of facility names.
        """
        return pulumi.get(self, "facility_names")

    @facility_names.setter
    def facility_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceFacilityNames']]]]]):
        pulumi.set(self, "facility_names", value)

    @property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceLogLevels']]]]]:
        """
        The log levels to collect.
        """
        return pulumi.get(self, "log_levels")

    @log_levels.setter
    def log_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceLogLevels']]]]]):
        pulumi.set(self, "log_levels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownSyslogDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class WindowsEventLogDataSourceArgsDict(TypedDict):
        """
        Definition of which Windows Event Log events will be collected and how they will be collected.
        Only collected from Windows machines.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsEventLogDataSourceStreams']]]]]
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform the data source.
        """
        x_path_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Windows Event Log queries in XPATH format.
        """
elif False:
    WindowsEventLogDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsEventLogDataSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsEventLogDataSourceStreams']]]]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None,
                 x_path_queries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Definition of which Windows Event Log events will be collected and how they will be collected.
        Only collected from Windows machines.
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsEventLogDataSourceStreams']]]] streams: List of streams that this data source will be sent to.
               A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param pulumi.Input[str] transform_kql: The KQL query to transform the data source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_path_queries: A list of Windows Event Log queries in XPATH format.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)
        if x_path_queries is not None:
            pulumi.set(__self__, "x_path_queries", x_path_queries)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsEventLogDataSourceStreams']]]]]:
        """
        List of streams that this data source will be sent to.
        A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsEventLogDataSourceStreams']]]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform the data source.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)

    @property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Windows Event Log queries in XPATH format.
        """
        return pulumi.get(self, "x_path_queries")

    @x_path_queries.setter
    def x_path_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_path_queries", value)


if not MYPY:
    class WindowsFirewallLogsDataSourceArgsDict(TypedDict):
        """
        Enables Firewall logs to be collected by this data collection rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Firewall logs streams
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        profile_filter: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsFirewallLogsDataSourceProfileFilter']]]]]
        """
        Firewall logs profile filter
        """
elif False:
    WindowsFirewallLogsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFirewallLogsDataSourceArgs:
    def __init__(__self__, *,
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: Optional[pulumi.Input[str]] = None,
                 profile_filter: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsFirewallLogsDataSourceProfileFilter']]]]] = None):
        """
        Enables Firewall logs to be collected by this data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Firewall logs streams
        :param pulumi.Input[str] name: A friendly name for the data source.
               This name should be unique across all data sources (regardless of type) within the data collection rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsFirewallLogsDataSourceProfileFilter']]]] profile_filter: Firewall logs profile filter
        """
        pulumi.set(__self__, "streams", streams)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if profile_filter is not None:
            pulumi.set(__self__, "profile_filter", profile_filter)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Firewall logs streams
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the data source.
        This name should be unique across all data sources (regardless of type) within the data collection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="profileFilter")
    def profile_filter(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsFirewallLogsDataSourceProfileFilter']]]]]:
        """
        Firewall logs profile filter
        """
        return pulumi.get(self, "profile_filter")

    @profile_filter.setter
    def profile_filter(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'KnownWindowsFirewallLogsDataSourceProfileFilter']]]]]):
        pulumi.set(self, "profile_filter", value)


