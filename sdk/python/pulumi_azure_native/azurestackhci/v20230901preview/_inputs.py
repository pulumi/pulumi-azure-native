# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'IPPoolArgs',
    'IPPoolArgsDict',
    'LogicalNetworkPropertiesDhcpOptionsArgs',
    'LogicalNetworkPropertiesDhcpOptionsArgsDict',
    'RouteTableArgs',
    'RouteTableArgsDict',
    'RouteArgs',
    'RouteArgsDict',
    'SubnetPropertiesFormatIpConfigurationReferencesArgs',
    'SubnetPropertiesFormatIpConfigurationReferencesArgsDict',
    'SubnetArgs',
    'SubnetArgsDict',
]

MYPY = False

if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[str] name: The name of the extended location.
        :param pulumi.Input[Union[str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IPPoolArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[str]]
        """
        End of the IP address pool
        """
        ip_pool_type: NotRequired[pulumi.Input['IPPoolTypeEnum']]
        """
        Type of the IP Pool [vm, vippool]
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the IP-Pool
        """
        start: NotRequired[pulumi.Input[str]]
        """
        Start of the IP address pool
        """
elif False:
    IPPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPPoolArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 ip_pool_type: Optional[pulumi.Input['IPPoolTypeEnum']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: End of the IP address pool
        :param pulumi.Input['IPPoolTypeEnum'] ip_pool_type: Type of the IP Pool [vm, vippool]
        :param pulumi.Input[str] name: Name of the IP-Pool
        :param pulumi.Input[str] start: Start of the IP address pool
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if ip_pool_type is not None:
            pulumi.set(__self__, "ip_pool_type", ip_pool_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        End of the IP address pool
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="ipPoolType")
    def ip_pool_type(self) -> Optional[pulumi.Input['IPPoolTypeEnum']]:
        """
        Type of the IP Pool [vm, vippool]
        """
        return pulumi.get(self, "ip_pool_type")

    @ip_pool_type.setter
    def ip_pool_type(self, value: Optional[pulumi.Input['IPPoolTypeEnum']]):
        pulumi.set(self, "ip_pool_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IP-Pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the IP address pool
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class LogicalNetworkPropertiesDhcpOptionsArgsDict(TypedDict):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of DNS servers IP addresses.
        """
elif False:
    LogicalNetworkPropertiesDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalNetworkPropertiesDhcpOptionsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: The list of DNS servers IP addresses.
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of DNS servers IP addresses.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class RouteTableArgsDict(TypedDict):
        """
        Route table resource.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteArgsDict']]]]
        """
        Collection of routes contained within a route table.
        """
elif False:
    RouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]] = None):
        """
        Route table resource.
        :param pulumi.Input[Sequence[pulumi.Input['RouteArgs']]] routes: Collection of routes contained within a route table.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]:
        """
        Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class RouteArgsDict(TypedDict):
        """
        Route - Route resource.
        """
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        The destination CIDR to which the route applies.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - name of the subnet
        """
        next_hop_ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
elif False:
    RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 next_hop_ip_address: Optional[pulumi.Input[str]] = None):
        """
        Route - Route resource.
        :param pulumi.Input[str] address_prefix: The destination CIDR to which the route applies.
        :param pulumi.Input[str] name: Name - name of the subnet
        :param pulumi.Input[str] next_hop_ip_address: The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - name of the subnet
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @next_hop_ip_address.setter
    def next_hop_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_ip_address", value)


if not MYPY:
    class SubnetPropertiesFormatIpConfigurationReferencesArgsDict(TypedDict):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        """
        id: NotRequired[pulumi.Input[str]]
        """
        IPConfigurationID
        """
elif False:
    SubnetPropertiesFormatIpConfigurationReferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetPropertiesFormatIpConfigurationReferencesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        :param pulumi.Input[str] id: IPConfigurationID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        IPConfigurationID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SubnetArgsDict(TypedDict):
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of address prefixes for the subnet.
        """
        ip_allocation_method: NotRequired[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        ip_configuration_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetPropertiesFormatIpConfigurationReferencesArgsDict']]]]
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['IPPoolArgsDict']]]]
        """
        network associated pool of IP Addresses
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        route_table: NotRequired[pulumi.Input['RouteTableArgsDict']]
        """
        Route table resource.
        """
        vlan: NotRequired[pulumi.Input[int]]
        """
        Vlan to use for the subnet
        """
elif False:
    SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_allocation_method: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]] = None,
                 ip_configuration_references: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetPropertiesFormatIpConfigurationReferencesArgs']]]] = None,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 route_table: Optional[pulumi.Input['RouteTableArgs']] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] address_prefix: The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_prefixes: List of address prefixes for the subnet.
        :param pulumi.Input[Union[str, 'IpAllocationMethodEnum']] ip_allocation_method: IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input[Sequence[pulumi.Input['SubnetPropertiesFormatIpConfigurationReferencesArgs']]] ip_configuration_references: IPConfigurationReferences - list of IPConfigurationReferences
        :param pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]] ip_pools: network associated pool of IP Addresses
        :param pulumi.Input[str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['RouteTableArgs'] route_table: Route table resource.
        :param pulumi.Input[int] vlan: Vlan to use for the subnet
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if ip_allocation_method is not None:
            pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        if ip_configuration_references is not None:
            pulumi.set(__self__, "ip_configuration_references", ip_configuration_references)
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]:
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "ip_allocation_method")

    @ip_allocation_method.setter
    def ip_allocation_method(self, value: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]):
        pulumi.set(self, "ip_allocation_method", value)

    @property
    @pulumi.getter(name="ipConfigurationReferences")
    def ip_configuration_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetPropertiesFormatIpConfigurationReferencesArgs']]]]:
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        return pulumi.get(self, "ip_configuration_references")

    @ip_configuration_references.setter
    def ip_configuration_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetPropertiesFormatIpConfigurationReferencesArgs']]]]):
        pulumi.set(self, "ip_configuration_references", value)

    @property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]:
        """
        network associated pool of IP Addresses
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]):
        pulumi.set(self, "ip_pools", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['RouteTableArgs']]:
        """
        Route table resource.
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['RouteTableArgs']]):
        pulumi.set(self, "route_table", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        Vlan to use for the subnet
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


