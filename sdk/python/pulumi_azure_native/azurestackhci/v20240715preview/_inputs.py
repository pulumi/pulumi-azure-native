# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'GalleryImageIdentifierArgs',
    'GalleryImageIdentifierArgsDict',
    'GalleryImageVersionArgs',
    'GalleryImageVersionArgsDict',
    'GuestCredentialArgs',
    'GuestCredentialArgsDict',
    'HttpProxyConfigurationArgs',
    'HttpProxyConfigurationArgsDict',
    'IPConfigurationPropertiesArgs',
    'IPConfigurationPropertiesArgsDict',
    'IPConfigurationArgs',
    'IPConfigurationArgsDict',
    'IPPoolArgs',
    'IPPoolArgsDict',
    'ImageArmReferenceArgs',
    'ImageArmReferenceArgsDict',
    'InterfaceDNSSettingsArgs',
    'InterfaceDNSSettingsArgsDict',
    'LogicalNetworkArmReferenceArgs',
    'LogicalNetworkArmReferenceArgsDict',
    'LogicalNetworkPropertiesDhcpOptionsArgs',
    'LogicalNetworkPropertiesDhcpOptionsArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'NetworkInterfaceArmReferenceArgs',
    'NetworkInterfaceArmReferenceArgsDict',
    'NetworkSecurityGroupArmReferenceArgs',
    'NetworkSecurityGroupArmReferenceArgsDict',
    'RouteTableArgs',
    'RouteTableArgsDict',
    'RouteArgs',
    'RouteArgsDict',
    'SshConfigurationArgs',
    'SshConfigurationArgsDict',
    'SshPublicKeyArgs',
    'SshPublicKeyArgsDict',
    'SubnetIpConfigurationReferenceArgs',
    'SubnetIpConfigurationReferenceArgsDict',
    'SubnetArgs',
    'SubnetArgsDict',
    'VirtualHardDiskArmReferenceArgs',
    'VirtualHardDiskArmReferenceArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs',
    'VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs',
    'VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileArgs',
    'VirtualMachineInstancePropertiesHardwareProfileArgsDict',
    'VirtualMachineInstancePropertiesNetworkProfileArgs',
    'VirtualMachineInstancePropertiesNetworkProfileArgsDict',
    'VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs',
    'VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict',
    'VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs',
    'VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict',
    'VirtualMachineInstancePropertiesOsProfileArgs',
    'VirtualMachineInstancePropertiesOsProfileArgsDict',
    'VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs',
    'VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict',
    'VirtualMachineInstancePropertiesSecurityProfileArgs',
    'VirtualMachineInstancePropertiesSecurityProfileArgsDict',
    'VirtualMachineInstancePropertiesStorageProfileOsDiskArgs',
    'VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict',
    'VirtualMachineInstancePropertiesStorageProfileArgs',
    'VirtualMachineInstancePropertiesStorageProfileArgsDict',
]

MYPY = False

if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[str] name: The name of the extended location.
        :param pulumi.Input[Union[str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GalleryImageIdentifierArgsDict(TypedDict):
        """
        This is the gallery image definition identifier.
        """
        offer: pulumi.Input[str]
        """
        The name of the gallery image definition offer.
        """
        publisher: pulumi.Input[str]
        """
        The name of the gallery image definition publisher.
        """
        sku: pulumi.Input[str]
        """
        The name of the gallery image definition SKU.
        """
elif False:
    GalleryImageIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageIdentifierArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str]):
        """
        This is the gallery image definition identifier.
        :param pulumi.Input[str] offer: The name of the gallery image definition offer.
        :param pulumi.Input[str] publisher: The name of the gallery image definition publisher.
        :param pulumi.Input[str] sku: The name of the gallery image definition SKU.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition offer.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition SKU.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class GalleryImageVersionArgsDict(TypedDict):
        """
        Specifies information about the gallery image version that you want to create or update.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        This is the version of the gallery image.
        """
elif False:
    GalleryImageVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageVersionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Specifies information about the gallery image version that you want to create or update.
        :param pulumi.Input[str] name: This is the version of the gallery image.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This is the version of the gallery image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GuestCredentialArgsDict(TypedDict):
        """
        Username / Password Credentials to connect to guest.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password to connect with the guest.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username to connect with the guest.
        """
elif False:
    GuestCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuestCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Username / Password Credentials to connect to guest.
        :param pulumi.Input[str] password: The password to connect with the guest.
        :param pulumi.Input[str] username: The username to connect with the guest.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to connect with the guest.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to connect with the guest.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class HttpProxyConfigurationArgsDict(TypedDict):
        """
        HTTP Proxy configuration for the VM.
        """
        http_proxy: NotRequired[pulumi.Input[str]]
        """
        The HTTP proxy server endpoint to use.
        """
        https_proxy: NotRequired[pulumi.Input[str]]
        """
        The HTTPS proxy server endpoint to use.
        """
        no_proxy: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The endpoints that should not go through proxy.
        """
        trusted_ca: NotRequired[pulumi.Input[str]]
        """
        Alternative CA cert to use for connecting to proxy servers.
        """
elif False:
    HttpProxyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpProxyConfigurationArgs:
    def __init__(__self__, *,
                 http_proxy: Optional[pulumi.Input[str]] = None,
                 https_proxy: Optional[pulumi.Input[str]] = None,
                 no_proxy: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 trusted_ca: Optional[pulumi.Input[str]] = None):
        """
        HTTP Proxy configuration for the VM.
        :param pulumi.Input[str] http_proxy: The HTTP proxy server endpoint to use.
        :param pulumi.Input[str] https_proxy: The HTTPS proxy server endpoint to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] no_proxy: The endpoints that should not go through proxy.
        :param pulumi.Input[str] trusted_ca: Alternative CA cert to use for connecting to proxy servers.
        """
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if trusted_ca is not None:
            pulumi.set(__self__, "trusted_ca", trusted_ca)

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP proxy server endpoint to use.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_proxy", value)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTPS proxy server endpoint to use.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_proxy", value)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The endpoints that should not go through proxy.
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxy", value)

    @property
    @pulumi.getter(name="trustedCa")
    def trusted_ca(self) -> Optional[pulumi.Input[str]]:
        """
        Alternative CA cert to use for connecting to proxy servers.
        """
        return pulumi.get(self, "trusted_ca")

    @trusted_ca.setter
    def trusted_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca", value)


if not MYPY:
    class IPConfigurationPropertiesArgsDict(TypedDict):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        subnet: NotRequired[pulumi.Input['LogicalNetworkArmReferenceArgsDict']]
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
elif False:
    IPConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']] = None):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        :param pulumi.Input[str] private_ip_address: PrivateIPAddress - Private IP address of the IP configuration.
        :param pulumi.Input['LogicalNetworkArmReferenceArgs'] subnet: Subnet - Name of Subnet bound to the IP configuration.
        """
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']]:
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class IPConfigurationArgsDict(TypedDict):
        """
        InterfaceIPConfiguration IPConfiguration in a network interface.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        properties: NotRequired[pulumi.Input['IPConfigurationPropertiesArgsDict']]
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
elif False:
    IPConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input['IPConfigurationPropertiesArgs']] = None):
        """
        InterfaceIPConfiguration IPConfiguration in a network interface.
        :param pulumi.Input[str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['IPConfigurationPropertiesArgs'] properties: InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['IPConfigurationPropertiesArgs']]:
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['IPConfigurationPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class IPPoolArgsDict(TypedDict):
        """
        Describes IPPool
        """
        end: NotRequired[pulumi.Input[str]]
        """
        End of the IP address pool
        """
        ip_pool_type: NotRequired[pulumi.Input[Union[str, 'IPPoolTypeEnum']]]
        """
        Type of the IP Pool [vm, vippool]
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the IP-Pool
        """
        start: NotRequired[pulumi.Input[str]]
        """
        Start of the IP address pool
        """
elif False:
    IPPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPPoolArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 ip_pool_type: Optional[pulumi.Input[Union[str, 'IPPoolTypeEnum']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        Describes IPPool
        :param pulumi.Input[str] end: End of the IP address pool
        :param pulumi.Input[Union[str, 'IPPoolTypeEnum']] ip_pool_type: Type of the IP Pool [vm, vippool]
        :param pulumi.Input[str] name: Name of the IP-Pool
        :param pulumi.Input[str] start: Start of the IP address pool
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if ip_pool_type is not None:
            pulumi.set(__self__, "ip_pool_type", ip_pool_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        End of the IP address pool
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="ipPoolType")
    def ip_pool_type(self) -> Optional[pulumi.Input[Union[str, 'IPPoolTypeEnum']]]:
        """
        Type of the IP Pool [vm, vippool]
        """
        return pulumi.get(self, "ip_pool_type")

    @ip_pool_type.setter
    def ip_pool_type(self, value: Optional[pulumi.Input[Union[str, 'IPPoolTypeEnum']]]):
        pulumi.set(self, "ip_pool_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IP-Pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the IP address pool
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class ImageArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Gallery Image.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for an image resource used by the virtual machine instance.
        """
elif False:
    ImageArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Gallery Image.
        :param pulumi.Input[str] id: The ARM ID for an image resource used by the virtual machine instance.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for an image resource used by the virtual machine instance.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InterfaceDNSSettingsArgsDict(TypedDict):
        """
        DNS Settings of the interface
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of DNS server IP Addresses for the interface
        """
elif False:
    InterfaceDNSSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterfaceDNSSettingsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DNS Settings of the interface
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: List of DNS server IP Addresses for the interface
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of DNS server IP Addresses for the interface
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class LogicalNetworkArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Logical Network.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Logical Network.
        """
elif False:
    LogicalNetworkArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalNetworkArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Logical Network.
        :param pulumi.Input[str] id: The ARM ID for a Logical Network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Logical Network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LogicalNetworkPropertiesDhcpOptionsArgsDict(TypedDict):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of DNS servers IP addresses.
        """
elif False:
    LogicalNetworkPropertiesDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalNetworkPropertiesDhcpOptionsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: The list of DNS servers IP addresses.
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of DNS servers IP addresses.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class NetworkInterfaceArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Interface.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Network Interface.
        """
elif False:
    NetworkInterfaceArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Network Interface.
        :param pulumi.Input[str] id: The ARM ID for a Network Interface.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Network Interface.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NetworkSecurityGroupArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Security Group.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Network Security Group.
        """
elif False:
    NetworkSecurityGroupArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityGroupArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Network Security Group.
        :param pulumi.Input[str] id: The ARM ID for a Network Security Group.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Network Security Group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RouteTableArgsDict(TypedDict):
        """
        Route table resource.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteArgsDict']]]]
        """
        Collection of routes contained within a route table.
        """
elif False:
    RouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]] = None):
        """
        Route table resource.
        :param pulumi.Input[Sequence[pulumi.Input['RouteArgs']]] routes: Collection of routes contained within a route table.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]:
        """
        Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class RouteArgsDict(TypedDict):
        """
        Route - Route resource.
        """
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        The destination CIDR to which the route applies.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - name of the subnet
        """
        next_hop_ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
elif False:
    RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 next_hop_ip_address: Optional[pulumi.Input[str]] = None):
        """
        Route - Route resource.
        :param pulumi.Input[str] address_prefix: The destination CIDR to which the route applies.
        :param pulumi.Input[str] name: Name - name of the subnet
        :param pulumi.Input[str] next_hop_ip_address: The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - name of the subnet
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @next_hop_ip_address.setter
    def next_hop_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_ip_address", value)


if not MYPY:
    class SshConfigurationArgsDict(TypedDict):
        """
        SSH configuration for Linux based VMs running on Azure
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgsDict']]]]
        """
        The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    SshConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshConfigurationArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]] = None):
        """
        SSH configuration for Linux based VMs running on Azure
        :param pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]] public_keys: The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]:
        """
        The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class SshPublicKeyArgsDict(TypedDict):
        """
        Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
        """
        key_data: NotRequired[pulumi.Input[str]]
        """
        SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    SshPublicKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshPublicKeyArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
        :param pulumi.Input[str] key_data: SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        :param pulumi.Input[str] path: Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[str]]:
        """
        SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class SubnetIpConfigurationReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Interface.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Network Interface.
        """
elif False:
    SubnetIpConfigurationReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetIpConfigurationReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Network Interface.
        :param pulumi.Input[str] id: The ARM ID for a Network Interface.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Network Interface.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SubnetArgsDict(TypedDict):
        """
        Properties of the subnet.
        """
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of address prefixes for the subnet.
        """
        ip_allocation_method: NotRequired[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        ip_configuration_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgsDict']]]]
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['IPPoolArgsDict']]]]
        """
        network associated pool of IP Addresses
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        network_security_group: NotRequired[pulumi.Input['NetworkSecurityGroupArmReferenceArgsDict']]
        """
        NetworkSecurityGroup - Network Security Group attached to the logical network.
        """
        route_table: NotRequired[pulumi.Input['RouteTableArgsDict']]
        """
        Route table resource.
        """
        vlan: NotRequired[pulumi.Input[int]]
        """
        Vlan to use for the subnet
        """
elif False:
    SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_allocation_method: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]] = None,
                 ip_configuration_references: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]] = None,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_security_group: Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']] = None,
                 route_table: Optional[pulumi.Input['RouteTableArgs']] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        Properties of the subnet.
        :param pulumi.Input[str] address_prefix: The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_prefixes: List of address prefixes for the subnet.
        :param pulumi.Input[Union[str, 'IpAllocationMethodEnum']] ip_allocation_method: IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]] ip_configuration_references: IPConfigurationReferences - list of IPConfigurationReferences
        :param pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]] ip_pools: network associated pool of IP Addresses
        :param pulumi.Input[str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['NetworkSecurityGroupArmReferenceArgs'] network_security_group: NetworkSecurityGroup - Network Security Group attached to the logical network.
        :param pulumi.Input['RouteTableArgs'] route_table: Route table resource.
        :param pulumi.Input[int] vlan: Vlan to use for the subnet
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if ip_allocation_method is not None:
            pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        if ip_configuration_references is not None:
            pulumi.set(__self__, "ip_configuration_references", ip_configuration_references)
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_security_group is not None:
            pulumi.set(__self__, "network_security_group", network_security_group)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]:
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "ip_allocation_method")

    @ip_allocation_method.setter
    def ip_allocation_method(self, value: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]):
        pulumi.set(self, "ip_allocation_method", value)

    @property
    @pulumi.getter(name="ipConfigurationReferences")
    def ip_configuration_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]]:
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        return pulumi.get(self, "ip_configuration_references")

    @ip_configuration_references.setter
    def ip_configuration_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]]):
        pulumi.set(self, "ip_configuration_references", value)

    @property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]:
        """
        network associated pool of IP Addresses
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]):
        pulumi.set(self, "ip_pools", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkSecurityGroup")
    def network_security_group(self) -> Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']]:
        """
        NetworkSecurityGroup - Network Security Group attached to the logical network.
        """
        return pulumi.get(self, "network_security_group")

    @network_security_group.setter
    def network_security_group(self, value: Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']]):
        pulumi.set(self, "network_security_group", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['RouteTableArgs']]:
        """
        Route table resource.
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['RouteTableArgs']]):
        pulumi.set(self, "route_table", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        Vlan to use for the subnet
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class VirtualHardDiskArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Virtual Hard Disk.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Virtual Hard Disk.
        """
elif False:
    VirtualHardDiskArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualHardDiskArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The ARM ID for a Virtual Hard Disk.
        :param pulumi.Input[str] id: The ARM ID for a Virtual Hard Disk.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Virtual Hard Disk.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict(TypedDict):
        """
        Dynamic memory config
        """
        maximum_memory_mb: NotRequired[pulumi.Input[float]]
        """
        Maximum memory in MB
        """
        minimum_memory_mb: NotRequired[pulumi.Input[float]]
        """
        Minimum memory in MB
        """
        target_memory_buffer: NotRequired[pulumi.Input[int]]
        """
        Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs:
    def __init__(__self__, *,
                 maximum_memory_mb: Optional[pulumi.Input[float]] = None,
                 minimum_memory_mb: Optional[pulumi.Input[float]] = None,
                 target_memory_buffer: Optional[pulumi.Input[int]] = None):
        """
        Dynamic memory config
        :param pulumi.Input[float] maximum_memory_mb: Maximum memory in MB
        :param pulumi.Input[float] minimum_memory_mb: Minimum memory in MB
        :param pulumi.Input[int] target_memory_buffer: Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        if maximum_memory_mb is not None:
            pulumi.set(__self__, "maximum_memory_mb", maximum_memory_mb)
        if minimum_memory_mb is not None:
            pulumi.set(__self__, "minimum_memory_mb", minimum_memory_mb)
        if target_memory_buffer is not None:
            pulumi.set(__self__, "target_memory_buffer", target_memory_buffer)

    @property
    @pulumi.getter(name="maximumMemoryMB")
    def maximum_memory_mb(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum memory in MB
        """
        return pulumi.get(self, "maximum_memory_mb")

    @maximum_memory_mb.setter
    def maximum_memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "maximum_memory_mb", value)

    @property
    @pulumi.getter(name="minimumMemoryMB")
    def minimum_memory_mb(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum memory in MB
        """
        return pulumi.get(self, "minimum_memory_mb")

    @minimum_memory_mb.setter
    def minimum_memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "minimum_memory_mb", value)

    @property
    @pulumi.getter(name="targetMemoryBuffer")
    def target_memory_buffer(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        return pulumi.get(self, "target_memory_buffer")

    @target_memory_buffer.setter
    def target_memory_buffer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_memory_buffer", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict(TypedDict):
        """
        GPU properties - describes the GPU configuration.
        """
        assignment_type: pulumi.Input[Union[str, 'GpuAssignmentTypeEnum']]
        """
        GPU assignment type
        """
        gpu_name: NotRequired[pulumi.Input[str]]
        """
        Name of the GPU
        """
        partition_size_mb: NotRequired[pulumi.Input[float]]
        """
        Size of gpu partition in MB for GPU-P
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs:
    def __init__(__self__, *,
                 assignment_type: pulumi.Input[Union[str, 'GpuAssignmentTypeEnum']],
                 gpu_name: Optional[pulumi.Input[str]] = None,
                 partition_size_mb: Optional[pulumi.Input[float]] = None):
        """
        GPU properties - describes the GPU configuration.
        :param pulumi.Input[Union[str, 'GpuAssignmentTypeEnum']] assignment_type: GPU assignment type
        :param pulumi.Input[str] gpu_name: Name of the GPU
        :param pulumi.Input[float] partition_size_mb: Size of gpu partition in MB for GPU-P
        """
        pulumi.set(__self__, "assignment_type", assignment_type)
        if gpu_name is not None:
            pulumi.set(__self__, "gpu_name", gpu_name)
        if partition_size_mb is not None:
            pulumi.set(__self__, "partition_size_mb", partition_size_mb)

    @property
    @pulumi.getter(name="assignmentType")
    def assignment_type(self) -> pulumi.Input[Union[str, 'GpuAssignmentTypeEnum']]:
        """
        GPU assignment type
        """
        return pulumi.get(self, "assignment_type")

    @assignment_type.setter
    def assignment_type(self, value: pulumi.Input[Union[str, 'GpuAssignmentTypeEnum']]):
        pulumi.set(self, "assignment_type", value)

    @property
    @pulumi.getter(name="gpuName")
    def gpu_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the GPU
        """
        return pulumi.get(self, "gpu_name")

    @gpu_name.setter
    def gpu_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_name", value)

    @property
    @pulumi.getter(name="partitionSizeMB")
    def partition_size_mb(self) -> Optional[pulumi.Input[float]]:
        """
        Size of gpu partition in MB for GPU-P
        """
        return pulumi.get(self, "partition_size_mb")

    @partition_size_mb.setter
    def partition_size_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "partition_size_mb", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileArgsDict(TypedDict):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine instance.
        """
        dynamic_memory_config: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict']]
        """
        Dynamic memory config
        """
        memory_mb: NotRequired[pulumi.Input[float]]
        """
        RAM in MB for the virtual machine instance
        """
        processors: NotRequired[pulumi.Input[int]]
        """
        number of processors for the virtual machine instance
        """
        virtual_machine_gpus: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict']]]]
        """
        virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        """
        vm_size: NotRequired[pulumi.Input[Union[str, 'VmSizeEnum']]]
        """
        Enum of VM Sizes
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileArgs:
    def __init__(__self__, *,
                 dynamic_memory_config: Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']] = None,
                 memory_mb: Optional[pulumi.Input[float]] = None,
                 processors: Optional[pulumi.Input[int]] = None,
                 virtual_machine_gpus: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]] = None,
                 vm_size: Optional[pulumi.Input[Union[str, 'VmSizeEnum']]] = None):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine instance.
        :param pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs'] dynamic_memory_config: Dynamic memory config
        :param pulumi.Input[float] memory_mb: RAM in MB for the virtual machine instance
        :param pulumi.Input[int] processors: number of processors for the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]] virtual_machine_gpus: virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        :param pulumi.Input[Union[str, 'VmSizeEnum']] vm_size: Enum of VM Sizes
        """
        if dynamic_memory_config is not None:
            pulumi.set(__self__, "dynamic_memory_config", dynamic_memory_config)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if virtual_machine_gpus is not None:
            pulumi.set(__self__, "virtual_machine_gpus", virtual_machine_gpus)
        if vm_size is None:
            vm_size = 'Default'
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="dynamicMemoryConfig")
    def dynamic_memory_config(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']]:
        """
        Dynamic memory config
        """
        return pulumi.get(self, "dynamic_memory_config")

    @dynamic_memory_config.setter
    def dynamic_memory_config(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']]):
        pulumi.set(self, "dynamic_memory_config", value)

    @property
    @pulumi.getter(name="memoryMB")
    def memory_mb(self) -> Optional[pulumi.Input[float]]:
        """
        RAM in MB for the virtual machine instance
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[int]]:
        """
        number of processors for the virtual machine instance
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "processors", value)

    @property
    @pulumi.getter(name="virtualMachineGPUs")
    def virtual_machine_gpus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]]:
        """
        virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        """
        return pulumi.get(self, "virtual_machine_gpus")

    @virtual_machine_gpus.setter
    def virtual_machine_gpus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]]):
        pulumi.set(self, "virtual_machine_gpus", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[Union[str, 'VmSizeEnum']]]:
        """
        Enum of VM Sizes
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[Union[str, 'VmSizeEnum']]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class VirtualMachineInstancePropertiesNetworkProfileArgsDict(TypedDict):
        """
        NetworkProfile - describes the network configuration the virtual machine instance
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgsDict']]]]
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]] = None):
        """
        NetworkProfile - describes the network configuration the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]] network_interfaces: NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]]:
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict(TypedDict):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        disable_password_authentication: NotRequired[pulumi.Input[bool]]
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        provision_vm_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        provision_vm_config_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['SshConfigurationArgsDict']]
        """
        Specifies the ssh key configuration for a Linux OS.
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs:
    def __init__(__self__, *,
                 disable_password_authentication: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 provision_vm_config_agent: Optional[pulumi.Input[bool]] = None,
                 ssh: Optional[pulumi.Input['SshConfigurationArgs']] = None):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        :param pulumi.Input[bool] disable_password_authentication: DisablePasswordAuthentication - whether password authentication should be disabled
        :param pulumi.Input[bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        :param pulumi.Input[bool] provision_vm_config_agent: Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        :param pulumi.Input['SshConfigurationArgs'] ssh: Specifies the ssh key configuration for a Linux OS.
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if provision_vm_agent is None:
            provision_vm_agent = True
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if provision_vm_config_agent is None:
            provision_vm_config_agent = True
        if provision_vm_config_agent is not None:
            pulumi.set(__self__, "provision_vm_config_agent", provision_vm_config_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter(name="provisionVMConfigAgent")
    def provision_vm_config_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_config_agent")

    @provision_vm_config_agent.setter
    def provision_vm_config_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_config_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['SshConfigurationArgs']]:
        """
        Specifies the ssh key configuration for a Linux OS.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['SshConfigurationArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict(TypedDict):
        """
        Windows Configuration for the virtual machine instance
        """
        enable_automatic_updates: NotRequired[pulumi.Input[bool]]
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        provision_vm_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        provision_vm_config_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['SshConfigurationArgsDict']]
        """
        Specifies the ssh key configuration for Windows OS.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        TimeZone for the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs:
    def __init__(__self__, *,
                 enable_automatic_updates: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 provision_vm_config_agent: Optional[pulumi.Input[bool]] = None,
                 ssh: Optional[pulumi.Input['SshConfigurationArgs']] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Windows Configuration for the virtual machine instance
        :param pulumi.Input[bool] enable_automatic_updates: Whether to EnableAutomaticUpdates on the machine
        :param pulumi.Input[bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        :param pulumi.Input[bool] provision_vm_config_agent: Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        :param pulumi.Input['SshConfigurationArgs'] ssh: Specifies the ssh key configuration for Windows OS.
        :param pulumi.Input[str] time_zone: TimeZone for the virtual machine instance
        """
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if provision_vm_agent is None:
            provision_vm_agent = True
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if provision_vm_config_agent is None:
            provision_vm_config_agent = True
        if provision_vm_config_agent is not None:
            pulumi.set(__self__, "provision_vm_config_agent", provision_vm_config_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        return pulumi.get(self, "enable_automatic_updates")

    @enable_automatic_updates.setter
    def enable_automatic_updates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_updates", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter(name="provisionVMConfigAgent")
    def provision_vm_config_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_config_agent")

    @provision_vm_config_agent.setter
    def provision_vm_config_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_config_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['SshConfigurationArgs']]:
        """
        Specifies the ssh key configuration for Windows OS.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['SshConfigurationArgs']]):
        pulumi.set(self, "ssh", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        TimeZone for the virtual machine instance
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileArgsDict(TypedDict):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        """
        admin_password: NotRequired[pulumi.Input[str]]
        """
        AdminPassword - admin password
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        AdminUsername - admin username
        """
        computer_name: NotRequired[pulumi.Input[str]]
        """
        ComputerName - name of the compute
        """
        linux_configuration: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict']]
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        windows_configuration: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict']]
        """
        Windows Configuration for the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 computer_name: Optional[pulumi.Input[str]] = None,
                 linux_configuration: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']] = None,
                 windows_configuration: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']] = None):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        :param pulumi.Input[str] admin_password: AdminPassword - admin password
        :param pulumi.Input[str] admin_username: AdminUsername - admin username
        :param pulumi.Input[str] computer_name: ComputerName - name of the compute
        :param pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs'] linux_configuration: LinuxConfiguration - linux specific configuration values for the virtual machine instance
        :param pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs'] windows_configuration: Windows Configuration for the virtual machine instance
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if computer_name is not None:
            pulumi.set(__self__, "computer_name", computer_name)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        AdminPassword - admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        AdminUsername - admin username
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> Optional[pulumi.Input[str]]:
        """
        ComputerName - name of the compute
        """
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']]:
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']]:
        """
        Windows Configuration for the virtual machine instance
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


if not MYPY:
    class VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict(TypedDict):
        """
        Uefi settings - Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether secure boot should be enabled on the virtual machine instance.
        """
elif False:
    VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs:
    def __init__(__self__, *,
                 secure_boot_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Uefi settings - Specifies whether secure boot should be enabled on the virtual machine instance.
        :param pulumi.Input[bool] secure_boot_enabled: Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        if secure_boot_enabled is None:
            secure_boot_enabled = False
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        return pulumi.get(self, "secure_boot_enabled")

    @secure_boot_enabled.setter
    def secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure_boot_enabled", value)


if not MYPY:
    class VirtualMachineInstancePropertiesSecurityProfileArgsDict(TypedDict):
        """
        SecurityProfile - Specifies the security settings for the virtual machine instance.
        """
        enable_tpm: NotRequired[pulumi.Input[bool]]
        """
        Enable TPM flag
        """
        security_type: NotRequired[pulumi.Input[Union[str, 'SecurityTypes']]]
        """
        Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        """
        uefi_settings: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict']]
        """
        Uefi settings of the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesSecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesSecurityProfileArgs:
    def __init__(__self__, *,
                 enable_tpm: Optional[pulumi.Input[bool]] = None,
                 security_type: Optional[pulumi.Input[Union[str, 'SecurityTypes']]] = None,
                 uefi_settings: Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']] = None):
        """
        SecurityProfile - Specifies the security settings for the virtual machine instance.
        :param pulumi.Input[bool] enable_tpm: Enable TPM flag
        :param pulumi.Input[Union[str, 'SecurityTypes']] security_type: Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        :param pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs'] uefi_settings: Uefi settings of the virtual machine instance
        """
        if enable_tpm is None:
            enable_tpm = False
        if enable_tpm is not None:
            pulumi.set(__self__, "enable_tpm", enable_tpm)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if uefi_settings is not None:
            pulumi.set(__self__, "uefi_settings", uefi_settings)

    @property
    @pulumi.getter(name="enableTPM")
    def enable_tpm(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable TPM flag
        """
        return pulumi.get(self, "enable_tpm")

    @enable_tpm.setter
    def enable_tpm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tpm", value)

    @property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[pulumi.Input[Union[str, 'SecurityTypes']]]:
        """
        Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        """
        return pulumi.get(self, "security_type")

    @security_type.setter
    def security_type(self, value: Optional[pulumi.Input[Union[str, 'SecurityTypes']]]):
        pulumi.set(self, "security_type", value)

    @property
    @pulumi.getter(name="uefiSettings")
    def uefi_settings(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']]:
        """
        Uefi settings of the virtual machine instance
        """
        return pulumi.get(self, "uefi_settings")

    @uefi_settings.setter
    def uefi_settings(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']]):
        pulumi.set(self, "uefi_settings", value)


if not MYPY:
    class VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict(TypedDict):
        """
        VHD to attach as OS disk
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID for a Virtual Hard Disk.
        """
        os_type: NotRequired[pulumi.Input[Union[str, 'OperatingSystemTypes']]]
        """
        This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
elif False:
    VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesStorageProfileOsDiskArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[Union[str, 'OperatingSystemTypes']]] = None):
        """
        VHD to attach as OS disk
        :param pulumi.Input[str] id: The ARM ID for a Virtual Hard Disk.
        :param pulumi.Input[Union[str, 'OperatingSystemTypes']] os_type: This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID for a Virtual Hard Disk.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[str, 'OperatingSystemTypes']]]:
        """
        This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[str, 'OperatingSystemTypes']]]):
        pulumi.set(self, "os_type", value)


if not MYPY:
    class VirtualMachineInstancePropertiesStorageProfileArgsDict(TypedDict):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine instance
        """
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgsDict']]]]
        """
        adds data disks to the virtual machine instance
        """
        image_reference: NotRequired[pulumi.Input['ImageArmReferenceArgsDict']]
        """
        Which Image to use for the virtual machine instance
        """
        os_disk: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict']]
        """
        VHD to attach as OS disk
        """
        vm_config_storage_path_id: NotRequired[pulumi.Input[str]]
        """
        Id of the storage container that hosts the VM configuration file
        """
elif False:
    VirtualMachineInstancePropertiesStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesStorageProfileArgs:
    def __init__(__self__, *,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]] = None,
                 image_reference: Optional[pulumi.Input['ImageArmReferenceArgs']] = None,
                 os_disk: Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']] = None,
                 vm_config_storage_path_id: Optional[pulumi.Input[str]] = None):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]] data_disks: adds data disks to the virtual machine instance
        :param pulumi.Input['ImageArmReferenceArgs'] image_reference: Which Image to use for the virtual machine instance
        :param pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs'] os_disk: VHD to attach as OS disk
        :param pulumi.Input[str] vm_config_storage_path_id: Id of the storage container that hosts the VM configuration file
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if image_reference is not None:
            pulumi.set(__self__, "image_reference", image_reference)
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if vm_config_storage_path_id is not None:
            pulumi.set(__self__, "vm_config_storage_path_id", vm_config_storage_path_id)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]]:
        """
        adds data disks to the virtual machine instance
        """
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="imageReference")
    def image_reference(self) -> Optional[pulumi.Input['ImageArmReferenceArgs']]:
        """
        Which Image to use for the virtual machine instance
        """
        return pulumi.get(self, "image_reference")

    @image_reference.setter
    def image_reference(self, value: Optional[pulumi.Input['ImageArmReferenceArgs']]):
        pulumi.set(self, "image_reference", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']]:
        """
        VHD to attach as OS disk
        """
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="vmConfigStoragePathId")
    def vm_config_storage_path_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the storage container that hosts the VM configuration file
        """
        return pulumi.get(self, "vm_config_storage_path_id")

    @vm_config_storage_path_id.setter
    def vm_config_storage_path_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_config_storage_path_id", value)


