# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ArcConnectivityPropertiesArgs',
    'ArcConnectivityPropertiesArgsDict',
    'ClusterDesiredPropertiesArgs',
    'ClusterDesiredPropertiesArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'GalleryImageIdentifierArgs',
    'GalleryImageIdentifierArgsDict',
    'GalleryImageVersionArgs',
    'GalleryImageVersionArgsDict',
    'GuestCredentialArgs',
    'GuestCredentialArgsDict',
    'HttpProxyConfigurationArgs',
    'HttpProxyConfigurationArgsDict',
    'IPConfigurationPropertiesArgs',
    'IPConfigurationPropertiesArgsDict',
    'IPConfigurationSubnetArgs',
    'IPConfigurationSubnetArgsDict',
    'IPConfigurationArgs',
    'IPConfigurationArgsDict',
    'IPPoolArgs',
    'IPPoolArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'InterfaceDNSSettingsArgs',
    'InterfaceDNSSettingsArgsDict',
    'SoftwareAssurancePropertiesArgs',
    'SoftwareAssurancePropertiesArgsDict',
    'StepArgs',
    'StepArgsDict',
    'UpdatePrerequisiteArgs',
    'UpdatePrerequisiteArgsDict',
    'VirtualMachinePropertiesDataDisksArgs',
    'VirtualMachinePropertiesDataDisksArgsDict',
    'VirtualMachinePropertiesDynamicMemoryConfigArgs',
    'VirtualMachinePropertiesDynamicMemoryConfigArgsDict',
    'VirtualMachinePropertiesHardwareProfileArgs',
    'VirtualMachinePropertiesHardwareProfileArgsDict',
    'VirtualMachinePropertiesImageReferenceArgs',
    'VirtualMachinePropertiesImageReferenceArgsDict',
    'VirtualMachinePropertiesLinuxConfigurationArgs',
    'VirtualMachinePropertiesLinuxConfigurationArgsDict',
    'VirtualMachinePropertiesNetworkInterfacesArgs',
    'VirtualMachinePropertiesNetworkInterfacesArgsDict',
    'VirtualMachinePropertiesNetworkProfileArgs',
    'VirtualMachinePropertiesNetworkProfileArgsDict',
    'VirtualMachinePropertiesOsDiskArgs',
    'VirtualMachinePropertiesOsDiskArgsDict',
    'VirtualMachinePropertiesOsProfileArgs',
    'VirtualMachinePropertiesOsProfileArgsDict',
    'VirtualMachinePropertiesPublicKeysPublicKeysArgs',
    'VirtualMachinePropertiesPublicKeysPublicKeysArgsDict',
    'VirtualMachinePropertiesPublicKeysArgs',
    'VirtualMachinePropertiesPublicKeysArgsDict',
    'VirtualMachinePropertiesSecurityProfileArgs',
    'VirtualMachinePropertiesSecurityProfileArgsDict',
    'VirtualMachinePropertiesSshSshArgs',
    'VirtualMachinePropertiesSshSshArgsDict',
    'VirtualMachinePropertiesSshArgs',
    'VirtualMachinePropertiesSshArgsDict',
    'VirtualMachinePropertiesStorageProfileArgs',
    'VirtualMachinePropertiesStorageProfileArgsDict',
    'VirtualMachinePropertiesUefiSettingsArgs',
    'VirtualMachinePropertiesUefiSettingsArgsDict',
    'VirtualMachinePropertiesWindowsConfigurationArgs',
    'VirtualMachinePropertiesWindowsConfigurationArgsDict',
    'VirtualNetworkPropertiesDhcpOptionsArgs',
    'VirtualNetworkPropertiesDhcpOptionsArgsDict',
    'VirtualNetworkPropertiesIpConfigurationReferencesArgs',
    'VirtualNetworkPropertiesIpConfigurationReferencesArgsDict',
    'VirtualNetworkPropertiesRouteTableArgs',
    'VirtualNetworkPropertiesRouteTableArgsDict',
    'VirtualNetworkPropertiesRoutesArgs',
    'VirtualNetworkPropertiesRoutesArgsDict',
    'VirtualNetworkPropertiesSubnetsArgs',
    'VirtualNetworkPropertiesSubnetsArgsDict',
]

MYPY = False

if not MYPY:
    class ArcConnectivityPropertiesArgsDict(TypedDict):
        """
        Connectivity related configuration required by arc server.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True indicates ARC connectivity is enabled
        """
elif False:
    ArcConnectivityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArcConnectivityPropertiesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Connectivity related configuration required by arc server.
        :param pulumi.Input[bool] enabled: True indicates ARC connectivity is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True indicates ARC connectivity is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterDesiredPropertiesArgsDict(TypedDict):
        """
        Desired properties of the cluster.
        """
        diagnostic_level: NotRequired[pulumi.Input[Union[str, 'DiagnosticLevel']]]
        """
        Desired level of diagnostic data emitted by the cluster.
        """
        windows_server_subscription: NotRequired[pulumi.Input[Union[str, 'WindowsServerSubscription']]]
        """
        Desired state of Windows Server Subscription.
        """
elif False:
    ClusterDesiredPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDesiredPropertiesArgs:
    def __init__(__self__, *,
                 diagnostic_level: Optional[pulumi.Input[Union[str, 'DiagnosticLevel']]] = None,
                 windows_server_subscription: Optional[pulumi.Input[Union[str, 'WindowsServerSubscription']]] = None):
        """
        Desired properties of the cluster.
        :param pulumi.Input[Union[str, 'DiagnosticLevel']] diagnostic_level: Desired level of diagnostic data emitted by the cluster.
        :param pulumi.Input[Union[str, 'WindowsServerSubscription']] windows_server_subscription: Desired state of Windows Server Subscription.
        """
        if diagnostic_level is not None:
            pulumi.set(__self__, "diagnostic_level", diagnostic_level)
        if windows_server_subscription is not None:
            pulumi.set(__self__, "windows_server_subscription", windows_server_subscription)

    @property
    @pulumi.getter(name="diagnosticLevel")
    def diagnostic_level(self) -> Optional[pulumi.Input[Union[str, 'DiagnosticLevel']]]:
        """
        Desired level of diagnostic data emitted by the cluster.
        """
        return pulumi.get(self, "diagnostic_level")

    @diagnostic_level.setter
    def diagnostic_level(self, value: Optional[pulumi.Input[Union[str, 'DiagnosticLevel']]]):
        pulumi.set(self, "diagnostic_level", value)

    @property
    @pulumi.getter(name="windowsServerSubscription")
    def windows_server_subscription(self) -> Optional[pulumi.Input[Union[str, 'WindowsServerSubscription']]]:
        """
        Desired state of Windows Server Subscription.
        """
        return pulumi.get(self, "windows_server_subscription")

    @windows_server_subscription.setter
    def windows_server_subscription(self, value: Optional[pulumi.Input[Union[str, 'WindowsServerSubscription']]]):
        pulumi.set(self, "windows_server_subscription", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[str] name: The name of the extended location.
        :param pulumi.Input[Union[str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GalleryImageIdentifierArgsDict(TypedDict):
        """
        This is the gallery image definition identifier.
        """
        offer: pulumi.Input[str]
        """
        The name of the gallery image definition offer.
        """
        publisher: pulumi.Input[str]
        """
        The name of the gallery image definition publisher.
        """
        sku: pulumi.Input[str]
        """
        The name of the gallery image definition SKU.
        """
elif False:
    GalleryImageIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageIdentifierArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str]):
        """
        This is the gallery image definition identifier.
        :param pulumi.Input[str] offer: The name of the gallery image definition offer.
        :param pulumi.Input[str] publisher: The name of the gallery image definition publisher.
        :param pulumi.Input[str] sku: The name of the gallery image definition SKU.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition offer.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        The name of the gallery image definition SKU.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class GalleryImageVersionArgsDict(TypedDict):
        """
        Specifies information about the gallery image version that you want to create or update.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        This is the version of the gallery image.
        """
elif False:
    GalleryImageVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageVersionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Specifies information about the gallery image version that you want to create or update.
        :param pulumi.Input[str] name: This is the version of the gallery image.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This is the version of the gallery image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GuestCredentialArgsDict(TypedDict):
        """
        Username / Password Credentials to connect to guest.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password to connect with the guest.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username to connect with the guest.
        """
elif False:
    GuestCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuestCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Username / Password Credentials to connect to guest.
        :param pulumi.Input[str] password: The password to connect with the guest.
        :param pulumi.Input[str] username: The username to connect with the guest.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to connect with the guest.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to connect with the guest.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class HttpProxyConfigurationArgsDict(TypedDict):
        """
        HTTP Proxy configuration for the VM.
        """
        https_proxy: NotRequired[pulumi.Input[str]]
        """
        The httpsProxy url.
        """
elif False:
    HttpProxyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpProxyConfigurationArgs:
    def __init__(__self__, *,
                 https_proxy: Optional[pulumi.Input[str]] = None):
        """
        HTTP Proxy configuration for the VM.
        :param pulumi.Input[str] https_proxy: The httpsProxy url.
        """
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        The httpsProxy url.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_proxy", value)


if not MYPY:
    class IPConfigurationPropertiesArgsDict(TypedDict):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        prefix_length: NotRequired[pulumi.Input[str]]
        """
        prefixLength for network interface
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        private_ip_allocation_method: NotRequired[pulumi.Input[Union[str, 'PrivateIPAllocationMethodEnum']]]
        """
        PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        subnet: NotRequired[pulumi.Input['IPConfigurationSubnetArgsDict']]
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
elif False:
    IPConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 private_ip_allocation_method: Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethodEnum']]] = None,
                 subnet: Optional[pulumi.Input['IPConfigurationSubnetArgs']] = None):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        :param pulumi.Input[str] prefix_length: prefixLength for network interface
        :param pulumi.Input[str] private_ip_address: PrivateIPAddress - Private IP address of the IP configuration.
        :param pulumi.Input[Union[str, 'PrivateIPAllocationMethodEnum']] private_ip_allocation_method: PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input['IPConfigurationSubnetArgs'] subnet: Subnet - Name of Subnet bound to the IP configuration.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_allocation_method is not None:
            pulumi.set(__self__, "private_ip_allocation_method", private_ip_allocation_method)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[str]]:
        """
        prefixLength for network interface
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethodEnum']]]:
        """
        PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @private_ip_allocation_method.setter
    def private_ip_allocation_method(self, value: Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethodEnum']]]):
        pulumi.set(self, "private_ip_allocation_method", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['IPConfigurationSubnetArgs']]:
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['IPConfigurationSubnetArgs']]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class IPConfigurationSubnetArgsDict(TypedDict):
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID - The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        """
elif False:
    IPConfigurationSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationSubnetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Subnet - Name of Subnet bound to the IP configuration.
        :param pulumi.Input[str] id: ID - The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID - The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class IPConfigurationArgsDict(TypedDict):
        """
        InterfaceIPConfiguration iPConfiguration in a network interface.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        properties: NotRequired[pulumi.Input['IPConfigurationPropertiesArgsDict']]
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
elif False:
    IPConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input['IPConfigurationPropertiesArgs']] = None):
        """
        InterfaceIPConfiguration iPConfiguration in a network interface.
        :param pulumi.Input[str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['IPConfigurationPropertiesArgs'] properties: InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['IPConfigurationPropertiesArgs']]:
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['IPConfigurationPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class IPPoolArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[str]]
        """
        end of the ip address pool
        """
        ip_pool_type: NotRequired[pulumi.Input['IPPoolTypeEnum']]
        """
        ip pool type
        """
        start: NotRequired[pulumi.Input[str]]
        """
        start of the ip address pool
        """
elif False:
    IPPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPPoolArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 ip_pool_type: Optional[pulumi.Input['IPPoolTypeEnum']] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: end of the ip address pool
        :param pulumi.Input['IPPoolTypeEnum'] ip_pool_type: ip pool type
        :param pulumi.Input[str] start: start of the ip address pool
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if ip_pool_type is not None:
            pulumi.set(__self__, "ip_pool_type", ip_pool_type)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        end of the ip address pool
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="ipPoolType")
    def ip_pool_type(self) -> Optional[pulumi.Input['IPPoolTypeEnum']]:
        """
        ip pool type
        """
        return pulumi.get(self, "ip_pool_type")

    @ip_pool_type.setter
    def ip_pool_type(self, value: Optional[pulumi.Input['IPPoolTypeEnum']]):
        pulumi.set(self, "ip_pool_type", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        start of the ip address pool
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InterfaceDNSSettingsArgsDict(TypedDict):
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of DNS server IP Addresses for the interface
        """
elif False:
    InterfaceDNSSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterfaceDNSSettingsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: List of DNS server IP Addresses for the interface
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of DNS server IP Addresses for the interface
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class SoftwareAssurancePropertiesArgsDict(TypedDict):
        """
        Software Assurance properties of the cluster.
        """
        software_assurance_intent: NotRequired[pulumi.Input[Union[str, 'SoftwareAssuranceIntent']]]
        """
        Customer Intent for Software Assurance Benefit.
        """
        software_assurance_status: NotRequired[pulumi.Input[Union[str, 'SoftwareAssuranceStatus']]]
        """
        Status of the Software Assurance for the cluster.
        """
elif False:
    SoftwareAssurancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareAssurancePropertiesArgs:
    def __init__(__self__, *,
                 software_assurance_intent: Optional[pulumi.Input[Union[str, 'SoftwareAssuranceIntent']]] = None,
                 software_assurance_status: Optional[pulumi.Input[Union[str, 'SoftwareAssuranceStatus']]] = None):
        """
        Software Assurance properties of the cluster.
        :param pulumi.Input[Union[str, 'SoftwareAssuranceIntent']] software_assurance_intent: Customer Intent for Software Assurance Benefit.
        :param pulumi.Input[Union[str, 'SoftwareAssuranceStatus']] software_assurance_status: Status of the Software Assurance for the cluster.
        """
        if software_assurance_intent is not None:
            pulumi.set(__self__, "software_assurance_intent", software_assurance_intent)
        if software_assurance_status is not None:
            pulumi.set(__self__, "software_assurance_status", software_assurance_status)

    @property
    @pulumi.getter(name="softwareAssuranceIntent")
    def software_assurance_intent(self) -> Optional[pulumi.Input[Union[str, 'SoftwareAssuranceIntent']]]:
        """
        Customer Intent for Software Assurance Benefit.
        """
        return pulumi.get(self, "software_assurance_intent")

    @software_assurance_intent.setter
    def software_assurance_intent(self, value: Optional[pulumi.Input[Union[str, 'SoftwareAssuranceIntent']]]):
        pulumi.set(self, "software_assurance_intent", value)

    @property
    @pulumi.getter(name="softwareAssuranceStatus")
    def software_assurance_status(self) -> Optional[pulumi.Input[Union[str, 'SoftwareAssuranceStatus']]]:
        """
        Status of the Software Assurance for the cluster.
        """
        return pulumi.get(self, "software_assurance_status")

    @software_assurance_status.setter
    def software_assurance_status(self, value: Optional[pulumi.Input[Union[str, 'SoftwareAssuranceStatus']]]):
        pulumi.set(self, "software_assurance_status", value)


if not MYPY:
    class StepArgsDict(TypedDict):
        """
        Progress representation of the update run steps.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        More detailed description of the step.
        """
        end_time_utc: NotRequired[pulumi.Input[str]]
        """
        When the step reached a terminal state.
        """
        error_message: NotRequired[pulumi.Input[str]]
        """
        Error message, specified if the step is in a failed state.
        """
        expected_execution_time: NotRequired[pulumi.Input[str]]
        """
        Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        """
        last_updated_time_utc: NotRequired[pulumi.Input[str]]
        """
        Completion time of this step or the last completed sub-step.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the step.
        """
        start_time_utc: NotRequired[pulumi.Input[str]]
        """
        When the step started, or empty if it has not started executing.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['StepArgsDict']]]]
        """
        Recursive model for child steps of this step.
        """
elif False:
    StepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 end_time_utc: Optional[pulumi.Input[str]] = None,
                 error_message: Optional[pulumi.Input[str]] = None,
                 expected_execution_time: Optional[pulumi.Input[str]] = None,
                 last_updated_time_utc: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start_time_utc: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]] = None):
        """
        Progress representation of the update run steps.
        :param pulumi.Input[str] description: More detailed description of the step.
        :param pulumi.Input[str] end_time_utc: When the step reached a terminal state.
        :param pulumi.Input[str] error_message: Error message, specified if the step is in a failed state.
        :param pulumi.Input[str] expected_execution_time: Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        :param pulumi.Input[str] last_updated_time_utc: Completion time of this step or the last completed sub-step.
        :param pulumi.Input[str] name: Name of the step.
        :param pulumi.Input[str] start_time_utc: When the step started, or empty if it has not started executing.
        :param pulumi.Input[str] status: Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        :param pulumi.Input[Sequence[pulumi.Input['StepArgs']]] steps: Recursive model for child steps of this step.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_time_utc is not None:
            pulumi.set(__self__, "end_time_utc", end_time_utc)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if expected_execution_time is not None:
            pulumi.set(__self__, "expected_execution_time", expected_execution_time)
        if last_updated_time_utc is not None:
            pulumi.set(__self__, "last_updated_time_utc", last_updated_time_utc)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start_time_utc is not None:
            pulumi.set(__self__, "start_time_utc", start_time_utc)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        More detailed description of the step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        When the step reached a terminal state.
        """
        return pulumi.get(self, "end_time_utc")

    @end_time_utc.setter
    def end_time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_utc", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        Error message, specified if the step is in a failed state.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter(name="expectedExecutionTime")
    def expected_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        """
        return pulumi.get(self, "expected_execution_time")

    @expected_execution_time.setter
    def expected_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_execution_time", value)

    @property
    @pulumi.getter(name="lastUpdatedTimeUtc")
    def last_updated_time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Completion time of this step or the last completed sub-step.
        """
        return pulumi.get(self, "last_updated_time_utc")

    @last_updated_time_utc.setter
    def last_updated_time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated_time_utc", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        When the step started, or empty if it has not started executing.
        """
        return pulumi.get(self, "start_time_utc")

    @start_time_utc.setter
    def start_time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_utc", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]]:
        """
        Recursive model for child steps of this step.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class UpdatePrerequisiteArgsDict(TypedDict):
        """
        If update State is HasPrerequisite, this property contains an array of objects describing prerequisite updates before installing this update. Otherwise, it is empty.
        """
        package_name: NotRequired[pulumi.Input[str]]
        """
        Friendly name of the prerequisite.
        """
        update_type: NotRequired[pulumi.Input[str]]
        """
        Updatable component type.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the prerequisite.
        """
elif False:
    UpdatePrerequisiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdatePrerequisiteArgs:
    def __init__(__self__, *,
                 package_name: Optional[pulumi.Input[str]] = None,
                 update_type: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        If update State is HasPrerequisite, this property contains an array of objects describing prerequisite updates before installing this update. Otherwise, it is empty.
        :param pulumi.Input[str] package_name: Friendly name of the prerequisite.
        :param pulumi.Input[str] update_type: Updatable component type.
        :param pulumi.Input[str] version: Version of the prerequisite.
        """
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if update_type is not None:
            pulumi.set(__self__, "update_type", update_type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Friendly name of the prerequisite.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[pulumi.Input[str]]:
        """
        Updatable component type.
        """
        return pulumi.get(self, "update_type")

    @update_type.setter
    def update_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the prerequisite.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VirtualMachinePropertiesDataDisksArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Resource ID of the data disk
        """
elif False:
    VirtualMachinePropertiesDataDisksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesDataDisksArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Resource ID of the data disk
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of the data disk
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesDynamicMemoryConfigArgsDict(TypedDict):
        maximum_memory_mb: NotRequired[pulumi.Input[float]]
        minimum_memory_mb: NotRequired[pulumi.Input[float]]
        target_memory_buffer: NotRequired[pulumi.Input[int]]
        """
        Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
elif False:
    VirtualMachinePropertiesDynamicMemoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesDynamicMemoryConfigArgs:
    def __init__(__self__, *,
                 maximum_memory_mb: Optional[pulumi.Input[float]] = None,
                 minimum_memory_mb: Optional[pulumi.Input[float]] = None,
                 target_memory_buffer: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] target_memory_buffer: Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        if maximum_memory_mb is not None:
            pulumi.set(__self__, "maximum_memory_mb", maximum_memory_mb)
        if minimum_memory_mb is not None:
            pulumi.set(__self__, "minimum_memory_mb", minimum_memory_mb)
        if target_memory_buffer is not None:
            pulumi.set(__self__, "target_memory_buffer", target_memory_buffer)

    @property
    @pulumi.getter(name="maximumMemoryMB")
    def maximum_memory_mb(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "maximum_memory_mb")

    @maximum_memory_mb.setter
    def maximum_memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "maximum_memory_mb", value)

    @property
    @pulumi.getter(name="minimumMemoryMB")
    def minimum_memory_mb(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "minimum_memory_mb")

    @minimum_memory_mb.setter
    def minimum_memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "minimum_memory_mb", value)

    @property
    @pulumi.getter(name="targetMemoryBuffer")
    def target_memory_buffer(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        return pulumi.get(self, "target_memory_buffer")

    @target_memory_buffer.setter
    def target_memory_buffer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_memory_buffer", value)


if not MYPY:
    class VirtualMachinePropertiesHardwareProfileArgsDict(TypedDict):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine.
        """
        dynamic_memory_config: NotRequired[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgsDict']]
        memory_mb: NotRequired[pulumi.Input[float]]
        """
        RAM in MB for the virtual machine
        """
        processors: NotRequired[pulumi.Input[int]]
        """
        number of processors for the virtual machine
        """
        vm_size: NotRequired[pulumi.Input[Union[str, 'VmSizeEnum']]]
elif False:
    VirtualMachinePropertiesHardwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesHardwareProfileArgs:
    def __init__(__self__, *,
                 dynamic_memory_config: Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']] = None,
                 memory_mb: Optional[pulumi.Input[float]] = None,
                 processors: Optional[pulumi.Input[int]] = None,
                 vm_size: Optional[pulumi.Input[Union[str, 'VmSizeEnum']]] = None):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine.
        :param pulumi.Input[float] memory_mb: RAM in MB for the virtual machine
        :param pulumi.Input[int] processors: number of processors for the virtual machine
        """
        if dynamic_memory_config is not None:
            pulumi.set(__self__, "dynamic_memory_config", dynamic_memory_config)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if vm_size is None:
            vm_size = 'Default'
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="dynamicMemoryConfig")
    def dynamic_memory_config(self) -> Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']]:
        return pulumi.get(self, "dynamic_memory_config")

    @dynamic_memory_config.setter
    def dynamic_memory_config(self, value: Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']]):
        pulumi.set(self, "dynamic_memory_config", value)

    @property
    @pulumi.getter(name="memoryMB")
    def memory_mb(self) -> Optional[pulumi.Input[float]]:
        """
        RAM in MB for the virtual machine
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[int]]:
        """
        number of processors for the virtual machine
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "processors", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[Union[str, 'VmSizeEnum']]]:
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[Union[str, 'VmSizeEnum']]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class VirtualMachinePropertiesImageReferenceArgsDict(TypedDict):
        """
        Which Image to use for the virtual machine
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Resource ID of the image
        """
elif False:
    VirtualMachinePropertiesImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesImageReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Which Image to use for the virtual machine
        :param pulumi.Input[str] id: Resource ID of the image
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of the image
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesLinuxConfigurationArgsDict(TypedDict):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        disable_password_authentication: NotRequired[pulumi.Input[bool]]
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        provision_vm_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['VirtualMachinePropertiesSshArgsDict']]
        """
        SSH - contains settings related to ssh configuration
        """
elif False:
    VirtualMachinePropertiesLinuxConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesLinuxConfigurationArgs:
    def __init__(__self__, *,
                 disable_password_authentication: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 ssh: Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']] = None):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        :param pulumi.Input[bool] disable_password_authentication: DisablePasswordAuthentication - whether password authentication should be disabled
        :param pulumi.Input[bool] provision_vm_agent: Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        :param pulumi.Input['VirtualMachinePropertiesSshArgs'] ssh: SSH - contains settings related to ssh configuration
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']]:
        """
        SSH - contains settings related to ssh configuration
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class VirtualMachinePropertiesNetworkInterfacesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        ID - Resource Id of the network interface
        """
elif False:
    VirtualMachinePropertiesNetworkInterfacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesNetworkInterfacesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID - Resource Id of the network interface
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID - Resource Id of the network interface
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesNetworkProfileArgsDict(TypedDict):
        """
        NetworkProfile - describes the network configuration the virtual machine
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgsDict']]]]
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
elif False:
    VirtualMachinePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]] = None):
        """
        NetworkProfile - describes the network configuration the virtual machine
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]] network_interfaces: NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]]:
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]]):
        pulumi.set(self, "network_interfaces", value)


if not MYPY:
    class VirtualMachinePropertiesOsDiskArgsDict(TypedDict):
        """
        VHD to attach as OS disk
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Resource ID of the OS disk
        """
elif False:
    VirtualMachinePropertiesOsDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesOsDiskArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        VHD to attach as OS disk
        :param pulumi.Input[str] id: Resource ID of the OS disk
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of the OS disk
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesOsProfileArgsDict(TypedDict):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        """
        admin_password: NotRequired[pulumi.Input[str]]
        """
        AdminPassword - admin password
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        AdminUsername - admin username
        """
        computer_name: NotRequired[pulumi.Input[str]]
        """
        ComputerName - name of the compute
        """
        linux_configuration: NotRequired[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgsDict']]
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        os_type: NotRequired[pulumi.Input[Union[str, 'OsTypeEnum']]]
        """
        OsType - string specifying whether the OS is Linux or Windows
        """
        windows_configuration: NotRequired[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgsDict']]
        """
        Windows Configuration for the virtual machine 
        """
elif False:
    VirtualMachinePropertiesOsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesOsProfileArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 computer_name: Optional[pulumi.Input[str]] = None,
                 linux_configuration: Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']] = None,
                 os_type: Optional[pulumi.Input[Union[str, 'OsTypeEnum']]] = None,
                 windows_configuration: Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']] = None):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        :param pulumi.Input[str] admin_password: AdminPassword - admin password
        :param pulumi.Input[str] admin_username: AdminUsername - admin username
        :param pulumi.Input[str] computer_name: ComputerName - name of the compute
        :param pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs'] linux_configuration: LinuxConfiguration - linux specific configuration values for the virtual machine
        :param pulumi.Input[Union[str, 'OsTypeEnum']] os_type: OsType - string specifying whether the OS is Linux or Windows
        :param pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs'] windows_configuration: Windows Configuration for the virtual machine 
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if computer_name is not None:
            pulumi.set(__self__, "computer_name", computer_name)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        AdminPassword - admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        AdminUsername - admin username
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> Optional[pulumi.Input[str]]:
        """
        ComputerName - name of the compute
        """
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']]:
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[str, 'OsTypeEnum']]]:
        """
        OsType - string specifying whether the OS is Linux or Windows
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[str, 'OsTypeEnum']]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']]:
        """
        Windows Configuration for the virtual machine 
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


if not MYPY:
    class VirtualMachinePropertiesPublicKeysPublicKeysArgsDict(TypedDict):
        key_data: NotRequired[pulumi.Input[str]]
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    VirtualMachinePropertiesPublicKeysPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesPublicKeysPublicKeysArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_data: KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        :param pulumi.Input[str] path: Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[str]]:
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class VirtualMachinePropertiesPublicKeysArgsDict(TypedDict):
        key_data: NotRequired[pulumi.Input[str]]
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    VirtualMachinePropertiesPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesPublicKeysArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_data: KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        :param pulumi.Input[str] path: Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[str]]:
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class VirtualMachinePropertiesSecurityProfileArgsDict(TypedDict):
        """
        SecurityProfile - Specifies the security settings for the virtual machine.
        """
        enable_tpm: NotRequired[pulumi.Input[bool]]
        uefi_settings: NotRequired[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgsDict']]
elif False:
    VirtualMachinePropertiesSecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSecurityProfileArgs:
    def __init__(__self__, *,
                 enable_tpm: Optional[pulumi.Input[bool]] = None,
                 uefi_settings: Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']] = None):
        """
        SecurityProfile - Specifies the security settings for the virtual machine.
        """
        if enable_tpm is None:
            enable_tpm = False
        if enable_tpm is not None:
            pulumi.set(__self__, "enable_tpm", enable_tpm)
        if uefi_settings is not None:
            pulumi.set(__self__, "uefi_settings", uefi_settings)

    @property
    @pulumi.getter(name="enableTPM")
    def enable_tpm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_tpm")

    @enable_tpm.setter
    def enable_tpm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tpm", value)

    @property
    @pulumi.getter(name="uefiSettings")
    def uefi_settings(self) -> Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']]:
        return pulumi.get(self, "uefi_settings")

    @uefi_settings.setter
    def uefi_settings(self, value: Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']]):
        pulumi.set(self, "uefi_settings", value)


if not MYPY:
    class VirtualMachinePropertiesSshSshArgsDict(TypedDict):
        """
        SSH Configuration
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgsDict']]]]
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    VirtualMachinePropertiesSshSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSshSshArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]] = None):
        """
        SSH Configuration
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]] public_keys: PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]]:
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class VirtualMachinePropertiesSshArgsDict(TypedDict):
        """
        SSH - contains settings related to ssh configuration
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgsDict']]]]
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    VirtualMachinePropertiesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSshArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]] = None):
        """
        SSH - contains settings related to ssh configuration
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]] public_keys: PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]]:
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class VirtualMachinePropertiesStorageProfileArgsDict(TypedDict):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine
        """
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgsDict']]]]
        """
        adds data disks to the virtual machine
        """
        image_reference: NotRequired[pulumi.Input['VirtualMachinePropertiesImageReferenceArgsDict']]
        """
        Which Image to use for the virtual machine
        """
        os_disk: NotRequired[pulumi.Input['VirtualMachinePropertiesOsDiskArgsDict']]
        """
        VHD to attach as OS disk
        """
        vm_config_storage_path_id: NotRequired[pulumi.Input[str]]
        """
        Id of the storage container that hosts the VM configuration file
        """
elif False:
    VirtualMachinePropertiesStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesStorageProfileArgs:
    def __init__(__self__, *,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]] = None,
                 image_reference: Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']] = None,
                 os_disk: Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']] = None,
                 vm_config_storage_path_id: Optional[pulumi.Input[str]] = None):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]] data_disks: adds data disks to the virtual machine
        :param pulumi.Input['VirtualMachinePropertiesImageReferenceArgs'] image_reference: Which Image to use for the virtual machine
        :param pulumi.Input['VirtualMachinePropertiesOsDiskArgs'] os_disk: VHD to attach as OS disk
        :param pulumi.Input[str] vm_config_storage_path_id: Id of the storage container that hosts the VM configuration file
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if image_reference is not None:
            pulumi.set(__self__, "image_reference", image_reference)
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if vm_config_storage_path_id is not None:
            pulumi.set(__self__, "vm_config_storage_path_id", vm_config_storage_path_id)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]]:
        """
        adds data disks to the virtual machine
        """
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="imageReference")
    def image_reference(self) -> Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']]:
        """
        Which Image to use for the virtual machine
        """
        return pulumi.get(self, "image_reference")

    @image_reference.setter
    def image_reference(self, value: Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']]):
        pulumi.set(self, "image_reference", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']]:
        """
        VHD to attach as OS disk
        """
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="vmConfigStoragePathId")
    def vm_config_storage_path_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the storage container that hosts the VM configuration file
        """
        return pulumi.get(self, "vm_config_storage_path_id")

    @vm_config_storage_path_id.setter
    def vm_config_storage_path_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_config_storage_path_id", value)


if not MYPY:
    class VirtualMachinePropertiesUefiSettingsArgsDict(TypedDict):
        secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether secure boot should be enabled on the virtual machine.
        """
elif False:
    VirtualMachinePropertiesUefiSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesUefiSettingsArgs:
    def __init__(__self__, *,
                 secure_boot_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] secure_boot_enabled: Specifies whether secure boot should be enabled on the virtual machine.
        """
        if secure_boot_enabled is None:
            secure_boot_enabled = False
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether secure boot should be enabled on the virtual machine.
        """
        return pulumi.get(self, "secure_boot_enabled")

    @secure_boot_enabled.setter
    def secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure_boot_enabled", value)


if not MYPY:
    class VirtualMachinePropertiesWindowsConfigurationArgsDict(TypedDict):
        """
        Windows Configuration for the virtual machine 
        """
        enable_automatic_updates: NotRequired[pulumi.Input[bool]]
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        provision_vm_agent: NotRequired[pulumi.Input[bool]]
        """
        Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['VirtualMachinePropertiesSshSshArgsDict']]
        """
        SSH Configuration
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        TimeZone for the virtual machine
        """
elif False:
    VirtualMachinePropertiesWindowsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesWindowsConfigurationArgs:
    def __init__(__self__, *,
                 enable_automatic_updates: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 ssh: Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Windows Configuration for the virtual machine 
        :param pulumi.Input[bool] enable_automatic_updates: Whether to EnableAutomaticUpdates on the machine
        :param pulumi.Input[bool] provision_vm_agent: Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        :param pulumi.Input['VirtualMachinePropertiesSshSshArgs'] ssh: SSH Configuration
        :param pulumi.Input[str] time_zone: TimeZone for the virtual machine
        """
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        return pulumi.get(self, "enable_automatic_updates")

    @enable_automatic_updates.setter
    def enable_automatic_updates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_updates", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Usedâ€¯to indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']]:
        """
        SSH Configuration
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']]):
        pulumi.set(self, "ssh", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        TimeZone for the virtual machine
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class VirtualNetworkPropertiesDhcpOptionsArgsDict(TypedDict):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of DNS servers IP addresses.
        """
elif False:
    VirtualNetworkPropertiesDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesDhcpOptionsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: The list of DNS servers IP addresses.
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of DNS servers IP addresses.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class VirtualNetworkPropertiesIpConfigurationReferencesArgsDict(TypedDict):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        """
        id: NotRequired[pulumi.Input[str]]
        """
        IPConfigurationID
        """
elif False:
    VirtualNetworkPropertiesIpConfigurationReferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesIpConfigurationReferencesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        :param pulumi.Input[str] id: IPConfigurationID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        IPConfigurationID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualNetworkPropertiesRouteTableArgsDict(TypedDict):
        """
        RouteTable for the subnet
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Etag - Gets a unique read-only string that changes whenever the resource is updated.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - READ-ONLY; Resource name.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgsDict']]]]
        """
        Routes - Collection of routes contained within a route table.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type - READ-ONLY; Resource type.
        """
elif False:
    VirtualNetworkPropertiesRouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesRouteTableArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        RouteTable for the subnet
        :param pulumi.Input[str] id: Etag - Gets a unique read-only string that changes whenever the resource is updated.
        :param pulumi.Input[str] name: Name - READ-ONLY; Resource name.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]] routes: Routes - Collection of routes contained within a route table.
        :param pulumi.Input[str] type: Type - READ-ONLY; Resource type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Etag - Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - READ-ONLY; Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]]:
        """
        Routes - Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type - READ-ONLY; Resource type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VirtualNetworkPropertiesRoutesArgsDict(TypedDict):
        """
        Route is associated with a subnet.
        """
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        AddressPrefix - The destination CIDR to which the route applies.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - name of the subnet
        """
        next_hop_ip_address: NotRequired[pulumi.Input[str]]
        """
        NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
elif False:
    VirtualNetworkPropertiesRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesRoutesArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 next_hop_ip_address: Optional[pulumi.Input[str]] = None):
        """
        Route is associated with a subnet.
        :param pulumi.Input[str] address_prefix: AddressPrefix - The destination CIDR to which the route applies.
        :param pulumi.Input[str] name: Name - name of the subnet
        :param pulumi.Input[str] next_hop_ip_address: NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        AddressPrefix - The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - name of the subnet
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @next_hop_ip_address.setter
    def next_hop_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_ip_address", value)


if not MYPY:
    class VirtualNetworkPropertiesSubnetsArgsDict(TypedDict):
        """
        Subnet subnet in a virtual network resource.
        """
        address_prefix: NotRequired[pulumi.Input[str]]
        """
        Cidr for this subnet - IPv4, IPv6
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AddressPrefixes - List of address prefixes for the subnet.
        """
        ip_allocation_method: NotRequired[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        ip_configuration_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgsDict']]]]
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['IPPoolArgsDict']]]]
        """
        network associated pool of IP Addresses
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        route_table: NotRequired[pulumi.Input['VirtualNetworkPropertiesRouteTableArgsDict']]
        """
        RouteTable for the subnet
        """
        vlan: NotRequired[pulumi.Input[int]]
        """
        Vlan to use for the subnet
        """
elif False:
    VirtualNetworkPropertiesSubnetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesSubnetsArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[str]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_allocation_method: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]] = None,
                 ip_configuration_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]] = None,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 route_table: Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        Subnet subnet in a virtual network resource.
        :param pulumi.Input[str] address_prefix: Cidr for this subnet - IPv4, IPv6
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_prefixes: AddressPrefixes - List of address prefixes for the subnet.
        :param pulumi.Input[Union[str, 'IpAllocationMethodEnum']] ip_allocation_method: IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]] ip_configuration_references: IPConfigurationReferences - list of IPConfigurationReferences
        :param pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]] ip_pools: network associated pool of IP Addresses
        :param pulumi.Input[str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['VirtualNetworkPropertiesRouteTableArgs'] route_table: RouteTable for the subnet
        :param pulumi.Input[int] vlan: Vlan to use for the subnet
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if ip_allocation_method is not None:
            pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        if ip_configuration_references is not None:
            pulumi.set(__self__, "ip_configuration_references", ip_configuration_references)
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Cidr for this subnet - IPv4, IPv6
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AddressPrefixes - List of address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]:
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "ip_allocation_method")

    @ip_allocation_method.setter
    def ip_allocation_method(self, value: Optional[pulumi.Input[Union[str, 'IpAllocationMethodEnum']]]):
        pulumi.set(self, "ip_allocation_method", value)

    @property
    @pulumi.getter(name="ipConfigurationReferences")
    def ip_configuration_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]]:
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        return pulumi.get(self, "ip_configuration_references")

    @ip_configuration_references.setter
    def ip_configuration_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]]):
        pulumi.set(self, "ip_configuration_references", value)

    @property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]:
        """
        network associated pool of IP Addresses
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]):
        pulumi.set(self, "ip_pools", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']]:
        """
        RouteTable for the subnet
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']]):
        pulumi.set(self, "route_table", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        Vlan to use for the subnet
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


