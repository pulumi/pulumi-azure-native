# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AdapterPropertyOverridesArgs',
    'AdapterPropertyOverridesArgsDict',
    'ArcConnectivityPropertiesArgs',
    'ArcConnectivityPropertiesArgsDict',
    'ClusterDesiredPropertiesArgs',
    'ClusterDesiredPropertiesArgsDict',
    'DeploymentClusterArgs',
    'DeploymentClusterArgsDict',
    'DeploymentConfigurationArgs',
    'DeploymentConfigurationArgsDict',
    'DeploymentDataArgs',
    'DeploymentDataArgsDict',
    'DeploymentSecuritySettingsArgs',
    'DeploymentSecuritySettingsArgsDict',
    'DeviceConfigurationArgs',
    'DeviceConfigurationArgsDict',
    'EceDeploymentSecretsArgs',
    'EceDeploymentSecretsArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'GalleryImageIdentifierArgs',
    'GalleryImageIdentifierArgsDict',
    'GalleryImageVersionArgs',
    'GalleryImageVersionArgsDict',
    'GuestCredentialArgs',
    'GuestCredentialArgsDict',
    'HciCollectLogJobPropertiesArgs',
    'HciCollectLogJobPropertiesArgsDict',
    'HciEdgeDevicePropertiesArgs',
    'HciEdgeDevicePropertiesArgsDict',
    'HciRemoteSupportJobPropertiesArgs',
    'HciRemoteSupportJobPropertiesArgsDict',
    'HostNetworkArgs',
    'HostNetworkArgsDict',
    'HttpProxyConfigurationArgs',
    'HttpProxyConfigurationArgsDict',
    'IPConfigurationPropertiesArgs',
    'IPConfigurationPropertiesArgsDict',
    'IPConfigurationArgs',
    'IPConfigurationArgsDict',
    'IPPoolArgs',
    'IPPoolArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'ImageArmReferenceArgs',
    'ImageArmReferenceArgsDict',
    'InfrastructureNetworkArgs',
    'InfrastructureNetworkArgsDict',
    'IntentsArgs',
    'IntentsArgsDict',
    'InterfaceDNSSettingsArgs',
    'InterfaceDNSSettingsArgsDict',
    'IpPoolsArgs',
    'IpPoolsArgsDict',
    'LogicalNetworkArmReferenceArgs',
    'LogicalNetworkArmReferenceArgsDict',
    'LogicalNetworkPropertiesDhcpOptionsArgs',
    'LogicalNetworkPropertiesDhcpOptionsArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'NetworkControllerArgs',
    'NetworkControllerArgsDict',
    'NetworkInterfaceArmReferenceArgs',
    'NetworkInterfaceArmReferenceArgsDict',
    'NetworkSecurityGroupArmReferenceArgs',
    'NetworkSecurityGroupArmReferenceArgsDict',
    'NicDetailArgs',
    'NicDetailArgsDict',
    'ObservabilityArgs',
    'ObservabilityArgsDict',
    'OptionalServicesArgs',
    'OptionalServicesArgsDict',
    'PhysicalNodesArgs',
    'PhysicalNodesArgsDict',
    'QosPolicyOverridesArgs',
    'QosPolicyOverridesArgsDict',
    'RouteTableArgs',
    'RouteTableArgsDict',
    'RouteArgs',
    'RouteArgsDict',
    'SbeCredentialsArgs',
    'SbeCredentialsArgsDict',
    'SbeDeploymentInfoArgs',
    'SbeDeploymentInfoArgsDict',
    'SbePartnerInfoArgs',
    'SbePartnerInfoArgsDict',
    'SbePartnerPropertiesArgs',
    'SbePartnerPropertiesArgsDict',
    'ScaleUnitsArgs',
    'ScaleUnitsArgsDict',
    'SdnIntegrationArgs',
    'SdnIntegrationArgsDict',
    'ServiceConfigurationArgs',
    'ServiceConfigurationArgsDict',
    'SoftwareAssurancePropertiesArgs',
    'SoftwareAssurancePropertiesArgsDict',
    'SshConfigurationArgs',
    'SshConfigurationArgsDict',
    'SshPublicKeyArgs',
    'SshPublicKeyArgsDict',
    'StepArgs',
    'StepArgsDict',
    'StorageAdapterIPInfoArgs',
    'StorageAdapterIPInfoArgsDict',
    'StorageNetworksArgs',
    'StorageNetworksArgsDict',
    'StorageArgs',
    'StorageArgsDict',
    'SubnetIpConfigurationReferenceArgs',
    'SubnetIpConfigurationReferenceArgsDict',
    'SubnetArgs',
    'SubnetArgsDict',
    'UpdatePrerequisiteArgs',
    'UpdatePrerequisiteArgsDict',
    'VMDiskSecurityProfileArgs',
    'VMDiskSecurityProfileArgsDict',
    'VirtualHardDiskArmReferenceArgs',
    'VirtualHardDiskArmReferenceArgsDict',
    'VirtualMachineInstanceManagedDiskParametersArgs',
    'VirtualMachineInstanceManagedDiskParametersArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs',
    'VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs',
    'VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict',
    'VirtualMachineInstancePropertiesHardwareProfileArgs',
    'VirtualMachineInstancePropertiesHardwareProfileArgsDict',
    'VirtualMachineInstancePropertiesNetworkProfileArgs',
    'VirtualMachineInstancePropertiesNetworkProfileArgsDict',
    'VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs',
    'VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict',
    'VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs',
    'VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict',
    'VirtualMachineInstancePropertiesOsProfileArgs',
    'VirtualMachineInstancePropertiesOsProfileArgsDict',
    'VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs',
    'VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict',
    'VirtualMachineInstancePropertiesSecurityProfileArgs',
    'VirtualMachineInstancePropertiesSecurityProfileArgsDict',
    'VirtualMachineInstancePropertiesStorageProfileOsDiskArgs',
    'VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict',
    'VirtualMachineInstancePropertiesStorageProfileArgs',
    'VirtualMachineInstancePropertiesStorageProfileArgsDict',
    'VirtualMachinePropertiesDataDisksArgs',
    'VirtualMachinePropertiesDataDisksArgsDict',
    'VirtualMachinePropertiesDynamicMemoryConfigArgs',
    'VirtualMachinePropertiesDynamicMemoryConfigArgsDict',
    'VirtualMachinePropertiesHardwareProfileArgs',
    'VirtualMachinePropertiesHardwareProfileArgsDict',
    'VirtualMachinePropertiesImageReferenceArgs',
    'VirtualMachinePropertiesImageReferenceArgsDict',
    'VirtualMachinePropertiesLinuxConfigurationArgs',
    'VirtualMachinePropertiesLinuxConfigurationArgsDict',
    'VirtualMachinePropertiesNetworkInterfacesArgs',
    'VirtualMachinePropertiesNetworkInterfacesArgsDict',
    'VirtualMachinePropertiesNetworkProfileArgs',
    'VirtualMachinePropertiesNetworkProfileArgsDict',
    'VirtualMachinePropertiesOsDiskArgs',
    'VirtualMachinePropertiesOsDiskArgsDict',
    'VirtualMachinePropertiesOsProfileArgs',
    'VirtualMachinePropertiesOsProfileArgsDict',
    'VirtualMachinePropertiesPublicKeysPublicKeysArgs',
    'VirtualMachinePropertiesPublicKeysPublicKeysArgsDict',
    'VirtualMachinePropertiesPublicKeysArgs',
    'VirtualMachinePropertiesPublicKeysArgsDict',
    'VirtualMachinePropertiesSecurityProfileArgs',
    'VirtualMachinePropertiesSecurityProfileArgsDict',
    'VirtualMachinePropertiesSshSshArgs',
    'VirtualMachinePropertiesSshSshArgsDict',
    'VirtualMachinePropertiesSshArgs',
    'VirtualMachinePropertiesSshArgsDict',
    'VirtualMachinePropertiesStorageProfileArgs',
    'VirtualMachinePropertiesStorageProfileArgsDict',
    'VirtualMachinePropertiesUefiSettingsArgs',
    'VirtualMachinePropertiesUefiSettingsArgsDict',
    'VirtualMachinePropertiesWindowsConfigurationArgs',
    'VirtualMachinePropertiesWindowsConfigurationArgsDict',
    'VirtualNetworkPropertiesDhcpOptionsArgs',
    'VirtualNetworkPropertiesDhcpOptionsArgsDict',
    'VirtualNetworkPropertiesIpConfigurationReferencesArgs',
    'VirtualNetworkPropertiesIpConfigurationReferencesArgsDict',
    'VirtualNetworkPropertiesRouteTableArgs',
    'VirtualNetworkPropertiesRouteTableArgsDict',
    'VirtualNetworkPropertiesRoutesArgs',
    'VirtualNetworkPropertiesRoutesArgsDict',
    'VirtualNetworkPropertiesSubnetsArgs',
    'VirtualNetworkPropertiesSubnetsArgsDict',
    'VirtualSwitchConfigurationOverridesArgs',
    'VirtualSwitchConfigurationOverridesArgsDict',
    'VmImageRepositoryCredentialsArgs',
    'VmImageRepositoryCredentialsArgsDict',
]

MYPY = False

if not MYPY:
    class AdapterPropertyOverridesArgsDict(TypedDict):
        """
        The AdapterPropertyOverrides of a cluster.
        """
        jumbo_packet: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        network_direct: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        network_direct_technology: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation. Expected values are 'iWARP', 'RoCEv2', 'RoCE'
        """
elif False:
    AdapterPropertyOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdapterPropertyOverridesArgs:
    def __init__(__self__, *,
                 jumbo_packet: Optional[pulumi.Input[builtins.str]] = None,
                 network_direct: Optional[pulumi.Input[builtins.str]] = None,
                 network_direct_technology: Optional[pulumi.Input[builtins.str]] = None):
        """
        The AdapterPropertyOverrides of a cluster.
        :param pulumi.Input[builtins.str] jumbo_packet: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.str] network_direct: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.str] network_direct_technology: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation. Expected values are 'iWARP', 'RoCEv2', 'RoCE'
        """
        if jumbo_packet is not None:
            pulumi.set(__self__, "jumbo_packet", jumbo_packet)
        if network_direct is not None:
            pulumi.set(__self__, "network_direct", network_direct)
        if network_direct_technology is not None:
            pulumi.set(__self__, "network_direct_technology", network_direct_technology)

    @property
    @pulumi.getter(name="jumboPacket")
    def jumbo_packet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "jumbo_packet")

    @jumbo_packet.setter
    def jumbo_packet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jumbo_packet", value)

    @property
    @pulumi.getter(name="networkDirect")
    def network_direct(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "network_direct")

    @network_direct.setter
    def network_direct(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_direct", value)

    @property
    @pulumi.getter(name="networkDirectTechnology")
    def network_direct_technology(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation. Expected values are 'iWARP', 'RoCEv2', 'RoCE'
        """
        return pulumi.get(self, "network_direct_technology")

    @network_direct_technology.setter
    def network_direct_technology(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_direct_technology", value)


if not MYPY:
    class ArcConnectivityPropertiesArgsDict(TypedDict):
        """
        Connectivity related configuration required by arc server.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True indicates ARC connectivity is enabled
        """
        service_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceConfigurationArgsDict']]]]
        """
        Service configurations associated with the connectivity resource. They are only processed by the server if 'enabled' property is set to 'true'.
        """
elif False:
    ArcConnectivityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArcConnectivityPropertiesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 service_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceConfigurationArgs']]]] = None):
        """
        Connectivity related configuration required by arc server.
        :param pulumi.Input[builtins.bool] enabled: True indicates ARC connectivity is enabled
        :param pulumi.Input[Sequence[pulumi.Input['ServiceConfigurationArgs']]] service_configurations: Service configurations associated with the connectivity resource. They are only processed by the server if 'enabled' property is set to 'true'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if service_configurations is not None:
            pulumi.set(__self__, "service_configurations", service_configurations)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True indicates ARC connectivity is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="serviceConfigurations")
    def service_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceConfigurationArgs']]]]:
        """
        Service configurations associated with the connectivity resource. They are only processed by the server if 'enabled' property is set to 'true'.
        """
        return pulumi.get(self, "service_configurations")

    @service_configurations.setter
    def service_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceConfigurationArgs']]]]):
        pulumi.set(self, "service_configurations", value)


if not MYPY:
    class ClusterDesiredPropertiesArgsDict(TypedDict):
        """
        Desired properties of the cluster.
        """
        diagnostic_level: NotRequired[pulumi.Input[Union[builtins.str, 'DiagnosticLevel']]]
        """
        Desired level of diagnostic data emitted by the cluster.
        """
        windows_server_subscription: NotRequired[pulumi.Input[Union[builtins.str, 'WindowsServerSubscription']]]
        """
        Desired state of Windows Server Subscription.
        """
elif False:
    ClusterDesiredPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDesiredPropertiesArgs:
    def __init__(__self__, *,
                 diagnostic_level: Optional[pulumi.Input[Union[builtins.str, 'DiagnosticLevel']]] = None,
                 windows_server_subscription: Optional[pulumi.Input[Union[builtins.str, 'WindowsServerSubscription']]] = None):
        """
        Desired properties of the cluster.
        :param pulumi.Input[Union[builtins.str, 'DiagnosticLevel']] diagnostic_level: Desired level of diagnostic data emitted by the cluster.
        :param pulumi.Input[Union[builtins.str, 'WindowsServerSubscription']] windows_server_subscription: Desired state of Windows Server Subscription.
        """
        if diagnostic_level is not None:
            pulumi.set(__self__, "diagnostic_level", diagnostic_level)
        if windows_server_subscription is not None:
            pulumi.set(__self__, "windows_server_subscription", windows_server_subscription)

    @property
    @pulumi.getter(name="diagnosticLevel")
    def diagnostic_level(self) -> Optional[pulumi.Input[Union[builtins.str, 'DiagnosticLevel']]]:
        """
        Desired level of diagnostic data emitted by the cluster.
        """
        return pulumi.get(self, "diagnostic_level")

    @diagnostic_level.setter
    def diagnostic_level(self, value: Optional[pulumi.Input[Union[builtins.str, 'DiagnosticLevel']]]):
        pulumi.set(self, "diagnostic_level", value)

    @property
    @pulumi.getter(name="windowsServerSubscription")
    def windows_server_subscription(self) -> Optional[pulumi.Input[Union[builtins.str, 'WindowsServerSubscription']]]:
        """
        Desired state of Windows Server Subscription.
        """
        return pulumi.get(self, "windows_server_subscription")

    @windows_server_subscription.setter
    def windows_server_subscription(self, value: Optional[pulumi.Input[Union[builtins.str, 'WindowsServerSubscription']]]):
        pulumi.set(self, "windows_server_subscription", value)


if not MYPY:
    class DeploymentClusterArgsDict(TypedDict):
        """
        AzureStackHCI Cluster deployment properties.
        """
        azure_service_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        For Azure blob service endpoint type, select either Default or Custom domain. If you selected **Custom domain, enter the domain for the blob service in this format core.windows.net.
        """
        cloud_account_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Specify the Azure Storage account name for cloud witness for your Azure Stack HCI cluster.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cluster name provided when preparing Active Directory.
        """
        witness_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Specify the fileshare path for the local witness for your Azure Stack HCI cluster.
        """
        witness_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Use a cloud witness if you have internet access and if you use an Azure Storage account to provide a vote on cluster quorum. A cloud witness uses Azure Blob Storage to read or write a blob file and then uses it to arbitrate in split-brain resolution. Only allowed values are 'Cloud', 'FileShare'. 
        """
elif False:
    DeploymentClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentClusterArgs:
    def __init__(__self__, *,
                 azure_service_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 cloud_account_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 witness_path: Optional[pulumi.Input[builtins.str]] = None,
                 witness_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        AzureStackHCI Cluster deployment properties.
        :param pulumi.Input[builtins.str] azure_service_endpoint: For Azure blob service endpoint type, select either Default or Custom domain. If you selected **Custom domain, enter the domain for the blob service in this format core.windows.net.
        :param pulumi.Input[builtins.str] cloud_account_name: Specify the Azure Storage account name for cloud witness for your Azure Stack HCI cluster.
        :param pulumi.Input[builtins.str] name: The cluster name provided when preparing Active Directory.
        :param pulumi.Input[builtins.str] witness_path: Specify the fileshare path for the local witness for your Azure Stack HCI cluster.
        :param pulumi.Input[builtins.str] witness_type: Use a cloud witness if you have internet access and if you use an Azure Storage account to provide a vote on cluster quorum. A cloud witness uses Azure Blob Storage to read or write a blob file and then uses it to arbitrate in split-brain resolution. Only allowed values are 'Cloud', 'FileShare'. 
        """
        if azure_service_endpoint is not None:
            pulumi.set(__self__, "azure_service_endpoint", azure_service_endpoint)
        if cloud_account_name is not None:
            pulumi.set(__self__, "cloud_account_name", cloud_account_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if witness_path is not None:
            pulumi.set(__self__, "witness_path", witness_path)
        if witness_type is not None:
            pulumi.set(__self__, "witness_type", witness_type)

    @property
    @pulumi.getter(name="azureServiceEndpoint")
    def azure_service_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For Azure blob service endpoint type, select either Default or Custom domain. If you selected **Custom domain, enter the domain for the blob service in this format core.windows.net.
        """
        return pulumi.get(self, "azure_service_endpoint")

    @azure_service_endpoint.setter
    def azure_service_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "azure_service_endpoint", value)

    @property
    @pulumi.getter(name="cloudAccountName")
    def cloud_account_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specify the Azure Storage account name for cloud witness for your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "cloud_account_name")

    @cloud_account_name.setter
    def cloud_account_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cloud_account_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cluster name provided when preparing Active Directory.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="witnessPath")
    def witness_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specify the fileshare path for the local witness for your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "witness_path")

    @witness_path.setter
    def witness_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "witness_path", value)

    @property
    @pulumi.getter(name="witnessType")
    def witness_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use a cloud witness if you have internet access and if you use an Azure Storage account to provide a vote on cluster quorum. A cloud witness uses Azure Blob Storage to read or write a blob file and then uses it to arbitrate in split-brain resolution. Only allowed values are 'Cloud', 'FileShare'. 
        """
        return pulumi.get(self, "witness_type")

    @witness_type.setter
    def witness_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "witness_type", value)


if not MYPY:
    class DeploymentConfigurationArgsDict(TypedDict):
        """
        Deployment Configuration
        """
        scale_units: pulumi.Input[Sequence[pulumi.Input['ScaleUnitsArgsDict']]]
        """
        Scale units will contains list of deployment data
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        deployment template version 
        """
elif False:
    DeploymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentConfigurationArgs:
    def __init__(__self__, *,
                 scale_units: pulumi.Input[Sequence[pulumi.Input['ScaleUnitsArgs']]],
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Deployment Configuration
        :param pulumi.Input[Sequence[pulumi.Input['ScaleUnitsArgs']]] scale_units: Scale units will contains list of deployment data
        :param pulumi.Input[builtins.str] version: deployment template version 
        """
        pulumi.set(__self__, "scale_units", scale_units)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="scaleUnits")
    def scale_units(self) -> pulumi.Input[Sequence[pulumi.Input['ScaleUnitsArgs']]]:
        """
        Scale units will contains list of deployment data
        """
        return pulumi.get(self, "scale_units")

    @scale_units.setter
    def scale_units(self, value: pulumi.Input[Sequence[pulumi.Input['ScaleUnitsArgs']]]):
        pulumi.set(self, "scale_units", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        deployment template version 
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DeploymentDataArgsDict(TypedDict):
        """
        The Deployment data of AzureStackHCI Cluster.
        """
        adou_path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path to the Active Directory Organizational Unit container object prepared for the deployment. 
        """
        cluster: NotRequired[pulumi.Input['DeploymentClusterArgsDict']]
        """
        Observability config to deploy AzureStackHCI Cluster.
        """
        domain_fqdn: NotRequired[pulumi.Input[builtins.str]]
        """
        FQDN to deploy cluster
        """
        host_network: NotRequired[pulumi.Input['HostNetworkArgsDict']]
        """
        HostNetwork config to deploy AzureStackHCI Cluster.
        """
        infrastructure_network: NotRequired[pulumi.Input[Sequence[pulumi.Input['InfrastructureNetworkArgsDict']]]]
        """
        InfrastructureNetwork config to deploy AzureStackHCI Cluster.
        """
        naming_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        naming prefix to deploy cluster.
        """
        observability: NotRequired[pulumi.Input['ObservabilityArgsDict']]
        """
        Observability config to deploy AzureStackHCI Cluster.
        """
        optional_services: NotRequired[pulumi.Input['OptionalServicesArgsDict']]
        """
        OptionalServices config to deploy AzureStackHCI Cluster.
        """
        physical_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PhysicalNodesArgsDict']]]]
        """
        list of physical nodes config to deploy AzureStackHCI Cluster.
        """
        sdn_integration: NotRequired[pulumi.Input['SdnIntegrationArgsDict']]
        """
        SDN Integration config to deploy AzureStackHCI Cluster.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['EceDeploymentSecretsArgsDict']]]]
        """
        secrets used for cloud deployment.
        """
        secrets_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure keyvault endpoint. This property is deprecated from 2023-12-01-preview. Please use secrets property instead.
        """
        security_settings: NotRequired[pulumi.Input['DeploymentSecuritySettingsArgsDict']]
        """
        SecuritySettings to deploy AzureStackHCI Cluster.
        """
        storage: NotRequired[pulumi.Input['StorageArgsDict']]
        """
        Storage config to deploy AzureStackHCI Cluster.
        """
elif False:
    DeploymentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentDataArgs:
    def __init__(__self__, *,
                 adou_path: Optional[pulumi.Input[builtins.str]] = None,
                 cluster: Optional[pulumi.Input['DeploymentClusterArgs']] = None,
                 domain_fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 host_network: Optional[pulumi.Input['HostNetworkArgs']] = None,
                 infrastructure_network: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureNetworkArgs']]]] = None,
                 naming_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 observability: Optional[pulumi.Input['ObservabilityArgs']] = None,
                 optional_services: Optional[pulumi.Input['OptionalServicesArgs']] = None,
                 physical_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['PhysicalNodesArgs']]]] = None,
                 sdn_integration: Optional[pulumi.Input['SdnIntegrationArgs']] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['EceDeploymentSecretsArgs']]]] = None,
                 secrets_location: Optional[pulumi.Input[builtins.str]] = None,
                 security_settings: Optional[pulumi.Input['DeploymentSecuritySettingsArgs']] = None,
                 storage: Optional[pulumi.Input['StorageArgs']] = None):
        """
        The Deployment data of AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] adou_path: The path to the Active Directory Organizational Unit container object prepared for the deployment. 
        :param pulumi.Input['DeploymentClusterArgs'] cluster: Observability config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] domain_fqdn: FQDN to deploy cluster
        :param pulumi.Input['HostNetworkArgs'] host_network: HostNetwork config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['InfrastructureNetworkArgs']]] infrastructure_network: InfrastructureNetwork config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] naming_prefix: naming prefix to deploy cluster.
        :param pulumi.Input['ObservabilityArgs'] observability: Observability config to deploy AzureStackHCI Cluster.
        :param pulumi.Input['OptionalServicesArgs'] optional_services: OptionalServices config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['PhysicalNodesArgs']]] physical_nodes: list of physical nodes config to deploy AzureStackHCI Cluster.
        :param pulumi.Input['SdnIntegrationArgs'] sdn_integration: SDN Integration config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['EceDeploymentSecretsArgs']]] secrets: secrets used for cloud deployment.
        :param pulumi.Input[builtins.str] secrets_location: Azure keyvault endpoint. This property is deprecated from 2023-12-01-preview. Please use secrets property instead.
        :param pulumi.Input['DeploymentSecuritySettingsArgs'] security_settings: SecuritySettings to deploy AzureStackHCI Cluster.
        :param pulumi.Input['StorageArgs'] storage: Storage config to deploy AzureStackHCI Cluster.
        """
        if adou_path is not None:
            pulumi.set(__self__, "adou_path", adou_path)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if domain_fqdn is not None:
            pulumi.set(__self__, "domain_fqdn", domain_fqdn)
        if host_network is not None:
            pulumi.set(__self__, "host_network", host_network)
        if infrastructure_network is not None:
            pulumi.set(__self__, "infrastructure_network", infrastructure_network)
        if naming_prefix is not None:
            pulumi.set(__self__, "naming_prefix", naming_prefix)
        if observability is not None:
            pulumi.set(__self__, "observability", observability)
        if optional_services is not None:
            pulumi.set(__self__, "optional_services", optional_services)
        if physical_nodes is not None:
            pulumi.set(__self__, "physical_nodes", physical_nodes)
        if sdn_integration is not None:
            pulumi.set(__self__, "sdn_integration", sdn_integration)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if secrets_location is not None:
            pulumi.set(__self__, "secrets_location", secrets_location)
        if security_settings is not None:
            pulumi.set(__self__, "security_settings", security_settings)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="adouPath")
    def adou_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path to the Active Directory Organizational Unit container object prepared for the deployment. 
        """
        return pulumi.get(self, "adou_path")

    @adou_path.setter
    def adou_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "adou_path", value)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input['DeploymentClusterArgs']]:
        """
        Observability config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input['DeploymentClusterArgs']]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="domainFqdn")
    def domain_fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        FQDN to deploy cluster
        """
        return pulumi.get(self, "domain_fqdn")

    @domain_fqdn.setter
    def domain_fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain_fqdn", value)

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> Optional[pulumi.Input['HostNetworkArgs']]:
        """
        HostNetwork config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "host_network")

    @host_network.setter
    def host_network(self, value: Optional[pulumi.Input['HostNetworkArgs']]):
        pulumi.set(self, "host_network", value)

    @property
    @pulumi.getter(name="infrastructureNetwork")
    def infrastructure_network(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureNetworkArgs']]]]:
        """
        InfrastructureNetwork config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "infrastructure_network")

    @infrastructure_network.setter
    def infrastructure_network(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureNetworkArgs']]]]):
        pulumi.set(self, "infrastructure_network", value)

    @property
    @pulumi.getter(name="namingPrefix")
    def naming_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        naming prefix to deploy cluster.
        """
        return pulumi.get(self, "naming_prefix")

    @naming_prefix.setter
    def naming_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "naming_prefix", value)

    @property
    @pulumi.getter
    def observability(self) -> Optional[pulumi.Input['ObservabilityArgs']]:
        """
        Observability config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "observability")

    @observability.setter
    def observability(self, value: Optional[pulumi.Input['ObservabilityArgs']]):
        pulumi.set(self, "observability", value)

    @property
    @pulumi.getter(name="optionalServices")
    def optional_services(self) -> Optional[pulumi.Input['OptionalServicesArgs']]:
        """
        OptionalServices config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "optional_services")

    @optional_services.setter
    def optional_services(self, value: Optional[pulumi.Input['OptionalServicesArgs']]):
        pulumi.set(self, "optional_services", value)

    @property
    @pulumi.getter(name="physicalNodes")
    def physical_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PhysicalNodesArgs']]]]:
        """
        list of physical nodes config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "physical_nodes")

    @physical_nodes.setter
    def physical_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PhysicalNodesArgs']]]]):
        pulumi.set(self, "physical_nodes", value)

    @property
    @pulumi.getter(name="sdnIntegration")
    def sdn_integration(self) -> Optional[pulumi.Input['SdnIntegrationArgs']]:
        """
        SDN Integration config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "sdn_integration")

    @sdn_integration.setter
    def sdn_integration(self, value: Optional[pulumi.Input['SdnIntegrationArgs']]):
        pulumi.set(self, "sdn_integration", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EceDeploymentSecretsArgs']]]]:
        """
        secrets used for cloud deployment.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EceDeploymentSecretsArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="secretsLocation")
    def secrets_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure keyvault endpoint. This property is deprecated from 2023-12-01-preview. Please use secrets property instead.
        """
        return pulumi.get(self, "secrets_location")

    @secrets_location.setter
    def secrets_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secrets_location", value)

    @property
    @pulumi.getter(name="securitySettings")
    def security_settings(self) -> Optional[pulumi.Input['DeploymentSecuritySettingsArgs']]:
        """
        SecuritySettings to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "security_settings")

    @security_settings.setter
    def security_settings(self, value: Optional[pulumi.Input['DeploymentSecuritySettingsArgs']]):
        pulumi.set(self, "security_settings", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['StorageArgs']]:
        """
        Storage config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['StorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class DeploymentSecuritySettingsArgsDict(TypedDict):
        """
        The SecuritySettings of AzureStackHCI Cluster.
        """
        bitlocker_boot_volume: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, BitLocker XTS_AES 256-bit encryption is enabled for all data-at-rest on the OS volume of your Azure Stack HCI cluster. This setting is TPM-hardware dependent. 
        """
        bitlocker_data_volumes: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, BitLocker XTS-AES 256-bit encryption is enabled for all data-at-rest on your Azure Stack HCI cluster shared volumes.
        """
        credential_guard_enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, Credential Guard is enabled.
        """
        drift_control_enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, the security baseline is re-applied regularly.
        """
        drtm_protection: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, Secure Boot is enabled on your Azure HCI cluster. This setting is hardware dependent.
        """
        hvci_protection: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, Hypervisor-protected Code Integrity is enabled on your Azure HCI cluster.
        """
        side_channel_mitigation_enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, all the side channel mitigations are enabled
        """
        smb_cluster_encryption: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, cluster east-west traffic is encrypted.
        """
        smb_signing_enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, the SMB default instance requires sign in for the client and server services.
        """
        wdac_enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        WDAC is enabled by default and limits the applications and the code that you can run on your Azure Stack HCI cluster.
        """
elif False:
    DeploymentSecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSecuritySettingsArgs:
    def __init__(__self__, *,
                 bitlocker_boot_volume: Optional[pulumi.Input[builtins.bool]] = None,
                 bitlocker_data_volumes: Optional[pulumi.Input[builtins.bool]] = None,
                 credential_guard_enforced: Optional[pulumi.Input[builtins.bool]] = None,
                 drift_control_enforced: Optional[pulumi.Input[builtins.bool]] = None,
                 drtm_protection: Optional[pulumi.Input[builtins.bool]] = None,
                 hvci_protection: Optional[pulumi.Input[builtins.bool]] = None,
                 side_channel_mitigation_enforced: Optional[pulumi.Input[builtins.bool]] = None,
                 smb_cluster_encryption: Optional[pulumi.Input[builtins.bool]] = None,
                 smb_signing_enforced: Optional[pulumi.Input[builtins.bool]] = None,
                 wdac_enforced: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The SecuritySettings of AzureStackHCI Cluster.
        :param pulumi.Input[builtins.bool] bitlocker_boot_volume: When set to true, BitLocker XTS_AES 256-bit encryption is enabled for all data-at-rest on the OS volume of your Azure Stack HCI cluster. This setting is TPM-hardware dependent. 
        :param pulumi.Input[builtins.bool] bitlocker_data_volumes: When set to true, BitLocker XTS-AES 256-bit encryption is enabled for all data-at-rest on your Azure Stack HCI cluster shared volumes.
        :param pulumi.Input[builtins.bool] credential_guard_enforced: When set to true, Credential Guard is enabled.
        :param pulumi.Input[builtins.bool] drift_control_enforced: When set to true, the security baseline is re-applied regularly.
        :param pulumi.Input[builtins.bool] drtm_protection: By default, Secure Boot is enabled on your Azure HCI cluster. This setting is hardware dependent.
        :param pulumi.Input[builtins.bool] hvci_protection: By default, Hypervisor-protected Code Integrity is enabled on your Azure HCI cluster.
        :param pulumi.Input[builtins.bool] side_channel_mitigation_enforced: When set to true, all the side channel mitigations are enabled
        :param pulumi.Input[builtins.bool] smb_cluster_encryption: When set to true, cluster east-west traffic is encrypted.
        :param pulumi.Input[builtins.bool] smb_signing_enforced: When set to true, the SMB default instance requires sign in for the client and server services.
        :param pulumi.Input[builtins.bool] wdac_enforced: WDAC is enabled by default and limits the applications and the code that you can run on your Azure Stack HCI cluster.
        """
        if bitlocker_boot_volume is None:
            bitlocker_boot_volume = True
        if bitlocker_boot_volume is not None:
            pulumi.set(__self__, "bitlocker_boot_volume", bitlocker_boot_volume)
        if bitlocker_data_volumes is None:
            bitlocker_data_volumes = True
        if bitlocker_data_volumes is not None:
            pulumi.set(__self__, "bitlocker_data_volumes", bitlocker_data_volumes)
        if credential_guard_enforced is None:
            credential_guard_enforced = False
        if credential_guard_enforced is not None:
            pulumi.set(__self__, "credential_guard_enforced", credential_guard_enforced)
        if drift_control_enforced is None:
            drift_control_enforced = True
        if drift_control_enforced is not None:
            pulumi.set(__self__, "drift_control_enforced", drift_control_enforced)
        if drtm_protection is None:
            drtm_protection = True
        if drtm_protection is not None:
            pulumi.set(__self__, "drtm_protection", drtm_protection)
        if hvci_protection is None:
            hvci_protection = True
        if hvci_protection is not None:
            pulumi.set(__self__, "hvci_protection", hvci_protection)
        if side_channel_mitigation_enforced is None:
            side_channel_mitigation_enforced = True
        if side_channel_mitigation_enforced is not None:
            pulumi.set(__self__, "side_channel_mitigation_enforced", side_channel_mitigation_enforced)
        if smb_cluster_encryption is None:
            smb_cluster_encryption = False
        if smb_cluster_encryption is not None:
            pulumi.set(__self__, "smb_cluster_encryption", smb_cluster_encryption)
        if smb_signing_enforced is None:
            smb_signing_enforced = True
        if smb_signing_enforced is not None:
            pulumi.set(__self__, "smb_signing_enforced", smb_signing_enforced)
        if wdac_enforced is None:
            wdac_enforced = True
        if wdac_enforced is not None:
            pulumi.set(__self__, "wdac_enforced", wdac_enforced)

    @property
    @pulumi.getter(name="bitlockerBootVolume")
    def bitlocker_boot_volume(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, BitLocker XTS_AES 256-bit encryption is enabled for all data-at-rest on the OS volume of your Azure Stack HCI cluster. This setting is TPM-hardware dependent. 
        """
        return pulumi.get(self, "bitlocker_boot_volume")

    @bitlocker_boot_volume.setter
    def bitlocker_boot_volume(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bitlocker_boot_volume", value)

    @property
    @pulumi.getter(name="bitlockerDataVolumes")
    def bitlocker_data_volumes(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, BitLocker XTS-AES 256-bit encryption is enabled for all data-at-rest on your Azure Stack HCI cluster shared volumes.
        """
        return pulumi.get(self, "bitlocker_data_volumes")

    @bitlocker_data_volumes.setter
    def bitlocker_data_volumes(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bitlocker_data_volumes", value)

    @property
    @pulumi.getter(name="credentialGuardEnforced")
    def credential_guard_enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, Credential Guard is enabled.
        """
        return pulumi.get(self, "credential_guard_enforced")

    @credential_guard_enforced.setter
    def credential_guard_enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "credential_guard_enforced", value)

    @property
    @pulumi.getter(name="driftControlEnforced")
    def drift_control_enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, the security baseline is re-applied regularly.
        """
        return pulumi.get(self, "drift_control_enforced")

    @drift_control_enforced.setter
    def drift_control_enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "drift_control_enforced", value)

    @property
    @pulumi.getter(name="drtmProtection")
    def drtm_protection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, Secure Boot is enabled on your Azure HCI cluster. This setting is hardware dependent.
        """
        return pulumi.get(self, "drtm_protection")

    @drtm_protection.setter
    def drtm_protection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "drtm_protection", value)

    @property
    @pulumi.getter(name="hvciProtection")
    def hvci_protection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, Hypervisor-protected Code Integrity is enabled on your Azure HCI cluster.
        """
        return pulumi.get(self, "hvci_protection")

    @hvci_protection.setter
    def hvci_protection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hvci_protection", value)

    @property
    @pulumi.getter(name="sideChannelMitigationEnforced")
    def side_channel_mitigation_enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, all the side channel mitigations are enabled
        """
        return pulumi.get(self, "side_channel_mitigation_enforced")

    @side_channel_mitigation_enforced.setter
    def side_channel_mitigation_enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "side_channel_mitigation_enforced", value)

    @property
    @pulumi.getter(name="smbClusterEncryption")
    def smb_cluster_encryption(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, cluster east-west traffic is encrypted.
        """
        return pulumi.get(self, "smb_cluster_encryption")

    @smb_cluster_encryption.setter
    def smb_cluster_encryption(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "smb_cluster_encryption", value)

    @property
    @pulumi.getter(name="smbSigningEnforced")
    def smb_signing_enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, the SMB default instance requires sign in for the client and server services.
        """
        return pulumi.get(self, "smb_signing_enforced")

    @smb_signing_enforced.setter
    def smb_signing_enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "smb_signing_enforced", value)

    @property
    @pulumi.getter(name="wdacEnforced")
    def wdac_enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        WDAC is enabled by default and limits the applications and the code that you can run on your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "wdac_enforced")

    @wdac_enforced.setter
    def wdac_enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wdac_enforced", value)


if not MYPY:
    class DeviceConfigurationArgsDict(TypedDict):
        """
        The device Configuration for edge device.
        """
        device_metadata: NotRequired[pulumi.Input[builtins.str]]
        """
        Device metadata details.
        """
        nic_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NicDetailArgsDict']]]]
        """
        NIC Details of device
        """
elif False:
    DeviceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceConfigurationArgs:
    def __init__(__self__, *,
                 device_metadata: Optional[pulumi.Input[builtins.str]] = None,
                 nic_details: Optional[pulumi.Input[Sequence[pulumi.Input['NicDetailArgs']]]] = None):
        """
        The device Configuration for edge device.
        :param pulumi.Input[builtins.str] device_metadata: Device metadata details.
        :param pulumi.Input[Sequence[pulumi.Input['NicDetailArgs']]] nic_details: NIC Details of device
        """
        if device_metadata is not None:
            pulumi.set(__self__, "device_metadata", device_metadata)
        if nic_details is not None:
            pulumi.set(__self__, "nic_details", nic_details)

    @property
    @pulumi.getter(name="deviceMetadata")
    def device_metadata(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Device metadata details.
        """
        return pulumi.get(self, "device_metadata")

    @device_metadata.setter
    def device_metadata(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_metadata", value)

    @property
    @pulumi.getter(name="nicDetails")
    def nic_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NicDetailArgs']]]]:
        """
        NIC Details of device
        """
        return pulumi.get(self, "nic_details")

    @nic_details.setter
    def nic_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NicDetailArgs']]]]):
        pulumi.set(self, "nic_details", value)


if not MYPY:
    class EceDeploymentSecretsArgsDict(TypedDict):
        """
        Protected parameters list stored in keyvault.
        """
        ece_secret_name: NotRequired[pulumi.Input[Union[builtins.str, 'EceSecrets']]]
        """
        Secret name expected for Enterprise Cloud Engine (ECE) deployment.
        """
        secret_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret URI stored in keyvault.
        """
        secret_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret name stored in keyvault.
        """
elif False:
    EceDeploymentSecretsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EceDeploymentSecretsArgs:
    def __init__(__self__, *,
                 ece_secret_name: Optional[pulumi.Input[Union[builtins.str, 'EceSecrets']]] = None,
                 secret_location: Optional[pulumi.Input[builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Protected parameters list stored in keyvault.
        :param pulumi.Input[Union[builtins.str, 'EceSecrets']] ece_secret_name: Secret name expected for Enterprise Cloud Engine (ECE) deployment.
        :param pulumi.Input[builtins.str] secret_location: Secret URI stored in keyvault.
        :param pulumi.Input[builtins.str] secret_name: Secret name stored in keyvault.
        """
        if ece_secret_name is not None:
            pulumi.set(__self__, "ece_secret_name", ece_secret_name)
        if secret_location is not None:
            pulumi.set(__self__, "secret_location", secret_location)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="eceSecretName")
    def ece_secret_name(self) -> Optional[pulumi.Input[Union[builtins.str, 'EceSecrets']]]:
        """
        Secret name expected for Enterprise Cloud Engine (ECE) deployment.
        """
        return pulumi.get(self, "ece_secret_name")

    @ece_secret_name.setter
    def ece_secret_name(self, value: Optional[pulumi.Input[Union[builtins.str, 'EceSecrets']]]):
        pulumi.set(self, "ece_secret_name", value)

    @property
    @pulumi.getter(name="secretLocation")
    def secret_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret URI stored in keyvault.
        """
        return pulumi.get(self, "secret_location")

    @secret_location.setter
    def secret_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_location", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret name stored in keyvault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[builtins.str] name: The name of the extended location.
        :param pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GalleryImageIdentifierArgsDict(TypedDict):
        """
        This is the gallery image definition identifier.
        """
        offer: pulumi.Input[builtins.str]
        """
        The name of the gallery image definition offer.
        """
        publisher: pulumi.Input[builtins.str]
        """
        The name of the gallery image definition publisher.
        """
        sku: pulumi.Input[builtins.str]
        """
        The name of the gallery image definition SKU.
        """
elif False:
    GalleryImageIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageIdentifierArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[builtins.str],
                 publisher: pulumi.Input[builtins.str],
                 sku: pulumi.Input[builtins.str]):
        """
        This is the gallery image definition identifier.
        :param pulumi.Input[builtins.str] offer: The name of the gallery image definition offer.
        :param pulumi.Input[builtins.str] publisher: The name of the gallery image definition publisher.
        :param pulumi.Input[builtins.str] sku: The name of the gallery image definition SKU.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[builtins.str]:
        """
        The name of the gallery image definition offer.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[builtins.str]:
        """
        The name of the gallery image definition publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[builtins.str]:
        """
        The name of the gallery image definition SKU.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class GalleryImageVersionArgsDict(TypedDict):
        """
        Specifies information about the gallery image version that you want to create or update.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        This is the version of the gallery image.
        """
elif False:
    GalleryImageVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GalleryImageVersionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specifies information about the gallery image version that you want to create or update.
        :param pulumi.Input[builtins.str] name: This is the version of the gallery image.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This is the version of the gallery image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GuestCredentialArgsDict(TypedDict):
        """
        Username / Password Credentials to connect to guest.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        The password to connect with the guest.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username to connect with the guest.
        """
elif False:
    GuestCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuestCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Username / Password Credentials to connect to guest.
        :param pulumi.Input[builtins.str] password: The password to connect with the guest.
        :param pulumi.Input[builtins.str] username: The username to connect with the guest.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The password to connect with the guest.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username to connect with the guest.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class HciCollectLogJobPropertiesArgsDict(TypedDict):
        """
        Represents the properties of an HCI Collect Log job.
        """
        from_date: pulumi.Input[builtins.str]
        """
        From date for log collection.
        """
        job_type: pulumi.Input[builtins.str]
        """
        Job Type supported.
        Expected value is 'CollectLog'.
        """
        to_date: pulumi.Input[builtins.str]
        """
        To date for log collection.
        """
        deployment_mode: NotRequired[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]
        """
        Deployment mode to trigger job.
        """
elif False:
    HciCollectLogJobPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HciCollectLogJobPropertiesArgs:
    def __init__(__self__, *,
                 from_date: pulumi.Input[builtins.str],
                 job_type: pulumi.Input[builtins.str],
                 to_date: pulumi.Input[builtins.str],
                 deployment_mode: Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]] = None):
        """
        Represents the properties of an HCI Collect Log job.
        :param pulumi.Input[builtins.str] from_date: From date for log collection.
        :param pulumi.Input[builtins.str] job_type: Job Type supported.
               Expected value is 'CollectLog'.
        :param pulumi.Input[builtins.str] to_date: To date for log collection.
        :param pulumi.Input[Union[builtins.str, 'DeploymentMode']] deployment_mode: Deployment mode to trigger job.
        """
        pulumi.set(__self__, "from_date", from_date)
        pulumi.set(__self__, "job_type", 'CollectLog')
        pulumi.set(__self__, "to_date", to_date)
        if deployment_mode is not None:
            pulumi.set(__self__, "deployment_mode", deployment_mode)

    @property
    @pulumi.getter(name="fromDate")
    def from_date(self) -> pulumi.Input[builtins.str]:
        """
        From date for log collection.
        """
        return pulumi.get(self, "from_date")

    @from_date.setter
    def from_date(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "from_date", value)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[builtins.str]:
        """
        Job Type supported.
        Expected value is 'CollectLog'.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "job_type", value)

    @property
    @pulumi.getter(name="toDate")
    def to_date(self) -> pulumi.Input[builtins.str]:
        """
        To date for log collection.
        """
        return pulumi.get(self, "to_date")

    @to_date.setter
    def to_date(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "to_date", value)

    @property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]:
        """
        Deployment mode to trigger job.
        """
        return pulumi.get(self, "deployment_mode")

    @deployment_mode.setter
    def deployment_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]):
        pulumi.set(self, "deployment_mode", value)


if not MYPY:
    class HciEdgeDevicePropertiesArgsDict(TypedDict):
        """
        properties for Arc-enabled edge device with HCI OS.
        """
        device_configuration: NotRequired[pulumi.Input['DeviceConfigurationArgsDict']]
        """
        Device Configuration
        """
elif False:
    HciEdgeDevicePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HciEdgeDevicePropertiesArgs:
    def __init__(__self__, *,
                 device_configuration: Optional[pulumi.Input['DeviceConfigurationArgs']] = None):
        """
        properties for Arc-enabled edge device with HCI OS.
        :param pulumi.Input['DeviceConfigurationArgs'] device_configuration: Device Configuration
        """
        if device_configuration is not None:
            pulumi.set(__self__, "device_configuration", device_configuration)

    @property
    @pulumi.getter(name="deviceConfiguration")
    def device_configuration(self) -> Optional[pulumi.Input['DeviceConfigurationArgs']]:
        """
        Device Configuration
        """
        return pulumi.get(self, "device_configuration")

    @device_configuration.setter
    def device_configuration(self, value: Optional[pulumi.Input['DeviceConfigurationArgs']]):
        pulumi.set(self, "device_configuration", value)


if not MYPY:
    class HciRemoteSupportJobPropertiesArgsDict(TypedDict):
        """
        Represents the properties of a remote support job for HCI.
        """
        access_level: pulumi.Input[Union[builtins.str, 'RemoteSupportAccessLevel']]
        """
        Remote support access level.
        """
        expiration_timestamp: pulumi.Input[builtins.str]
        """
        Remote support expiration timestamp.
        """
        job_type: pulumi.Input[builtins.str]
        """
        Job Type supported.
        Expected value is 'RemoteSupport'.
        """
        type: pulumi.Input[Union[builtins.str, 'RemoteSupportType']]
        """
        Remote support type.
        """
        deployment_mode: NotRequired[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]
        """
        Deployment mode to trigger job.
        """
elif False:
    HciRemoteSupportJobPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HciRemoteSupportJobPropertiesArgs:
    def __init__(__self__, *,
                 access_level: pulumi.Input[Union[builtins.str, 'RemoteSupportAccessLevel']],
                 expiration_timestamp: pulumi.Input[builtins.str],
                 job_type: pulumi.Input[builtins.str],
                 type: pulumi.Input[Union[builtins.str, 'RemoteSupportType']],
                 deployment_mode: Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]] = None):
        """
        Represents the properties of a remote support job for HCI.
        :param pulumi.Input[Union[builtins.str, 'RemoteSupportAccessLevel']] access_level: Remote support access level.
        :param pulumi.Input[builtins.str] expiration_timestamp: Remote support expiration timestamp.
        :param pulumi.Input[builtins.str] job_type: Job Type supported.
               Expected value is 'RemoteSupport'.
        :param pulumi.Input[Union[builtins.str, 'RemoteSupportType']] type: Remote support type.
        :param pulumi.Input[Union[builtins.str, 'DeploymentMode']] deployment_mode: Deployment mode to trigger job.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "expiration_timestamp", expiration_timestamp)
        pulumi.set(__self__, "job_type", 'RemoteSupport')
        pulumi.set(__self__, "type", type)
        if deployment_mode is not None:
            pulumi.set(__self__, "deployment_mode", deployment_mode)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> pulumi.Input[Union[builtins.str, 'RemoteSupportAccessLevel']]:
        """
        Remote support access level.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: pulumi.Input[Union[builtins.str, 'RemoteSupportAccessLevel']]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="expirationTimestamp")
    def expiration_timestamp(self) -> pulumi.Input[builtins.str]:
        """
        Remote support expiration timestamp.
        """
        return pulumi.get(self, "expiration_timestamp")

    @expiration_timestamp.setter
    def expiration_timestamp(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expiration_timestamp", value)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[builtins.str]:
        """
        Job Type supported.
        Expected value is 'RemoteSupport'.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "job_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'RemoteSupportType']]:
        """
        Remote support type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'RemoteSupportType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]:
        """
        Deployment mode to trigger job.
        """
        return pulumi.get(self, "deployment_mode")

    @deployment_mode.setter
    def deployment_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'DeploymentMode']]]):
        pulumi.set(self, "deployment_mode", value)


if not MYPY:
    class HostNetworkArgsDict(TypedDict):
        """
        The HostNetwork of a cluster.
        """
        enable_storage_auto_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional parameter required only for 3 Nodes Switchless deployments. This allows users to specify IPs and Mask for Storage NICs when Network ATC is not assigning the IPs for storage automatically.
        """
        intents: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntentsArgsDict']]]]
        """
        The network intents assigned to the network reference pattern used for the deployment. Each intent will define its own name, traffic type, adapter names, and overrides as recommended by your OEM.
        """
        storage_connectivity_switchless: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines how the storage adapters between nodes are connected either switch or switch less..
        """
        storage_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageNetworksArgsDict']]]]
        """
        List of StorageNetworks config to deploy AzureStackHCI Cluster.
        """
elif False:
    HostNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostNetworkArgs:
    def __init__(__self__, *,
                 enable_storage_auto_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 intents: Optional[pulumi.Input[Sequence[pulumi.Input['IntentsArgs']]]] = None,
                 storage_connectivity_switchless: Optional[pulumi.Input[builtins.bool]] = None,
                 storage_networks: Optional[pulumi.Input[Sequence[pulumi.Input['StorageNetworksArgs']]]] = None):
        """
        The HostNetwork of a cluster.
        :param pulumi.Input[builtins.bool] enable_storage_auto_ip: Optional parameter required only for 3 Nodes Switchless deployments. This allows users to specify IPs and Mask for Storage NICs when Network ATC is not assigning the IPs for storage automatically.
        :param pulumi.Input[Sequence[pulumi.Input['IntentsArgs']]] intents: The network intents assigned to the network reference pattern used for the deployment. Each intent will define its own name, traffic type, adapter names, and overrides as recommended by your OEM.
        :param pulumi.Input[builtins.bool] storage_connectivity_switchless: Defines how the storage adapters between nodes are connected either switch or switch less..
        :param pulumi.Input[Sequence[pulumi.Input['StorageNetworksArgs']]] storage_networks: List of StorageNetworks config to deploy AzureStackHCI Cluster.
        """
        if enable_storage_auto_ip is None:
            enable_storage_auto_ip = False
        if enable_storage_auto_ip is not None:
            pulumi.set(__self__, "enable_storage_auto_ip", enable_storage_auto_ip)
        if intents is not None:
            pulumi.set(__self__, "intents", intents)
        if storage_connectivity_switchless is None:
            storage_connectivity_switchless = False
        if storage_connectivity_switchless is not None:
            pulumi.set(__self__, "storage_connectivity_switchless", storage_connectivity_switchless)
        if storage_networks is not None:
            pulumi.set(__self__, "storage_networks", storage_networks)

    @property
    @pulumi.getter(name="enableStorageAutoIp")
    def enable_storage_auto_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional parameter required only for 3 Nodes Switchless deployments. This allows users to specify IPs and Mask for Storage NICs when Network ATC is not assigning the IPs for storage automatically.
        """
        return pulumi.get(self, "enable_storage_auto_ip")

    @enable_storage_auto_ip.setter
    def enable_storage_auto_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_storage_auto_ip", value)

    @property
    @pulumi.getter
    def intents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntentsArgs']]]]:
        """
        The network intents assigned to the network reference pattern used for the deployment. Each intent will define its own name, traffic type, adapter names, and overrides as recommended by your OEM.
        """
        return pulumi.get(self, "intents")

    @intents.setter
    def intents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntentsArgs']]]]):
        pulumi.set(self, "intents", value)

    @property
    @pulumi.getter(name="storageConnectivitySwitchless")
    def storage_connectivity_switchless(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines how the storage adapters between nodes are connected either switch or switch less..
        """
        return pulumi.get(self, "storage_connectivity_switchless")

    @storage_connectivity_switchless.setter
    def storage_connectivity_switchless(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "storage_connectivity_switchless", value)

    @property
    @pulumi.getter(name="storageNetworks")
    def storage_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageNetworksArgs']]]]:
        """
        List of StorageNetworks config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "storage_networks")

    @storage_networks.setter
    def storage_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageNetworksArgs']]]]):
        pulumi.set(self, "storage_networks", value)


if not MYPY:
    class HttpProxyConfigurationArgsDict(TypedDict):
        """
        HTTP Proxy configuration for the VM.
        """
        http_proxy: NotRequired[pulumi.Input[builtins.str]]
        """
        The HTTP proxy server endpoint to use.
        """
        https_proxy: NotRequired[pulumi.Input[builtins.str]]
        """
        The HTTPS proxy server endpoint to use.
        """
        no_proxy: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The endpoints that should not go through proxy.
        """
        trusted_ca: NotRequired[pulumi.Input[builtins.str]]
        """
        Alternative CA cert to use for connecting to proxy servers.
        """
elif False:
    HttpProxyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpProxyConfigurationArgs:
    def __init__(__self__, *,
                 http_proxy: Optional[pulumi.Input[builtins.str]] = None,
                 https_proxy: Optional[pulumi.Input[builtins.str]] = None,
                 no_proxy: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 trusted_ca: Optional[pulumi.Input[builtins.str]] = None):
        """
        HTTP Proxy configuration for the VM.
        :param pulumi.Input[builtins.str] http_proxy: The HTTP proxy server endpoint to use.
        :param pulumi.Input[builtins.str] https_proxy: The HTTPS proxy server endpoint to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] no_proxy: The endpoints that should not go through proxy.
        :param pulumi.Input[builtins.str] trusted_ca: Alternative CA cert to use for connecting to proxy servers.
        """
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if trusted_ca is not None:
            pulumi.set(__self__, "trusted_ca", trusted_ca)

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The HTTP proxy server endpoint to use.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "http_proxy", value)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The HTTPS proxy server endpoint to use.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "https_proxy", value)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The endpoints that should not go through proxy.
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "no_proxy", value)

    @property
    @pulumi.getter(name="trustedCa")
    def trusted_ca(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Alternative CA cert to use for connecting to proxy servers.
        """
        return pulumi.get(self, "trusted_ca")

    @trusted_ca.setter
    def trusted_ca(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trusted_ca", value)


if not MYPY:
    class IPConfigurationPropertiesArgsDict(TypedDict):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        private_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        subnet: NotRequired[pulumi.Input['LogicalNetworkArmReferenceArgsDict']]
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
elif False:
    IPConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 private_ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 subnet: Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']] = None):
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        :param pulumi.Input[builtins.str] private_ip_address: PrivateIPAddress - Private IP address of the IP configuration.
        :param pulumi.Input['LogicalNetworkArmReferenceArgs'] subnet: Subnet - Name of Subnet bound to the IP configuration.
        """
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PrivateIPAddress - Private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']]:
        """
        Subnet - Name of Subnet bound to the IP configuration.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['LogicalNetworkArmReferenceArgs']]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class IPConfigurationArgsDict(TypedDict):
        """
        InterfaceIPConfiguration IPConfiguration in a network interface.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        properties: NotRequired[pulumi.Input['IPConfigurationPropertiesArgsDict']]
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
elif False:
    IPConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 properties: Optional[pulumi.Input['IPConfigurationPropertiesArgs']] = None):
        """
        InterfaceIPConfiguration IPConfiguration in a network interface.
        :param pulumi.Input[builtins.str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['IPConfigurationPropertiesArgs'] properties: InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['IPConfigurationPropertiesArgs']]:
        """
        InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['IPConfigurationPropertiesArgs']]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class IPPoolArgsDict(TypedDict):
        """
        Describes IPPool
        """
        end: NotRequired[pulumi.Input[builtins.str]]
        """
        End of the IP address pool
        """
        ip_pool_type: NotRequired[pulumi.Input[Union[builtins.str, 'IPPoolTypeEnum']]]
        """
        Type of the IP Pool [vm, vippool]
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the IP-Pool
        """
        start: NotRequired[pulumi.Input[builtins.str]]
        """
        Start of the IP address pool
        """
elif False:
    IPPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPPoolArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.str]] = None,
                 ip_pool_type: Optional[pulumi.Input[Union[builtins.str, 'IPPoolTypeEnum']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 start: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes IPPool
        :param pulumi.Input[builtins.str] end: End of the IP address pool
        :param pulumi.Input[Union[builtins.str, 'IPPoolTypeEnum']] ip_pool_type: Type of the IP Pool [vm, vippool]
        :param pulumi.Input[builtins.str] name: Name of the IP-Pool
        :param pulumi.Input[builtins.str] start: Start of the IP address pool
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if ip_pool_type is not None:
            pulumi.set(__self__, "ip_pool_type", ip_pool_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End of the IP address pool
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="ipPoolType")
    def ip_pool_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'IPPoolTypeEnum']]]:
        """
        Type of the IP Pool [vm, vippool]
        """
        return pulumi.get(self, "ip_pool_type")

    @ip_pool_type.setter
    def ip_pool_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'IPPoolTypeEnum']]]):
        pulumi.set(self, "ip_pool_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the IP-Pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start of the IP address pool
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ImageArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Gallery Image.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for an image resource used by the virtual machine instance.
        """
elif False:
    ImageArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Gallery Image.
        :param pulumi.Input[builtins.str] id: The ARM ID for an image resource used by the virtual machine instance.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for an image resource used by the virtual machine instance.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class InfrastructureNetworkArgsDict(TypedDict):
        """
        The InfrastructureNetwork of a AzureStackHCI Cluster.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IPv4 address of the DNS servers in your environment.
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Default gateway that should be used for the provided IP address space.
        """
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpPoolsArgsDict']]]]
        """
        Range of IP addresses from which addresses are allocated for nodes within a subnet.
        """
        subnet_mask: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet mask that matches the provided IP address space.
        """
        use_dhcp: NotRequired[pulumi.Input[builtins.bool]]
        """
        Allows customers to use DHCP for Hosts and Cluster IPs. If not declared, the deployment will default to static IPs. When true, GW and DNS servers are not required
        """
elif False:
    InfrastructureNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureNetworkArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['IpPoolsArgs']]]] = None,
                 subnet_mask: Optional[pulumi.Input[builtins.str]] = None,
                 use_dhcp: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The InfrastructureNetwork of a AzureStackHCI Cluster.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: IPv4 address of the DNS servers in your environment.
        :param pulumi.Input[builtins.str] gateway: Default gateway that should be used for the provided IP address space.
        :param pulumi.Input[Sequence[pulumi.Input['IpPoolsArgs']]] ip_pools: Range of IP addresses from which addresses are allocated for nodes within a subnet.
        :param pulumi.Input[builtins.str] subnet_mask: Subnet mask that matches the provided IP address space.
        :param pulumi.Input[builtins.bool] use_dhcp: Allows customers to use DHCP for Hosts and Cluster IPs. If not declared, the deployment will default to static IPs. When true, GW and DNS servers are not required
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if use_dhcp is not None:
            pulumi.set(__self__, "use_dhcp", use_dhcp)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IPv4 address of the DNS servers in your environment.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default gateway that should be used for the provided IP address space.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpPoolsArgs']]]]:
        """
        Range of IP addresses from which addresses are allocated for nodes within a subnet.
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpPoolsArgs']]]]):
        pulumi.set(self, "ip_pools", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet mask that matches the provided IP address space.
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="useDhcp")
    def use_dhcp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Allows customers to use DHCP for Hosts and Cluster IPs. If not declared, the deployment will default to static IPs. When true, GW and DNS servers are not required
        """
        return pulumi.get(self, "use_dhcp")

    @use_dhcp.setter
    def use_dhcp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_dhcp", value)


if not MYPY:
    class IntentsArgsDict(TypedDict):
        """
        The Intents of a cluster.
        """
        adapter: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Array of network interfaces used for the network intent.
        """
        adapter_property_overrides: NotRequired[pulumi.Input['AdapterPropertyOverridesArgsDict']]
        """
        Set Adapter PropertyOverrides for cluster.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the network intent you wish to create.
        """
        override_adapter_property: NotRequired[pulumi.Input[builtins.bool]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        override_qos_policy: NotRequired[pulumi.Input[builtins.bool]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        override_virtual_switch_configuration: NotRequired[pulumi.Input[builtins.bool]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        qos_policy_overrides: NotRequired[pulumi.Input['QosPolicyOverridesArgsDict']]
        """
        Set QoS PolicyOverrides for cluster.
        """
        traffic_type: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of network traffic types. Only allowed values are 'Compute', 'Storage', 'Management'.
        """
        virtual_switch_configuration_overrides: NotRequired[pulumi.Input['VirtualSwitchConfigurationOverridesArgsDict']]
        """
        Set virtualSwitch ConfigurationOverrides for cluster.
        """
elif False:
    IntentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntentsArgs:
    def __init__(__self__, *,
                 adapter: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 adapter_property_overrides: Optional[pulumi.Input['AdapterPropertyOverridesArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 override_adapter_property: Optional[pulumi.Input[builtins.bool]] = None,
                 override_qos_policy: Optional[pulumi.Input[builtins.bool]] = None,
                 override_virtual_switch_configuration: Optional[pulumi.Input[builtins.bool]] = None,
                 qos_policy_overrides: Optional[pulumi.Input['QosPolicyOverridesArgs']] = None,
                 traffic_type: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 virtual_switch_configuration_overrides: Optional[pulumi.Input['VirtualSwitchConfigurationOverridesArgs']] = None):
        """
        The Intents of a cluster.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] adapter: Array of network interfaces used for the network intent.
        :param pulumi.Input['AdapterPropertyOverridesArgs'] adapter_property_overrides: Set Adapter PropertyOverrides for cluster.
        :param pulumi.Input[builtins.str] name: Name of the network intent you wish to create.
        :param pulumi.Input[builtins.bool] override_adapter_property: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.bool] override_qos_policy: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.bool] override_virtual_switch_configuration: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input['QosPolicyOverridesArgs'] qos_policy_overrides: Set QoS PolicyOverrides for cluster.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] traffic_type: List of network traffic types. Only allowed values are 'Compute', 'Storage', 'Management'.
        :param pulumi.Input['VirtualSwitchConfigurationOverridesArgs'] virtual_switch_configuration_overrides: Set virtualSwitch ConfigurationOverrides for cluster.
        """
        if adapter is not None:
            pulumi.set(__self__, "adapter", adapter)
        if adapter_property_overrides is not None:
            pulumi.set(__self__, "adapter_property_overrides", adapter_property_overrides)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_adapter_property is None:
            override_adapter_property = False
        if override_adapter_property is not None:
            pulumi.set(__self__, "override_adapter_property", override_adapter_property)
        if override_qos_policy is None:
            override_qos_policy = False
        if override_qos_policy is not None:
            pulumi.set(__self__, "override_qos_policy", override_qos_policy)
        if override_virtual_switch_configuration is None:
            override_virtual_switch_configuration = False
        if override_virtual_switch_configuration is not None:
            pulumi.set(__self__, "override_virtual_switch_configuration", override_virtual_switch_configuration)
        if qos_policy_overrides is not None:
            pulumi.set(__self__, "qos_policy_overrides", qos_policy_overrides)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)
        if virtual_switch_configuration_overrides is not None:
            pulumi.set(__self__, "virtual_switch_configuration_overrides", virtual_switch_configuration_overrides)

    @property
    @pulumi.getter
    def adapter(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Array of network interfaces used for the network intent.
        """
        return pulumi.get(self, "adapter")

    @adapter.setter
    def adapter(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "adapter", value)

    @property
    @pulumi.getter(name="adapterPropertyOverrides")
    def adapter_property_overrides(self) -> Optional[pulumi.Input['AdapterPropertyOverridesArgs']]:
        """
        Set Adapter PropertyOverrides for cluster.
        """
        return pulumi.get(self, "adapter_property_overrides")

    @adapter_property_overrides.setter
    def adapter_property_overrides(self, value: Optional[pulumi.Input['AdapterPropertyOverridesArgs']]):
        pulumi.set(self, "adapter_property_overrides", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the network intent you wish to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideAdapterProperty")
    def override_adapter_property(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "override_adapter_property")

    @override_adapter_property.setter
    def override_adapter_property(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_adapter_property", value)

    @property
    @pulumi.getter(name="overrideQosPolicy")
    def override_qos_policy(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "override_qos_policy")

    @override_qos_policy.setter
    def override_qos_policy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_qos_policy", value)

    @property
    @pulumi.getter(name="overrideVirtualSwitchConfiguration")
    def override_virtual_switch_configuration(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "override_virtual_switch_configuration")

    @override_virtual_switch_configuration.setter
    def override_virtual_switch_configuration(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_virtual_switch_configuration", value)

    @property
    @pulumi.getter(name="qosPolicyOverrides")
    def qos_policy_overrides(self) -> Optional[pulumi.Input['QosPolicyOverridesArgs']]:
        """
        Set QoS PolicyOverrides for cluster.
        """
        return pulumi.get(self, "qos_policy_overrides")

    @qos_policy_overrides.setter
    def qos_policy_overrides(self, value: Optional[pulumi.Input['QosPolicyOverridesArgs']]):
        pulumi.set(self, "qos_policy_overrides", value)

    @property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of network traffic types. Only allowed values are 'Compute', 'Storage', 'Management'.
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "traffic_type", value)

    @property
    @pulumi.getter(name="virtualSwitchConfigurationOverrides")
    def virtual_switch_configuration_overrides(self) -> Optional[pulumi.Input['VirtualSwitchConfigurationOverridesArgs']]:
        """
        Set virtualSwitch ConfigurationOverrides for cluster.
        """
        return pulumi.get(self, "virtual_switch_configuration_overrides")

    @virtual_switch_configuration_overrides.setter
    def virtual_switch_configuration_overrides(self, value: Optional[pulumi.Input['VirtualSwitchConfigurationOverridesArgs']]):
        pulumi.set(self, "virtual_switch_configuration_overrides", value)


if not MYPY:
    class InterfaceDNSSettingsArgsDict(TypedDict):
        """
        DNS Settings of the interface
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of DNS server IP Addresses for the interface
        """
elif False:
    InterfaceDNSSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterfaceDNSSettingsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        DNS Settings of the interface
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: List of DNS server IP Addresses for the interface
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of DNS server IP Addresses for the interface
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class IpPoolsArgsDict(TypedDict):
        """
        The dnsServers of a device.
        """
        ending_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Ending IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        """
        starting_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Starting IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        """
elif False:
    IpPoolsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpPoolsArgs:
    def __init__(__self__, *,
                 ending_address: Optional[pulumi.Input[builtins.str]] = None,
                 starting_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        The dnsServers of a device.
        :param pulumi.Input[builtins.str] ending_address: Ending IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        :param pulumi.Input[builtins.str] starting_address: Starting IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        """
        if ending_address is not None:
            pulumi.set(__self__, "ending_address", ending_address)
        if starting_address is not None:
            pulumi.set(__self__, "starting_address", starting_address)

    @property
    @pulumi.getter(name="endingAddress")
    def ending_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Ending IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        """
        return pulumi.get(self, "ending_address")

    @ending_address.setter
    def ending_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ending_address", value)

    @property
    @pulumi.getter(name="startingAddress")
    def starting_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Starting IP address for the management network. A minimum of six free, contiguous IPv4 addresses (excluding your host IPs) are needed for infrastructure services such as clustering.
        """
        return pulumi.get(self, "starting_address")

    @starting_address.setter
    def starting_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "starting_address", value)


if not MYPY:
    class LogicalNetworkArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Logical Network.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Logical Network.
        """
elif False:
    LogicalNetworkArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalNetworkArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Logical Network.
        :param pulumi.Input[builtins.str] id: The ARM ID for a Logical Network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Logical Network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LogicalNetworkPropertiesDhcpOptionsArgsDict(TypedDict):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of DNS servers IP addresses.
        """
elif False:
    LogicalNetworkPropertiesDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalNetworkPropertiesDhcpOptionsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the logical network. Standard DHCP option for a subnet overrides logical network DHCP options.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: The list of DNS servers IP addresses.
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of DNS servers IP addresses.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class NetworkControllerArgsDict(TypedDict):
        """
        network controller config for SDN Integration to deploy AzureStackHCI Cluster.
        """
        mac_address_pool_start: NotRequired[pulumi.Input[builtins.str]]
        """
        macAddressPoolStart of network controller used for SDN Integration.
        """
        mac_address_pool_stop: NotRequired[pulumi.Input[builtins.str]]
        """
        macAddressPoolStop of network controller used for SDN Integration.
        """
        network_virtualization_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        NetworkVirtualizationEnabled of network controller used for SDN Integration.
        """
elif False:
    NetworkControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkControllerArgs:
    def __init__(__self__, *,
                 mac_address_pool_start: Optional[pulumi.Input[builtins.str]] = None,
                 mac_address_pool_stop: Optional[pulumi.Input[builtins.str]] = None,
                 network_virtualization_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        network controller config for SDN Integration to deploy AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] mac_address_pool_start: macAddressPoolStart of network controller used for SDN Integration.
        :param pulumi.Input[builtins.str] mac_address_pool_stop: macAddressPoolStop of network controller used for SDN Integration.
        :param pulumi.Input[builtins.bool] network_virtualization_enabled: NetworkVirtualizationEnabled of network controller used for SDN Integration.
        """
        if mac_address_pool_start is not None:
            pulumi.set(__self__, "mac_address_pool_start", mac_address_pool_start)
        if mac_address_pool_stop is not None:
            pulumi.set(__self__, "mac_address_pool_stop", mac_address_pool_stop)
        if network_virtualization_enabled is not None:
            pulumi.set(__self__, "network_virtualization_enabled", network_virtualization_enabled)

    @property
    @pulumi.getter(name="macAddressPoolStart")
    def mac_address_pool_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        macAddressPoolStart of network controller used for SDN Integration.
        """
        return pulumi.get(self, "mac_address_pool_start")

    @mac_address_pool_start.setter
    def mac_address_pool_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_address_pool_start", value)

    @property
    @pulumi.getter(name="macAddressPoolStop")
    def mac_address_pool_stop(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        macAddressPoolStop of network controller used for SDN Integration.
        """
        return pulumi.get(self, "mac_address_pool_stop")

    @mac_address_pool_stop.setter
    def mac_address_pool_stop(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_address_pool_stop", value)

    @property
    @pulumi.getter(name="networkVirtualizationEnabled")
    def network_virtualization_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        NetworkVirtualizationEnabled of network controller used for SDN Integration.
        """
        return pulumi.get(self, "network_virtualization_enabled")

    @network_virtualization_enabled.setter
    def network_virtualization_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "network_virtualization_enabled", value)


if not MYPY:
    class NetworkInterfaceArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Interface.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Network Interface.
        """
elif False:
    NetworkInterfaceArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Network Interface.
        :param pulumi.Input[builtins.str] id: The ARM ID for a Network Interface.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Network Interface.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NetworkSecurityGroupArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Security Group.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Network Security Group.
        """
elif False:
    NetworkSecurityGroupArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityGroupArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Network Security Group.
        :param pulumi.Input[builtins.str] id: The ARM ID for a Network Security Group.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Network Security Group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NicDetailArgsDict(TypedDict):
        """
        The NIC Detail of a device.
        """
        adapter_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Adapter Name of NIC
        """
        component_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Component Id of NIC
        """
        default_gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Default Gateway of NIC
        """
        default_isolation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Default Isolation of Management NIC
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        DNS Servers for NIC
        """
        driver_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Driver Version of NIC
        """
        interface_description: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface Description of NIC
        """
        ip4_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet Mask of NIC
        """
        subnet_mask: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet Mask of NIC
        """
elif False:
    NicDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicDetailArgs:
    def __init__(__self__, *,
                 adapter_name: Optional[pulumi.Input[builtins.str]] = None,
                 component_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_gateway: Optional[pulumi.Input[builtins.str]] = None,
                 default_isolation_id: Optional[pulumi.Input[builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 driver_version: Optional[pulumi.Input[builtins.str]] = None,
                 interface_description: Optional[pulumi.Input[builtins.str]] = None,
                 ip4_address: Optional[pulumi.Input[builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[builtins.str]] = None):
        """
        The NIC Detail of a device.
        :param pulumi.Input[builtins.str] adapter_name: Adapter Name of NIC
        :param pulumi.Input[builtins.str] component_id: Component Id of NIC
        :param pulumi.Input[builtins.str] default_gateway: Default Gateway of NIC
        :param pulumi.Input[builtins.str] default_isolation_id: Default Isolation of Management NIC
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: DNS Servers for NIC
        :param pulumi.Input[builtins.str] driver_version: Driver Version of NIC
        :param pulumi.Input[builtins.str] interface_description: Interface Description of NIC
        :param pulumi.Input[builtins.str] ip4_address: Subnet Mask of NIC
        :param pulumi.Input[builtins.str] subnet_mask: Subnet Mask of NIC
        """
        if adapter_name is not None:
            pulumi.set(__self__, "adapter_name", adapter_name)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if default_gateway is not None:
            pulumi.set(__self__, "default_gateway", default_gateway)
        if default_isolation_id is not None:
            pulumi.set(__self__, "default_isolation_id", default_isolation_id)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if driver_version is not None:
            pulumi.set(__self__, "driver_version", driver_version)
        if interface_description is not None:
            pulumi.set(__self__, "interface_description", interface_description)
        if ip4_address is not None:
            pulumi.set(__self__, "ip4_address", ip4_address)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter(name="adapterName")
    def adapter_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Adapter Name of NIC
        """
        return pulumi.get(self, "adapter_name")

    @adapter_name.setter
    def adapter_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "adapter_name", value)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component Id of NIC
        """
        return pulumi.get(self, "component_id")

    @component_id.setter
    def component_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component_id", value)

    @property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default Gateway of NIC
        """
        return pulumi.get(self, "default_gateway")

    @default_gateway.setter
    def default_gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_gateway", value)

    @property
    @pulumi.getter(name="defaultIsolationId")
    def default_isolation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default Isolation of Management NIC
        """
        return pulumi.get(self, "default_isolation_id")

    @default_isolation_id.setter
    def default_isolation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_isolation_id", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        DNS Servers for NIC
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="driverVersion")
    def driver_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Driver Version of NIC
        """
        return pulumi.get(self, "driver_version")

    @driver_version.setter
    def driver_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "driver_version", value)

    @property
    @pulumi.getter(name="interfaceDescription")
    def interface_description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface Description of NIC
        """
        return pulumi.get(self, "interface_description")

    @interface_description.setter
    def interface_description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "interface_description", value)

    @property
    @pulumi.getter(name="ip4Address")
    def ip4_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet Mask of NIC
        """
        return pulumi.get(self, "ip4_address")

    @ip4_address.setter
    def ip4_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip4_address", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet Mask of NIC
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_mask", value)


if not MYPY:
    class ObservabilityArgsDict(TypedDict):
        """
        The Observability of AzureStackHCI Cluster.
        """
        episodic_data_upload: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, collects log data to facilitate quicker issue resolution.
        """
        eu_location: NotRequired[pulumi.Input[builtins.bool]]
        """
        Location of your cluster. The log and diagnostic data is sent to the appropriate diagnostics servers depending upon where your cluster resides. Setting this to false results in all data sent to Microsoft to be stored outside of the EU.
        """
        streaming_data_client: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables telemetry data to be sent to Microsoft
        """
elif False:
    ObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservabilityArgs:
    def __init__(__self__, *,
                 episodic_data_upload: Optional[pulumi.Input[builtins.bool]] = None,
                 eu_location: Optional[pulumi.Input[builtins.bool]] = None,
                 streaming_data_client: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The Observability of AzureStackHCI Cluster.
        :param pulumi.Input[builtins.bool] episodic_data_upload: When set to true, collects log data to facilitate quicker issue resolution.
        :param pulumi.Input[builtins.bool] eu_location: Location of your cluster. The log and diagnostic data is sent to the appropriate diagnostics servers depending upon where your cluster resides. Setting this to false results in all data sent to Microsoft to be stored outside of the EU.
        :param pulumi.Input[builtins.bool] streaming_data_client: Enables telemetry data to be sent to Microsoft
        """
        if episodic_data_upload is None:
            episodic_data_upload = True
        if episodic_data_upload is not None:
            pulumi.set(__self__, "episodic_data_upload", episodic_data_upload)
        if eu_location is None:
            eu_location = False
        if eu_location is not None:
            pulumi.set(__self__, "eu_location", eu_location)
        if streaming_data_client is None:
            streaming_data_client = True
        if streaming_data_client is not None:
            pulumi.set(__self__, "streaming_data_client", streaming_data_client)

    @property
    @pulumi.getter(name="episodicDataUpload")
    def episodic_data_upload(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, collects log data to facilitate quicker issue resolution.
        """
        return pulumi.get(self, "episodic_data_upload")

    @episodic_data_upload.setter
    def episodic_data_upload(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "episodic_data_upload", value)

    @property
    @pulumi.getter(name="euLocation")
    def eu_location(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Location of your cluster. The log and diagnostic data is sent to the appropriate diagnostics servers depending upon where your cluster resides. Setting this to false results in all data sent to Microsoft to be stored outside of the EU.
        """
        return pulumi.get(self, "eu_location")

    @eu_location.setter
    def eu_location(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eu_location", value)

    @property
    @pulumi.getter(name="streamingDataClient")
    def streaming_data_client(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables telemetry data to be sent to Microsoft
        """
        return pulumi.get(self, "streaming_data_client")

    @streaming_data_client.setter
    def streaming_data_client(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "streaming_data_client", value)


if not MYPY:
    class OptionalServicesArgsDict(TypedDict):
        """
        The OptionalServices of AzureStackHCI Cluster.
        """
        custom_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of custom location.
        """
elif False:
    OptionalServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptionalServicesArgs:
    def __init__(__self__, *,
                 custom_location: Optional[pulumi.Input[builtins.str]] = None):
        """
        The OptionalServices of AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] custom_location: The name of custom location.
        """
        if custom_location is not None:
            pulumi.set(__self__, "custom_location", custom_location)

    @property
    @pulumi.getter(name="customLocation")
    def custom_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of custom location.
        """
        return pulumi.get(self, "custom_location")

    @custom_location.setter
    def custom_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_location", value)


if not MYPY:
    class PhysicalNodesArgsDict(TypedDict):
        """
        The PhysicalNodes of a cluster.
        """
        ipv4_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The IPv4 address assigned to each physical server on your Azure Stack HCI cluster.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        NETBIOS name of each physical server on your Azure Stack HCI cluster.
        """
elif False:
    PhysicalNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PhysicalNodesArgs:
    def __init__(__self__, *,
                 ipv4_address: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The PhysicalNodes of a cluster.
        :param pulumi.Input[builtins.str] ipv4_address: The IPv4 address assigned to each physical server on your Azure Stack HCI cluster.
        :param pulumi.Input[builtins.str] name: NETBIOS name of each physical server on your Azure Stack HCI cluster.
        """
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IPv4 address assigned to each physical server on your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NETBIOS name of each physical server on your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class QosPolicyOverridesArgsDict(TypedDict):
        """
        The QoSPolicyOverrides of a cluster.
        """
        bandwidth_percentage_smb: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        priority_value8021_action_cluster: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        priority_value8021_action_smb: NotRequired[pulumi.Input[builtins.str]]
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
elif False:
    QosPolicyOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyOverridesArgs:
    def __init__(__self__, *,
                 bandwidth_percentage_smb: Optional[pulumi.Input[builtins.str]] = None,
                 priority_value8021_action_cluster: Optional[pulumi.Input[builtins.str]] = None,
                 priority_value8021_action_smb: Optional[pulumi.Input[builtins.str]] = None):
        """
        The QoSPolicyOverrides of a cluster.
        :param pulumi.Input[builtins.str] bandwidth_percentage_smb: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.str] priority_value8021_action_cluster: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        :param pulumi.Input[builtins.str] priority_value8021_action_smb: This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        if bandwidth_percentage_smb is not None:
            pulumi.set(__self__, "bandwidth_percentage_smb", bandwidth_percentage_smb)
        if priority_value8021_action_cluster is not None:
            pulumi.set(__self__, "priority_value8021_action_cluster", priority_value8021_action_cluster)
        if priority_value8021_action_smb is not None:
            pulumi.set(__self__, "priority_value8021_action_smb", priority_value8021_action_smb)

    @property
    @pulumi.getter(name="bandwidthPercentageSMB")
    def bandwidth_percentage_smb(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "bandwidth_percentage_smb")

    @bandwidth_percentage_smb.setter
    def bandwidth_percentage_smb(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_percentage_smb", value)

    @property
    @pulumi.getter(name="priorityValue8021ActionCluster")
    def priority_value8021_action_cluster(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "priority_value8021_action_cluster")

    @priority_value8021_action_cluster.setter
    def priority_value8021_action_cluster(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "priority_value8021_action_cluster", value)

    @property
    @pulumi.getter(name="priorityValue8021ActionSMB")
    def priority_value8021_action_smb(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This parameter should only be modified based on your OEM guidance. Do not modify this parameter without OEM validation.
        """
        return pulumi.get(self, "priority_value8021_action_smb")

    @priority_value8021_action_smb.setter
    def priority_value8021_action_smb(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "priority_value8021_action_smb", value)


if not MYPY:
    class RouteTableArgsDict(TypedDict):
        """
        Route table resource.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteArgsDict']]]]
        """
        Collection of routes contained within a route table.
        """
elif False:
    RouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]] = None):
        """
        Route table resource.
        :param pulumi.Input[Sequence[pulumi.Input['RouteArgs']]] routes: Collection of routes contained within a route table.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]:
        """
        Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteArgs']]]]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class RouteArgsDict(TypedDict):
        """
        Route - Route resource.
        """
        address_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination CIDR to which the route applies.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - name of the subnet
        """
        next_hop_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
elif False:
    RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 next_hop_ip_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        Route - Route resource.
        :param pulumi.Input[builtins.str] address_prefix: The destination CIDR to which the route applies.
        :param pulumi.Input[builtins.str] name: Name - name of the subnet
        :param pulumi.Input[builtins.str] next_hop_ip_address: The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - name of the subnet
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @next_hop_ip_address.setter
    def next_hop_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "next_hop_ip_address", value)


if not MYPY:
    class SbeCredentialsArgsDict(TypedDict):
        """
        secrets used for solution builder extension (SBE) partner extensibility.
        """
        ece_secret_name: NotRequired[pulumi.Input[builtins.str]]
        """
        secret name expected for Enterprise Cloud Engine (ECE).
        """
        secret_location: NotRequired[pulumi.Input[builtins.str]]
        """
        secret URI stored in keyvault.
        """
        secret_name: NotRequired[pulumi.Input[builtins.str]]
        """
        secret name stored in keyvault.
        """
elif False:
    SbeCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SbeCredentialsArgs:
    def __init__(__self__, *,
                 ece_secret_name: Optional[pulumi.Input[builtins.str]] = None,
                 secret_location: Optional[pulumi.Input[builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        secrets used for solution builder extension (SBE) partner extensibility.
        :param pulumi.Input[builtins.str] ece_secret_name: secret name expected for Enterprise Cloud Engine (ECE).
        :param pulumi.Input[builtins.str] secret_location: secret URI stored in keyvault.
        :param pulumi.Input[builtins.str] secret_name: secret name stored in keyvault.
        """
        if ece_secret_name is not None:
            pulumi.set(__self__, "ece_secret_name", ece_secret_name)
        if secret_location is not None:
            pulumi.set(__self__, "secret_location", secret_location)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="eceSecretName")
    def ece_secret_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        secret name expected for Enterprise Cloud Engine (ECE).
        """
        return pulumi.get(self, "ece_secret_name")

    @ece_secret_name.setter
    def ece_secret_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ece_secret_name", value)

    @property
    @pulumi.getter(name="secretLocation")
    def secret_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        secret URI stored in keyvault.
        """
        return pulumi.get(self, "secret_location")

    @secret_location.setter
    def secret_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_location", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        secret name stored in keyvault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class SbeDeploymentInfoArgsDict(TypedDict):
        """
        Solution builder extension (SBE) package and manifest information for the solution builder extension staged for AzureStackHCI cluster deployment.
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE family name.
        """
        publisher: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE manifest publisher.
        """
        sbe_manifest_creation_date: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE Manifest Creation Date.
        """
        sbe_manifest_source: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE Manifest Source.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE package version.
        """
elif False:
    SbeDeploymentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SbeDeploymentInfoArgs:
    def __init__(__self__, *,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 publisher: Optional[pulumi.Input[builtins.str]] = None,
                 sbe_manifest_creation_date: Optional[pulumi.Input[builtins.str]] = None,
                 sbe_manifest_source: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Solution builder extension (SBE) package and manifest information for the solution builder extension staged for AzureStackHCI cluster deployment.
        :param pulumi.Input[builtins.str] family: SBE family name.
        :param pulumi.Input[builtins.str] publisher: SBE manifest publisher.
        :param pulumi.Input[builtins.str] sbe_manifest_creation_date: SBE Manifest Creation Date.
        :param pulumi.Input[builtins.str] sbe_manifest_source: SBE Manifest Source.
        :param pulumi.Input[builtins.str] version: SBE package version.
        """
        if family is not None:
            pulumi.set(__self__, "family", family)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sbe_manifest_creation_date is not None:
            pulumi.set(__self__, "sbe_manifest_creation_date", sbe_manifest_creation_date)
        if sbe_manifest_source is not None:
            pulumi.set(__self__, "sbe_manifest_source", sbe_manifest_source)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE family name.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE manifest publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="sbeManifestCreationDate")
    def sbe_manifest_creation_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE Manifest Creation Date.
        """
        return pulumi.get(self, "sbe_manifest_creation_date")

    @sbe_manifest_creation_date.setter
    def sbe_manifest_creation_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sbe_manifest_creation_date", value)

    @property
    @pulumi.getter(name="sbeManifestSource")
    def sbe_manifest_source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE Manifest Source.
        """
        return pulumi.get(self, "sbe_manifest_source")

    @sbe_manifest_source.setter
    def sbe_manifest_source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sbe_manifest_source", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE package version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SbePartnerInfoArgsDict(TypedDict):
        """
        The solution builder extension (SBE) partner deployment info for cluster.
        """
        credential_list: NotRequired[pulumi.Input[Sequence[pulumi.Input['SbeCredentialsArgsDict']]]]
        """
        SBE credentials list for AzureStackHCI cluster deployment.
        """
        partner_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['SbePartnerPropertiesArgsDict']]]]
        """
        List of SBE partner properties for AzureStackHCI cluster deployment.
        """
        sbe_deployment_info: NotRequired[pulumi.Input['SbeDeploymentInfoArgsDict']]
        """
        SBE package and manifest information for the solution Builder Extension staged for AzureStackHCI cluster deployment.
        """
elif False:
    SbePartnerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SbePartnerInfoArgs:
    def __init__(__self__, *,
                 credential_list: Optional[pulumi.Input[Sequence[pulumi.Input['SbeCredentialsArgs']]]] = None,
                 partner_properties: Optional[pulumi.Input[Sequence[pulumi.Input['SbePartnerPropertiesArgs']]]] = None,
                 sbe_deployment_info: Optional[pulumi.Input['SbeDeploymentInfoArgs']] = None):
        """
        The solution builder extension (SBE) partner deployment info for cluster.
        :param pulumi.Input[Sequence[pulumi.Input['SbeCredentialsArgs']]] credential_list: SBE credentials list for AzureStackHCI cluster deployment.
        :param pulumi.Input[Sequence[pulumi.Input['SbePartnerPropertiesArgs']]] partner_properties: List of SBE partner properties for AzureStackHCI cluster deployment.
        :param pulumi.Input['SbeDeploymentInfoArgs'] sbe_deployment_info: SBE package and manifest information for the solution Builder Extension staged for AzureStackHCI cluster deployment.
        """
        if credential_list is not None:
            pulumi.set(__self__, "credential_list", credential_list)
        if partner_properties is not None:
            pulumi.set(__self__, "partner_properties", partner_properties)
        if sbe_deployment_info is not None:
            pulumi.set(__self__, "sbe_deployment_info", sbe_deployment_info)

    @property
    @pulumi.getter(name="credentialList")
    def credential_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SbeCredentialsArgs']]]]:
        """
        SBE credentials list for AzureStackHCI cluster deployment.
        """
        return pulumi.get(self, "credential_list")

    @credential_list.setter
    def credential_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SbeCredentialsArgs']]]]):
        pulumi.set(self, "credential_list", value)

    @property
    @pulumi.getter(name="partnerProperties")
    def partner_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SbePartnerPropertiesArgs']]]]:
        """
        List of SBE partner properties for AzureStackHCI cluster deployment.
        """
        return pulumi.get(self, "partner_properties")

    @partner_properties.setter
    def partner_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SbePartnerPropertiesArgs']]]]):
        pulumi.set(self, "partner_properties", value)

    @property
    @pulumi.getter(name="sbeDeploymentInfo")
    def sbe_deployment_info(self) -> Optional[pulumi.Input['SbeDeploymentInfoArgs']]:
        """
        SBE package and manifest information for the solution Builder Extension staged for AzureStackHCI cluster deployment.
        """
        return pulumi.get(self, "sbe_deployment_info")

    @sbe_deployment_info.setter
    def sbe_deployment_info(self, value: Optional[pulumi.Input['SbeDeploymentInfoArgs']]):
        pulumi.set(self, "sbe_deployment_info", value)


if not MYPY:
    class SbePartnerPropertiesArgsDict(TypedDict):
        """
        Solution builder extension (SBE) partner properties object.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE partner property name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        SBE partner property value.
        """
elif False:
    SbePartnerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SbePartnerPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Solution builder extension (SBE) partner properties object.
        :param pulumi.Input[builtins.str] name: SBE partner property name.
        :param pulumi.Input[builtins.str] value: SBE partner property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE partner property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SBE partner property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ScaleUnitsArgsDict(TypedDict):
        """
        Scale units will contains list of deployment data
        """
        deployment_data: pulumi.Input['DeploymentDataArgsDict']
        """
        Deployment Data to deploy AzureStackHCI Cluster.
        """
        sbe_partner_info: NotRequired[pulumi.Input['SbePartnerInfoArgsDict']]
        """
        Solution builder extension (SBE) partner properties
        """
elif False:
    ScaleUnitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleUnitsArgs:
    def __init__(__self__, *,
                 deployment_data: pulumi.Input['DeploymentDataArgs'],
                 sbe_partner_info: Optional[pulumi.Input['SbePartnerInfoArgs']] = None):
        """
        Scale units will contains list of deployment data
        :param pulumi.Input['DeploymentDataArgs'] deployment_data: Deployment Data to deploy AzureStackHCI Cluster.
        :param pulumi.Input['SbePartnerInfoArgs'] sbe_partner_info: Solution builder extension (SBE) partner properties
        """
        pulumi.set(__self__, "deployment_data", deployment_data)
        if sbe_partner_info is not None:
            pulumi.set(__self__, "sbe_partner_info", sbe_partner_info)

    @property
    @pulumi.getter(name="deploymentData")
    def deployment_data(self) -> pulumi.Input['DeploymentDataArgs']:
        """
        Deployment Data to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "deployment_data")

    @deployment_data.setter
    def deployment_data(self, value: pulumi.Input['DeploymentDataArgs']):
        pulumi.set(self, "deployment_data", value)

    @property
    @pulumi.getter(name="sbePartnerInfo")
    def sbe_partner_info(self) -> Optional[pulumi.Input['SbePartnerInfoArgs']]:
        """
        Solution builder extension (SBE) partner properties
        """
        return pulumi.get(self, "sbe_partner_info")

    @sbe_partner_info.setter
    def sbe_partner_info(self, value: Optional[pulumi.Input['SbePartnerInfoArgs']]):
        pulumi.set(self, "sbe_partner_info", value)


if not MYPY:
    class SdnIntegrationArgsDict(TypedDict):
        """
        SDN Integration config to deploy AzureStackHCI Cluster.
        """
        network_controller: NotRequired[pulumi.Input['NetworkControllerArgsDict']]
        """
        network controller config for SDN Integration to deploy AzureStackHCI Cluster.
        """
elif False:
    SdnIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdnIntegrationArgs:
    def __init__(__self__, *,
                 network_controller: Optional[pulumi.Input['NetworkControllerArgs']] = None):
        """
        SDN Integration config to deploy AzureStackHCI Cluster.
        :param pulumi.Input['NetworkControllerArgs'] network_controller: network controller config for SDN Integration to deploy AzureStackHCI Cluster.
        """
        if network_controller is not None:
            pulumi.set(__self__, "network_controller", network_controller)

    @property
    @pulumi.getter(name="networkController")
    def network_controller(self) -> Optional[pulumi.Input['NetworkControllerArgs']]:
        """
        network controller config for SDN Integration to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "network_controller")

    @network_controller.setter
    def network_controller(self, value: Optional[pulumi.Input['NetworkControllerArgs']]):
        pulumi.set(self, "network_controller", value)


if not MYPY:
    class ServiceConfigurationArgsDict(TypedDict):
        """
        Service configuration details
        """
        port: pulumi.Input[builtins.float]
        """
        The port on which service is enabled.
        """
        service_name: pulumi.Input[Union[builtins.str, 'ServiceName']]
        """
        Name of the service.
        """
elif False:
    ServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConfigurationArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.float],
                 service_name: pulumi.Input[Union[builtins.str, 'ServiceName']]):
        """
        Service configuration details
        :param pulumi.Input[builtins.float] port: The port on which service is enabled.
        :param pulumi.Input[Union[builtins.str, 'ServiceName']] service_name: Name of the service.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.float]:
        """
        The port on which service is enabled.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[Union[builtins.str, 'ServiceName']]:
        """
        Name of the service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[Union[builtins.str, 'ServiceName']]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class SoftwareAssurancePropertiesArgsDict(TypedDict):
        """
        Software Assurance properties of the cluster.
        """
        software_assurance_intent: NotRequired[pulumi.Input[Union[builtins.str, 'SoftwareAssuranceIntent']]]
        """
        Customer Intent for Software Assurance Benefit.
        """
elif False:
    SoftwareAssurancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftwareAssurancePropertiesArgs:
    def __init__(__self__, *,
                 software_assurance_intent: Optional[pulumi.Input[Union[builtins.str, 'SoftwareAssuranceIntent']]] = None):
        """
        Software Assurance properties of the cluster.
        :param pulumi.Input[Union[builtins.str, 'SoftwareAssuranceIntent']] software_assurance_intent: Customer Intent for Software Assurance Benefit.
        """
        if software_assurance_intent is not None:
            pulumi.set(__self__, "software_assurance_intent", software_assurance_intent)

    @property
    @pulumi.getter(name="softwareAssuranceIntent")
    def software_assurance_intent(self) -> Optional[pulumi.Input[Union[builtins.str, 'SoftwareAssuranceIntent']]]:
        """
        Customer Intent for Software Assurance Benefit.
        """
        return pulumi.get(self, "software_assurance_intent")

    @software_assurance_intent.setter
    def software_assurance_intent(self, value: Optional[pulumi.Input[Union[builtins.str, 'SoftwareAssuranceIntent']]]):
        pulumi.set(self, "software_assurance_intent", value)


if not MYPY:
    class SshConfigurationArgsDict(TypedDict):
        """
        SSH configuration for Linux based VMs running on Azure
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgsDict']]]]
        """
        The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    SshConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshConfigurationArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]] = None):
        """
        SSH configuration for Linux based VMs running on Azure
        :param pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]] public_keys: The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]:
        """
        The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class SshPublicKeyArgsDict(TypedDict):
        """
        Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
        """
        key_data: NotRequired[pulumi.Input[builtins.str]]
        """
        SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://learn.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    SshPublicKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshPublicKeyArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
        :param pulumi.Input[builtins.str] key_data: SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://learn.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        :param pulumi.Input[builtins.str] path: Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://learn.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class StepArgsDict(TypedDict):
        """
        Progress representation of the update run steps.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        More detailed description of the step.
        """
        end_time_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        When the step reached a terminal state.
        """
        error_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message, specified if the step is in a failed state.
        """
        expected_execution_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        """
        last_updated_time_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        Completion time of this step or the last completed sub-step.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the step.
        """
        start_time_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        When the step started, or empty if it has not started executing.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['StepArgsDict']]]]
        """
        Recursive model for child steps of this step.
        """
elif False:
    StepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 end_time_utc: Optional[pulumi.Input[builtins.str]] = None,
                 error_message: Optional[pulumi.Input[builtins.str]] = None,
                 expected_execution_time: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_time_utc: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 start_time_utc: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]] = None):
        """
        Progress representation of the update run steps.
        :param pulumi.Input[builtins.str] description: More detailed description of the step.
        :param pulumi.Input[builtins.str] end_time_utc: When the step reached a terminal state.
        :param pulumi.Input[builtins.str] error_message: Error message, specified if the step is in a failed state.
        :param pulumi.Input[builtins.str] expected_execution_time: Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        :param pulumi.Input[builtins.str] last_updated_time_utc: Completion time of this step or the last completed sub-step.
        :param pulumi.Input[builtins.str] name: Name of the step.
        :param pulumi.Input[builtins.str] start_time_utc: When the step started, or empty if it has not started executing.
        :param pulumi.Input[builtins.str] status: Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        :param pulumi.Input[Sequence[pulumi.Input['StepArgs']]] steps: Recursive model for child steps of this step.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_time_utc is not None:
            pulumi.set(__self__, "end_time_utc", end_time_utc)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if expected_execution_time is not None:
            pulumi.set(__self__, "expected_execution_time", expected_execution_time)
        if last_updated_time_utc is not None:
            pulumi.set(__self__, "last_updated_time_utc", last_updated_time_utc)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start_time_utc is not None:
            pulumi.set(__self__, "start_time_utc", start_time_utc)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        More detailed description of the step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When the step reached a terminal state.
        """
        return pulumi.get(self, "end_time_utc")

    @end_time_utc.setter
    def end_time_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time_utc", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message, specified if the step is in a failed state.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter(name="expectedExecutionTime")
    def expected_execution_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Expected execution time of a given step. This is optionally authored in the update action plan and can be empty.
        """
        return pulumi.get(self, "expected_execution_time")

    @expected_execution_time.setter
    def expected_execution_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expected_execution_time", value)

    @property
    @pulumi.getter(name="lastUpdatedTimeUtc")
    def last_updated_time_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Completion time of this step or the last completed sub-step.
        """
        return pulumi.get(self, "last_updated_time_utc")

    @last_updated_time_utc.setter
    def last_updated_time_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_time_utc", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When the step started, or empty if it has not started executing.
        """
        return pulumi.get(self, "start_time_utc")

    @start_time_utc.setter
    def start_time_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time_utc", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Status of the step, bubbled up from the ECE action plan for installation attempts. Values are: 'Success', 'Error', 'InProgress', and 'Unknown status'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]]:
        """
        Recursive model for child steps of this step.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class StorageAdapterIPInfoArgsDict(TypedDict):
        """
        The StorageAdapter physical nodes of a cluster.
        """
        ipv4_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The IPv4 address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        """
        physical_node: NotRequired[pulumi.Input[builtins.str]]
        """
        storage adapter physical node name.
        """
        subnet_mask: NotRequired[pulumi.Input[builtins.str]]
        """
        The SubnetMask address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        """
elif False:
    StorageAdapterIPInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageAdapterIPInfoArgs:
    def __init__(__self__, *,
                 ipv4_address: Optional[pulumi.Input[builtins.str]] = None,
                 physical_node: Optional[pulumi.Input[builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[builtins.str]] = None):
        """
        The StorageAdapter physical nodes of a cluster.
        :param pulumi.Input[builtins.str] ipv4_address: The IPv4 address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        :param pulumi.Input[builtins.str] physical_node: storage adapter physical node name.
        :param pulumi.Input[builtins.str] subnet_mask: The SubnetMask address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        """
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if physical_node is not None:
            pulumi.set(__self__, "physical_node", physical_node)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IPv4 address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="physicalNode")
    def physical_node(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        storage adapter physical node name.
        """
        return pulumi.get(self, "physical_node")

    @physical_node.setter
    def physical_node(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "physical_node", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SubnetMask address assigned to each storage adapter physical node on your Azure Stack HCI cluster.
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_mask", value)


if not MYPY:
    class StorageNetworksArgsDict(TypedDict):
        """
        The StorageNetworks of a cluster.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the storage network.
        """
        network_adapter_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the storage network adapter.
        """
        storage_adapter_ip_info: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageAdapterIPInfoArgsDict']]]]
        """
        List of Storage adapter physical nodes config to deploy AzureStackHCI Cluster.
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID specified for the VLAN storage network. This setting is applied to the network interfaces that route the storage and VM migration traffic. 
        """
elif False:
    StorageNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageNetworksArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 network_adapter_name: Optional[pulumi.Input[builtins.str]] = None,
                 storage_adapter_ip_info: Optional[pulumi.Input[Sequence[pulumi.Input['StorageAdapterIPInfoArgs']]]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The StorageNetworks of a cluster.
        :param pulumi.Input[builtins.str] name: Name of the storage network.
        :param pulumi.Input[builtins.str] network_adapter_name: Name of the storage network adapter.
        :param pulumi.Input[Sequence[pulumi.Input['StorageAdapterIPInfoArgs']]] storage_adapter_ip_info: List of Storage adapter physical nodes config to deploy AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] vlan_id: ID specified for the VLAN storage network. This setting is applied to the network interfaces that route the storage and VM migration traffic. 
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_adapter_name is not None:
            pulumi.set(__self__, "network_adapter_name", network_adapter_name)
        if storage_adapter_ip_info is not None:
            pulumi.set(__self__, "storage_adapter_ip_info", storage_adapter_ip_info)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the storage network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkAdapterName")
    def network_adapter_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the storage network adapter.
        """
        return pulumi.get(self, "network_adapter_name")

    @network_adapter_name.setter
    def network_adapter_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_adapter_name", value)

    @property
    @pulumi.getter(name="storageAdapterIPInfo")
    def storage_adapter_ip_info(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageAdapterIPInfoArgs']]]]:
        """
        List of Storage adapter physical nodes config to deploy AzureStackHCI Cluster.
        """
        return pulumi.get(self, "storage_adapter_ip_info")

    @storage_adapter_ip_info.setter
    def storage_adapter_ip_info(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageAdapterIPInfoArgs']]]]):
        pulumi.set(self, "storage_adapter_ip_info", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID specified for the VLAN storage network. This setting is applied to the network interfaces that route the storage and VM migration traffic. 
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class StorageArgsDict(TypedDict):
        """
        The Storage config of AzureStackHCI Cluster.
        """
        configuration_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        By default, this mode is set to Express and your storage is configured as per best practices based on the number of nodes in the cluster. Allowed values are 'Express','InfraOnly', 'KeepStorage'
        """
elif False:
    StorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageArgs:
    def __init__(__self__, *,
                 configuration_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        The Storage config of AzureStackHCI Cluster.
        :param pulumi.Input[builtins.str] configuration_mode: By default, this mode is set to Express and your storage is configured as per best practices based on the number of nodes in the cluster. Allowed values are 'Express','InfraOnly', 'KeepStorage'
        """
        if configuration_mode is None:
            configuration_mode = 'Express'
        if configuration_mode is not None:
            pulumi.set(__self__, "configuration_mode", configuration_mode)

    @property
    @pulumi.getter(name="configurationMode")
    def configuration_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        By default, this mode is set to Express and your storage is configured as per best practices based on the number of nodes in the cluster. Allowed values are 'Express','InfraOnly', 'KeepStorage'
        """
        return pulumi.get(self, "configuration_mode")

    @configuration_mode.setter
    def configuration_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "configuration_mode", value)


if not MYPY:
    class SubnetIpConfigurationReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Network Interface.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Network Interface.
        """
elif False:
    SubnetIpConfigurationReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetIpConfigurationReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Network Interface.
        :param pulumi.Input[builtins.str] id: The ARM ID for a Network Interface.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Network Interface.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SubnetArgsDict(TypedDict):
        """
        Properties of the subnet.
        """
        address_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of address prefixes for the subnet.
        """
        ip_allocation_method: NotRequired[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        ip_configuration_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgsDict']]]]
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['IPPoolArgsDict']]]]
        """
        network associated pool of IP Addresses
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        network_security_group: NotRequired[pulumi.Input['NetworkSecurityGroupArmReferenceArgsDict']]
        """
        NetworkSecurityGroup - Network Security Group attached to the logical network.
        """
        route_table: NotRequired[pulumi.Input['RouteTableArgsDict']]
        """
        Route table resource.
        """
        vlan: NotRequired[pulumi.Input[builtins.int]]
        """
        Vlan to use for the subnet
        """
elif False:
    SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ip_allocation_method: Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]] = None,
                 ip_configuration_references: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]] = None,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 network_security_group: Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']] = None,
                 route_table: Optional[pulumi.Input['RouteTableArgs']] = None,
                 vlan: Optional[pulumi.Input[builtins.int]] = None):
        """
        Properties of the subnet.
        :param pulumi.Input[builtins.str] address_prefix: The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] address_prefixes: List of address prefixes for the subnet.
        :param pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']] ip_allocation_method: IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]] ip_configuration_references: IPConfigurationReferences - list of IPConfigurationReferences
        :param pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]] ip_pools: network associated pool of IP Addresses
        :param pulumi.Input[builtins.str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['NetworkSecurityGroupArmReferenceArgs'] network_security_group: NetworkSecurityGroup - Network Security Group attached to the logical network.
        :param pulumi.Input['RouteTableArgs'] route_table: Route table resource.
        :param pulumi.Input[builtins.int] vlan: Vlan to use for the subnet
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if ip_allocation_method is not None:
            pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        if ip_configuration_references is not None:
            pulumi.set(__self__, "ip_configuration_references", ip_configuration_references)
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_security_group is not None:
            pulumi.set(__self__, "network_security_group", network_security_group)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The address prefix for the subnet: Cidr for this subnet - IPv4, IPv6.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]:
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "ip_allocation_method")

    @ip_allocation_method.setter
    def ip_allocation_method(self, value: Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]):
        pulumi.set(self, "ip_allocation_method", value)

    @property
    @pulumi.getter(name="ipConfigurationReferences")
    def ip_configuration_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]]:
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        return pulumi.get(self, "ip_configuration_references")

    @ip_configuration_references.setter
    def ip_configuration_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetIpConfigurationReferenceArgs']]]]):
        pulumi.set(self, "ip_configuration_references", value)

    @property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]:
        """
        network associated pool of IP Addresses
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IPPoolArgs']]]]):
        pulumi.set(self, "ip_pools", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkSecurityGroup")
    def network_security_group(self) -> Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']]:
        """
        NetworkSecurityGroup - Network Security Group attached to the logical network.
        """
        return pulumi.get(self, "network_security_group")

    @network_security_group.setter
    def network_security_group(self, value: Optional[pulumi.Input['NetworkSecurityGroupArmReferenceArgs']]):
        pulumi.set(self, "network_security_group", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['RouteTableArgs']]:
        """
        Route table resource.
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['RouteTableArgs']]):
        pulumi.set(self, "route_table", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Vlan to use for the subnet
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class UpdatePrerequisiteArgsDict(TypedDict):
        """
        If update State is HasPrerequisite, this property contains an array of objects describing prerequisite updates before installing this update. Otherwise, it is empty.
        """
        package_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Friendly name of the prerequisite.
        """
        update_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Updatable component type.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the prerequisite.
        """
elif False:
    UpdatePrerequisiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdatePrerequisiteArgs:
    def __init__(__self__, *,
                 package_name: Optional[pulumi.Input[builtins.str]] = None,
                 update_type: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        If update State is HasPrerequisite, this property contains an array of objects describing prerequisite updates before installing this update. Otherwise, it is empty.
        :param pulumi.Input[builtins.str] package_name: Friendly name of the prerequisite.
        :param pulumi.Input[builtins.str] update_type: Updatable component type.
        :param pulumi.Input[builtins.str] version: Version of the prerequisite.
        """
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if update_type is not None:
            pulumi.set(__self__, "update_type", update_type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Friendly name of the prerequisite.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Updatable component type.
        """
        return pulumi.get(self, "update_type")

    @update_type.setter
    def update_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the prerequisite.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VMDiskSecurityProfileArgsDict(TypedDict):
        """
        Specifies the security profile settings for the managed disk. NOTE: It can only be set for Confidential VMs
        """
        security_encryption_type: NotRequired[pulumi.Input[Union[builtins.str, 'SecurityEncryptionType']]]
        """
        Specifies the EncryptionType of the managed disk. It is set to NonPersistedTPM for not persisting firmware state in the VMGuestState blob. NOTE: It can be set for only Confidential VMs.
        """
elif False:
    VMDiskSecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VMDiskSecurityProfileArgs:
    def __init__(__self__, *,
                 security_encryption_type: Optional[pulumi.Input[Union[builtins.str, 'SecurityEncryptionType']]] = None):
        """
        Specifies the security profile settings for the managed disk. NOTE: It can only be set for Confidential VMs
        :param pulumi.Input[Union[builtins.str, 'SecurityEncryptionType']] security_encryption_type: Specifies the EncryptionType of the managed disk. It is set to NonPersistedTPM for not persisting firmware state in the VMGuestState blob. NOTE: It can be set for only Confidential VMs.
        """
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'SecurityEncryptionType']]]:
        """
        Specifies the EncryptionType of the managed disk. It is set to NonPersistedTPM for not persisting firmware state in the VMGuestState blob. NOTE: It can be set for only Confidential VMs.
        """
        return pulumi.get(self, "security_encryption_type")

    @security_encryption_type.setter
    def security_encryption_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'SecurityEncryptionType']]]):
        pulumi.set(self, "security_encryption_type", value)


if not MYPY:
    class VirtualHardDiskArmReferenceArgsDict(TypedDict):
        """
        The ARM ID for a Virtual Hard Disk.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Virtual Hard Disk.
        """
elif False:
    VirtualHardDiskArmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualHardDiskArmReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The ARM ID for a Virtual Hard Disk.
        :param pulumi.Input[builtins.str] id: The ARM ID for a Virtual Hard Disk.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Virtual Hard Disk.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachineInstanceManagedDiskParametersArgsDict(TypedDict):
        """
        The parameters of a managed disk.
        """
        security_profile: NotRequired[pulumi.Input['VMDiskSecurityProfileArgsDict']]
        """
        Specifies the security profile for the managed disk.
        """
elif False:
    VirtualMachineInstanceManagedDiskParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstanceManagedDiskParametersArgs:
    def __init__(__self__, *,
                 security_profile: Optional[pulumi.Input['VMDiskSecurityProfileArgs']] = None):
        """
        The parameters of a managed disk.
        :param pulumi.Input['VMDiskSecurityProfileArgs'] security_profile: Specifies the security profile for the managed disk.
        """
        if security_profile is not None:
            pulumi.set(__self__, "security_profile", security_profile)

    @property
    @pulumi.getter(name="securityProfile")
    def security_profile(self) -> Optional[pulumi.Input['VMDiskSecurityProfileArgs']]:
        """
        Specifies the security profile for the managed disk.
        """
        return pulumi.get(self, "security_profile")

    @security_profile.setter
    def security_profile(self, value: Optional[pulumi.Input['VMDiskSecurityProfileArgs']]):
        pulumi.set(self, "security_profile", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict(TypedDict):
        """
        Dynamic memory config
        """
        maximum_memory_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum memory in MB
        """
        minimum_memory_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Minimum memory in MB
        """
        target_memory_buffer: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs:
    def __init__(__self__, *,
                 maximum_memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 minimum_memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 target_memory_buffer: Optional[pulumi.Input[builtins.int]] = None):
        """
        Dynamic memory config
        :param pulumi.Input[builtins.float] maximum_memory_mb: Maximum memory in MB
        :param pulumi.Input[builtins.float] minimum_memory_mb: Minimum memory in MB
        :param pulumi.Input[builtins.int] target_memory_buffer: Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        if maximum_memory_mb is not None:
            pulumi.set(__self__, "maximum_memory_mb", maximum_memory_mb)
        if minimum_memory_mb is not None:
            pulumi.set(__self__, "minimum_memory_mb", minimum_memory_mb)
        if target_memory_buffer is not None:
            pulumi.set(__self__, "target_memory_buffer", target_memory_buffer)

    @property
    @pulumi.getter(name="maximumMemoryMB")
    def maximum_memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum memory in MB
        """
        return pulumi.get(self, "maximum_memory_mb")

    @maximum_memory_mb.setter
    def maximum_memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "maximum_memory_mb", value)

    @property
    @pulumi.getter(name="minimumMemoryMB")
    def minimum_memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Minimum memory in MB
        """
        return pulumi.get(self, "minimum_memory_mb")

    @minimum_memory_mb.setter
    def minimum_memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "minimum_memory_mb", value)

    @property
    @pulumi.getter(name="targetMemoryBuffer")
    def target_memory_buffer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the amount of extra memory that should be reserved for a virtual machine instance at runtime, as a percentage of the total memory that the virtual machine instance is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        return pulumi.get(self, "target_memory_buffer")

    @target_memory_buffer.setter
    def target_memory_buffer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_memory_buffer", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict(TypedDict):
        """
        GPU properties - describes the GPU configuration.
        """
        assignment_type: pulumi.Input[Union[builtins.str, 'GpuAssignmentTypeEnum']]
        """
        GPU assignment type
        """
        gpu_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the GPU
        """
        partition_size_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Size of gpu partition in MB for GPU-P
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs:
    def __init__(__self__, *,
                 assignment_type: pulumi.Input[Union[builtins.str, 'GpuAssignmentTypeEnum']],
                 gpu_name: Optional[pulumi.Input[builtins.str]] = None,
                 partition_size_mb: Optional[pulumi.Input[builtins.float]] = None):
        """
        GPU properties - describes the GPU configuration.
        :param pulumi.Input[Union[builtins.str, 'GpuAssignmentTypeEnum']] assignment_type: GPU assignment type
        :param pulumi.Input[builtins.str] gpu_name: Name of the GPU
        :param pulumi.Input[builtins.float] partition_size_mb: Size of gpu partition in MB for GPU-P
        """
        pulumi.set(__self__, "assignment_type", assignment_type)
        if gpu_name is not None:
            pulumi.set(__self__, "gpu_name", gpu_name)
        if partition_size_mb is not None:
            pulumi.set(__self__, "partition_size_mb", partition_size_mb)

    @property
    @pulumi.getter(name="assignmentType")
    def assignment_type(self) -> pulumi.Input[Union[builtins.str, 'GpuAssignmentTypeEnum']]:
        """
        GPU assignment type
        """
        return pulumi.get(self, "assignment_type")

    @assignment_type.setter
    def assignment_type(self, value: pulumi.Input[Union[builtins.str, 'GpuAssignmentTypeEnum']]):
        pulumi.set(self, "assignment_type", value)

    @property
    @pulumi.getter(name="gpuName")
    def gpu_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the GPU
        """
        return pulumi.get(self, "gpu_name")

    @gpu_name.setter
    def gpu_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gpu_name", value)

    @property
    @pulumi.getter(name="partitionSizeMB")
    def partition_size_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Size of gpu partition in MB for GPU-P
        """
        return pulumi.get(self, "partition_size_mb")

    @partition_size_mb.setter
    def partition_size_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "partition_size_mb", value)


if not MYPY:
    class VirtualMachineInstancePropertiesHardwareProfileArgsDict(TypedDict):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine instance.
        """
        dynamic_memory_config: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgsDict']]
        """
        Dynamic memory config
        """
        memory_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        RAM in MB for the virtual machine instance
        """
        processors: NotRequired[pulumi.Input[builtins.int]]
        """
        number of processors for the virtual machine instance
        """
        virtual_machine_gpus: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgsDict']]]]
        """
        virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        """
        vm_size: NotRequired[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]
        """
        Enum of VM Sizes
        """
elif False:
    VirtualMachineInstancePropertiesHardwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesHardwareProfileArgs:
    def __init__(__self__, *,
                 dynamic_memory_config: Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']] = None,
                 memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 processors: Optional[pulumi.Input[builtins.int]] = None,
                 virtual_machine_gpus: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]] = None,
                 vm_size: Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]] = None):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine instance.
        :param pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs'] dynamic_memory_config: Dynamic memory config
        :param pulumi.Input[builtins.float] memory_mb: RAM in MB for the virtual machine instance
        :param pulumi.Input[builtins.int] processors: number of processors for the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]] virtual_machine_gpus: virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        :param pulumi.Input[Union[builtins.str, 'VmSizeEnum']] vm_size: Enum of VM Sizes
        """
        if dynamic_memory_config is not None:
            pulumi.set(__self__, "dynamic_memory_config", dynamic_memory_config)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if virtual_machine_gpus is not None:
            pulumi.set(__self__, "virtual_machine_gpus", virtual_machine_gpus)
        if vm_size is None:
            vm_size = 'Default'
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="dynamicMemoryConfig")
    def dynamic_memory_config(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']]:
        """
        Dynamic memory config
        """
        return pulumi.get(self, "dynamic_memory_config")

    @dynamic_memory_config.setter
    def dynamic_memory_config(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileDynamicMemoryConfigArgs']]):
        pulumi.set(self, "dynamic_memory_config", value)

    @property
    @pulumi.getter(name="memoryMB")
    def memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        RAM in MB for the virtual machine instance
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        number of processors for the virtual machine instance
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "processors", value)

    @property
    @pulumi.getter(name="virtualMachineGPUs")
    def virtual_machine_gpus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]]:
        """
        virtualMachineGPUs - list of gpus to be attached to the virtual machine instance
        """
        return pulumi.get(self, "virtual_machine_gpus")

    @virtual_machine_gpus.setter
    def virtual_machine_gpus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInstancePropertiesHardwareProfileVirtualMachineGPUArgs']]]]):
        pulumi.set(self, "virtual_machine_gpus", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]:
        """
        Enum of VM Sizes
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class VirtualMachineInstancePropertiesNetworkProfileArgsDict(TypedDict):
        """
        NetworkProfile - describes the network configuration the virtual machine instance
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgsDict']]]]
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]] = None):
        """
        NetworkProfile - describes the network configuration the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]] network_interfaces: NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]]:
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine instance
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInterfaceArmReferenceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict(TypedDict):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        disable_password_authentication: NotRequired[pulumi.Input[builtins.bool]]
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        provision_vm_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        provision_vm_config_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['SshConfigurationArgsDict']]
        """
        Specifies the ssh key configuration for a Linux OS.
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs:
    def __init__(__self__, *,
                 disable_password_authentication: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_config_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 ssh: Optional[pulumi.Input['SshConfigurationArgs']] = None):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        :param pulumi.Input[builtins.bool] disable_password_authentication: DisablePasswordAuthentication - whether password authentication should be disabled
        :param pulumi.Input[builtins.bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        :param pulumi.Input[builtins.bool] provision_vm_config_agent: Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        :param pulumi.Input['SshConfigurationArgs'] ssh: Specifies the ssh key configuration for a Linux OS.
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if provision_vm_agent is None:
            provision_vm_agent = True
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if provision_vm_config_agent is None:
            provision_vm_config_agent = True
        if provision_vm_config_agent is not None:
            pulumi.set(__self__, "provision_vm_config_agent", provision_vm_config_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter(name="provisionVMConfigAgent")
    def provision_vm_config_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_config_agent")

    @provision_vm_config_agent.setter
    def provision_vm_config_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_config_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['SshConfigurationArgs']]:
        """
        Specifies the ssh key configuration for a Linux OS.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['SshConfigurationArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict(TypedDict):
        """
        Windows Configuration for the virtual machine instance
        """
        enable_automatic_updates: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        provision_vm_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        provision_vm_config_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['SshConfigurationArgsDict']]
        """
        Specifies the ssh key configuration for Windows OS.
        """
        time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        TimeZone for the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs:
    def __init__(__self__, *,
                 enable_automatic_updates: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_config_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 ssh: Optional[pulumi.Input['SshConfigurationArgs']] = None,
                 time_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        Windows Configuration for the virtual machine instance
        :param pulumi.Input[builtins.bool] enable_automatic_updates: Whether to EnableAutomaticUpdates on the machine
        :param pulumi.Input[builtins.bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        :param pulumi.Input[builtins.bool] provision_vm_config_agent: Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        :param pulumi.Input['SshConfigurationArgs'] ssh: Specifies the ssh key configuration for Windows OS.
        :param pulumi.Input[builtins.str] time_zone: TimeZone for the virtual machine instance
        """
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if provision_vm_agent is None:
            provision_vm_agent = True
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if provision_vm_config_agent is None:
            provision_vm_config_agent = True
        if provision_vm_config_agent is not None:
            pulumi.set(__self__, "provision_vm_config_agent", provision_vm_config_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        return pulumi.get(self, "enable_automatic_updates")

    @enable_automatic_updates.setter
    def enable_automatic_updates(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_automatic_updates", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine instance creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter(name="provisionVMConfigAgent")
    def provision_vm_config_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether the VM Config Agent should be installed during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_config_agent")

    @provision_vm_config_agent.setter
    def provision_vm_config_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_config_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['SshConfigurationArgs']]:
        """
        Specifies the ssh key configuration for Windows OS.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['SshConfigurationArgs']]):
        pulumi.set(self, "ssh", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        TimeZone for the virtual machine instance
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class VirtualMachineInstancePropertiesOsProfileArgsDict(TypedDict):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        """
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        AdminPassword - admin password
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        AdminUsername - admin username
        """
        computer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        ComputerName - name of the compute
        """
        linux_configuration: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgsDict']]
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        windows_configuration: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgsDict']]
        """
        Windows Configuration for the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesOsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesOsProfileArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 computer_name: Optional[pulumi.Input[builtins.str]] = None,
                 linux_configuration: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']] = None,
                 windows_configuration: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']] = None):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        :param pulumi.Input[builtins.str] admin_password: AdminPassword - admin password
        :param pulumi.Input[builtins.str] admin_username: AdminUsername - admin username
        :param pulumi.Input[builtins.str] computer_name: ComputerName - name of the compute
        :param pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs'] linux_configuration: LinuxConfiguration - linux specific configuration values for the virtual machine instance
        :param pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs'] windows_configuration: Windows Configuration for the virtual machine instance
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if computer_name is not None:
            pulumi.set(__self__, "computer_name", computer_name)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AdminPassword - admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AdminUsername - admin username
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ComputerName - name of the compute
        """
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']]:
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine instance
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']]:
        """
        Windows Configuration for the virtual machine instance
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesOsProfileWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


if not MYPY:
    class VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict(TypedDict):
        """
        Uefi settings - Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        secure_boot_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether secure boot should be enabled on the virtual machine instance.
        """
elif False:
    VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs:
    def __init__(__self__, *,
                 secure_boot_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Uefi settings - Specifies whether secure boot should be enabled on the virtual machine instance.
        :param pulumi.Input[builtins.bool] secure_boot_enabled: Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        if secure_boot_enabled is None:
            secure_boot_enabled = False
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether secure boot should be enabled on the virtual machine instance.
        """
        return pulumi.get(self, "secure_boot_enabled")

    @secure_boot_enabled.setter
    def secure_boot_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "secure_boot_enabled", value)


if not MYPY:
    class VirtualMachineInstancePropertiesSecurityProfileArgsDict(TypedDict):
        """
        SecurityProfile - Specifies the security settings for the virtual machine instance.
        """
        enable_tpm: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable TPM flag
        """
        security_type: NotRequired[pulumi.Input[Union[builtins.str, 'SecurityTypes']]]
        """
        Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        """
        uefi_settings: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgsDict']]
        """
        Uefi settings of the virtual machine instance
        """
elif False:
    VirtualMachineInstancePropertiesSecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesSecurityProfileArgs:
    def __init__(__self__, *,
                 enable_tpm: Optional[pulumi.Input[builtins.bool]] = None,
                 security_type: Optional[pulumi.Input[Union[builtins.str, 'SecurityTypes']]] = None,
                 uefi_settings: Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']] = None):
        """
        SecurityProfile - Specifies the security settings for the virtual machine instance.
        :param pulumi.Input[builtins.bool] enable_tpm: Enable TPM flag
        :param pulumi.Input[Union[builtins.str, 'SecurityTypes']] security_type: Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        :param pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs'] uefi_settings: Uefi settings of the virtual machine instance
        """
        if enable_tpm is None:
            enable_tpm = False
        if enable_tpm is not None:
            pulumi.set(__self__, "enable_tpm", enable_tpm)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if uefi_settings is not None:
            pulumi.set(__self__, "uefi_settings", uefi_settings)

    @property
    @pulumi.getter(name="enableTPM")
    def enable_tpm(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable TPM flag
        """
        return pulumi.get(self, "enable_tpm")

    @enable_tpm.setter
    def enable_tpm(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_tpm", value)

    @property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'SecurityTypes']]]:
        """
        Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
        """
        return pulumi.get(self, "security_type")

    @security_type.setter
    def security_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'SecurityTypes']]]):
        pulumi.set(self, "security_type", value)

    @property
    @pulumi.getter(name="uefiSettings")
    def uefi_settings(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']]:
        """
        Uefi settings of the virtual machine instance
        """
        return pulumi.get(self, "uefi_settings")

    @uefi_settings.setter
    def uefi_settings(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesSecurityProfileUefiSettingsArgs']]):
        pulumi.set(self, "uefi_settings", value)


if not MYPY:
    class VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict(TypedDict):
        """
        VHD to attach as OS disk
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARM ID for a Virtual Hard Disk.
        """
        managed_disk: NotRequired[pulumi.Input['VirtualMachineInstanceManagedDiskParametersArgsDict']]
        """
        The managed disk parameters.
        """
        os_type: NotRequired[pulumi.Input[Union[builtins.str, 'OperatingSystemTypes']]]
        """
        This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
elif False:
    VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesStorageProfileOsDiskArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 managed_disk: Optional[pulumi.Input['VirtualMachineInstanceManagedDiskParametersArgs']] = None,
                 os_type: Optional[pulumi.Input[Union[builtins.str, 'OperatingSystemTypes']]] = None):
        """
        VHD to attach as OS disk
        :param pulumi.Input[builtins.str] id: The ARM ID for a Virtual Hard Disk.
        :param pulumi.Input['VirtualMachineInstanceManagedDiskParametersArgs'] managed_disk: The managed disk parameters.
        :param pulumi.Input[Union[builtins.str, 'OperatingSystemTypes']] os_type: This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if managed_disk is not None:
            pulumi.set(__self__, "managed_disk", managed_disk)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARM ID for a Virtual Hard Disk.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="managedDisk")
    def managed_disk(self) -> Optional[pulumi.Input['VirtualMachineInstanceManagedDiskParametersArgs']]:
        """
        The managed disk parameters.
        """
        return pulumi.get(self, "managed_disk")

    @managed_disk.setter
    def managed_disk(self, value: Optional[pulumi.Input['VirtualMachineInstanceManagedDiskParametersArgs']]):
        pulumi.set(self, "managed_disk", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'OperatingSystemTypes']]]:
        """
        This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'OperatingSystemTypes']]]):
        pulumi.set(self, "os_type", value)


if not MYPY:
    class VirtualMachineInstancePropertiesStorageProfileArgsDict(TypedDict):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine instance
        """
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgsDict']]]]
        """
        adds data disks to the virtual machine instance
        """
        image_reference: NotRequired[pulumi.Input['ImageArmReferenceArgsDict']]
        """
        Which Image to use for the virtual machine instance
        """
        os_disk: NotRequired[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgsDict']]
        """
        VHD to attach as OS disk
        """
        vm_config_storage_path_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the storage container that hosts the VM configuration file
        """
elif False:
    VirtualMachineInstancePropertiesStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineInstancePropertiesStorageProfileArgs:
    def __init__(__self__, *,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]] = None,
                 image_reference: Optional[pulumi.Input['ImageArmReferenceArgs']] = None,
                 os_disk: Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']] = None,
                 vm_config_storage_path_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine instance
        :param pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]] data_disks: adds data disks to the virtual machine instance
        :param pulumi.Input['ImageArmReferenceArgs'] image_reference: Which Image to use for the virtual machine instance
        :param pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs'] os_disk: VHD to attach as OS disk
        :param pulumi.Input[builtins.str] vm_config_storage_path_id: Id of the storage container that hosts the VM configuration file
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if image_reference is not None:
            pulumi.set(__self__, "image_reference", image_reference)
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if vm_config_storage_path_id is not None:
            pulumi.set(__self__, "vm_config_storage_path_id", vm_config_storage_path_id)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]]:
        """
        adds data disks to the virtual machine instance
        """
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualHardDiskArmReferenceArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="imageReference")
    def image_reference(self) -> Optional[pulumi.Input['ImageArmReferenceArgs']]:
        """
        Which Image to use for the virtual machine instance
        """
        return pulumi.get(self, "image_reference")

    @image_reference.setter
    def image_reference(self, value: Optional[pulumi.Input['ImageArmReferenceArgs']]):
        pulumi.set(self, "image_reference", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']]:
        """
        VHD to attach as OS disk
        """
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['VirtualMachineInstancePropertiesStorageProfileOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="vmConfigStoragePathId")
    def vm_config_storage_path_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the storage container that hosts the VM configuration file
        """
        return pulumi.get(self, "vm_config_storage_path_id")

    @vm_config_storage_path_id.setter
    def vm_config_storage_path_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vm_config_storage_path_id", value)


if not MYPY:
    class VirtualMachinePropertiesDataDisksArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the data disk
        """
elif False:
    VirtualMachinePropertiesDataDisksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesDataDisksArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Resource ID of the data disk
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the data disk
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesDynamicMemoryConfigArgsDict(TypedDict):
        maximum_memory_mb: NotRequired[pulumi.Input[builtins.float]]
        minimum_memory_mb: NotRequired[pulumi.Input[builtins.float]]
        target_memory_buffer: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
elif False:
    VirtualMachinePropertiesDynamicMemoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesDynamicMemoryConfigArgs:
    def __init__(__self__, *,
                 maximum_memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 minimum_memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 target_memory_buffer: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] target_memory_buffer: Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        if maximum_memory_mb is not None:
            pulumi.set(__self__, "maximum_memory_mb", maximum_memory_mb)
        if minimum_memory_mb is not None:
            pulumi.set(__self__, "minimum_memory_mb", minimum_memory_mb)
        if target_memory_buffer is not None:
            pulumi.set(__self__, "target_memory_buffer", target_memory_buffer)

    @property
    @pulumi.getter(name="maximumMemoryMB")
    def maximum_memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "maximum_memory_mb")

    @maximum_memory_mb.setter
    def maximum_memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "maximum_memory_mb", value)

    @property
    @pulumi.getter(name="minimumMemoryMB")
    def minimum_memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "minimum_memory_mb")

    @minimum_memory_mb.setter
    def minimum_memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "minimum_memory_mb", value)

    @property
    @pulumi.getter(name="targetMemoryBuffer")
    def target_memory_buffer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the amount of extra memory that should be reserved for a virtual machine at runtime, as a percentage of the total memory that the virtual machine is thought to need. This only applies to virtual systems with dynamic memory enabled. This property can be in the range of 5 to 2000.
        """
        return pulumi.get(self, "target_memory_buffer")

    @target_memory_buffer.setter
    def target_memory_buffer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_memory_buffer", value)


if not MYPY:
    class VirtualMachinePropertiesHardwareProfileArgsDict(TypedDict):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine.
        """
        dynamic_memory_config: NotRequired[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgsDict']]
        memory_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        RAM in MB for the virtual machine
        """
        processors: NotRequired[pulumi.Input[builtins.int]]
        """
        number of processors for the virtual machine
        """
        vm_size: NotRequired[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]
elif False:
    VirtualMachinePropertiesHardwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesHardwareProfileArgs:
    def __init__(__self__, *,
                 dynamic_memory_config: Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']] = None,
                 memory_mb: Optional[pulumi.Input[builtins.float]] = None,
                 processors: Optional[pulumi.Input[builtins.int]] = None,
                 vm_size: Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]] = None):
        """
        HardwareProfile - Specifies the hardware settings for the virtual machine.
        :param pulumi.Input[builtins.float] memory_mb: RAM in MB for the virtual machine
        :param pulumi.Input[builtins.int] processors: number of processors for the virtual machine
        """
        if dynamic_memory_config is not None:
            pulumi.set(__self__, "dynamic_memory_config", dynamic_memory_config)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if vm_size is None:
            vm_size = 'Default'
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="dynamicMemoryConfig")
    def dynamic_memory_config(self) -> Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']]:
        return pulumi.get(self, "dynamic_memory_config")

    @dynamic_memory_config.setter
    def dynamic_memory_config(self, value: Optional[pulumi.Input['VirtualMachinePropertiesDynamicMemoryConfigArgs']]):
        pulumi.set(self, "dynamic_memory_config", value)

    @property
    @pulumi.getter(name="memoryMB")
    def memory_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        RAM in MB for the virtual machine
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        number of processors for the virtual machine
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "processors", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]:
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'VmSizeEnum']]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class VirtualMachinePropertiesImageReferenceArgsDict(TypedDict):
        """
        Which Image to use for the virtual machine
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the image
        """
elif False:
    VirtualMachinePropertiesImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesImageReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Which Image to use for the virtual machine
        :param pulumi.Input[builtins.str] id: Resource ID of the image
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the image
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesLinuxConfigurationArgsDict(TypedDict):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        disable_password_authentication: NotRequired[pulumi.Input[builtins.bool]]
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        provision_vm_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['VirtualMachinePropertiesSshArgsDict']]
        """
        SSH - contains settings related to ssh configuration
        """
elif False:
    VirtualMachinePropertiesLinuxConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesLinuxConfigurationArgs:
    def __init__(__self__, *,
                 disable_password_authentication: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 ssh: Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']] = None):
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        :param pulumi.Input[builtins.bool] disable_password_authentication: DisablePasswordAuthentication - whether password authentication should be disabled
        :param pulumi.Input[builtins.bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        :param pulumi.Input['VirtualMachinePropertiesSshArgs'] ssh: SSH - contains settings related to ssh configuration
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        DisablePasswordAuthentication - whether password authentication should be disabled
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']]:
        """
        SSH - contains settings related to ssh configuration
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['VirtualMachinePropertiesSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class VirtualMachinePropertiesNetworkInterfacesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID - Resource Id of the network interface
        """
elif False:
    VirtualMachinePropertiesNetworkInterfacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesNetworkInterfacesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: ID - Resource Id of the network interface
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID - Resource Id of the network interface
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesNetworkProfileArgsDict(TypedDict):
        """
        NetworkProfile - describes the network configuration the virtual machine
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgsDict']]]]
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
elif False:
    VirtualMachinePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]] = None):
        """
        NetworkProfile - describes the network configuration the virtual machine
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]] network_interfaces: NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]]:
        """
        NetworkInterfaces - list of network interfaces to be attached to the virtual machine
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesNetworkInterfacesArgs']]]]):
        pulumi.set(self, "network_interfaces", value)


if not MYPY:
    class VirtualMachinePropertiesOsDiskArgsDict(TypedDict):
        """
        VHD to attach as OS disk
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the OS disk
        """
elif False:
    VirtualMachinePropertiesOsDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesOsDiskArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        VHD to attach as OS disk
        :param pulumi.Input[builtins.str] id: Resource ID of the OS disk
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the OS disk
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualMachinePropertiesOsProfileArgsDict(TypedDict):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        """
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        AdminPassword - admin password
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        AdminUsername - admin username
        """
        computer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        ComputerName - name of the compute
        """
        linux_configuration: NotRequired[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgsDict']]
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        os_type: NotRequired[pulumi.Input[Union[builtins.str, 'OsTypeEnum']]]
        """
        OsType - string specifying whether the OS is Linux or Windows
        """
        windows_configuration: NotRequired[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgsDict']]
        """
        Windows Configuration for the virtual machine 
        """
elif False:
    VirtualMachinePropertiesOsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesOsProfileArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 computer_name: Optional[pulumi.Input[builtins.str]] = None,
                 linux_configuration: Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']] = None,
                 os_type: Optional[pulumi.Input[Union[builtins.str, 'OsTypeEnum']]] = None,
                 windows_configuration: Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']] = None):
        """
        OsProfile - describes the configuration of the operating system and sets login data
        :param pulumi.Input[builtins.str] admin_password: AdminPassword - admin password
        :param pulumi.Input[builtins.str] admin_username: AdminUsername - admin username
        :param pulumi.Input[builtins.str] computer_name: ComputerName - name of the compute
        :param pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs'] linux_configuration: LinuxConfiguration - linux specific configuration values for the virtual machine
        :param pulumi.Input[Union[builtins.str, 'OsTypeEnum']] os_type: OsType - string specifying whether the OS is Linux or Windows
        :param pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs'] windows_configuration: Windows Configuration for the virtual machine 
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if computer_name is not None:
            pulumi.set(__self__, "computer_name", computer_name)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AdminPassword - admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AdminUsername - admin username
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ComputerName - name of the compute
        """
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']]:
        """
        LinuxConfiguration - linux specific configuration values for the virtual machine
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['VirtualMachinePropertiesLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'OsTypeEnum']]]:
        """
        OsType - string specifying whether the OS is Linux or Windows
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'OsTypeEnum']]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']]:
        """
        Windows Configuration for the virtual machine 
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['VirtualMachinePropertiesWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


if not MYPY:
    class VirtualMachinePropertiesPublicKeysPublicKeysArgsDict(TypedDict):
        key_data: NotRequired[pulumi.Input[builtins.str]]
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    VirtualMachinePropertiesPublicKeysPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesPublicKeysPublicKeysArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_data: KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        :param pulumi.Input[builtins.str] path: Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class VirtualMachinePropertiesPublicKeysArgsDict(TypedDict):
        key_data: NotRequired[pulumi.Input[builtins.str]]
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
elif False:
    VirtualMachinePropertiesPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesPublicKeysArgs:
    def __init__(__self__, *,
                 key_data: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_data: KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        :param pulumi.Input[builtins.str] path: Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class VirtualMachinePropertiesSecurityProfileArgsDict(TypedDict):
        """
        SecurityProfile - Specifies the security settings for the virtual machine.
        """
        enable_tpm: NotRequired[pulumi.Input[builtins.bool]]
        uefi_settings: NotRequired[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgsDict']]
elif False:
    VirtualMachinePropertiesSecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSecurityProfileArgs:
    def __init__(__self__, *,
                 enable_tpm: Optional[pulumi.Input[builtins.bool]] = None,
                 uefi_settings: Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']] = None):
        """
        SecurityProfile - Specifies the security settings for the virtual machine.
        """
        if enable_tpm is None:
            enable_tpm = False
        if enable_tpm is not None:
            pulumi.set(__self__, "enable_tpm", enable_tpm)
        if uefi_settings is not None:
            pulumi.set(__self__, "uefi_settings", uefi_settings)

    @property
    @pulumi.getter(name="enableTPM")
    def enable_tpm(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_tpm")

    @enable_tpm.setter
    def enable_tpm(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_tpm", value)

    @property
    @pulumi.getter(name="uefiSettings")
    def uefi_settings(self) -> Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']]:
        return pulumi.get(self, "uefi_settings")

    @uefi_settings.setter
    def uefi_settings(self, value: Optional[pulumi.Input['VirtualMachinePropertiesUefiSettingsArgs']]):
        pulumi.set(self, "uefi_settings", value)


if not MYPY:
    class VirtualMachinePropertiesSshSshArgsDict(TypedDict):
        """
        SSH Configuration
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgsDict']]]]
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    VirtualMachinePropertiesSshSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSshSshArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]] = None):
        """
        SSH Configuration
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]] public_keys: PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]]:
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysPublicKeysArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class VirtualMachinePropertiesSshArgsDict(TypedDict):
        """
        SSH - contains settings related to ssh configuration
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgsDict']]]]
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
elif False:
    VirtualMachinePropertiesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesSshArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]] = None):
        """
        SSH - contains settings related to ssh configuration
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]] public_keys: PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]]:
        """
        PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesPublicKeysArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class VirtualMachinePropertiesStorageProfileArgsDict(TypedDict):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine
        """
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgsDict']]]]
        """
        adds data disks to the virtual machine
        """
        image_reference: NotRequired[pulumi.Input['VirtualMachinePropertiesImageReferenceArgsDict']]
        """
        Which Image to use for the virtual machine
        """
        os_disk: NotRequired[pulumi.Input['VirtualMachinePropertiesOsDiskArgsDict']]
        """
        VHD to attach as OS disk
        """
        vm_config_storage_path_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the storage container that hosts the VM configuration file
        """
elif False:
    VirtualMachinePropertiesStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesStorageProfileArgs:
    def __init__(__self__, *,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]] = None,
                 image_reference: Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']] = None,
                 os_disk: Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']] = None,
                 vm_config_storage_path_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        StorageProfile - contains information about the disks and storage information for the virtual machine
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]] data_disks: adds data disks to the virtual machine
        :param pulumi.Input['VirtualMachinePropertiesImageReferenceArgs'] image_reference: Which Image to use for the virtual machine
        :param pulumi.Input['VirtualMachinePropertiesOsDiskArgs'] os_disk: VHD to attach as OS disk
        :param pulumi.Input[builtins.str] vm_config_storage_path_id: Id of the storage container that hosts the VM configuration file
        """
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if image_reference is not None:
            pulumi.set(__self__, "image_reference", image_reference)
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if vm_config_storage_path_id is not None:
            pulumi.set(__self__, "vm_config_storage_path_id", vm_config_storage_path_id)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]]:
        """
        adds data disks to the virtual machine
        """
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachinePropertiesDataDisksArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="imageReference")
    def image_reference(self) -> Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']]:
        """
        Which Image to use for the virtual machine
        """
        return pulumi.get(self, "image_reference")

    @image_reference.setter
    def image_reference(self, value: Optional[pulumi.Input['VirtualMachinePropertiesImageReferenceArgs']]):
        pulumi.set(self, "image_reference", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']]:
        """
        VHD to attach as OS disk
        """
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['VirtualMachinePropertiesOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="vmConfigStoragePathId")
    def vm_config_storage_path_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the storage container that hosts the VM configuration file
        """
        return pulumi.get(self, "vm_config_storage_path_id")

    @vm_config_storage_path_id.setter
    def vm_config_storage_path_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vm_config_storage_path_id", value)


if not MYPY:
    class VirtualMachinePropertiesUefiSettingsArgsDict(TypedDict):
        secure_boot_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether secure boot should be enabled on the virtual machine.
        """
elif False:
    VirtualMachinePropertiesUefiSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesUefiSettingsArgs:
    def __init__(__self__, *,
                 secure_boot_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] secure_boot_enabled: Specifies whether secure boot should be enabled on the virtual machine.
        """
        if secure_boot_enabled is None:
            secure_boot_enabled = False
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether secure boot should be enabled on the virtual machine.
        """
        return pulumi.get(self, "secure_boot_enabled")

    @secure_boot_enabled.setter
    def secure_boot_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "secure_boot_enabled", value)


if not MYPY:
    class VirtualMachinePropertiesWindowsConfigurationArgsDict(TypedDict):
        """
        Windows Configuration for the virtual machine 
        """
        enable_automatic_updates: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        provision_vm_agent: NotRequired[pulumi.Input[builtins.bool]]
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        ssh: NotRequired[pulumi.Input['VirtualMachinePropertiesSshSshArgsDict']]
        """
        SSH Configuration
        """
        time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        TimeZone for the virtual machine
        """
elif False:
    VirtualMachinePropertiesWindowsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachinePropertiesWindowsConfigurationArgs:
    def __init__(__self__, *,
                 enable_automatic_updates: Optional[pulumi.Input[builtins.bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[builtins.bool]] = None,
                 ssh: Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']] = None,
                 time_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        Windows Configuration for the virtual machine 
        :param pulumi.Input[builtins.bool] enable_automatic_updates: Whether to EnableAutomaticUpdates on the machine
        :param pulumi.Input[builtins.bool] provision_vm_agent: Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        :param pulumi.Input['VirtualMachinePropertiesSshSshArgs'] ssh: SSH Configuration
        :param pulumi.Input[builtins.str] time_zone: TimeZone for the virtual machine
        """
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to EnableAutomaticUpdates on the machine
        """
        return pulumi.get(self, "enable_automatic_updates")

    @enable_automatic_updates.setter
    def enable_automatic_updates(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_automatic_updates", value)

    @property
    @pulumi.getter(name="provisionVMAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Usedto indicate whether Arc for Servers agent onboarding should be triggered during the virtual machine creation process.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']]:
        """
        SSH Configuration
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['VirtualMachinePropertiesSshSshArgs']]):
        pulumi.set(self, "ssh", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        TimeZone for the virtual machine
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class VirtualNetworkPropertiesDhcpOptionsArgsDict(TypedDict):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of DNS servers IP addresses.
        """
elif False:
    VirtualNetworkPropertiesDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesDhcpOptionsArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: The list of DNS servers IP addresses.
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of DNS servers IP addresses.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class VirtualNetworkPropertiesIpConfigurationReferencesArgsDict(TypedDict):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        IPConfigurationID
        """
elif False:
    VirtualNetworkPropertiesIpConfigurationReferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesIpConfigurationReferencesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        IPConfigurationReference - Describes a IPConfiguration under the virtual network
        :param pulumi.Input[builtins.str] id: IPConfigurationID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IPConfigurationID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VirtualNetworkPropertiesRouteTableArgsDict(TypedDict):
        """
        RouteTable for the subnet
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Etag - Gets a unique read-only string that changes whenever the resource is updated.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - READ-ONLY; Resource name.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgsDict']]]]
        """
        Routes - Collection of routes contained within a route table.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type - READ-ONLY; Resource type.
        """
elif False:
    VirtualNetworkPropertiesRouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesRouteTableArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        RouteTable for the subnet
        :param pulumi.Input[builtins.str] id: Etag - Gets a unique read-only string that changes whenever the resource is updated.
        :param pulumi.Input[builtins.str] name: Name - READ-ONLY; Resource name.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]] routes: Routes - Collection of routes contained within a route table.
        :param pulumi.Input[builtins.str] type: Type - READ-ONLY; Resource type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Etag - Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - READ-ONLY; Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]]:
        """
        Routes - Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesRoutesArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type - READ-ONLY; Resource type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VirtualNetworkPropertiesRoutesArgsDict(TypedDict):
        """
        Route is associated with a subnet.
        """
        address_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        AddressPrefix - The destination CIDR to which the route applies.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - name of the subnet
        """
        next_hop_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
elif False:
    VirtualNetworkPropertiesRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesRoutesArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 next_hop_ip_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        Route is associated with a subnet.
        :param pulumi.Input[builtins.str] address_prefix: AddressPrefix - The destination CIDR to which the route applies.
        :param pulumi.Input[builtins.str] name: Name - name of the subnet
        :param pulumi.Input[builtins.str] next_hop_ip_address: NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AddressPrefix - The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - name of the subnet
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @next_hop_ip_address.setter
    def next_hop_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "next_hop_ip_address", value)


if not MYPY:
    class VirtualNetworkPropertiesSubnetsArgsDict(TypedDict):
        """
        Subnet subnet in a virtual network resource.
        """
        address_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Cidr for this subnet - IPv4, IPv6
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        AddressPrefixes - List of address prefixes for the subnet.
        """
        ip_allocation_method: NotRequired[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        ip_configuration_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgsDict']]]]
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        route_table: NotRequired[pulumi.Input['VirtualNetworkPropertiesRouteTableArgsDict']]
        """
        RouteTable for the subnet
        """
        vlan: NotRequired[pulumi.Input[builtins.int]]
        """
        Vlan to use for the subnet
        """
elif False:
    VirtualNetworkPropertiesSubnetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkPropertiesSubnetsArgs:
    def __init__(__self__, *,
                 address_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ip_allocation_method: Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]] = None,
                 ip_configuration_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 route_table: Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']] = None,
                 vlan: Optional[pulumi.Input[builtins.int]] = None):
        """
        Subnet subnet in a virtual network resource.
        :param pulumi.Input[builtins.str] address_prefix: Cidr for this subnet - IPv4, IPv6
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] address_prefixes: AddressPrefixes - List of address prefixes for the subnet.
        :param pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']] ip_allocation_method: IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]] ip_configuration_references: IPConfigurationReferences - list of IPConfigurationReferences
        :param pulumi.Input[builtins.str] name: Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param pulumi.Input['VirtualNetworkPropertiesRouteTableArgs'] route_table: RouteTable for the subnet
        :param pulumi.Input[builtins.int] vlan: Vlan to use for the subnet
        """
        if address_prefix is not None:
            pulumi.set(__self__, "address_prefix", address_prefix)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if ip_allocation_method is not None:
            pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        if ip_configuration_references is not None:
            pulumi.set(__self__, "ip_configuration_references", ip_configuration_references)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cidr for this subnet - IPv4, IPv6
        """
        return pulumi.get(self, "address_prefix")

    @address_prefix.setter
    def address_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_prefix", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        AddressPrefixes - List of address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]:
        """
        IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
        """
        return pulumi.get(self, "ip_allocation_method")

    @ip_allocation_method.setter
    def ip_allocation_method(self, value: Optional[pulumi.Input[Union[builtins.str, 'IpAllocationMethodEnum']]]):
        pulumi.set(self, "ip_allocation_method", value)

    @property
    @pulumi.getter(name="ipConfigurationReferences")
    def ip_configuration_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]]:
        """
        IPConfigurationReferences - list of IPConfigurationReferences
        """
        return pulumi.get(self, "ip_configuration_references")

    @ip_configuration_references.setter
    def ip_configuration_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkPropertiesIpConfigurationReferencesArgs']]]]):
        pulumi.set(self, "ip_configuration_references", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']]:
        """
        RouteTable for the subnet
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['VirtualNetworkPropertiesRouteTableArgs']]):
        pulumi.set(self, "route_table", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Vlan to use for the subnet
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vlan", value)


if not MYPY:
    class VirtualSwitchConfigurationOverridesArgsDict(TypedDict):
        """
        The VirtualSwitchConfigurationOverrides of a cluster.
        """
        enable_iov: NotRequired[pulumi.Input[builtins.str]]
        """
        Enable IoV for Virtual Switch
        """
        load_balancing_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        Load Balancing Algorithm for Virtual Switch
        """
elif False:
    VirtualSwitchConfigurationOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualSwitchConfigurationOverridesArgs:
    def __init__(__self__, *,
                 enable_iov: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancing_algorithm: Optional[pulumi.Input[builtins.str]] = None):
        """
        The VirtualSwitchConfigurationOverrides of a cluster.
        :param pulumi.Input[builtins.str] enable_iov: Enable IoV for Virtual Switch
        :param pulumi.Input[builtins.str] load_balancing_algorithm: Load Balancing Algorithm for Virtual Switch
        """
        if enable_iov is not None:
            pulumi.set(__self__, "enable_iov", enable_iov)
        if load_balancing_algorithm is not None:
            pulumi.set(__self__, "load_balancing_algorithm", load_balancing_algorithm)

    @property
    @pulumi.getter(name="enableIov")
    def enable_iov(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enable IoV for Virtual Switch
        """
        return pulumi.get(self, "enable_iov")

    @enable_iov.setter
    def enable_iov(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enable_iov", value)

    @property
    @pulumi.getter(name="loadBalancingAlgorithm")
    def load_balancing_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Load Balancing Algorithm for Virtual Switch
        """
        return pulumi.get(self, "load_balancing_algorithm")

    @load_balancing_algorithm.setter
    def load_balancing_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancing_algorithm", value)


if not MYPY:
    class VmImageRepositoryCredentialsArgsDict(TypedDict):
        """
        The credentials used to login to the image repository that has access to the specified image
        """
        password: pulumi.Input[builtins.str]
        """
        Password for accessing image repository
        """
        username: pulumi.Input[builtins.str]
        """
        Username for accessing image repository
        """
elif False:
    VmImageRepositoryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmImageRepositoryCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        """
        The credentials used to login to the image repository that has access to the specified image
        :param pulumi.Input[builtins.str] password: Password for accessing image repository
        :param pulumi.Input[builtins.str] username: Username for accessing image repository
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        """
        Password for accessing image repository
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        Username for accessing image repository
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


