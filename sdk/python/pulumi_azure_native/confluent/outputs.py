# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureBlobStorageSinkConnectorServiceInfoResponse',
    'AzureBlobStorageSourceConnectorServiceInfoResponse',
    'AzureCosmosDBSinkConnectorServiceInfoResponse',
    'AzureCosmosDBSourceConnectorServiceInfoResponse',
    'AzureSynapseAnalyticsSinkConnectorServiceInfoResponse',
    'ClusterByokEntityResponse',
    'ClusterConfigEntityResponse',
    'ClusterEnvironmentEntityResponse',
    'ClusterNetworkEntityResponse',
    'ClusterRecordResponse',
    'ClusterSpecEntityResponse',
    'ClusterStatusEntityResponse',
    'ConfluentListMetadataResponse',
    'ConnectorInfoBaseResponse',
    'EnvironmentRecordResponse',
    'InvitationRecordResponse',
    'KafkaAzureBlobStorageSinkConnectorInfoResponse',
    'KafkaAzureBlobStorageSourceConnectorInfoResponse',
    'KafkaAzureCosmosDBSinkConnectorInfoResponse',
    'KafkaAzureCosmosDBSourceConnectorInfoResponse',
    'KafkaAzureSynapseAnalyticsSinkConnectorInfoResponse',
    'MetadataEntityResponse',
    'OfferDetailResponse',
    'RegionRecordResponse',
    'RegionSpecEntityResponse',
    'RoleBindingRecordResponse',
    'SCClusterByokEntityResponse',
    'SCClusterNetworkEnvironmentEntityResponse',
    'SCClusterSpecEntityResponse',
    'SCMetadataEntityResponse',
    'ServiceAccountRecordResponse',
    'StreamGovernanceConfigResponse',
    'SystemDataResponse',
    'TopicMetadataEntityResponse',
    'TopicsInputConfigResponse',
    'TopicsRelatedLinkResponse',
    'UserDetailResponse',
    'UserRecordResponse',
]

@pulumi.output_type
class AzureBlobStorageSinkConnectorServiceInfoResponse(dict):
    """
    The authentication info when auth_type is azureBlobStorageSinkConnector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorServiceType":
            suggest = "connector_service_type"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageContainerName":
            suggest = "storage_container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobStorageSinkConnectorServiceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobStorageSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobStorageSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_service_type: _builtins.str,
                 storage_account_key: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None):
        """
        The authentication info when auth_type is azureBlobStorageSinkConnector
        :param _builtins.str connector_service_type: The connector service type.
               Expected value is 'AzureBlobStorageSinkConnector'.
        :param _builtins.str storage_account_key: Azure Blob Storage Account Key
        :param _builtins.str storage_account_name: Azure Blob Storage Account Name
        :param _builtins.str storage_container_name: Azure Blob Storage Account Container Name
        """
        pulumi.set(__self__, "connector_service_type", 'AzureBlobStorageSinkConnector')
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)

    @_builtins.property
    @pulumi.getter(name="connectorServiceType")
    def connector_service_type(self) -> _builtins.str:
        """
        The connector service type.
        Expected value is 'AzureBlobStorageSinkConnector'.
        """
        return pulumi.get(self, "connector_service_type")

    @_builtins.property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Key
        """
        return pulumi.get(self, "storage_account_key")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Name
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Container Name
        """
        return pulumi.get(self, "storage_container_name")


@pulumi.output_type
class AzureBlobStorageSourceConnectorServiceInfoResponse(dict):
    """
    The connector service type is AzureBlobStorageSourceConnector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorServiceType":
            suggest = "connector_service_type"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageContainerName":
            suggest = "storage_container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobStorageSourceConnectorServiceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobStorageSourceConnectorServiceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobStorageSourceConnectorServiceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_service_type: _builtins.str,
                 storage_account_key: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None):
        """
        The connector service type is AzureBlobStorageSourceConnector
        :param _builtins.str connector_service_type: The connector service type.
               Expected value is 'AzureBlobStorageSourceConnector'.
        :param _builtins.str storage_account_key: Azure Blob Storage Account Key
        :param _builtins.str storage_account_name: Azure Blob Storage Account Name
        :param _builtins.str storage_container_name: Azure Blob Storage Account Container Name
        """
        pulumi.set(__self__, "connector_service_type", 'AzureBlobStorageSourceConnector')
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)

    @_builtins.property
    @pulumi.getter(name="connectorServiceType")
    def connector_service_type(self) -> _builtins.str:
        """
        The connector service type.
        Expected value is 'AzureBlobStorageSourceConnector'.
        """
        return pulumi.get(self, "connector_service_type")

    @_builtins.property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Key
        """
        return pulumi.get(self, "storage_account_key")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Name
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Azure Blob Storage Account Container Name
        """
        return pulumi.get(self, "storage_container_name")


@pulumi.output_type
class AzureCosmosDBSinkConnectorServiceInfoResponse(dict):
    """
    The authentication info when auth_type is AzureCosmosDBSinkConnector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorServiceType":
            suggest = "connector_service_type"
        elif key == "cosmosConnectionEndpoint":
            suggest = "cosmos_connection_endpoint"
        elif key == "cosmosContainersTopicMapping":
            suggest = "cosmos_containers_topic_mapping"
        elif key == "cosmosDatabaseName":
            suggest = "cosmos_database_name"
        elif key == "cosmosIdStrategy":
            suggest = "cosmos_id_strategy"
        elif key == "cosmosMasterKey":
            suggest = "cosmos_master_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDBSinkConnectorServiceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDBSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDBSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_service_type: _builtins.str,
                 cosmos_connection_endpoint: Optional[_builtins.str] = None,
                 cosmos_containers_topic_mapping: Optional[_builtins.str] = None,
                 cosmos_database_name: Optional[_builtins.str] = None,
                 cosmos_id_strategy: Optional[_builtins.str] = None,
                 cosmos_master_key: Optional[_builtins.str] = None):
        """
        The authentication info when auth_type is AzureCosmosDBSinkConnector
        :param _builtins.str connector_service_type: The connector service type.
               Expected value is 'AzureCosmosDBSinkConnector'.
        :param _builtins.str cosmos_connection_endpoint: Azure Cosmos Database Connection Endpoint
        :param _builtins.str cosmos_containers_topic_mapping: Azure Cosmos Database Containers Topic Mapping
        :param _builtins.str cosmos_database_name: Azure Cosmos Database Name
        :param _builtins.str cosmos_id_strategy: Azure Cosmos Database Id Strategy
        :param _builtins.str cosmos_master_key: Azure Cosmos Database Master Key
        """
        pulumi.set(__self__, "connector_service_type", 'AzureCosmosDBSinkConnector')
        if cosmos_connection_endpoint is not None:
            pulumi.set(__self__, "cosmos_connection_endpoint", cosmos_connection_endpoint)
        if cosmos_containers_topic_mapping is not None:
            pulumi.set(__self__, "cosmos_containers_topic_mapping", cosmos_containers_topic_mapping)
        if cosmos_database_name is not None:
            pulumi.set(__self__, "cosmos_database_name", cosmos_database_name)
        if cosmos_id_strategy is not None:
            pulumi.set(__self__, "cosmos_id_strategy", cosmos_id_strategy)
        if cosmos_master_key is not None:
            pulumi.set(__self__, "cosmos_master_key", cosmos_master_key)

    @_builtins.property
    @pulumi.getter(name="connectorServiceType")
    def connector_service_type(self) -> _builtins.str:
        """
        The connector service type.
        Expected value is 'AzureCosmosDBSinkConnector'.
        """
        return pulumi.get(self, "connector_service_type")

    @_builtins.property
    @pulumi.getter(name="cosmosConnectionEndpoint")
    def cosmos_connection_endpoint(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Connection Endpoint
        """
        return pulumi.get(self, "cosmos_connection_endpoint")

    @_builtins.property
    @pulumi.getter(name="cosmosContainersTopicMapping")
    def cosmos_containers_topic_mapping(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Containers Topic Mapping
        """
        return pulumi.get(self, "cosmos_containers_topic_mapping")

    @_builtins.property
    @pulumi.getter(name="cosmosDatabaseName")
    def cosmos_database_name(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Name
        """
        return pulumi.get(self, "cosmos_database_name")

    @_builtins.property
    @pulumi.getter(name="cosmosIdStrategy")
    def cosmos_id_strategy(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Id Strategy
        """
        return pulumi.get(self, "cosmos_id_strategy")

    @_builtins.property
    @pulumi.getter(name="cosmosMasterKey")
    def cosmos_master_key(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Master Key
        """
        return pulumi.get(self, "cosmos_master_key")


@pulumi.output_type
class AzureCosmosDBSourceConnectorServiceInfoResponse(dict):
    """
    The authentication info when auth_type is AzureCosmosDBSourceConnector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorServiceType":
            suggest = "connector_service_type"
        elif key == "cosmosConnectionEndpoint":
            suggest = "cosmos_connection_endpoint"
        elif key == "cosmosContainersTopicMapping":
            suggest = "cosmos_containers_topic_mapping"
        elif key == "cosmosDatabaseName":
            suggest = "cosmos_database_name"
        elif key == "cosmosMasterKey":
            suggest = "cosmos_master_key"
        elif key == "cosmosMessageKeyEnabled":
            suggest = "cosmos_message_key_enabled"
        elif key == "cosmosMessageKeyField":
            suggest = "cosmos_message_key_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDBSourceConnectorServiceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDBSourceConnectorServiceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDBSourceConnectorServiceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_service_type: _builtins.str,
                 cosmos_connection_endpoint: Optional[_builtins.str] = None,
                 cosmos_containers_topic_mapping: Optional[_builtins.str] = None,
                 cosmos_database_name: Optional[_builtins.str] = None,
                 cosmos_master_key: Optional[_builtins.str] = None,
                 cosmos_message_key_enabled: Optional[_builtins.bool] = None,
                 cosmos_message_key_field: Optional[_builtins.str] = None):
        """
        The authentication info when auth_type is AzureCosmosDBSourceConnector
        :param _builtins.str connector_service_type: The connector service type.
               Expected value is 'AzureCosmosDBSourceConnector'.
        :param _builtins.str cosmos_connection_endpoint: Azure Cosmos Database Connection Endpoint
        :param _builtins.str cosmos_containers_topic_mapping: Azure Cosmos Database Containers Topic Mapping
        :param _builtins.str cosmos_database_name: Azure Cosmos Database Name
        :param _builtins.str cosmos_master_key: Azure Cosmos Database Master Key
        :param _builtins.bool cosmos_message_key_enabled: Azure Cosmos Database Message Key Enabled
        :param _builtins.str cosmos_message_key_field: Azure Cosmos Database Message Key Field
        """
        pulumi.set(__self__, "connector_service_type", 'AzureCosmosDBSourceConnector')
        if cosmos_connection_endpoint is not None:
            pulumi.set(__self__, "cosmos_connection_endpoint", cosmos_connection_endpoint)
        if cosmos_containers_topic_mapping is not None:
            pulumi.set(__self__, "cosmos_containers_topic_mapping", cosmos_containers_topic_mapping)
        if cosmos_database_name is not None:
            pulumi.set(__self__, "cosmos_database_name", cosmos_database_name)
        if cosmos_master_key is not None:
            pulumi.set(__self__, "cosmos_master_key", cosmos_master_key)
        if cosmos_message_key_enabled is not None:
            pulumi.set(__self__, "cosmos_message_key_enabled", cosmos_message_key_enabled)
        if cosmos_message_key_field is not None:
            pulumi.set(__self__, "cosmos_message_key_field", cosmos_message_key_field)

    @_builtins.property
    @pulumi.getter(name="connectorServiceType")
    def connector_service_type(self) -> _builtins.str:
        """
        The connector service type.
        Expected value is 'AzureCosmosDBSourceConnector'.
        """
        return pulumi.get(self, "connector_service_type")

    @_builtins.property
    @pulumi.getter(name="cosmosConnectionEndpoint")
    def cosmos_connection_endpoint(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Connection Endpoint
        """
        return pulumi.get(self, "cosmos_connection_endpoint")

    @_builtins.property
    @pulumi.getter(name="cosmosContainersTopicMapping")
    def cosmos_containers_topic_mapping(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Containers Topic Mapping
        """
        return pulumi.get(self, "cosmos_containers_topic_mapping")

    @_builtins.property
    @pulumi.getter(name="cosmosDatabaseName")
    def cosmos_database_name(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Name
        """
        return pulumi.get(self, "cosmos_database_name")

    @_builtins.property
    @pulumi.getter(name="cosmosMasterKey")
    def cosmos_master_key(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Master Key
        """
        return pulumi.get(self, "cosmos_master_key")

    @_builtins.property
    @pulumi.getter(name="cosmosMessageKeyEnabled")
    def cosmos_message_key_enabled(self) -> Optional[_builtins.bool]:
        """
        Azure Cosmos Database Message Key Enabled
        """
        return pulumi.get(self, "cosmos_message_key_enabled")

    @_builtins.property
    @pulumi.getter(name="cosmosMessageKeyField")
    def cosmos_message_key_field(self) -> Optional[_builtins.str]:
        """
        Azure Cosmos Database Message Key Field
        """
        return pulumi.get(self, "cosmos_message_key_field")


@pulumi.output_type
class AzureSynapseAnalyticsSinkConnectorServiceInfoResponse(dict):
    """
    The authentication info when auth_type is AzureSynapseAnalyticsSinkConnector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorServiceType":
            suggest = "connector_service_type"
        elif key == "synapseSqlDatabaseName":
            suggest = "synapse_sql_database_name"
        elif key == "synapseSqlPassword":
            suggest = "synapse_sql_password"
        elif key == "synapseSqlServerName":
            suggest = "synapse_sql_server_name"
        elif key == "synapseSqlUser":
            suggest = "synapse_sql_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureSynapseAnalyticsSinkConnectorServiceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureSynapseAnalyticsSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureSynapseAnalyticsSinkConnectorServiceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_service_type: _builtins.str,
                 synapse_sql_database_name: Optional[_builtins.str] = None,
                 synapse_sql_password: Optional[_builtins.str] = None,
                 synapse_sql_server_name: Optional[_builtins.str] = None,
                 synapse_sql_user: Optional[_builtins.str] = None):
        """
        The authentication info when auth_type is AzureSynapseAnalyticsSinkConnector
        :param _builtins.str connector_service_type: The connector service type.
               Expected value is 'AzureSynapseAnalyticsSinkConnector'.
        :param _builtins.str synapse_sql_database_name: Azure Synapse Dedicated SQL Pool Database Name
        :param _builtins.str synapse_sql_password: Azure Synapse SQL login details
        :param _builtins.str synapse_sql_server_name: Azure Synapse Analytics SQL Server Name
        :param _builtins.str synapse_sql_user: Azure Synapse SQL login details
        """
        pulumi.set(__self__, "connector_service_type", 'AzureSynapseAnalyticsSinkConnector')
        if synapse_sql_database_name is not None:
            pulumi.set(__self__, "synapse_sql_database_name", synapse_sql_database_name)
        if synapse_sql_password is not None:
            pulumi.set(__self__, "synapse_sql_password", synapse_sql_password)
        if synapse_sql_server_name is not None:
            pulumi.set(__self__, "synapse_sql_server_name", synapse_sql_server_name)
        if synapse_sql_user is not None:
            pulumi.set(__self__, "synapse_sql_user", synapse_sql_user)

    @_builtins.property
    @pulumi.getter(name="connectorServiceType")
    def connector_service_type(self) -> _builtins.str:
        """
        The connector service type.
        Expected value is 'AzureSynapseAnalyticsSinkConnector'.
        """
        return pulumi.get(self, "connector_service_type")

    @_builtins.property
    @pulumi.getter(name="synapseSqlDatabaseName")
    def synapse_sql_database_name(self) -> Optional[_builtins.str]:
        """
        Azure Synapse Dedicated SQL Pool Database Name
        """
        return pulumi.get(self, "synapse_sql_database_name")

    @_builtins.property
    @pulumi.getter(name="synapseSqlPassword")
    def synapse_sql_password(self) -> Optional[_builtins.str]:
        """
        Azure Synapse SQL login details
        """
        return pulumi.get(self, "synapse_sql_password")

    @_builtins.property
    @pulumi.getter(name="synapseSqlServerName")
    def synapse_sql_server_name(self) -> Optional[_builtins.str]:
        """
        Azure Synapse Analytics SQL Server Name
        """
        return pulumi.get(self, "synapse_sql_server_name")

    @_builtins.property
    @pulumi.getter(name="synapseSqlUser")
    def synapse_sql_user(self) -> Optional[_builtins.str]:
        """
        Azure Synapse SQL login details
        """
        return pulumi.get(self, "synapse_sql_user")


@pulumi.output_type
class ClusterByokEntityResponse(dict):
    """
    The network associated with this object
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 related: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None):
        """
        The network associated with this object
        :param _builtins.str id: ID of the referred resource
        :param _builtins.str related: API URL for accessing or modifying the referred object
        :param _builtins.str resource_name: CRN reference to the referred resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if related is not None:
            pulumi.set(__self__, "related", related)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the referred resource
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        API URL for accessing or modifying the referred object
        """
        return pulumi.get(self, "related")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        CRN reference to the referred resource
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class ClusterConfigEntityResponse(dict):
    """
    The configuration of the Kafka cluster
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None):
        """
        The configuration of the Kafka cluster
        :param _builtins.str kind: The lifecycle phase of the cluster
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        The lifecycle phase of the cluster
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class ClusterEnvironmentEntityResponse(dict):
    """
    The environment to which cluster belongs
    """
    def __init__(__self__, *,
                 environment: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 related: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None):
        """
        The environment to which cluster belongs
        :param _builtins.str environment: Environment of the referred resource
        :param _builtins.str id: ID of the referred resource
        :param _builtins.str related: API URL for accessing or modifying the referred object
        :param _builtins.str resource_name: CRN reference to the referred resource
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if related is not None:
            pulumi.set(__self__, "related", related)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Environment of the referred resource
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the referred resource
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        API URL for accessing or modifying the referred object
        """
        return pulumi.get(self, "related")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        CRN reference to the referred resource
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class ClusterNetworkEntityResponse(dict):
    """
    The network associated with this object
    """
    def __init__(__self__, *,
                 environment: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 related: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None):
        """
        The network associated with this object
        :param _builtins.str environment: Environment of the referred resource
        :param _builtins.str id: ID of the referred resource
        :param _builtins.str related: API URL for accessing or modifying the referred object
        :param _builtins.str resource_name: CRN reference to the referred resource
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if related is not None:
            pulumi.set(__self__, "related", related)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Environment of the referred resource
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the referred resource
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        API URL for accessing or modifying the referred object
        """
        return pulumi.get(self, "related")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        CRN reference to the referred resource
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class ClusterRecordResponse(dict):
    """
    Details of cluster record
    """
    def __init__(__self__, *,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None,
                 spec: Optional['outputs.ClusterSpecEntityResponse'] = None,
                 status: Optional['outputs.ClusterStatusEntityResponse'] = None):
        """
        Details of cluster record
        :param _builtins.str display_name: Display name of the cluster
        :param _builtins.str id: Id of the cluster
        :param _builtins.str kind: Type of cluster
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        :param 'ClusterSpecEntityResponse' spec: Specification of the cluster
        :param 'ClusterStatusEntityResponse' status: Specification of the cluster
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name of the cluster
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the cluster
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of cluster
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.ClusterSpecEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.ClusterStatusEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ClusterSpecEntityResponse(dict):
    """
    Spec of the cluster record
    """
    def __init__(__self__, *,
                 api_endpoint: Optional[_builtins.str] = None,
                 availability: Optional[_builtins.str] = None,
                 byok: Optional['outputs.ClusterByokEntityResponse'] = None,
                 cloud: Optional[_builtins.str] = None,
                 config: Optional['outputs.ClusterConfigEntityResponse'] = None,
                 display_name: Optional[_builtins.str] = None,
                 environment: Optional['outputs.ClusterEnvironmentEntityResponse'] = None,
                 http_endpoint: Optional[_builtins.str] = None,
                 kafka_bootstrap_endpoint: Optional[_builtins.str] = None,
                 network: Optional['outputs.ClusterNetworkEntityResponse'] = None,
                 region: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        Spec of the cluster record
        :param _builtins.str api_endpoint: The Kafka API cluster endpoint
        :param _builtins.str availability: The availability zone configuration of the cluster
        :param 'ClusterByokEntityResponse' byok: Specification of the cluster
        :param _builtins.str cloud: The cloud service provider
        :param 'ClusterConfigEntityResponse' config: Specification of the cluster
        :param _builtins.str display_name: The name of the cluster
        :param 'ClusterEnvironmentEntityResponse' environment: Specification of the cluster
        :param _builtins.str http_endpoint: The cluster HTTP request URL.
        :param _builtins.str kafka_bootstrap_endpoint: The bootstrap endpoint used by Kafka clients to connect to the cluster
        :param 'ClusterNetworkEntityResponse' network: Specification of the cluster
        :param _builtins.str region: The cloud service provider region
        :param _builtins.str zone: type of zone availability
        """
        if api_endpoint is not None:
            pulumi.set(__self__, "api_endpoint", api_endpoint)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if byok is not None:
            pulumi.set(__self__, "byok", byok)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if kafka_bootstrap_endpoint is not None:
            pulumi.set(__self__, "kafka_bootstrap_endpoint", kafka_bootstrap_endpoint)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> Optional[_builtins.str]:
        """
        The Kafka API cluster endpoint
        """
        return pulumi.get(self, "api_endpoint")

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        The availability zone configuration of the cluster
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter
    def byok(self) -> Optional['outputs.ClusterByokEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "byok")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        """
        The cloud service provider
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.ClusterConfigEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional['outputs.ClusterEnvironmentEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        The cluster HTTP request URL.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="kafkaBootstrapEndpoint")
    def kafka_bootstrap_endpoint(self) -> Optional[_builtins.str]:
        """
        The bootstrap endpoint used by Kafka clients to connect to the cluster
        """
        return pulumi.get(self, "kafka_bootstrap_endpoint")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterNetworkEntityResponse']:
        """
        Specification of the cluster
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The cloud service provider region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        type of zone availability
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterStatusEntityResponse(dict):
    """
    Status of the cluster record
    """
    def __init__(__self__, *,
                 cku: Optional[_builtins.int] = None,
                 phase: Optional[_builtins.str] = None):
        """
        Status of the cluster record
        :param _builtins.int cku: The number of Confluent Kafka Units
        :param _builtins.str phase: The lifecycle phase of the cluster
        """
        if cku is not None:
            pulumi.set(__self__, "cku", cku)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @_builtins.property
    @pulumi.getter
    def cku(self) -> Optional[_builtins.int]:
        """
        The number of Confluent Kafka Units
        """
        return pulumi.get(self, "cku")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        The lifecycle phase of the cluster
        """
        return pulumi.get(self, "phase")


@pulumi.output_type
class ConfluentListMetadataResponse(dict):
    """
    Metadata of the list
    """
    def __init__(__self__, *,
                 first: Optional[_builtins.str] = None,
                 last: Optional[_builtins.str] = None,
                 next: Optional[_builtins.str] = None,
                 prev: Optional[_builtins.str] = None,
                 total_size: Optional[_builtins.int] = None):
        """
        Metadata of the list
        :param _builtins.str first: First page of the list
        :param _builtins.str last: Last page of the list
        :param _builtins.str next: Next page of the list
        :param _builtins.str prev: Previous page of the list
        :param _builtins.int total_size: Total size of the list
        """
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if next is not None:
            pulumi.set(__self__, "next", next)
        if prev is not None:
            pulumi.set(__self__, "prev", prev)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @_builtins.property
    @pulumi.getter
    def first(self) -> Optional[_builtins.str]:
        """
        First page of the list
        """
        return pulumi.get(self, "first")

    @_builtins.property
    @pulumi.getter
    def last(self) -> Optional[_builtins.str]:
        """
        Last page of the list
        """
        return pulumi.get(self, "last")

    @_builtins.property
    @pulumi.getter
    def next(self) -> Optional[_builtins.str]:
        """
        Next page of the list
        """
        return pulumi.get(self, "next")

    @_builtins.property
    @pulumi.getter
    def prev(self) -> Optional[_builtins.str]:
        """
        Previous page of the list
        """
        return pulumi.get(self, "prev")

    @_builtins.property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[_builtins.int]:
        """
        Total size of the list
        """
        return pulumi.get(self, "total_size")


@pulumi.output_type
class ConnectorInfoBaseResponse(dict):
    """
    Connector Info Base properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorClass":
            suggest = "connector_class"
        elif key == "connectorId":
            suggest = "connector_id"
        elif key == "connectorName":
            suggest = "connector_name"
        elif key == "connectorState":
            suggest = "connector_state"
        elif key == "connectorType":
            suggest = "connector_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorInfoBaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorInfoBaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorInfoBaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_class: Optional[_builtins.str] = None,
                 connector_id: Optional[_builtins.str] = None,
                 connector_name: Optional[_builtins.str] = None,
                 connector_state: Optional[_builtins.str] = None,
                 connector_type: Optional[_builtins.str] = None):
        """
        Connector Info Base properties
        :param _builtins.str connector_class: Connector Class
        :param _builtins.str connector_id: Connector Id
        :param _builtins.str connector_name: Connector Name
        :param _builtins.str connector_state: Connector Status
        :param _builtins.str connector_type: Connector Type
        """
        if connector_class is not None:
            pulumi.set(__self__, "connector_class", connector_class)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if connector_name is not None:
            pulumi.set(__self__, "connector_name", connector_name)
        if connector_state is not None:
            pulumi.set(__self__, "connector_state", connector_state)
        if connector_type is not None:
            pulumi.set(__self__, "connector_type", connector_type)

    @_builtins.property
    @pulumi.getter(name="connectorClass")
    def connector_class(self) -> Optional[_builtins.str]:
        """
        Connector Class
        """
        return pulumi.get(self, "connector_class")

    @_builtins.property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[_builtins.str]:
        """
        Connector Id
        """
        return pulumi.get(self, "connector_id")

    @_builtins.property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> Optional[_builtins.str]:
        """
        Connector Name
        """
        return pulumi.get(self, "connector_name")

    @_builtins.property
    @pulumi.getter(name="connectorState")
    def connector_state(self) -> Optional[_builtins.str]:
        """
        Connector Status
        """
        return pulumi.get(self, "connector_state")

    @_builtins.property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> Optional[_builtins.str]:
        """
        Connector Type
        """
        return pulumi.get(self, "connector_type")


@pulumi.output_type
class EnvironmentRecordResponse(dict):
    """
    Details about environment name, metadata and environment id of an environment
    """
    def __init__(__self__, *,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None):
        """
        Details about environment name, metadata and environment id of an environment
        :param _builtins.str display_name: Display name of the user
        :param _builtins.str id: Id of the environment
        :param _builtins.str kind: Type of environment
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name of the user
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the environment
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of environment
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class InvitationRecordResponse(dict):
    """
    Record of the invitation
    """
    def __init__(__self__, *,
                 accepted_at: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None,
                 status: Optional[_builtins.str] = None):
        """
        Record of the invitation
        :param _builtins.str accepted_at: Accepted date time of the invitation
        :param _builtins.str auth_type: Auth type of the user
        :param _builtins.str email: Email of the user
        :param _builtins.str expires_at: Expiration date time of the invitation
        :param _builtins.str id: Id of the invitation
        :param _builtins.str kind: Type of account
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        :param _builtins.str status: Status of the invitation
        """
        if accepted_at is not None:
            pulumi.set(__self__, "accepted_at", accepted_at)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="acceptedAt")
    def accepted_at(self) -> Optional[_builtins.str]:
        """
        Accepted date time of the invitation
        """
        return pulumi.get(self, "accepted_at")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Auth type of the user
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of the user
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        Expiration date time of the invitation
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the invitation
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of account
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the invitation
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class KafkaAzureBlobStorageSinkConnectorInfoResponse(dict):
    """
    The partner connector type is KafkaAzureBlobStorageSink
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerConnectorType":
            suggest = "partner_connector_type"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "flushSize":
            suggest = "flush_size"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "maxTasks":
            suggest = "max_tasks"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "topicsDir":
            suggest = "topics_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaAzureBlobStorageSinkConnectorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaAzureBlobStorageSinkConnectorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaAzureBlobStorageSinkConnectorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_connector_type: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 flush_size: Optional[_builtins.str] = None,
                 input_format: Optional[_builtins.str] = None,
                 max_tasks: Optional[_builtins.str] = None,
                 output_format: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 time_interval: Optional[_builtins.str] = None,
                 topics: Optional[Sequence[_builtins.str]] = None,
                 topics_dir: Optional[_builtins.str] = None):
        """
        The partner connector type is KafkaAzureBlobStorageSink
        :param _builtins.str partner_connector_type: Partner Connector type.
               Expected value is 'KafkaAzureBlobStorageSink'.
        :param _builtins.str api_key: Kafka API Key
        :param _builtins.str api_secret: Kafka API Key Secret
        :param _builtins.str auth_type: Kafka Auth Type
        :param _builtins.str flush_size: Flush size
        :param _builtins.str input_format: Kafka Input Data Format Type
        :param _builtins.str max_tasks: Maximum Tasks
        :param _builtins.str output_format: Kafka Output Data Format Type
        :param _builtins.str service_account_id: Kafka Service Account Id
        :param _builtins.str time_interval: Time Interval
        :param Sequence[_builtins.str] topics: Kafka topics list
        :param _builtins.str topics_dir: Kafka topics directory
        """
        pulumi.set(__self__, "partner_connector_type", 'KafkaAzureBlobStorageSink')
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if flush_size is not None:
            pulumi.set(__self__, "flush_size", flush_size)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if max_tasks is not None:
            pulumi.set(__self__, "max_tasks", max_tasks)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)
        if topics_dir is not None:
            pulumi.set(__self__, "topics_dir", topics_dir)

    @_builtins.property
    @pulumi.getter(name="partnerConnectorType")
    def partner_connector_type(self) -> _builtins.str:
        """
        Partner Connector type.
        Expected value is 'KafkaAzureBlobStorageSink'.
        """
        return pulumi.get(self, "partner_connector_type")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Kafka API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Kafka API Key Secret
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Kafka Auth Type
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> Optional[_builtins.str]:
        """
        Flush size
        """
        return pulumi.get(self, "flush_size")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        """
        Kafka Input Data Format Type
        """
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="maxTasks")
    def max_tasks(self) -> Optional[_builtins.str]:
        """
        Maximum Tasks
        """
        return pulumi.get(self, "max_tasks")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        """
        Kafka Output Data Format Type
        """
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Kafka Service Account Id
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[_builtins.str]:
        """
        Time Interval
        """
        return pulumi.get(self, "time_interval")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kafka topics list
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="topicsDir")
    def topics_dir(self) -> Optional[_builtins.str]:
        """
        Kafka topics directory
        """
        return pulumi.get(self, "topics_dir")


@pulumi.output_type
class KafkaAzureBlobStorageSourceConnectorInfoResponse(dict):
    """
    The partner connector type is KafkaAzureBlobStorageSource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerConnectorType":
            suggest = "partner_connector_type"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "maxTasks":
            suggest = "max_tasks"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "topicRegex":
            suggest = "topic_regex"
        elif key == "topicsDir":
            suggest = "topics_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaAzureBlobStorageSourceConnectorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaAzureBlobStorageSourceConnectorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaAzureBlobStorageSourceConnectorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_connector_type: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 input_format: Optional[_builtins.str] = None,
                 max_tasks: Optional[_builtins.str] = None,
                 output_format: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 topic_regex: Optional[_builtins.str] = None,
                 topics_dir: Optional[_builtins.str] = None):
        """
        The partner connector type is KafkaAzureBlobStorageSource
        :param _builtins.str partner_connector_type: Partner Connector type.
               Expected value is 'KafkaAzureBlobStorageSource'.
        :param _builtins.str api_key: Kafka API Key
        :param _builtins.str api_secret: Kafka API Secret
        :param _builtins.str auth_type: Kafka Auth Type
        :param _builtins.str input_format: Kafka Input Data Format Type
        :param _builtins.str max_tasks: Maximum Tasks
        :param _builtins.str output_format: Kafka Output Data Format Type
        :param _builtins.str service_account_id: Kafka Service Account Id
        :param _builtins.str topic_regex: Kafka topics Regex pattern
        :param _builtins.str topics_dir: Kafka topics directory
        """
        pulumi.set(__self__, "partner_connector_type", 'KafkaAzureBlobStorageSource')
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if max_tasks is not None:
            pulumi.set(__self__, "max_tasks", max_tasks)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if topic_regex is not None:
            pulumi.set(__self__, "topic_regex", topic_regex)
        if topics_dir is not None:
            pulumi.set(__self__, "topics_dir", topics_dir)

    @_builtins.property
    @pulumi.getter(name="partnerConnectorType")
    def partner_connector_type(self) -> _builtins.str:
        """
        Partner Connector type.
        Expected value is 'KafkaAzureBlobStorageSource'.
        """
        return pulumi.get(self, "partner_connector_type")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Kafka API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Kafka API Secret
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Kafka Auth Type
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        """
        Kafka Input Data Format Type
        """
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="maxTasks")
    def max_tasks(self) -> Optional[_builtins.str]:
        """
        Maximum Tasks
        """
        return pulumi.get(self, "max_tasks")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        """
        Kafka Output Data Format Type
        """
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Kafka Service Account Id
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="topicRegex")
    def topic_regex(self) -> Optional[_builtins.str]:
        """
        Kafka topics Regex pattern
        """
        return pulumi.get(self, "topic_regex")

    @_builtins.property
    @pulumi.getter(name="topicsDir")
    def topics_dir(self) -> Optional[_builtins.str]:
        """
        Kafka topics directory
        """
        return pulumi.get(self, "topics_dir")


@pulumi.output_type
class KafkaAzureCosmosDBSinkConnectorInfoResponse(dict):
    """
    The partner connector type is KafkaAzureCosmosDBSink
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerConnectorType":
            suggest = "partner_connector_type"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "flushSize":
            suggest = "flush_size"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "maxTasks":
            suggest = "max_tasks"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "topicsDir":
            suggest = "topics_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaAzureCosmosDBSinkConnectorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaAzureCosmosDBSinkConnectorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaAzureCosmosDBSinkConnectorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_connector_type: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 flush_size: Optional[_builtins.str] = None,
                 input_format: Optional[_builtins.str] = None,
                 max_tasks: Optional[_builtins.str] = None,
                 output_format: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 time_interval: Optional[_builtins.str] = None,
                 topics: Optional[Sequence[_builtins.str]] = None,
                 topics_dir: Optional[_builtins.str] = None):
        """
        The partner connector type is KafkaAzureCosmosDBSink
        :param _builtins.str partner_connector_type: Partner Connector type.
               Expected value is 'KafkaAzureCosmosDBSink'.
        :param _builtins.str api_key: Kafka API Key
        :param _builtins.str api_secret: Kafka API Key Secret
        :param _builtins.str auth_type: Kafka Auth Type
        :param _builtins.str flush_size: Flush size
        :param _builtins.str input_format: Kafka Input Data Format Type
        :param _builtins.str max_tasks: Maximum Tasks
        :param _builtins.str output_format: Kafka Output Data Format Type
        :param _builtins.str service_account_id: Kafka Service Account Id
        :param _builtins.str time_interval: Time Interval
        :param Sequence[_builtins.str] topics: Kafka topics list
        :param _builtins.str topics_dir: Kafka topics directory
        """
        pulumi.set(__self__, "partner_connector_type", 'KafkaAzureCosmosDBSink')
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if flush_size is not None:
            pulumi.set(__self__, "flush_size", flush_size)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if max_tasks is not None:
            pulumi.set(__self__, "max_tasks", max_tasks)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)
        if topics_dir is not None:
            pulumi.set(__self__, "topics_dir", topics_dir)

    @_builtins.property
    @pulumi.getter(name="partnerConnectorType")
    def partner_connector_type(self) -> _builtins.str:
        """
        Partner Connector type.
        Expected value is 'KafkaAzureCosmosDBSink'.
        """
        return pulumi.get(self, "partner_connector_type")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Kafka API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Kafka API Key Secret
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Kafka Auth Type
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> Optional[_builtins.str]:
        """
        Flush size
        """
        return pulumi.get(self, "flush_size")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        """
        Kafka Input Data Format Type
        """
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="maxTasks")
    def max_tasks(self) -> Optional[_builtins.str]:
        """
        Maximum Tasks
        """
        return pulumi.get(self, "max_tasks")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        """
        Kafka Output Data Format Type
        """
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Kafka Service Account Id
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[_builtins.str]:
        """
        Time Interval
        """
        return pulumi.get(self, "time_interval")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kafka topics list
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="topicsDir")
    def topics_dir(self) -> Optional[_builtins.str]:
        """
        Kafka topics directory
        """
        return pulumi.get(self, "topics_dir")


@pulumi.output_type
class KafkaAzureCosmosDBSourceConnectorInfoResponse(dict):
    """
    The partner connector type is KafkaAzureCosmosDBSource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerConnectorType":
            suggest = "partner_connector_type"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "maxTasks":
            suggest = "max_tasks"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "topicRegex":
            suggest = "topic_regex"
        elif key == "topicsDir":
            suggest = "topics_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaAzureCosmosDBSourceConnectorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaAzureCosmosDBSourceConnectorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaAzureCosmosDBSourceConnectorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_connector_type: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 input_format: Optional[_builtins.str] = None,
                 max_tasks: Optional[_builtins.str] = None,
                 output_format: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 topic_regex: Optional[_builtins.str] = None,
                 topics_dir: Optional[_builtins.str] = None):
        """
        The partner connector type is KafkaAzureCosmosDBSource
        :param _builtins.str partner_connector_type: Partner Connector type.
               Expected value is 'KafkaAzureCosmosDBSource'.
        :param _builtins.str api_key: Kafka API Key
        :param _builtins.str api_secret: Kafka API Secret
        :param _builtins.str auth_type: Kafka Auth Type
        :param _builtins.str input_format: Kafka Input Data Format Type
        :param _builtins.str max_tasks: Maximum Tasks
        :param _builtins.str output_format: Kafka Output Data Format Type
        :param _builtins.str service_account_id: Kafka Service Account Id
        :param _builtins.str topic_regex: Kafka topics Regex pattern
        :param _builtins.str topics_dir: Kafka topics directory
        """
        pulumi.set(__self__, "partner_connector_type", 'KafkaAzureCosmosDBSource')
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if max_tasks is not None:
            pulumi.set(__self__, "max_tasks", max_tasks)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if topic_regex is not None:
            pulumi.set(__self__, "topic_regex", topic_regex)
        if topics_dir is not None:
            pulumi.set(__self__, "topics_dir", topics_dir)

    @_builtins.property
    @pulumi.getter(name="partnerConnectorType")
    def partner_connector_type(self) -> _builtins.str:
        """
        Partner Connector type.
        Expected value is 'KafkaAzureCosmosDBSource'.
        """
        return pulumi.get(self, "partner_connector_type")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Kafka API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Kafka API Secret
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Kafka Auth Type
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        """
        Kafka Input Data Format Type
        """
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="maxTasks")
    def max_tasks(self) -> Optional[_builtins.str]:
        """
        Maximum Tasks
        """
        return pulumi.get(self, "max_tasks")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        """
        Kafka Output Data Format Type
        """
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Kafka Service Account Id
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="topicRegex")
    def topic_regex(self) -> Optional[_builtins.str]:
        """
        Kafka topics Regex pattern
        """
        return pulumi.get(self, "topic_regex")

    @_builtins.property
    @pulumi.getter(name="topicsDir")
    def topics_dir(self) -> Optional[_builtins.str]:
        """
        Kafka topics directory
        """
        return pulumi.get(self, "topics_dir")


@pulumi.output_type
class KafkaAzureSynapseAnalyticsSinkConnectorInfoResponse(dict):
    """
    The partner connector type is KafkaAzureSynapseAnalyticsSink
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerConnectorType":
            suggest = "partner_connector_type"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "flushSize":
            suggest = "flush_size"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "maxTasks":
            suggest = "max_tasks"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "topicsDir":
            suggest = "topics_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaAzureSynapseAnalyticsSinkConnectorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaAzureSynapseAnalyticsSinkConnectorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaAzureSynapseAnalyticsSinkConnectorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_connector_type: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 flush_size: Optional[_builtins.str] = None,
                 input_format: Optional[_builtins.str] = None,
                 max_tasks: Optional[_builtins.str] = None,
                 output_format: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 time_interval: Optional[_builtins.str] = None,
                 topics: Optional[Sequence[_builtins.str]] = None,
                 topics_dir: Optional[_builtins.str] = None):
        """
        The partner connector type is KafkaAzureSynapseAnalyticsSink
        :param _builtins.str partner_connector_type: Partner Connector type.
               Expected value is 'KafkaAzureSynapseAnalyticsSink'.
        :param _builtins.str api_key: Kafka API Key
        :param _builtins.str api_secret: Kafka API Key Secret
        :param _builtins.str auth_type: Kafka Auth Type
        :param _builtins.str flush_size: Flush size
        :param _builtins.str input_format: Kafka Input Data Format Type
        :param _builtins.str max_tasks: Maximum Tasks
        :param _builtins.str output_format: Kafka Output Data Format Type
        :param _builtins.str service_account_id: Kafka Service Account Id
        :param _builtins.str time_interval: Time Interval
        :param Sequence[_builtins.str] topics: Kafka topics list
        :param _builtins.str topics_dir: Kafka topics directory
        """
        pulumi.set(__self__, "partner_connector_type", 'KafkaAzureSynapseAnalyticsSink')
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if flush_size is not None:
            pulumi.set(__self__, "flush_size", flush_size)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if max_tasks is not None:
            pulumi.set(__self__, "max_tasks", max_tasks)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)
        if topics_dir is not None:
            pulumi.set(__self__, "topics_dir", topics_dir)

    @_builtins.property
    @pulumi.getter(name="partnerConnectorType")
    def partner_connector_type(self) -> _builtins.str:
        """
        Partner Connector type.
        Expected value is 'KafkaAzureSynapseAnalyticsSink'.
        """
        return pulumi.get(self, "partner_connector_type")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Kafka API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Kafka API Key Secret
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Kafka Auth Type
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> Optional[_builtins.str]:
        """
        Flush size
        """
        return pulumi.get(self, "flush_size")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        """
        Kafka Input Data Format Type
        """
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter(name="maxTasks")
    def max_tasks(self) -> Optional[_builtins.str]:
        """
        Maximum Tasks
        """
        return pulumi.get(self, "max_tasks")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        """
        Kafka Output Data Format Type
        """
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Kafka Service Account Id
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[_builtins.str]:
        """
        Time Interval
        """
        return pulumi.get(self, "time_interval")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        Kafka topics list
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="topicsDir")
    def topics_dir(self) -> Optional[_builtins.str]:
        """
        Kafka topics directory
        """
        return pulumi.get(self, "topics_dir")


@pulumi.output_type
class MetadataEntityResponse(dict):
    """
    Metadata of the data record
    """
    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 self: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        Metadata of the data record
        :param _builtins.str created_at: Created Date Time
        :param _builtins.str deleted_at: Deleted Date time
        :param _builtins.str resource_name: Resource name of the record
        :param _builtins.str self: Self lookup url
        :param _builtins.str updated_at: Updated Date time
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if self is not None:
            pulumi.set(__self__, "self", self)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created Date Time
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted Date time
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Resource name of the record
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.str]:
        """
        Self lookup url
        """
        return pulumi.get(self, "self")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated Date time
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class OfferDetailResponse(dict):
    """
    Confluent Offer detail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "planId":
            suggest = "plan_id"
        elif key == "planName":
            suggest = "plan_name"
        elif key == "publisherId":
            suggest = "publisher_id"
        elif key == "termUnit":
            suggest = "term_unit"
        elif key == "privateOfferId":
            suggest = "private_offer_id"
        elif key == "privateOfferIds":
            suggest = "private_offer_ids"
        elif key == "termId":
            suggest = "term_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OfferDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OfferDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OfferDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 plan_id: _builtins.str,
                 plan_name: _builtins.str,
                 publisher_id: _builtins.str,
                 term_unit: _builtins.str,
                 private_offer_id: Optional[_builtins.str] = None,
                 private_offer_ids: Optional[Sequence[_builtins.str]] = None,
                 status: Optional[_builtins.str] = None,
                 term_id: Optional[_builtins.str] = None):
        """
        Confluent Offer detail
        :param _builtins.str id: Offer Id
        :param _builtins.str plan_id: Offer Plan Id
        :param _builtins.str plan_name: Offer Plan Name
        :param _builtins.str publisher_id: Publisher Id
        :param _builtins.str term_unit: Offer Plan Term unit
        :param _builtins.str private_offer_id: Private Offer Id
        :param Sequence[_builtins.str] private_offer_ids: Array of Private Offer Ids
        :param _builtins.str status: SaaS Offer Status
        :param _builtins.str term_id: Offer Plan Term Id
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "plan_id", plan_id)
        pulumi.set(__self__, "plan_name", plan_name)
        pulumi.set(__self__, "publisher_id", publisher_id)
        pulumi.set(__self__, "term_unit", term_unit)
        if private_offer_id is not None:
            pulumi.set(__self__, "private_offer_id", private_offer_id)
        if private_offer_ids is not None:
            pulumi.set(__self__, "private_offer_ids", private_offer_ids)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if term_id is not None:
            pulumi.set(__self__, "term_id", term_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Offer Id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="planId")
    def plan_id(self) -> _builtins.str:
        """
        Offer Plan Id
        """
        return pulumi.get(self, "plan_id")

    @_builtins.property
    @pulumi.getter(name="planName")
    def plan_name(self) -> _builtins.str:
        """
        Offer Plan Name
        """
        return pulumi.get(self, "plan_name")

    @_builtins.property
    @pulumi.getter(name="publisherId")
    def publisher_id(self) -> _builtins.str:
        """
        Publisher Id
        """
        return pulumi.get(self, "publisher_id")

    @_builtins.property
    @pulumi.getter(name="termUnit")
    def term_unit(self) -> _builtins.str:
        """
        Offer Plan Term unit
        """
        return pulumi.get(self, "term_unit")

    @_builtins.property
    @pulumi.getter(name="privateOfferId")
    def private_offer_id(self) -> Optional[_builtins.str]:
        """
        Private Offer Id
        """
        return pulumi.get(self, "private_offer_id")

    @_builtins.property
    @pulumi.getter(name="privateOfferIds")
    def private_offer_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of Private Offer Ids
        """
        return pulumi.get(self, "private_offer_ids")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        SaaS Offer Status
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="termId")
    def term_id(self) -> Optional[_builtins.str]:
        """
        Offer Plan Term Id
        """
        return pulumi.get(self, "term_id")


@pulumi.output_type
class RegionRecordResponse(dict):
    """
    Details of region record
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.SCMetadataEntityResponse'] = None,
                 spec: Optional['outputs.RegionSpecEntityResponse'] = None):
        """
        Details of region record
        :param _builtins.str id: Id of the cluster
        :param _builtins.str kind: Kind of the cluster
        :param 'SCMetadataEntityResponse' metadata: Metadata of the record
        :param 'RegionSpecEntityResponse' spec: Specification of the region
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the cluster
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind of the cluster
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.SCMetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.RegionSpecEntityResponse']:
        """
        Specification of the region
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class RegionSpecEntityResponse(dict):
    """
    Region spec details
    """
    def __init__(__self__, *,
                 cloud: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 packages: Optional[Sequence[_builtins.str]] = None,
                 region_name: Optional[_builtins.str] = None):
        """
        Region spec details
        :param _builtins.str cloud: Cloud provider name
        :param _builtins.str name: Display Name of the region
        :param _builtins.str region_name: Region name
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        """
        Cloud provider name
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Display Name of the region
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def packages(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "packages")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[_builtins.str]:
        """
        Region name
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class RoleBindingRecordResponse(dict):
    """
    Details on principal, role name and crn pattern of a role binding
    """
    def __init__(__self__, *,
                 crn_pattern: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None,
                 principal: Optional[_builtins.str] = None,
                 role_name: Optional[_builtins.str] = None):
        """
        Details on principal, role name and crn pattern of a role binding
        :param _builtins.str crn_pattern: A CRN that specifies the scope and resource patterns necessary for the role to bind
        :param _builtins.str id: Id of the role binding
        :param _builtins.str kind: The type of the resource.
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        :param _builtins.str principal: The principal User or Group to bind the role to
        :param _builtins.str role_name: The name of the role to bind to the principal
        """
        if crn_pattern is not None:
            pulumi.set(__self__, "crn_pattern", crn_pattern)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="crnPattern")
    def crn_pattern(self) -> Optional[_builtins.str]:
        """
        A CRN that specifies the scope and resource patterns necessary for the role to bind
        """
        return pulumi.get(self, "crn_pattern")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the role binding
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        The type of the resource.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        The principal User or Group to bind the role to
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[_builtins.str]:
        """
        The name of the role to bind to the principal
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class SCClusterByokEntityResponse(dict):
    """
    The network associated with this object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SCClusterByokEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SCClusterByokEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SCClusterByokEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 related: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None):
        """
        The network associated with this object
        :param _builtins.str id: ID of the referred resource
        :param _builtins.str related: API URL for accessing or modifying the referred object
        :param _builtins.str resource_name: CRN reference to the referred resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if related is not None:
            pulumi.set(__self__, "related", related)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the referred resource
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        API URL for accessing or modifying the referred object
        """
        return pulumi.get(self, "related")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        CRN reference to the referred resource
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class SCClusterNetworkEnvironmentEntityResponse(dict):
    """
    The environment or the network to which cluster belongs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SCClusterNetworkEnvironmentEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SCClusterNetworkEnvironmentEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SCClusterNetworkEnvironmentEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 related: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None):
        """
        The environment or the network to which cluster belongs
        :param _builtins.str environment: Environment of the referred resource
        :param _builtins.str id: ID of the referred resource
        :param _builtins.str related: API URL for accessing or modifying the referred object
        :param _builtins.str resource_name: CRN reference to the referred resource
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if related is not None:
            pulumi.set(__self__, "related", related)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Environment of the referred resource
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the referred resource
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        API URL for accessing or modifying the referred object
        """
        return pulumi.get(self, "related")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        CRN reference to the referred resource
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class SCClusterSpecEntityResponse(dict):
    """
    Spec of the cluster record
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiEndpoint":
            suggest = "api_endpoint"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "kafkaBootstrapEndpoint":
            suggest = "kafka_bootstrap_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SCClusterSpecEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SCClusterSpecEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SCClusterSpecEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_endpoint: Optional[_builtins.str] = None,
                 availability: Optional[_builtins.str] = None,
                 byok: Optional['outputs.SCClusterByokEntityResponse'] = None,
                 cloud: Optional[_builtins.str] = None,
                 config: Optional['outputs.ClusterConfigEntityResponse'] = None,
                 environment: Optional['outputs.SCClusterNetworkEnvironmentEntityResponse'] = None,
                 http_endpoint: Optional[_builtins.str] = None,
                 kafka_bootstrap_endpoint: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional['outputs.SCClusterNetworkEnvironmentEntityResponse'] = None,
                 package: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        Spec of the cluster record
        :param _builtins.str api_endpoint: The Kafka API cluster endpoint
        :param _builtins.str availability: The availability zone configuration of the cluster
        :param 'SCClusterByokEntityResponse' byok: Specification of the cluster byok
        :param _builtins.str cloud: The cloud service provider
        :param 'ClusterConfigEntityResponse' config: Specification of the cluster configuration
        :param 'SCClusterNetworkEnvironmentEntityResponse' environment: Specification of the cluster environment
        :param _builtins.str http_endpoint: The cluster HTTP request URL.
        :param _builtins.str kafka_bootstrap_endpoint: The bootstrap endpoint used by Kafka clients to connect to the cluster
        :param _builtins.str name: The name of the cluster
        :param 'SCClusterNetworkEnvironmentEntityResponse' network: Specification of the cluster network
        :param _builtins.str package: Stream governance configuration
        :param _builtins.str region: The cloud service provider region
        :param _builtins.str zone: type of zone availability
        """
        if api_endpoint is not None:
            pulumi.set(__self__, "api_endpoint", api_endpoint)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if byok is not None:
            pulumi.set(__self__, "byok", byok)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if kafka_bootstrap_endpoint is not None:
            pulumi.set(__self__, "kafka_bootstrap_endpoint", kafka_bootstrap_endpoint)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if package is not None:
            pulumi.set(__self__, "package", package)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> Optional[_builtins.str]:
        """
        The Kafka API cluster endpoint
        """
        return pulumi.get(self, "api_endpoint")

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        The availability zone configuration of the cluster
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter
    def byok(self) -> Optional['outputs.SCClusterByokEntityResponse']:
        """
        Specification of the cluster byok
        """
        return pulumi.get(self, "byok")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        """
        The cloud service provider
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.ClusterConfigEntityResponse']:
        """
        Specification of the cluster configuration
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional['outputs.SCClusterNetworkEnvironmentEntityResponse']:
        """
        Specification of the cluster environment
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        The cluster HTTP request URL.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="kafkaBootstrapEndpoint")
    def kafka_bootstrap_endpoint(self) -> Optional[_builtins.str]:
        """
        The bootstrap endpoint used by Kafka clients to connect to the cluster
        """
        return pulumi.get(self, "kafka_bootstrap_endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.SCClusterNetworkEnvironmentEntityResponse']:
        """
        Specification of the cluster network
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[_builtins.str]:
        """
        Stream governance configuration
        """
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The cloud service provider region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        type of zone availability
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class SCMetadataEntityResponse(dict):
    """
    Metadata of the data record
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTimestamp":
            suggest = "created_timestamp"
        elif key == "deletedTimestamp":
            suggest = "deleted_timestamp"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "updatedTimestamp":
            suggest = "updated_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SCMetadataEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SCMetadataEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SCMetadataEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_timestamp: Optional[_builtins.str] = None,
                 deleted_timestamp: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 self: Optional[_builtins.str] = None,
                 updated_timestamp: Optional[_builtins.str] = None):
        """
        Metadata of the data record
        :param _builtins.str created_timestamp: Created Date Time
        :param _builtins.str deleted_timestamp: Deleted Date time
        :param _builtins.str resource_name: Resource name of the record
        :param _builtins.str self: Self lookup url
        :param _builtins.str updated_timestamp: Updated Date time
        """
        if created_timestamp is not None:
            pulumi.set(__self__, "created_timestamp", created_timestamp)
        if deleted_timestamp is not None:
            pulumi.set(__self__, "deleted_timestamp", deleted_timestamp)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if self is not None:
            pulumi.set(__self__, "self", self)
        if updated_timestamp is not None:
            pulumi.set(__self__, "updated_timestamp", updated_timestamp)

    @_builtins.property
    @pulumi.getter(name="createdTimestamp")
    def created_timestamp(self) -> Optional[_builtins.str]:
        """
        Created Date Time
        """
        return pulumi.get(self, "created_timestamp")

    @_builtins.property
    @pulumi.getter(name="deletedTimestamp")
    def deleted_timestamp(self) -> Optional[_builtins.str]:
        """
        Deleted Date time
        """
        return pulumi.get(self, "deleted_timestamp")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Resource name of the record
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.str]:
        """
        Self lookup url
        """
        return pulumi.get(self, "self")

    @_builtins.property
    @pulumi.getter(name="updatedTimestamp")
    def updated_timestamp(self) -> Optional[_builtins.str]:
        """
        Updated Date time
        """
        return pulumi.get(self, "updated_timestamp")


@pulumi.output_type
class ServiceAccountRecordResponse(dict):
    """
    Record of the service account
    """
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None):
        """
        Record of the service account
        :param _builtins.str description: Description of the service account
        :param _builtins.str display_name: Name of the service account
        :param _builtins.str id: Id of the service account
        :param _builtins.str kind: Type of account
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the service account
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Name of the service account
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the service account
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of account
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class StreamGovernanceConfigResponse(dict):
    """
    Stream governance configuration
    """
    def __init__(__self__, *,
                 package: Optional[_builtins.str] = None):
        """
        Stream governance configuration
        :param _builtins.str package: Stream governance configuration
        """
        if package is not None:
            pulumi.set(__self__, "package", package)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[_builtins.str]:
        """
        Stream governance configuration
        """
        return pulumi.get(self, "package")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TopicMetadataEntityResponse(dict):
    """
    Metadata of the data record
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicMetadataEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicMetadataEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicMetadataEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_name: Optional[_builtins.str] = None,
                 self: Optional[_builtins.str] = None):
        """
        Metadata of the data record
        :param _builtins.str resource_name: Resource name of the record
        :param _builtins.str self: Self lookup url
        """
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Resource name of the record
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.str]:
        """
        Self lookup url
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class TopicsInputConfigResponse(dict):
    """
    Topics input config
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Topics input config
        :param _builtins.str name: Name of the topic input config
        :param _builtins.str value: Value of the topic input config
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the topic input config
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the topic input config
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicsRelatedLinkResponse(dict):
    """
    Partition Config spec of the topic record
    """
    def __init__(__self__, *,
                 related: Optional[_builtins.str] = None):
        """
        Partition Config spec of the topic record
        :param _builtins.str related: Relationship of the topic
        """
        if related is not None:
            pulumi.set(__self__, "related", related)

    @_builtins.property
    @pulumi.getter
    def related(self) -> Optional[_builtins.str]:
        """
        Relationship of the topic
        """
        return pulumi.get(self, "related")


@pulumi.output_type
class UserDetailResponse(dict):
    """
    Subscriber detail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"
        elif key == "aadEmail":
            suggest = "aad_email"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: _builtins.str,
                 aad_email: Optional[_builtins.str] = None,
                 first_name: Optional[_builtins.str] = None,
                 last_name: Optional[_builtins.str] = None,
                 user_principal_name: Optional[_builtins.str] = None):
        """
        Subscriber detail
        :param _builtins.str email_address: Email address
        :param _builtins.str aad_email: AAD email address
        :param _builtins.str first_name: First name
        :param _builtins.str last_name: Last name
        :param _builtins.str user_principal_name: User principal name
        """
        pulumi.set(__self__, "email_address", email_address)
        if aad_email is not None:
            pulumi.set(__self__, "aad_email", aad_email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="aadEmail")
    def aad_email(self) -> Optional[_builtins.str]:
        """
        AAD email address
        """
        return pulumi.get(self, "aad_email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[_builtins.str]:
        """
        First name
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[_builtins.str]:
        """
        Last name
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[_builtins.str]:
        """
        User principal name
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class UserRecordResponse(dict):
    """
    Record of the user
    """
    def __init__(__self__, *,
                 auth_type: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 full_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['outputs.MetadataEntityResponse'] = None):
        """
        Record of the user
        :param _builtins.str auth_type: Auth type of the user
        :param _builtins.str email: Email of the user
        :param _builtins.str full_name: Name of the user
        :param _builtins.str id: Id of the user
        :param _builtins.str kind: Type of account
        :param 'MetadataEntityResponse' metadata: Metadata of the record
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        Auth type of the user
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of the user
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        Name of the user
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Id of the user
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of account
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MetadataEntityResponse']:
        """
        Metadata of the record
        """
        return pulumi.get(self, "metadata")


