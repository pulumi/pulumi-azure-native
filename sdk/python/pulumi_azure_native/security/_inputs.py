# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AdditionalWorkspacesPropertiesArgs',
    'AdditionalWorkspacesPropertiesArgsDict',
    'AllowlistCustomAlertRuleArgs',
    'AllowlistCustomAlertRuleArgsDict',
    'AssessmentStatusArgs',
    'AssessmentStatusArgsDict',
    'AssignedAssessmentItemArgs',
    'AssignedAssessmentItemArgsDict',
    'AssignedComponentItemArgs',
    'AssignedComponentItemArgsDict',
    'AssignedStandardItemArgs',
    'AssignedStandardItemArgsDict',
    'AssignmentPropertiesAdditionalDataArgs',
    'AssignmentPropertiesAdditionalDataArgsDict',
    'AttestationEvidenceArgs',
    'AttestationEvidenceArgsDict',
    'AuthorizationArgs',
    'AuthorizationArgsDict',
    'AutomationActionEventHubArgs',
    'AutomationActionEventHubArgsDict',
    'AutomationActionLogicAppArgs',
    'AutomationActionLogicAppArgsDict',
    'AutomationActionWorkspaceArgs',
    'AutomationActionWorkspaceArgsDict',
    'AutomationRuleSetArgs',
    'AutomationRuleSetArgsDict',
    'AutomationScopeArgs',
    'AutomationScopeArgsDict',
    'AutomationSourceArgs',
    'AutomationSourceArgsDict',
    'AutomationTriggeringRuleArgs',
    'AutomationTriggeringRuleArgsDict',
    'AwAssumeRoleAuthenticationDetailsPropertiesArgs',
    'AwAssumeRoleAuthenticationDetailsPropertiesArgsDict',
    'AwsCredsAuthenticationDetailsPropertiesArgs',
    'AwsCredsAuthenticationDetailsPropertiesArgsDict',
    'AwsEnvironmentDataArgs',
    'AwsEnvironmentDataArgsDict',
    'AwsOrganizationalDataMasterArgs',
    'AwsOrganizationalDataMasterArgsDict',
    'AwsOrganizationalDataMemberArgs',
    'AwsOrganizationalDataMemberArgsDict',
    'AzureDevOpsScopeEnvironmentDataArgs',
    'AzureDevOpsScopeEnvironmentDataArgsDict',
    'AzureResourceDetailsArgs',
    'AzureResourceDetailsArgsDict',
    'CspmMonitorAwsOfferingNativeCloudConnectionArgs',
    'CspmMonitorAwsOfferingNativeCloudConnectionArgsDict',
    'CspmMonitorAwsOfferingArgs',
    'CspmMonitorAwsOfferingArgsDict',
    'CspmMonitorAzureDevOpsOfferingArgs',
    'CspmMonitorAzureDevOpsOfferingArgsDict',
    'CspmMonitorGcpOfferingNativeCloudConnectionArgs',
    'CspmMonitorGcpOfferingNativeCloudConnectionArgsDict',
    'CspmMonitorGcpOfferingArgs',
    'CspmMonitorGcpOfferingArgsDict',
    'CspmMonitorGitLabOfferingArgs',
    'CspmMonitorGitLabOfferingArgsDict',
    'CspmMonitorGithubOfferingArgs',
    'CspmMonitorGithubOfferingArgsDict',
    'DefenderCspmAwsOfferingConfigurationArgs',
    'DefenderCspmAwsOfferingConfigurationArgsDict',
    'DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs',
    'DefenderCspmAwsOfferingDataSensitivityDiscoveryArgsDict',
    'DefenderCspmAwsOfferingDatabasesDspmArgs',
    'DefenderCspmAwsOfferingDatabasesDspmArgsDict',
    'DefenderCspmAwsOfferingVmScannersArgs',
    'DefenderCspmAwsOfferingVmScannersArgsDict',
    'DefenderCspmAwsOfferingArgs',
    'DefenderCspmAwsOfferingArgsDict',
    'DefenderCspmGcpOfferingArgs',
    'DefenderCspmGcpOfferingArgsDict',
    'DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs',
    'DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgsDict',
    'DefenderFoDatabasesAwsOfferingConfigurationArgs',
    'DefenderFoDatabasesAwsOfferingConfigurationArgsDict',
    'DefenderFoDatabasesAwsOfferingDatabasesDspmArgs',
    'DefenderFoDatabasesAwsOfferingDatabasesDspmArgsDict',
    'DefenderFoDatabasesAwsOfferingRdsArgs',
    'DefenderFoDatabasesAwsOfferingRdsArgsDict',
    'DefenderFoDatabasesAwsOfferingArgs',
    'DefenderFoDatabasesAwsOfferingArgsDict',
    'DefenderForContainersAwsOfferingCloudWatchToKinesisArgs',
    'DefenderForContainersAwsOfferingCloudWatchToKinesisArgsDict',
    'DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs',
    'DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgsDict',
    'DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs',
    'DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgsDict',
    'DefenderForContainersAwsOfferingKinesisToS3Args',
    'DefenderForContainersAwsOfferingKinesisToS3ArgsDict',
    'DefenderForContainersAwsOfferingKubernetesScubaReaderArgs',
    'DefenderForContainersAwsOfferingKubernetesScubaReaderArgsDict',
    'DefenderForContainersAwsOfferingKubernetesServiceArgs',
    'DefenderForContainersAwsOfferingKubernetesServiceArgsDict',
    'DefenderForContainersAwsOfferingArgs',
    'DefenderForContainersAwsOfferingArgsDict',
    'DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs',
    'DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgsDict',
    'DefenderForContainersGcpOfferingNativeCloudConnectionArgs',
    'DefenderForContainersGcpOfferingNativeCloudConnectionArgsDict',
    'DefenderForContainersGcpOfferingArgs',
    'DefenderForContainersGcpOfferingArgsDict',
    'DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs',
    'DefenderForDatabasesGcpOfferingArcAutoProvisioningArgsDict',
    'DefenderForDatabasesGcpOfferingConfigurationArgs',
    'DefenderForDatabasesGcpOfferingConfigurationArgsDict',
    'DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs',
    'DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgsDict',
    'DefenderForDatabasesGcpOfferingArgs',
    'DefenderForDatabasesGcpOfferingArgsDict',
    'DefenderForDevOpsAzureDevOpsOfferingArgs',
    'DefenderForDevOpsAzureDevOpsOfferingArgsDict',
    'DefenderForDevOpsGitLabOfferingArgs',
    'DefenderForDevOpsGitLabOfferingArgsDict',
    'DefenderForDevOpsGithubOfferingArgs',
    'DefenderForDevOpsGithubOfferingArgsDict',
    'DefenderForServersAwsOfferingArcAutoProvisioningArgs',
    'DefenderForServersAwsOfferingArcAutoProvisioningArgsDict',
    'DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs',
    'DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgsDict',
    'DefenderForServersAwsOfferingConfigurationConfigurationArgs',
    'DefenderForServersAwsOfferingConfigurationConfigurationArgsDict',
    'DefenderForServersAwsOfferingConfigurationArgs',
    'DefenderForServersAwsOfferingConfigurationArgsDict',
    'DefenderForServersAwsOfferingDefenderForServersArgs',
    'DefenderForServersAwsOfferingDefenderForServersArgsDict',
    'DefenderForServersAwsOfferingMdeAutoProvisioningArgs',
    'DefenderForServersAwsOfferingMdeAutoProvisioningArgsDict',
    'DefenderForServersAwsOfferingSubPlanArgs',
    'DefenderForServersAwsOfferingSubPlanArgsDict',
    'DefenderForServersAwsOfferingVaAutoProvisioningArgs',
    'DefenderForServersAwsOfferingVaAutoProvisioningArgsDict',
    'DefenderForServersAwsOfferingVmScannersArgs',
    'DefenderForServersAwsOfferingVmScannersArgsDict',
    'DefenderForServersAwsOfferingArgs',
    'DefenderForServersAwsOfferingArgsDict',
    'DefenderForServersGcpOfferingArcAutoProvisioningArgs',
    'DefenderForServersGcpOfferingArcAutoProvisioningArgsDict',
    'DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs',
    'DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgsDict',
    'DefenderForServersGcpOfferingConfigurationConfigurationArgs',
    'DefenderForServersGcpOfferingConfigurationConfigurationArgsDict',
    'DefenderForServersGcpOfferingConfigurationArgs',
    'DefenderForServersGcpOfferingConfigurationArgsDict',
    'DefenderForServersGcpOfferingDefenderForServersArgs',
    'DefenderForServersGcpOfferingDefenderForServersArgsDict',
    'DefenderForServersGcpOfferingMdeAutoProvisioningArgs',
    'DefenderForServersGcpOfferingMdeAutoProvisioningArgsDict',
    'DefenderForServersGcpOfferingSubPlanArgs',
    'DefenderForServersGcpOfferingSubPlanArgsDict',
    'DefenderForServersGcpOfferingVaAutoProvisioningArgs',
    'DefenderForServersGcpOfferingVaAutoProvisioningArgsDict',
    'DefenderForServersGcpOfferingVmScannersArgs',
    'DefenderForServersGcpOfferingVmScannersArgsDict',
    'DefenderForServersGcpOfferingArgs',
    'DefenderForServersGcpOfferingArgsDict',
    'DefenderForStorageSettingPropertiesArgs',
    'DefenderForStorageSettingPropertiesArgsDict',
    'DenylistCustomAlertRuleArgs',
    'DenylistCustomAlertRuleArgsDict',
    'DevOpsConfigurationPropertiesArgs',
    'DevOpsConfigurationPropertiesArgsDict',
    'DevOpsPolicyAssignmentPropertiesArgs',
    'DevOpsPolicyAssignmentPropertiesArgsDict',
    'DevOpsPolicyDescriptorArgs',
    'DevOpsPolicyDescriptorArgsDict',
    'ExtensionArgs',
    'ExtensionArgsDict',
    'GcpCredentialsDetailsPropertiesArgs',
    'GcpCredentialsDetailsPropertiesArgsDict',
    'GcpOrganizationalDataMemberArgs',
    'GcpOrganizationalDataMemberArgsDict',
    'GcpOrganizationalDataOrganizationArgs',
    'GcpOrganizationalDataOrganizationArgsDict',
    'GcpProjectDetailsArgs',
    'GcpProjectDetailsArgsDict',
    'GcpProjectEnvironmentDataArgs',
    'GcpProjectEnvironmentDataArgsDict',
    'GithubScopeEnvironmentDataArgs',
    'GithubScopeEnvironmentDataArgsDict',
    'GitlabScopeEnvironmentDataArgs',
    'GitlabScopeEnvironmentDataArgsDict',
    'GovernanceAssignmentAdditionalDataArgs',
    'GovernanceAssignmentAdditionalDataArgsDict',
    'GovernanceEmailNotificationArgs',
    'GovernanceEmailNotificationArgsDict',
    'GovernanceRuleEmailNotificationArgs',
    'GovernanceRuleEmailNotificationArgsDict',
    'GovernanceRuleOwnerSourceArgs',
    'GovernanceRuleOwnerSourceArgsDict',
    'HybridComputeSettingsPropertiesArgs',
    'HybridComputeSettingsPropertiesArgsDict',
    'InformationProtectionAwsOfferingInformationProtectionArgs',
    'InformationProtectionAwsOfferingInformationProtectionArgsDict',
    'InformationProtectionAwsOfferingArgs',
    'InformationProtectionAwsOfferingArgsDict',
    'JitNetworkAccessPolicyVirtualMachineArgs',
    'JitNetworkAccessPolicyVirtualMachineArgsDict',
    'JitNetworkAccessPortRuleArgs',
    'JitNetworkAccessPortRuleArgsDict',
    'JitNetworkAccessRequestPortArgs',
    'JitNetworkAccessRequestPortArgsDict',
    'JitNetworkAccessRequestVirtualMachineArgs',
    'JitNetworkAccessRequestVirtualMachineArgsDict',
    'JitNetworkAccessRequestArgs',
    'JitNetworkAccessRequestArgsDict',
    'MalwareScanningPropertiesArgs',
    'MalwareScanningPropertiesArgsDict',
    'OnPremiseResourceDetailsArgs',
    'OnPremiseResourceDetailsArgsDict',
    'OnPremiseSqlResourceDetailsArgs',
    'OnPremiseSqlResourceDetailsArgsDict',
    'OnUploadPropertiesArgs',
    'OnUploadPropertiesArgsDict',
    'PartialAssessmentPropertiesArgs',
    'PartialAssessmentPropertiesArgsDict',
    'ProxyServerPropertiesArgs',
    'ProxyServerPropertiesArgsDict',
    'RecommendationConfigurationPropertiesArgs',
    'RecommendationConfigurationPropertiesArgsDict',
    'RemediationEtaArgs',
    'RemediationEtaArgsDict',
    'ScopeElementArgs',
    'ScopeElementArgsDict',
    'SecurityAssessmentMetadataPartnerDataArgs',
    'SecurityAssessmentMetadataPartnerDataArgsDict',
    'SecurityAssessmentMetadataPropertiesResponsePublishDatesArgs',
    'SecurityAssessmentMetadataPropertiesResponsePublishDatesArgsDict',
    'SecurityAssessmentMetadataPropertiesArgs',
    'SecurityAssessmentMetadataPropertiesArgsDict',
    'SecurityAssessmentPartnerDataArgs',
    'SecurityAssessmentPartnerDataArgsDict',
    'SecurityContactPropertiesAlertNotificationsArgs',
    'SecurityContactPropertiesAlertNotificationsArgsDict',
    'SecurityContactPropertiesNotificationsByRoleArgs',
    'SecurityContactPropertiesNotificationsByRoleArgsDict',
    'SensitiveDataDiscoveryPropertiesArgs',
    'SensitiveDataDiscoveryPropertiesArgsDict',
    'ServicePrincipalPropertiesArgs',
    'ServicePrincipalPropertiesArgsDict',
    'StandardAssignmentPropertiesAttestationDataArgs',
    'StandardAssignmentPropertiesAttestationDataArgsDict',
    'StandardAssignmentPropertiesExemptionDataArgs',
    'StandardAssignmentPropertiesExemptionDataArgsDict',
    'StandardComponentPropertiesArgs',
    'StandardComponentPropertiesArgsDict',
    'SuppressionAlertsScopeArgs',
    'SuppressionAlertsScopeArgsDict',
    'ThresholdCustomAlertRuleArgs',
    'ThresholdCustomAlertRuleArgsDict',
    'TimeWindowCustomAlertRuleArgs',
    'TimeWindowCustomAlertRuleArgsDict',
    'UserDefinedResourcesPropertiesArgs',
    'UserDefinedResourcesPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class AdditionalWorkspacesPropertiesArgsDict(TypedDict):
        """
        Properties of the additional workspaces.
        """
        data_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AdditionalWorkspaceDataType']]]]]
        """
        List of data types sent to workspace
        """
        type: NotRequired[pulumi.Input[Union[str, 'AdditionalWorkspaceType']]]
        """
        Workspace type.
        """
        workspace: NotRequired[pulumi.Input[str]]
        """
        Workspace resource id
        """
elif False:
    AdditionalWorkspacesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdditionalWorkspacesPropertiesArgs:
    def __init__(__self__, *,
                 data_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AdditionalWorkspaceDataType']]]]] = None,
                 type: Optional[pulumi.Input[Union[str, 'AdditionalWorkspaceType']]] = None,
                 workspace: Optional[pulumi.Input[str]] = None):
        """
        Properties of the additional workspaces.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AdditionalWorkspaceDataType']]]] data_types: List of data types sent to workspace
        :param pulumi.Input[Union[str, 'AdditionalWorkspaceType']] type: Workspace type.
        :param pulumi.Input[str] workspace: Workspace resource id
        """
        if data_types is not None:
            pulumi.set(__self__, "data_types", data_types)
        if type is None:
            type = 'Sentinel'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AdditionalWorkspaceDataType']]]]]:
        """
        List of data types sent to workspace
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AdditionalWorkspaceDataType']]]]]):
        pulumi.set(self, "data_types", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'AdditionalWorkspaceType']]]:
        """
        Workspace type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'AdditionalWorkspaceType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input[str]]:
        """
        Workspace resource id
        """
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class AllowlistCustomAlertRuleArgsDict(TypedDict):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is allowed.
        """
        allowlist_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The values to allow. The format of the values depends on the rule type.
        """
        is_enabled: pulumi.Input[bool]
        """
        Status of the custom alert.
        """
        rule_type: pulumi.Input[str]
        """
        The type of the custom alert rule.
        Expected value is 'AllowlistCustomAlertRule'.
        """
elif False:
    AllowlistCustomAlertRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllowlistCustomAlertRuleArgs:
    def __init__(__self__, *,
                 allowlist_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: pulumi.Input[bool],
                 rule_type: pulumi.Input[str]):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowlist_values: The values to allow. The format of the values depends on the rule type.
        :param pulumi.Input[bool] is_enabled: Status of the custom alert.
        :param pulumi.Input[str] rule_type: The type of the custom alert rule.
               Expected value is 'AllowlistCustomAlertRule'.
        """
        pulumi.set(__self__, "allowlist_values", allowlist_values)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "rule_type", 'AllowlistCustomAlertRule')

    @property
    @pulumi.getter(name="allowlistValues")
    def allowlist_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The values to allow. The format of the values depends on the rule type.
        """
        return pulumi.get(self, "allowlist_values")

    @allowlist_values.setter
    def allowlist_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowlist_values", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        The type of the custom alert rule.
        Expected value is 'AllowlistCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)


if not MYPY:
    class AssessmentStatusArgsDict(TypedDict):
        """
        The result of the assessment
        """
        code: pulumi.Input[Union[str, 'AssessmentStatusCode']]
        """
        Programmatic code for the status of the assessment
        """
        cause: NotRequired[pulumi.Input[str]]
        """
        Programmatic code for the cause of the assessment status
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Human readable description of the assessment status
        """
elif False:
    AssessmentStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssessmentStatusArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[Union[str, 'AssessmentStatusCode']],
                 cause: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        The result of the assessment
        :param pulumi.Input[Union[str, 'AssessmentStatusCode']] code: Programmatic code for the status of the assessment
        :param pulumi.Input[str] cause: Programmatic code for the cause of the assessment status
        :param pulumi.Input[str] description: Human readable description of the assessment status
        """
        pulumi.set(__self__, "code", code)
        if cause is not None:
            pulumi.set(__self__, "cause", cause)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def code(self) -> pulumi.Input[Union[str, 'AssessmentStatusCode']]:
        """
        Programmatic code for the status of the assessment
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[Union[str, 'AssessmentStatusCode']]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def cause(self) -> Optional[pulumi.Input[str]]:
        """
        Programmatic code for the cause of the assessment status
        """
        return pulumi.get(self, "cause")

    @cause.setter
    def cause(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cause", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable description of the assessment status
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AssignedAssessmentItemArgsDict(TypedDict):
        """
        Describe the properties of a security assessment object reference (by key)
        """
        assessment_key: NotRequired[pulumi.Input[str]]
        """
        Unique key to a security assessment object
        """
elif False:
    AssignedAssessmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignedAssessmentItemArgs:
    def __init__(__self__, *,
                 assessment_key: Optional[pulumi.Input[str]] = None):
        """
        Describe the properties of a security assessment object reference (by key)
        :param pulumi.Input[str] assessment_key: Unique key to a security assessment object
        """
        if assessment_key is not None:
            pulumi.set(__self__, "assessment_key", assessment_key)

    @property
    @pulumi.getter(name="assessmentKey")
    def assessment_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique key to a security assessment object
        """
        return pulumi.get(self, "assessment_key")

    @assessment_key.setter
    def assessment_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assessment_key", value)


if not MYPY:
    class AssignedComponentItemArgsDict(TypedDict):
        """
        describe the properties of a security assessment object reference (by key)
        """
        key: NotRequired[pulumi.Input[str]]
        """
        unique key to a security assessment object
        """
elif False:
    AssignedComponentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignedComponentItemArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None):
        """
        describe the properties of a security assessment object reference (by key)
        :param pulumi.Input[str] key: unique key to a security assessment object
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        unique key to a security assessment object
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class AssignedStandardItemArgsDict(TypedDict):
        """
        Describe the properties of a of a standard assignments object reference
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Full resourceId of the Microsoft.Security/standard object
        """
elif False:
    AssignedStandardItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignedStandardItemArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Describe the properties of a of a standard assignments object reference
        :param pulumi.Input[str] id: Full resourceId of the Microsoft.Security/standard object
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Full resourceId of the Microsoft.Security/standard object
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AssignmentPropertiesAdditionalDataArgsDict(TypedDict):
        """
        Additional data about the assignment
        """
        exemption_category: NotRequired[pulumi.Input[str]]
        """
        Exemption category of this assignment
        """
elif False:
    AssignmentPropertiesAdditionalDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignmentPropertiesAdditionalDataArgs:
    def __init__(__self__, *,
                 exemption_category: Optional[pulumi.Input[str]] = None):
        """
        Additional data about the assignment
        :param pulumi.Input[str] exemption_category: Exemption category of this assignment
        """
        if exemption_category is not None:
            pulumi.set(__self__, "exemption_category", exemption_category)

    @property
    @pulumi.getter(name="exemptionCategory")
    def exemption_category(self) -> Optional[pulumi.Input[str]]:
        """
        Exemption category of this assignment
        """
        return pulumi.get(self, "exemption_category")

    @exemption_category.setter
    def exemption_category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exemption_category", value)


if not MYPY:
    class AttestationEvidenceArgsDict(TypedDict):
        """
        Describe the properties of a assignment attestation
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the evidence
        """
        source_url: NotRequired[pulumi.Input[str]]
        """
        The source url of the evidence
        """
elif False:
    AttestationEvidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttestationEvidenceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 source_url: Optional[pulumi.Input[str]] = None):
        """
        Describe the properties of a assignment attestation
        :param pulumi.Input[str] description: The description of the evidence
        :param pulumi.Input[str] source_url: The source url of the evidence
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the evidence
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[str]]:
        """
        The source url of the evidence
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_url", value)


if not MYPY:
    class AuthorizationArgsDict(TypedDict):
        """
        Authorization payload.
        """
        code: NotRequired[pulumi.Input[str]]
        """
        Gets or sets one-time OAuth code to exchange for refresh and access tokens.
        
        Only used during PUT/PATCH operations. The secret is cleared during GET.
        """
elif False:
    AuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None):
        """
        Authorization payload.
        :param pulumi.Input[str] code: Gets or sets one-time OAuth code to exchange for refresh and access tokens.
               
               Only used during PUT/PATCH operations. The secret is cleared during GET.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets one-time OAuth code to exchange for refresh and access tokens.
        
        Only used during PUT/PATCH operations. The secret is cleared during GET.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class AutomationActionEventHubArgsDict(TypedDict):
        """
        The target Event Hub to which event data will be exported. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        """
        action_type: pulumi.Input[str]
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'EventHub'.
        """
        connection_string: NotRequired[pulumi.Input[str]]
        """
        The target Event Hub connection string (it will not be included in any response).
        """
        event_hub_resource_id: NotRequired[pulumi.Input[str]]
        """
        The target Event Hub Azure Resource ID.
        """
elif False:
    AutomationActionEventHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationActionEventHubArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 connection_string: Optional[pulumi.Input[str]] = None,
                 event_hub_resource_id: Optional[pulumi.Input[str]] = None):
        """
        The target Event Hub to which event data will be exported. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        :param pulumi.Input[str] action_type: The type of the action that will be triggered by the Automation
               Expected value is 'EventHub'.
        :param pulumi.Input[str] connection_string: The target Event Hub connection string (it will not be included in any response).
        :param pulumi.Input[str] event_hub_resource_id: The target Event Hub Azure Resource ID.
        """
        pulumi.set(__self__, "action_type", 'EventHub')
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if event_hub_resource_id is not None:
            pulumi.set(__self__, "event_hub_resource_id", event_hub_resource_id)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'EventHub'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The target Event Hub connection string (it will not be included in any response).
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The target Event Hub Azure Resource ID.
        """
        return pulumi.get(self, "event_hub_resource_id")

    @event_hub_resource_id.setter
    def event_hub_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_resource_id", value)


if not MYPY:
    class AutomationActionLogicAppArgsDict(TypedDict):
        """
        The logic app action that should be triggered. To learn more about Microsoft Defender for Cloud's Workflow Automation capabilities, visit https://aka.ms/ASCWorkflowAutomationLearnMore
        """
        action_type: pulumi.Input[str]
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'LogicApp'.
        """
        logic_app_resource_id: NotRequired[pulumi.Input[str]]
        """
        The triggered Logic App Azure Resource ID. This can also reside on other subscriptions, given that you have permissions to trigger the Logic App
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The Logic App trigger URI endpoint (it will not be included in any response).
        """
elif False:
    AutomationActionLogicAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationActionLogicAppArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 logic_app_resource_id: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        The logic app action that should be triggered. To learn more about Microsoft Defender for Cloud's Workflow Automation capabilities, visit https://aka.ms/ASCWorkflowAutomationLearnMore
        :param pulumi.Input[str] action_type: The type of the action that will be triggered by the Automation
               Expected value is 'LogicApp'.
        :param pulumi.Input[str] logic_app_resource_id: The triggered Logic App Azure Resource ID. This can also reside on other subscriptions, given that you have permissions to trigger the Logic App
        :param pulumi.Input[str] uri: The Logic App trigger URI endpoint (it will not be included in any response).
        """
        pulumi.set(__self__, "action_type", 'LogicApp')
        if logic_app_resource_id is not None:
            pulumi.set(__self__, "logic_app_resource_id", logic_app_resource_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'LogicApp'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The triggered Logic App Azure Resource ID. This can also reside on other subscriptions, given that you have permissions to trigger the Logic App
        """
        return pulumi.get(self, "logic_app_resource_id")

    @logic_app_resource_id.setter
    def logic_app_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logic_app_resource_id", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Logic App trigger URI endpoint (it will not be included in any response).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AutomationActionWorkspaceArgsDict(TypedDict):
        """
        The Log Analytics Workspace to which event data will be exported. Security alerts data will reside in the 'SecurityAlert' table and the assessments data will reside in the 'SecurityRecommendation' table (under the 'Security'/'SecurityCenterFree' solutions). Note that in order to view the data in the workspace, the Security Center Log Analytics free/standard solution needs to be enabled on that workspace. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        """
        action_type: pulumi.Input[str]
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'Workspace'.
        """
        workspace_resource_id: NotRequired[pulumi.Input[str]]
        """
        The fully qualified Log Analytics Workspace Azure Resource ID.
        """
elif False:
    AutomationActionWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationActionWorkspaceArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 workspace_resource_id: Optional[pulumi.Input[str]] = None):
        """
        The Log Analytics Workspace to which event data will be exported. Security alerts data will reside in the 'SecurityAlert' table and the assessments data will reside in the 'SecurityRecommendation' table (under the 'Security'/'SecurityCenterFree' solutions). Note that in order to view the data in the workspace, the Security Center Log Analytics free/standard solution needs to be enabled on that workspace. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        :param pulumi.Input[str] action_type: The type of the action that will be triggered by the Automation
               Expected value is 'Workspace'.
        :param pulumi.Input[str] workspace_resource_id: The fully qualified Log Analytics Workspace Azure Resource ID.
        """
        pulumi.set(__self__, "action_type", 'Workspace')
        if workspace_resource_id is not None:
            pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'Workspace'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified Log Analytics Workspace Azure Resource ID.
        """
        return pulumi.get(self, "workspace_resource_id")

    @workspace_resource_id.setter
    def workspace_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_resource_id", value)


if not MYPY:
    class AutomationRuleSetArgsDict(TypedDict):
        """
        A rule set which evaluates all its rules upon an event interception. Only when all the included rules in the rule set will be evaluated as 'true', will the event trigger the defined actions.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomationTriggeringRuleArgsDict']]]]
elif False:
    AutomationRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleSetArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationTriggeringRuleArgs']]]] = None):
        """
        A rule set which evaluates all its rules upon an event interception. Only when all the included rules in the rule set will be evaluated as 'true', will the event trigger the defined actions.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomationTriggeringRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationTriggeringRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AutomationScopeArgsDict(TypedDict):
        """
        A single automation scope.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The resources scope description.
        """
        scope_path: NotRequired[pulumi.Input[str]]
        """
        The resources scope path. Can be the subscription on which the automation is defined on or a resource group under that subscription (fully qualified Azure resource IDs).
        """
elif False:
    AutomationScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationScopeArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 scope_path: Optional[pulumi.Input[str]] = None):
        """
        A single automation scope.
        :param pulumi.Input[str] description: The resources scope description.
        :param pulumi.Input[str] scope_path: The resources scope path. Can be the subscription on which the automation is defined on or a resource group under that subscription (fully qualified Azure resource IDs).
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if scope_path is not None:
            pulumi.set(__self__, "scope_path", scope_path)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The resources scope description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="scopePath")
    def scope_path(self) -> Optional[pulumi.Input[str]]:
        """
        The resources scope path. Can be the subscription on which the automation is defined on or a resource group under that subscription (fully qualified Azure resource IDs).
        """
        return pulumi.get(self, "scope_path")

    @scope_path.setter
    def scope_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope_path", value)


if not MYPY:
    class AutomationSourceArgsDict(TypedDict):
        """
        The source event types which evaluate the security automation set of rules. For example - security alerts and security assessments. To learn more about the supported security events data models schemas - please visit https://aka.ms/ASCAutomationSchemas.
        """
        event_source: NotRequired[pulumi.Input[Union[str, 'EventSource']]]
        """
        A valid event source type.
        """
        rule_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomationRuleSetArgsDict']]]]
        """
        A set of rules which evaluate upon event interception. A logical disjunction is applied between defined rule sets (logical 'or').
        """
elif False:
    AutomationSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationSourceArgs:
    def __init__(__self__, *,
                 event_source: Optional[pulumi.Input[Union[str, 'EventSource']]] = None,
                 rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleSetArgs']]]] = None):
        """
        The source event types which evaluate the security automation set of rules. For example - security alerts and security assessments. To learn more about the supported security events data models schemas - please visit https://aka.ms/ASCAutomationSchemas.
        :param pulumi.Input[Union[str, 'EventSource']] event_source: A valid event source type.
        :param pulumi.Input[Sequence[pulumi.Input['AutomationRuleSetArgs']]] rule_sets: A set of rules which evaluate upon event interception. A logical disjunction is applied between defined rule sets (logical 'or').
        """
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if rule_sets is not None:
            pulumi.set(__self__, "rule_sets", rule_sets)

    @property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[pulumi.Input[Union[str, 'EventSource']]]:
        """
        A valid event source type.
        """
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: Optional[pulumi.Input[Union[str, 'EventSource']]]):
        pulumi.set(self, "event_source", value)

    @property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleSetArgs']]]]:
        """
        A set of rules which evaluate upon event interception. A logical disjunction is applied between defined rule sets (logical 'or').
        """
        return pulumi.get(self, "rule_sets")

    @rule_sets.setter
    def rule_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleSetArgs']]]]):
        pulumi.set(self, "rule_sets", value)


if not MYPY:
    class AutomationTriggeringRuleArgsDict(TypedDict):
        """
        A rule which is evaluated upon event interception. The rule is configured by comparing a specific value from the event model to an expected value. This comparison is done by using one of the supported operators set.
        """
        expected_value: NotRequired[pulumi.Input[str]]
        """
        The expected value.
        """
        operator: NotRequired[pulumi.Input[Union[str, 'Operator']]]
        """
        A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
        """
        property_j_path: NotRequired[pulumi.Input[str]]
        """
        The JPath of the entity model property that should be checked.
        """
        property_type: NotRequired[pulumi.Input[Union[str, 'PropertyType']]]
        """
        The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
        """
elif False:
    AutomationTriggeringRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationTriggeringRuleArgs:
    def __init__(__self__, *,
                 expected_value: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'Operator']]] = None,
                 property_j_path: Optional[pulumi.Input[str]] = None,
                 property_type: Optional[pulumi.Input[Union[str, 'PropertyType']]] = None):
        """
        A rule which is evaluated upon event interception. The rule is configured by comparing a specific value from the event model to an expected value. This comparison is done by using one of the supported operators set.
        :param pulumi.Input[str] expected_value: The expected value.
        :param pulumi.Input[Union[str, 'Operator']] operator: A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
        :param pulumi.Input[str] property_j_path: The JPath of the entity model property that should be checked.
        :param pulumi.Input[Union[str, 'PropertyType']] property_type: The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
        """
        if expected_value is not None:
            pulumi.set(__self__, "expected_value", expected_value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_j_path is not None:
            pulumi.set(__self__, "property_j_path", property_j_path)
        if property_type is not None:
            pulumi.set(__self__, "property_type", property_type)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[pulumi.Input[str]]:
        """
        The expected value.
        """
        return pulumi.get(self, "expected_value")

    @expected_value.setter
    def expected_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'Operator']]]:
        """
        A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'Operator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="propertyJPath")
    def property_j_path(self) -> Optional[pulumi.Input[str]]:
        """
        The JPath of the entity model property that should be checked.
        """
        return pulumi.get(self, "property_j_path")

    @property_j_path.setter
    def property_j_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_j_path", value)

    @property
    @pulumi.getter(name="propertyType")
    def property_type(self) -> Optional[pulumi.Input[Union[str, 'PropertyType']]]:
        """
        The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
        """
        return pulumi.get(self, "property_type")

    @property_type.setter
    def property_type(self, value: Optional[pulumi.Input[Union[str, 'PropertyType']]]):
        pulumi.set(self, "property_type", value)


if not MYPY:
    class AwAssumeRoleAuthenticationDetailsPropertiesArgsDict(TypedDict):
        """
        AWS cloud account connector based assume role, the role enables delegating access to your AWS resources. The role is composed of role Amazon Resource Name (ARN) and external ID. For more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user.html">Creating a Role to Delegate Permissions to an IAM User (write only)</a>
        """
        authentication_type: pulumi.Input[str]
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsAssumeRole'.
        """
        aws_assume_role_arn: pulumi.Input[str]
        """
        Assumed role ID is an identifier that you can use to create temporary security credentials.
        """
        aws_external_id: pulumi.Input[str]
        """
        A unique identifier that is required when you assume a role in another account.
        """
elif False:
    AwAssumeRoleAuthenticationDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwAssumeRoleAuthenticationDetailsPropertiesArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 aws_assume_role_arn: pulumi.Input[str],
                 aws_external_id: pulumi.Input[str]):
        """
        AWS cloud account connector based assume role, the role enables delegating access to your AWS resources. The role is composed of role Amazon Resource Name (ARN) and external ID. For more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user.html">Creating a Role to Delegate Permissions to an IAM User (write only)</a>
        :param pulumi.Input[str] authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'awsAssumeRole'.
        :param pulumi.Input[str] aws_assume_role_arn: Assumed role ID is an identifier that you can use to create temporary security credentials.
        :param pulumi.Input[str] aws_external_id: A unique identifier that is required when you assume a role in another account.
        """
        pulumi.set(__self__, "authentication_type", 'awsAssumeRole')
        pulumi.set(__self__, "aws_assume_role_arn", aws_assume_role_arn)
        pulumi.set(__self__, "aws_external_id", aws_external_id)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsAssumeRole'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="awsAssumeRoleArn")
    def aws_assume_role_arn(self) -> pulumi.Input[str]:
        """
        Assumed role ID is an identifier that you can use to create temporary security credentials.
        """
        return pulumi.get(self, "aws_assume_role_arn")

    @aws_assume_role_arn.setter
    def aws_assume_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_assume_role_arn", value)

    @property
    @pulumi.getter(name="awsExternalId")
    def aws_external_id(self) -> pulumi.Input[str]:
        """
        A unique identifier that is required when you assume a role in another account.
        """
        return pulumi.get(self, "aws_external_id")

    @aws_external_id.setter
    def aws_external_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_external_id", value)


if not MYPY:
    class AwsCredsAuthenticationDetailsPropertiesArgsDict(TypedDict):
        """
        AWS cloud account connector based credentials, the credentials is composed of access key ID and secret key, for more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html">Creating an IAM User in Your AWS Account (write only)</a>
        """
        authentication_type: pulumi.Input[str]
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsCreds'.
        """
        aws_access_key_id: pulumi.Input[str]
        """
        Public key element of the AWS credential object (write only)
        """
        aws_secret_access_key: pulumi.Input[str]
        """
        Secret key element of the AWS credential object (write only)
        """
elif False:
    AwsCredsAuthenticationDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCredsAuthenticationDetailsPropertiesArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 aws_access_key_id: pulumi.Input[str],
                 aws_secret_access_key: pulumi.Input[str]):
        """
        AWS cloud account connector based credentials, the credentials is composed of access key ID and secret key, for more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html">Creating an IAM User in Your AWS Account (write only)</a>
        :param pulumi.Input[str] authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'awsCreds'.
        :param pulumi.Input[str] aws_access_key_id: Public key element of the AWS credential object (write only)
        :param pulumi.Input[str] aws_secret_access_key: Secret key element of the AWS credential object (write only)
        """
        pulumi.set(__self__, "authentication_type", 'awsCreds')
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsCreds'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> pulumi.Input[str]:
        """
        Public key element of the AWS credential object (write only)
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> pulumi.Input[str]:
        """
        Secret key element of the AWS credential object (write only)
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_secret_access_key", value)


if not MYPY:
    class AwsEnvironmentDataArgsDict(TypedDict):
        """
        The AWS connector environment data
        """
        environment_type: pulumi.Input[str]
        """
        The type of the environment data.
        Expected value is 'AwsAccount'.
        """
        organizational_data: NotRequired[pulumi.Input[Union['AwsOrganizationalDataMasterArgsDict', 'AwsOrganizationalDataMemberArgsDict']]]
        """
        The AWS account's organizational data
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of regions to scan
        """
elif False:
    AwsEnvironmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsEnvironmentDataArgs:
    def __init__(__self__, *,
                 environment_type: pulumi.Input[str],
                 organizational_data: Optional[pulumi.Input[Union['AwsOrganizationalDataMasterArgs', 'AwsOrganizationalDataMemberArgs']]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The AWS connector environment data
        :param pulumi.Input[str] environment_type: The type of the environment data.
               Expected value is 'AwsAccount'.
        :param pulumi.Input[Union['AwsOrganizationalDataMasterArgs', 'AwsOrganizationalDataMemberArgs']] organizational_data: The AWS account's organizational data
        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: list of regions to scan
        """
        pulumi.set(__self__, "environment_type", 'AwsAccount')
        if organizational_data is not None:
            pulumi.set(__self__, "organizational_data", organizational_data)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> pulumi.Input[str]:
        """
        The type of the environment data.
        Expected value is 'AwsAccount'.
        """
        return pulumi.get(self, "environment_type")

    @environment_type.setter
    def environment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_type", value)

    @property
    @pulumi.getter(name="organizationalData")
    def organizational_data(self) -> Optional[pulumi.Input[Union['AwsOrganizationalDataMasterArgs', 'AwsOrganizationalDataMemberArgs']]]:
        """
        The AWS account's organizational data
        """
        return pulumi.get(self, "organizational_data")

    @organizational_data.setter
    def organizational_data(self, value: Optional[pulumi.Input[Union['AwsOrganizationalDataMasterArgs', 'AwsOrganizationalDataMemberArgs']]]):
        pulumi.set(self, "organizational_data", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of regions to scan
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "regions", value)


if not MYPY:
    class AwsOrganizationalDataMasterArgsDict(TypedDict):
        """
        The AWS organization data for the master account
        """
        organization_membership_type: pulumi.Input[str]
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        excluded_account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        stackset_name: NotRequired[pulumi.Input[str]]
        """
        If the multi cloud account is of membership type organization, this will be the name of the onboarding stackset
        """
elif False:
    AwsOrganizationalDataMasterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsOrganizationalDataMasterArgs:
    def __init__(__self__, *,
                 organization_membership_type: pulumi.Input[str],
                 excluded_account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stackset_name: Optional[pulumi.Input[str]] = None):
        """
        The AWS organization data for the master account
        :param pulumi.Input[str] organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Organization'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_account_ids: If the multi cloud account is of membership type organization, list of accounts excluded from offering
        :param pulumi.Input[str] stackset_name: If the multi cloud account is of membership type organization, this will be the name of the onboarding stackset
        """
        pulumi.set(__self__, "organization_membership_type", 'Organization')
        if excluded_account_ids is not None:
            pulumi.set(__self__, "excluded_account_ids", excluded_account_ids)
        if stackset_name is not None:
            pulumi.set(__self__, "stackset_name", stackset_name)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> pulumi.Input[str]:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        return pulumi.get(self, "organization_membership_type")

    @organization_membership_type.setter
    def organization_membership_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_membership_type", value)

    @property
    @pulumi.getter(name="excludedAccountIds")
    def excluded_account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        return pulumi.get(self, "excluded_account_ids")

    @excluded_account_ids.setter
    def excluded_account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_account_ids", value)

    @property
    @pulumi.getter(name="stacksetName")
    def stackset_name(self) -> Optional[pulumi.Input[str]]:
        """
        If the multi cloud account is of membership type organization, this will be the name of the onboarding stackset
        """
        return pulumi.get(self, "stackset_name")

    @stackset_name.setter
    def stackset_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stackset_name", value)


if not MYPY:
    class AwsOrganizationalDataMemberArgsDict(TypedDict):
        """
        The AWS organization data for the member account
        """
        organization_membership_type: pulumi.Input[str]
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        parent_hierarchy_id: NotRequired[pulumi.Input[str]]
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the account's parent
        """
elif False:
    AwsOrganizationalDataMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsOrganizationalDataMemberArgs:
    def __init__(__self__, *,
                 organization_membership_type: pulumi.Input[str],
                 parent_hierarchy_id: Optional[pulumi.Input[str]] = None):
        """
        The AWS organization data for the member account
        :param pulumi.Input[str] organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Member'.
        :param pulumi.Input[str] parent_hierarchy_id: If the multi cloud account is not of membership type organization, this will be the ID of the account's parent
        """
        pulumi.set(__self__, "organization_membership_type", 'Member')
        if parent_hierarchy_id is not None:
            pulumi.set(__self__, "parent_hierarchy_id", parent_hierarchy_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> pulumi.Input[str]:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        return pulumi.get(self, "organization_membership_type")

    @organization_membership_type.setter
    def organization_membership_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_membership_type", value)

    @property
    @pulumi.getter(name="parentHierarchyId")
    def parent_hierarchy_id(self) -> Optional[pulumi.Input[str]]:
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the account's parent
        """
        return pulumi.get(self, "parent_hierarchy_id")

    @parent_hierarchy_id.setter
    def parent_hierarchy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_hierarchy_id", value)


if not MYPY:
    class AzureDevOpsScopeEnvironmentDataArgsDict(TypedDict):
        """
        The AzureDevOps scope connector's environment data
        """
        environment_type: pulumi.Input[str]
        """
        The type of the environment data.
        Expected value is 'AzureDevOpsScope'.
        """
elif False:
    AzureDevOpsScopeEnvironmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureDevOpsScopeEnvironmentDataArgs:
    def __init__(__self__, *,
                 environment_type: pulumi.Input[str]):
        """
        The AzureDevOps scope connector's environment data
        :param pulumi.Input[str] environment_type: The type of the environment data.
               Expected value is 'AzureDevOpsScope'.
        """
        pulumi.set(__self__, "environment_type", 'AzureDevOpsScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> pulumi.Input[str]:
        """
        The type of the environment data.
        Expected value is 'AzureDevOpsScope'.
        """
        return pulumi.get(self, "environment_type")

    @environment_type.setter
    def environment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_type", value)


if not MYPY:
    class AzureResourceDetailsArgsDict(TypedDict):
        """
        Details of the Azure resource that was assessed
        """
        source: pulumi.Input[str]
        """
        The platform where the assessed resource resides
        Expected value is 'Azure'.
        """
elif False:
    AzureResourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureResourceDetailsArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str]):
        """
        Details of the Azure resource that was assessed
        :param pulumi.Input[str] source: The platform where the assessed resource resides
               Expected value is 'Azure'.
        """
        pulumi.set(__self__, "source", 'Azure')

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The platform where the assessed resource resides
        Expected value is 'Azure'.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class CspmMonitorAwsOfferingNativeCloudConnectionArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
elif False:
    CspmMonitorAwsOfferingNativeCloudConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorAwsOfferingNativeCloudConnectionArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class CspmMonitorAwsOfferingArgsDict(TypedDict):
        """
        The CSPM monitoring for AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAws'.
        """
        native_cloud_connection: NotRequired[pulumi.Input['CspmMonitorAwsOfferingNativeCloudConnectionArgsDict']]
        """
        The native cloud connection configuration
        """
elif False:
    CspmMonitorAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 native_cloud_connection: Optional[pulumi.Input['CspmMonitorAwsOfferingNativeCloudConnectionArgs']] = None):
        """
        The CSPM monitoring for AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'CspmMonitorAws'.
        :param pulumi.Input['CspmMonitorAwsOfferingNativeCloudConnectionArgs'] native_cloud_connection: The native cloud connection configuration
        """
        pulumi.set(__self__, "offering_type", 'CspmMonitorAws')
        if native_cloud_connection is not None:
            pulumi.set(__self__, "native_cloud_connection", native_cloud_connection)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional[pulumi.Input['CspmMonitorAwsOfferingNativeCloudConnectionArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")

    @native_cloud_connection.setter
    def native_cloud_connection(self, value: Optional[pulumi.Input['CspmMonitorAwsOfferingNativeCloudConnectionArgs']]):
        pulumi.set(self, "native_cloud_connection", value)


if not MYPY:
    class CspmMonitorAzureDevOpsOfferingArgsDict(TypedDict):
        """
        The CSPM monitoring for AzureDevOps offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAzureDevOps'.
        """
elif False:
    CspmMonitorAzureDevOpsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorAzureDevOpsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The CSPM monitoring for AzureDevOps offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'CspmMonitorAzureDevOps'.
        """
        pulumi.set(__self__, "offering_type", 'CspmMonitorAzureDevOps')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAzureDevOps'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class CspmMonitorGcpOfferingNativeCloudConnectionArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The service account email address in GCP for this offering
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The GCP workload identity provider id for the offering
        """
elif False:
    CspmMonitorGcpOfferingNativeCloudConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorGcpOfferingNativeCloudConnectionArgs:
    def __init__(__self__, *,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] service_account_email_address: The service account email address in GCP for this offering
        :param pulumi.Input[str] workload_identity_provider_id: The GCP workload identity provider id for the offering
        """
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP workload identity provider id for the offering
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class CspmMonitorGcpOfferingArgsDict(TypedDict):
        """
        The CSPM monitoring for GCP offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGcp'.
        """
        native_cloud_connection: NotRequired[pulumi.Input['CspmMonitorGcpOfferingNativeCloudConnectionArgsDict']]
        """
        The native cloud connection configuration
        """
elif False:
    CspmMonitorGcpOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorGcpOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 native_cloud_connection: Optional[pulumi.Input['CspmMonitorGcpOfferingNativeCloudConnectionArgs']] = None):
        """
        The CSPM monitoring for GCP offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGcp'.
        :param pulumi.Input['CspmMonitorGcpOfferingNativeCloudConnectionArgs'] native_cloud_connection: The native cloud connection configuration
        """
        pulumi.set(__self__, "offering_type", 'CspmMonitorGcp')
        if native_cloud_connection is not None:
            pulumi.set(__self__, "native_cloud_connection", native_cloud_connection)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGcp'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional[pulumi.Input['CspmMonitorGcpOfferingNativeCloudConnectionArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")

    @native_cloud_connection.setter
    def native_cloud_connection(self, value: Optional[pulumi.Input['CspmMonitorGcpOfferingNativeCloudConnectionArgs']]):
        pulumi.set(self, "native_cloud_connection", value)


if not MYPY:
    class CspmMonitorGitLabOfferingArgsDict(TypedDict):
        """
        The CSPM (Cloud security posture management) monitoring for gitlab offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGitLab'.
        """
elif False:
    CspmMonitorGitLabOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorGitLabOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The CSPM (Cloud security posture management) monitoring for gitlab offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGitLab'.
        """
        pulumi.set(__self__, "offering_type", 'CspmMonitorGitLab')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGitLab'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class CspmMonitorGithubOfferingArgsDict(TypedDict):
        """
        The CSPM monitoring for github offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGithub'.
        """
elif False:
    CspmMonitorGithubOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CspmMonitorGithubOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The CSPM monitoring for github offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGithub'.
        """
        pulumi.set(__self__, "offering_type", 'CspmMonitorGithub')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGithub'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class DefenderCspmAwsOfferingConfigurationArgsDict(TypedDict):
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        exclusion_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        VM tags that indicates that VM should not be scanned
        """
        scanning_mode: NotRequired[pulumi.Input[Union[str, 'ScanningMode']]]
        """
        The scanning mode for the VM scan.
        """
elif False:
    DefenderCspmAwsOfferingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmAwsOfferingConfigurationArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 exclusion_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 scanning_mode: Optional[pulumi.Input[Union[str, 'ScanningMode']]] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclusion_tags: VM tags that indicates that VM should not be scanned
        :param pulumi.Input[Union[str, 'ScanningMode']] scanning_mode: The scanning mode for the VM scan.
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if exclusion_tags is not None:
            pulumi.set(__self__, "exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            pulumi.set(__self__, "scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        VM tags that indicates that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @exclusion_tags.setter
    def exclusion_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_tags", value)

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[pulumi.Input[Union[str, 'ScanningMode']]]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")

    @scanning_mode.setter
    def scanning_mode(self, value: Optional[pulumi.Input[Union[str, 'ScanningMode']]]):
        pulumi.set(self, "scanning_mode", value)


if not MYPY:
    class DefenderCspmAwsOfferingDataSensitivityDiscoveryArgsDict(TypedDict):
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender Data Sensitivity discovery enabled
        """
elif False:
    DefenderCspmAwsOfferingDataSensitivityDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[bool] enabled: Is Microsoft Defender Data Sensitivity discovery enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender Data Sensitivity discovery enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderCspmAwsOfferingDatabasesDspmArgsDict(TypedDict):
        """
        The databases DSPM configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is databases DSPM protection enabled
        """
elif False:
    DefenderCspmAwsOfferingDatabasesDspmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmAwsOfferingDatabasesDspmArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The databases DSPM configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[bool] enabled: Is databases DSPM protection enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is databases DSPM protection enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderCspmAwsOfferingVmScannersArgsDict(TypedDict):
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderCspmAwsOfferingConfigurationArgsDict']]
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
elif False:
    DefenderCspmAwsOfferingVmScannersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmAwsOfferingVmScannersArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderCspmAwsOfferingConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param pulumi.Input['DefenderCspmAwsOfferingConfigurationArgs'] configuration: configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[bool] enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderCspmAwsOfferingConfigurationArgs']]:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderCspmAwsOfferingConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderCspmAwsOfferingArgsDict(TypedDict):
        """
        The CSPM P1 for AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderCspmAws'.
        """
        data_sensitivity_discovery: NotRequired[pulumi.Input['DefenderCspmAwsOfferingDataSensitivityDiscoveryArgsDict']]
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        """
        databases_dspm: NotRequired[pulumi.Input['DefenderCspmAwsOfferingDatabasesDspmArgsDict']]
        """
        The databases DSPM configuration
        """
        vm_scanners: NotRequired[pulumi.Input['DefenderCspmAwsOfferingVmScannersArgsDict']]
        """
        The Microsoft Defender for Server VM scanning configuration
        """
elif False:
    DefenderCspmAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 data_sensitivity_discovery: Optional[pulumi.Input['DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs']] = None,
                 databases_dspm: Optional[pulumi.Input['DefenderCspmAwsOfferingDatabasesDspmArgs']] = None,
                 vm_scanners: Optional[pulumi.Input['DefenderCspmAwsOfferingVmScannersArgs']] = None):
        """
        The CSPM P1 for AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderCspmAws'.
        :param pulumi.Input['DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs'] data_sensitivity_discovery: The Microsoft Defender Data Sensitivity discovery configuration
        :param pulumi.Input['DefenderCspmAwsOfferingDatabasesDspmArgs'] databases_dspm: The databases DSPM configuration
        :param pulumi.Input['DefenderCspmAwsOfferingVmScannersArgs'] vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        pulumi.set(__self__, "offering_type", 'DefenderCspmAws')
        if data_sensitivity_discovery is not None:
            pulumi.set(__self__, "data_sensitivity_discovery", data_sensitivity_discovery)
        if databases_dspm is not None:
            pulumi.set(__self__, "databases_dspm", databases_dspm)
        if vm_scanners is not None:
            pulumi.set(__self__, "vm_scanners", vm_scanners)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderCspmAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="dataSensitivityDiscovery")
    def data_sensitivity_discovery(self) -> Optional[pulumi.Input['DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs']]:
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        """
        return pulumi.get(self, "data_sensitivity_discovery")

    @data_sensitivity_discovery.setter
    def data_sensitivity_discovery(self, value: Optional[pulumi.Input['DefenderCspmAwsOfferingDataSensitivityDiscoveryArgs']]):
        pulumi.set(self, "data_sensitivity_discovery", value)

    @property
    @pulumi.getter(name="databasesDspm")
    def databases_dspm(self) -> Optional[pulumi.Input['DefenderCspmAwsOfferingDatabasesDspmArgs']]:
        """
        The databases DSPM configuration
        """
        return pulumi.get(self, "databases_dspm")

    @databases_dspm.setter
    def databases_dspm(self, value: Optional[pulumi.Input['DefenderCspmAwsOfferingDatabasesDspmArgs']]):
        pulumi.set(self, "databases_dspm", value)

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional[pulumi.Input['DefenderCspmAwsOfferingVmScannersArgs']]:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")

    @vm_scanners.setter
    def vm_scanners(self, value: Optional[pulumi.Input['DefenderCspmAwsOfferingVmScannersArgs']]):
        pulumi.set(self, "vm_scanners", value)


if not MYPY:
    class DefenderCspmGcpOfferingArgsDict(TypedDict):
        """
        The CSPM P1 for GCP offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderCspmGcp'.
        """
elif False:
    DefenderCspmGcpOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderCspmGcpOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The CSPM P1 for GCP offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderCspmGcp'.
        """
        pulumi.set(__self__, "offering_type", 'DefenderCspmGcp')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderCspmGcp'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgsDict(TypedDict):
        """
        The ARC autoprovisioning configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        configuration: NotRequired[pulumi.Input['DefenderFoDatabasesAwsOfferingConfigurationArgsDict']]
        """
        Configuration for servers Arc auto provisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is arc auto provisioning enabled
        """
elif False:
    DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 configuration: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The ARC autoprovisioning configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input['DefenderFoDatabasesAwsOfferingConfigurationArgs'] configuration: Configuration for servers Arc auto provisioning
        :param pulumi.Input[bool] enabled: Is arc auto provisioning enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingConfigurationArgs']]:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderFoDatabasesAwsOfferingConfigurationArgsDict(TypedDict):
        """
        Configuration for servers Arc auto provisioning
        """
        private_link_scope: NotRequired[pulumi.Input[str]]
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        proxy: NotRequired[pulumi.Input[str]]
        """
        Optional http proxy endpoint to use for the Arc agent
        """
elif False:
    DefenderFoDatabasesAwsOfferingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderFoDatabasesAwsOfferingConfigurationArgs:
    def __init__(__self__, *,
                 private_link_scope: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None):
        """
        Configuration for servers Arc auto provisioning
        :param pulumi.Input[str] private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param pulumi.Input[str] proxy: Optional http proxy endpoint to use for the Arc agent
        """
        if private_link_scope is not None:
            pulumi.set(__self__, "private_link_scope", private_link_scope)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @private_link_scope.setter
    def private_link_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_scope", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Optional http proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)


if not MYPY:
    class DefenderFoDatabasesAwsOfferingDatabasesDspmArgsDict(TypedDict):
        """
        The databases data security posture management (DSPM) configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is databases data security posture management (DSPM) protection enabled
        """
elif False:
    DefenderFoDatabasesAwsOfferingDatabasesDspmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderFoDatabasesAwsOfferingDatabasesDspmArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The databases data security posture management (DSPM) configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[bool] enabled: Is databases data security posture management (DSPM) protection enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is databases data security posture management (DSPM) protection enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderFoDatabasesAwsOfferingRdsArgsDict(TypedDict):
        """
        The RDS configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is RDS protection enabled
        """
elif False:
    DefenderFoDatabasesAwsOfferingRdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderFoDatabasesAwsOfferingRdsArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The RDS configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[bool] enabled: Is RDS protection enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is RDS protection enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderFoDatabasesAwsOfferingArgsDict(TypedDict):
        """
        The Defender for Databases AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesAws'.
        """
        arc_auto_provisioning: NotRequired[pulumi.Input['DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgsDict']]
        """
        The ARC autoprovisioning configuration
        """
        databases_dspm: NotRequired[pulumi.Input['DefenderFoDatabasesAwsOfferingDatabasesDspmArgsDict']]
        """
        The databases data security posture management (DSPM) configuration
        """
        rds: NotRequired[pulumi.Input['DefenderFoDatabasesAwsOfferingRdsArgsDict']]
        """
        The RDS configuration
        """
elif False:
    DefenderFoDatabasesAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderFoDatabasesAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 arc_auto_provisioning: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs']] = None,
                 databases_dspm: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingDatabasesDspmArgs']] = None,
                 rds: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingRdsArgs']] = None):
        """
        The Defender for Databases AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForDatabasesAws'.
        :param pulumi.Input['DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs'] arc_auto_provisioning: The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderFoDatabasesAwsOfferingDatabasesDspmArgs'] databases_dspm: The databases data security posture management (DSPM) configuration
        :param pulumi.Input['DefenderFoDatabasesAwsOfferingRdsArgs'] rds: The RDS configuration
        """
        pulumi.set(__self__, "offering_type", 'DefenderForDatabasesAws')
        if arc_auto_provisioning is not None:
            pulumi.set(__self__, "arc_auto_provisioning", arc_auto_provisioning)
        if databases_dspm is not None:
            pulumi.set(__self__, "databases_dspm", databases_dspm)
        if rds is not None:
            pulumi.set(__self__, "rds", rds)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs']]:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @arc_auto_provisioning.setter
    def arc_auto_provisioning(self, value: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingArcAutoProvisioningArgs']]):
        pulumi.set(self, "arc_auto_provisioning", value)

    @property
    @pulumi.getter(name="databasesDspm")
    def databases_dspm(self) -> Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingDatabasesDspmArgs']]:
        """
        The databases data security posture management (DSPM) configuration
        """
        return pulumi.get(self, "databases_dspm")

    @databases_dspm.setter
    def databases_dspm(self, value: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingDatabasesDspmArgs']]):
        pulumi.set(self, "databases_dspm", value)

    @property
    @pulumi.getter
    def rds(self) -> Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingRdsArgs']]:
        """
        The RDS configuration
        """
        return pulumi.get(self, "rds")

    @rds.setter
    def rds(self, value: Optional[pulumi.Input['DefenderFoDatabasesAwsOfferingRdsArgs']]):
        pulumi.set(self, "rds", value)


if not MYPY:
    class DefenderForContainersAwsOfferingCloudWatchToKinesisArgsDict(TypedDict):
        """
        The cloudwatch to kinesis connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS used by CloudWatch to transfer data into Kinesis
        """
elif False:
    DefenderForContainersAwsOfferingCloudWatchToKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingCloudWatchToKinesisArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The cloudwatch to kinesis connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS used by CloudWatch to transfer data into Kinesis
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS used by CloudWatch to transfer data into Kinesis
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgsDict(TypedDict):
        """
        The container vulnerability assessment task configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
elif False:
    DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The container vulnerability assessment task configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgsDict(TypedDict):
        """
        The container vulnerability assessment configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
elif False:
    DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The container vulnerability assessment configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingKinesisToS3ArgsDict(TypedDict):
        """
        The kinesis to s3 connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS used by Kinesis to transfer data into S3
        """
elif False:
    DefenderForContainersAwsOfferingKinesisToS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingKinesisToS3Args:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The kinesis to s3 connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS used by Kinesis to transfer data into S3
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS used by Kinesis to transfer data into S3
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingKubernetesScubaReaderArgsDict(TypedDict):
        """
        The kubernetes to scuba connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature used for reading data
        """
elif False:
    DefenderForContainersAwsOfferingKubernetesScubaReaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingKubernetesScubaReaderArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The kubernetes to scuba connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature used for reading data
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature used for reading data
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingKubernetesServiceArgsDict(TypedDict):
        """
        The kubernetes service connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature used for provisioning resources
        """
elif False:
    DefenderForContainersAwsOfferingKubernetesServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingKubernetesServiceArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The kubernetes service connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature used for provisioning resources
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature used for provisioning resources
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForContainersAwsOfferingArgsDict(TypedDict):
        """
        The Defender for Containers AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersAws'.
        """
        auto_provisioning: NotRequired[pulumi.Input[bool]]
        """
        Is audit logs pipeline auto provisioning enabled
        """
        cloud_watch_to_kinesis: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingCloudWatchToKinesisArgsDict']]
        """
        The cloudwatch to kinesis connection configuration
        """
        container_vulnerability_assessment: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgsDict']]
        """
        The container vulnerability assessment configuration
        """
        container_vulnerability_assessment_task: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgsDict']]
        """
        The container vulnerability assessment task configuration
        """
        enable_container_vulnerability_assessment: NotRequired[pulumi.Input[bool]]
        """
        Enable container vulnerability assessment feature
        """
        kinesis_to_s3: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingKinesisToS3ArgsDict']]
        """
        The kinesis to s3 connection configuration
        """
        kube_audit_retention_time: NotRequired[pulumi.Input[float]]
        """
        The retention time in days of kube audit logs set on the CloudWatch log group
        """
        kubernetes_scuba_reader: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingKubernetesScubaReaderArgsDict']]
        """
        The kubernetes to scuba connection configuration
        """
        kubernetes_service: NotRequired[pulumi.Input['DefenderForContainersAwsOfferingKubernetesServiceArgsDict']]
        """
        The kubernetes service connection configuration
        """
        scuba_external_id: NotRequired[pulumi.Input[str]]
        """
        The externalId used by the data reader to prevent the confused deputy attack
        """
elif False:
    DefenderForContainersAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 auto_provisioning: Optional[pulumi.Input[bool]] = None,
                 cloud_watch_to_kinesis: Optional[pulumi.Input['DefenderForContainersAwsOfferingCloudWatchToKinesisArgs']] = None,
                 container_vulnerability_assessment: Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs']] = None,
                 container_vulnerability_assessment_task: Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs']] = None,
                 enable_container_vulnerability_assessment: Optional[pulumi.Input[bool]] = None,
                 kinesis_to_s3: Optional[pulumi.Input['DefenderForContainersAwsOfferingKinesisToS3Args']] = None,
                 kube_audit_retention_time: Optional[pulumi.Input[float]] = None,
                 kubernetes_scuba_reader: Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesScubaReaderArgs']] = None,
                 kubernetes_service: Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesServiceArgs']] = None,
                 scuba_external_id: Optional[pulumi.Input[str]] = None):
        """
        The Defender for Containers AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForContainersAws'.
        :param pulumi.Input[bool] auto_provisioning: Is audit logs pipeline auto provisioning enabled
        :param pulumi.Input['DefenderForContainersAwsOfferingCloudWatchToKinesisArgs'] cloud_watch_to_kinesis: The cloudwatch to kinesis connection configuration
        :param pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs'] container_vulnerability_assessment: The container vulnerability assessment configuration
        :param pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs'] container_vulnerability_assessment_task: The container vulnerability assessment task configuration
        :param pulumi.Input[bool] enable_container_vulnerability_assessment: Enable container vulnerability assessment feature
        :param pulumi.Input['DefenderForContainersAwsOfferingKinesisToS3Args'] kinesis_to_s3: The kinesis to s3 connection configuration
        :param pulumi.Input[float] kube_audit_retention_time: The retention time in days of kube audit logs set on the CloudWatch log group
        :param pulumi.Input['DefenderForContainersAwsOfferingKubernetesScubaReaderArgs'] kubernetes_scuba_reader: The kubernetes to scuba connection configuration
        :param pulumi.Input['DefenderForContainersAwsOfferingKubernetesServiceArgs'] kubernetes_service: The kubernetes service connection configuration
        :param pulumi.Input[str] scuba_external_id: The externalId used by the data reader to prevent the confused deputy attack
        """
        pulumi.set(__self__, "offering_type", 'DefenderForContainersAws')
        if auto_provisioning is not None:
            pulumi.set(__self__, "auto_provisioning", auto_provisioning)
        if cloud_watch_to_kinesis is not None:
            pulumi.set(__self__, "cloud_watch_to_kinesis", cloud_watch_to_kinesis)
        if container_vulnerability_assessment is not None:
            pulumi.set(__self__, "container_vulnerability_assessment", container_vulnerability_assessment)
        if container_vulnerability_assessment_task is not None:
            pulumi.set(__self__, "container_vulnerability_assessment_task", container_vulnerability_assessment_task)
        if enable_container_vulnerability_assessment is not None:
            pulumi.set(__self__, "enable_container_vulnerability_assessment", enable_container_vulnerability_assessment)
        if kinesis_to_s3 is not None:
            pulumi.set(__self__, "kinesis_to_s3", kinesis_to_s3)
        if kube_audit_retention_time is not None:
            pulumi.set(__self__, "kube_audit_retention_time", kube_audit_retention_time)
        if kubernetes_scuba_reader is not None:
            pulumi.set(__self__, "kubernetes_scuba_reader", kubernetes_scuba_reader)
        if kubernetes_service is not None:
            pulumi.set(__self__, "kubernetes_service", kubernetes_service)
        if scuba_external_id is not None:
            pulumi.set(__self__, "scuba_external_id", scuba_external_id)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="autoProvisioning")
    def auto_provisioning(self) -> Optional[pulumi.Input[bool]]:
        """
        Is audit logs pipeline auto provisioning enabled
        """
        return pulumi.get(self, "auto_provisioning")

    @auto_provisioning.setter
    def auto_provisioning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_provisioning", value)

    @property
    @pulumi.getter(name="cloudWatchToKinesis")
    def cloud_watch_to_kinesis(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingCloudWatchToKinesisArgs']]:
        """
        The cloudwatch to kinesis connection configuration
        """
        return pulumi.get(self, "cloud_watch_to_kinesis")

    @cloud_watch_to_kinesis.setter
    def cloud_watch_to_kinesis(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingCloudWatchToKinesisArgs']]):
        pulumi.set(self, "cloud_watch_to_kinesis", value)

    @property
    @pulumi.getter(name="containerVulnerabilityAssessment")
    def container_vulnerability_assessment(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs']]:
        """
        The container vulnerability assessment configuration
        """
        return pulumi.get(self, "container_vulnerability_assessment")

    @container_vulnerability_assessment.setter
    def container_vulnerability_assessment(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentArgs']]):
        pulumi.set(self, "container_vulnerability_assessment", value)

    @property
    @pulumi.getter(name="containerVulnerabilityAssessmentTask")
    def container_vulnerability_assessment_task(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs']]:
        """
        The container vulnerability assessment task configuration
        """
        return pulumi.get(self, "container_vulnerability_assessment_task")

    @container_vulnerability_assessment_task.setter
    def container_vulnerability_assessment_task(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingContainerVulnerabilityAssessmentTaskArgs']]):
        pulumi.set(self, "container_vulnerability_assessment_task", value)

    @property
    @pulumi.getter(name="enableContainerVulnerabilityAssessment")
    def enable_container_vulnerability_assessment(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable container vulnerability assessment feature
        """
        return pulumi.get(self, "enable_container_vulnerability_assessment")

    @enable_container_vulnerability_assessment.setter
    def enable_container_vulnerability_assessment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_container_vulnerability_assessment", value)

    @property
    @pulumi.getter(name="kinesisToS3")
    def kinesis_to_s3(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingKinesisToS3Args']]:
        """
        The kinesis to s3 connection configuration
        """
        return pulumi.get(self, "kinesis_to_s3")

    @kinesis_to_s3.setter
    def kinesis_to_s3(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingKinesisToS3Args']]):
        pulumi.set(self, "kinesis_to_s3", value)

    @property
    @pulumi.getter(name="kubeAuditRetentionTime")
    def kube_audit_retention_time(self) -> Optional[pulumi.Input[float]]:
        """
        The retention time in days of kube audit logs set on the CloudWatch log group
        """
        return pulumi.get(self, "kube_audit_retention_time")

    @kube_audit_retention_time.setter
    def kube_audit_retention_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "kube_audit_retention_time", value)

    @property
    @pulumi.getter(name="kubernetesScubaReader")
    def kubernetes_scuba_reader(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesScubaReaderArgs']]:
        """
        The kubernetes to scuba connection configuration
        """
        return pulumi.get(self, "kubernetes_scuba_reader")

    @kubernetes_scuba_reader.setter
    def kubernetes_scuba_reader(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesScubaReaderArgs']]):
        pulumi.set(self, "kubernetes_scuba_reader", value)

    @property
    @pulumi.getter(name="kubernetesService")
    def kubernetes_service(self) -> Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesServiceArgs']]:
        """
        The kubernetes service connection configuration
        """
        return pulumi.get(self, "kubernetes_service")

    @kubernetes_service.setter
    def kubernetes_service(self, value: Optional[pulumi.Input['DefenderForContainersAwsOfferingKubernetesServiceArgs']]):
        pulumi.set(self, "kubernetes_service", value)

    @property
    @pulumi.getter(name="scubaExternalId")
    def scuba_external_id(self) -> Optional[pulumi.Input[str]]:
        """
        The externalId used by the data reader to prevent the confused deputy attack
        """
        return pulumi.get(self, "scuba_external_id")

    @scuba_external_id.setter
    def scuba_external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scuba_external_id", value)


if not MYPY:
    class DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The data collection service account email address in GCP for this offering
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The data collection GCP workload identity provider id for this offering
        """
elif False:
    DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs:
    def __init__(__self__, *,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] service_account_email_address: The data collection service account email address in GCP for this offering
        :param pulumi.Input[str] workload_identity_provider_id: The data collection GCP workload identity provider id for this offering
        """
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The data collection service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The data collection GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class DefenderForContainersGcpOfferingNativeCloudConnectionArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The service account email address in GCP for this offering
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The GCP workload identity provider id for this offering
        """
elif False:
    DefenderForContainersGcpOfferingNativeCloudConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersGcpOfferingNativeCloudConnectionArgs:
    def __init__(__self__, *,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] service_account_email_address: The service account email address in GCP for this offering
        :param pulumi.Input[str] workload_identity_provider_id: The GCP workload identity provider id for this offering
        """
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class DefenderForContainersGcpOfferingArgsDict(TypedDict):
        """
        The containers GCP offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersGcp'.
        """
        audit_logs_auto_provisioning_flag: NotRequired[pulumi.Input[bool]]
        """
        Is audit logs data collection enabled
        """
        data_pipeline_native_cloud_connection: NotRequired[pulumi.Input['DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgsDict']]
        """
        The native cloud connection configuration
        """
        defender_agent_auto_provisioning_flag: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Cloud Kubernetes agent auto provisioning enabled
        """
        native_cloud_connection: NotRequired[pulumi.Input['DefenderForContainersGcpOfferingNativeCloudConnectionArgsDict']]
        """
        The native cloud connection configuration
        """
        policy_agent_auto_provisioning_flag: NotRequired[pulumi.Input[bool]]
        """
        Is Policy Kubernetes agent auto provisioning enabled
        """
elif False:
    DefenderForContainersGcpOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForContainersGcpOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 audit_logs_auto_provisioning_flag: Optional[pulumi.Input[bool]] = None,
                 data_pipeline_native_cloud_connection: Optional[pulumi.Input['DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs']] = None,
                 defender_agent_auto_provisioning_flag: Optional[pulumi.Input[bool]] = None,
                 native_cloud_connection: Optional[pulumi.Input['DefenderForContainersGcpOfferingNativeCloudConnectionArgs']] = None,
                 policy_agent_auto_provisioning_flag: Optional[pulumi.Input[bool]] = None):
        """
        The containers GCP offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForContainersGcp'.
        :param pulumi.Input[bool] audit_logs_auto_provisioning_flag: Is audit logs data collection enabled
        :param pulumi.Input['DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs'] data_pipeline_native_cloud_connection: The native cloud connection configuration
        :param pulumi.Input[bool] defender_agent_auto_provisioning_flag: Is Microsoft Defender for Cloud Kubernetes agent auto provisioning enabled
        :param pulumi.Input['DefenderForContainersGcpOfferingNativeCloudConnectionArgs'] native_cloud_connection: The native cloud connection configuration
        :param pulumi.Input[bool] policy_agent_auto_provisioning_flag: Is Policy Kubernetes agent auto provisioning enabled
        """
        pulumi.set(__self__, "offering_type", 'DefenderForContainersGcp')
        if audit_logs_auto_provisioning_flag is not None:
            pulumi.set(__self__, "audit_logs_auto_provisioning_flag", audit_logs_auto_provisioning_flag)
        if data_pipeline_native_cloud_connection is not None:
            pulumi.set(__self__, "data_pipeline_native_cloud_connection", data_pipeline_native_cloud_connection)
        if defender_agent_auto_provisioning_flag is not None:
            pulumi.set(__self__, "defender_agent_auto_provisioning_flag", defender_agent_auto_provisioning_flag)
        if native_cloud_connection is not None:
            pulumi.set(__self__, "native_cloud_connection", native_cloud_connection)
        if policy_agent_auto_provisioning_flag is not None:
            pulumi.set(__self__, "policy_agent_auto_provisioning_flag", policy_agent_auto_provisioning_flag)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersGcp'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="auditLogsAutoProvisioningFlag")
    def audit_logs_auto_provisioning_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        Is audit logs data collection enabled
        """
        return pulumi.get(self, "audit_logs_auto_provisioning_flag")

    @audit_logs_auto_provisioning_flag.setter
    def audit_logs_auto_provisioning_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "audit_logs_auto_provisioning_flag", value)

    @property
    @pulumi.getter(name="dataPipelineNativeCloudConnection")
    def data_pipeline_native_cloud_connection(self) -> Optional[pulumi.Input['DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "data_pipeline_native_cloud_connection")

    @data_pipeline_native_cloud_connection.setter
    def data_pipeline_native_cloud_connection(self, value: Optional[pulumi.Input['DefenderForContainersGcpOfferingDataPipelineNativeCloudConnectionArgs']]):
        pulumi.set(self, "data_pipeline_native_cloud_connection", value)

    @property
    @pulumi.getter(name="defenderAgentAutoProvisioningFlag")
    def defender_agent_auto_provisioning_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Cloud Kubernetes agent auto provisioning enabled
        """
        return pulumi.get(self, "defender_agent_auto_provisioning_flag")

    @defender_agent_auto_provisioning_flag.setter
    def defender_agent_auto_provisioning_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "defender_agent_auto_provisioning_flag", value)

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional[pulumi.Input['DefenderForContainersGcpOfferingNativeCloudConnectionArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")

    @native_cloud_connection.setter
    def native_cloud_connection(self, value: Optional[pulumi.Input['DefenderForContainersGcpOfferingNativeCloudConnectionArgs']]):
        pulumi.set(self, "native_cloud_connection", value)

    @property
    @pulumi.getter(name="policyAgentAutoProvisioningFlag")
    def policy_agent_auto_provisioning_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Policy Kubernetes agent auto provisioning enabled
        """
        return pulumi.get(self, "policy_agent_auto_provisioning_flag")

    @policy_agent_auto_provisioning_flag.setter
    def policy_agent_auto_provisioning_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "policy_agent_auto_provisioning_flag", value)


if not MYPY:
    class DefenderForDatabasesGcpOfferingArcAutoProvisioningArgsDict(TypedDict):
        """
        The ARC autoprovisioning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForDatabasesGcpOfferingConfigurationArgsDict']]
        """
        Configuration for servers Arc auto provisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is arc auto provisioning enabled
        """
elif False:
    DefenderForDatabasesGcpOfferingArcAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderForDatabasesGcpOfferingConfigurationArgs'] configuration: Configuration for servers Arc auto provisioning
        :param pulumi.Input[bool] enabled: Is arc auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForDatabasesGcpOfferingConfigurationArgs']]:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForDatabasesGcpOfferingConfigurationArgsDict(TypedDict):
        """
        Configuration for servers Arc auto provisioning
        """
        private_link_scope: NotRequired[pulumi.Input[str]]
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        proxy: NotRequired[pulumi.Input[str]]
        """
        Optional http proxy endpoint to use for the Arc agent
        """
elif False:
    DefenderForDatabasesGcpOfferingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDatabasesGcpOfferingConfigurationArgs:
    def __init__(__self__, *,
                 private_link_scope: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None):
        """
        Configuration for servers Arc auto provisioning
        :param pulumi.Input[str] private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param pulumi.Input[str] proxy: Optional http proxy endpoint to use for the Arc agent
        """
        if private_link_scope is not None:
            pulumi.set(__self__, "private_link_scope", private_link_scope)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @private_link_scope.setter
    def private_link_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_scope", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Optional http proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)


if not MYPY:
    class DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The service account email address in GCP for this offering
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The GCP workload identity provider id for this offering
        """
elif False:
    DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs:
    def __init__(__self__, *,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] service_account_email_address: The service account email address in GCP for this offering
        :param pulumi.Input[str] workload_identity_provider_id: The GCP workload identity provider id for this offering
        """
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class DefenderForDatabasesGcpOfferingArgsDict(TypedDict):
        """
        The Defender for Databases GCP offering configurations
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesGcp'.
        """
        arc_auto_provisioning: NotRequired[pulumi.Input['DefenderForDatabasesGcpOfferingArcAutoProvisioningArgsDict']]
        """
        The ARC autoprovisioning configuration
        """
        defender_for_databases_arc_auto_provisioning: NotRequired[pulumi.Input['DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgsDict']]
        """
        The native cloud connection configuration
        """
elif False:
    DefenderForDatabasesGcpOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDatabasesGcpOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 arc_auto_provisioning: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs']] = None,
                 defender_for_databases_arc_auto_provisioning: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs']] = None):
        """
        The Defender for Databases GCP offering configurations
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForDatabasesGcp'.
        :param pulumi.Input['DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs'] arc_auto_provisioning: The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs'] defender_for_databases_arc_auto_provisioning: The native cloud connection configuration
        """
        pulumi.set(__self__, "offering_type", 'DefenderForDatabasesGcp')
        if arc_auto_provisioning is not None:
            pulumi.set(__self__, "arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_databases_arc_auto_provisioning is not None:
            pulumi.set(__self__, "defender_for_databases_arc_auto_provisioning", defender_for_databases_arc_auto_provisioning)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesGcp'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs']]:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @arc_auto_provisioning.setter
    def arc_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingArcAutoProvisioningArgs']]):
        pulumi.set(self, "arc_auto_provisioning", value)

    @property
    @pulumi.getter(name="defenderForDatabasesArcAutoProvisioning")
    def defender_for_databases_arc_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "defender_for_databases_arc_auto_provisioning")

    @defender_for_databases_arc_auto_provisioning.setter
    def defender_for_databases_arc_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForDatabasesGcpOfferingDefenderForDatabasesArcAutoProvisioningArgs']]):
        pulumi.set(self, "defender_for_databases_arc_auto_provisioning", value)


if not MYPY:
    class DefenderForDevOpsAzureDevOpsOfferingArgsDict(TypedDict):
        """
        The Defender for DevOps for Azure DevOps offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsAzureDevOps'.
        """
elif False:
    DefenderForDevOpsAzureDevOpsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDevOpsAzureDevOpsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The Defender for DevOps for Azure DevOps offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsAzureDevOps'.
        """
        pulumi.set(__self__, "offering_type", 'DefenderForDevOpsAzureDevOps')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsAzureDevOps'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class DefenderForDevOpsGitLabOfferingArgsDict(TypedDict):
        """
        The Defender for DevOps for Gitlab offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGitLab'.
        """
elif False:
    DefenderForDevOpsGitLabOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDevOpsGitLabOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The Defender for DevOps for Gitlab offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsGitLab'.
        """
        pulumi.set(__self__, "offering_type", 'DefenderForDevOpsGitLab')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGitLab'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class DefenderForDevOpsGithubOfferingArgsDict(TypedDict):
        """
        The Defender for DevOps for Github offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGithub'.
        """
elif False:
    DefenderForDevOpsGithubOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForDevOpsGithubOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str]):
        """
        The Defender for DevOps for Github offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsGithub'.
        """
        pulumi.set(__self__, "offering_type", 'DefenderForDevOpsGithub')

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGithub'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)


if not MYPY:
    class DefenderForServersAwsOfferingArcAutoProvisioningArgsDict(TypedDict):
        """
        The ARC autoprovisioning configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersAwsOfferingConfigurationArgsDict']]
        """
        Configuration for servers Arc auto provisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is arc auto provisioning enabled
        """
elif False:
    DefenderForServersAwsOfferingArcAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingArcAutoProvisioningArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 configuration: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The ARC autoprovisioning configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input['DefenderForServersAwsOfferingConfigurationArgs'] configuration: Configuration for servers Arc auto provisioning
        :param pulumi.Input[bool] enabled: Is arc auto provisioning enabled
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationArgs']]:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgsDict(TypedDict):
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
        exclusion_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        VM tags that indicates that VM should not be scanned
        """
        scanning_mode: NotRequired[pulumi.Input[Union[str, 'ScanningMode']]]
        """
        The scanning mode for the VM scan.
        """
elif False:
    DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None,
                 exclusion_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 scanning_mode: Optional[pulumi.Input[Union[str, 'ScanningMode']]] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclusion_tags: VM tags that indicates that VM should not be scanned
        :param pulumi.Input[Union[str, 'ScanningMode']] scanning_mode: The scanning mode for the VM scan.
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)
        if exclusion_tags is not None:
            pulumi.set(__self__, "exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            pulumi.set(__self__, "scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        VM tags that indicates that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @exclusion_tags.setter
    def exclusion_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_tags", value)

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[pulumi.Input[Union[str, 'ScanningMode']]]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")

    @scanning_mode.setter
    def scanning_mode(self, value: Optional[pulumi.Input[Union[str, 'ScanningMode']]]):
        pulumi.set(self, "scanning_mode", value)


if not MYPY:
    class DefenderForServersAwsOfferingConfigurationConfigurationArgsDict(TypedDict):
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        type: NotRequired[pulumi.Input[Union[str, 'Type']]]
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
elif False:
    DefenderForServersAwsOfferingConfigurationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingConfigurationConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'Type']]] = None):
        """
        configuration for Vulnerability Assessment autoprovisioning
        :param pulumi.Input[Union[str, 'Type']] type: The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'Type']]]:
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'Type']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DefenderForServersAwsOfferingConfigurationArgsDict(TypedDict):
        """
        Configuration for servers Arc auto provisioning
        """
        private_link_scope: NotRequired[pulumi.Input[str]]
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        proxy: NotRequired[pulumi.Input[str]]
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
elif False:
    DefenderForServersAwsOfferingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingConfigurationArgs:
    def __init__(__self__, *,
                 private_link_scope: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None):
        """
        Configuration for servers Arc auto provisioning
        :param pulumi.Input[str] private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param pulumi.Input[str] proxy: Optional HTTP proxy endpoint to use for the Arc agent
        """
        if private_link_scope is not None:
            pulumi.set(__self__, "private_link_scope", private_link_scope)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @private_link_scope.setter
    def private_link_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_scope", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)


if not MYPY:
    class DefenderForServersAwsOfferingDefenderForServersArgsDict(TypedDict):
        """
        The Defender for servers connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
elif False:
    DefenderForServersAwsOfferingDefenderForServersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingDefenderForServersArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The Defender for servers connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class DefenderForServersAwsOfferingMdeAutoProvisioningArgsDict(TypedDict):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        configuration: NotRequired[Any]
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
elif False:
    DefenderForServersAwsOfferingMdeAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingMdeAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[Any] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        :param Any configuration: configuration for Microsoft Defender for Endpoint autoprovisioning
        :param pulumi.Input[bool] enabled: Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[Any]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersAwsOfferingSubPlanArgsDict(TypedDict):
        """
        configuration for the servers offering subPlan
        """
        type: NotRequired[pulumi.Input[Union[str, 'SubPlan']]]
        """
        The available sub plans
        """
elif False:
    DefenderForServersAwsOfferingSubPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingSubPlanArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'SubPlan']]] = None):
        """
        configuration for the servers offering subPlan
        :param pulumi.Input[Union[str, 'SubPlan']] type: The available sub plans
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'SubPlan']]]:
        """
        The available sub plans
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'SubPlan']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DefenderForServersAwsOfferingVaAutoProvisioningArgsDict(TypedDict):
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationArgsDict']]
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
elif False:
    DefenderForServersAwsOfferingVaAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingVaAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Vulnerability Assessment autoprovisioning configuration
        :param pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationArgs'] configuration: configuration for Vulnerability Assessment autoprovisioning
        :param pulumi.Input[bool] enabled: Is Vulnerability Assessment auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationArgs']]:
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersAwsOfferingVmScannersArgsDict(TypedDict):
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgsDict']]
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
elif False:
    DefenderForServersAwsOfferingVmScannersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingVmScannersArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs'] configuration: configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[bool] enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs']]:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingConfigurationConfigurationConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersAwsOfferingArgsDict(TypedDict):
        """
        The Defender for Servers AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForServersAws'.
        """
        arc_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersAwsOfferingArcAutoProvisioningArgsDict']]
        """
        The ARC autoprovisioning configuration
        """
        defender_for_servers: NotRequired[pulumi.Input['DefenderForServersAwsOfferingDefenderForServersArgsDict']]
        """
        The Defender for servers connection configuration
        """
        mde_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersAwsOfferingMdeAutoProvisioningArgsDict']]
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        sub_plan: NotRequired[pulumi.Input['DefenderForServersAwsOfferingSubPlanArgsDict']]
        """
        configuration for the servers offering subPlan
        """
        va_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersAwsOfferingVaAutoProvisioningArgsDict']]
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        vm_scanners: NotRequired[pulumi.Input['DefenderForServersAwsOfferingVmScannersArgsDict']]
        """
        The Microsoft Defender for Server VM scanning configuration
        """
elif False:
    DefenderForServersAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 arc_auto_provisioning: Optional[pulumi.Input['DefenderForServersAwsOfferingArcAutoProvisioningArgs']] = None,
                 defender_for_servers: Optional[pulumi.Input['DefenderForServersAwsOfferingDefenderForServersArgs']] = None,
                 mde_auto_provisioning: Optional[pulumi.Input['DefenderForServersAwsOfferingMdeAutoProvisioningArgs']] = None,
                 sub_plan: Optional[pulumi.Input['DefenderForServersAwsOfferingSubPlanArgs']] = None,
                 va_auto_provisioning: Optional[pulumi.Input['DefenderForServersAwsOfferingVaAutoProvisioningArgs']] = None,
                 vm_scanners: Optional[pulumi.Input['DefenderForServersAwsOfferingVmScannersArgs']] = None):
        """
        The Defender for Servers AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForServersAws'.
        :param pulumi.Input['DefenderForServersAwsOfferingArcAutoProvisioningArgs'] arc_auto_provisioning: The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderForServersAwsOfferingDefenderForServersArgs'] defender_for_servers: The Defender for servers connection configuration
        :param pulumi.Input['DefenderForServersAwsOfferingMdeAutoProvisioningArgs'] mde_auto_provisioning: The Microsoft Defender for Endpoint autoprovisioning configuration
        :param pulumi.Input['DefenderForServersAwsOfferingSubPlanArgs'] sub_plan: configuration for the servers offering subPlan
        :param pulumi.Input['DefenderForServersAwsOfferingVaAutoProvisioningArgs'] va_auto_provisioning: The Vulnerability Assessment autoprovisioning configuration
        :param pulumi.Input['DefenderForServersAwsOfferingVmScannersArgs'] vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        pulumi.set(__self__, "offering_type", 'DefenderForServersAws')
        if arc_auto_provisioning is not None:
            pulumi.set(__self__, "arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_servers is not None:
            pulumi.set(__self__, "defender_for_servers", defender_for_servers)
        if mde_auto_provisioning is not None:
            pulumi.set(__self__, "mde_auto_provisioning", mde_auto_provisioning)
        if sub_plan is not None:
            pulumi.set(__self__, "sub_plan", sub_plan)
        if va_auto_provisioning is not None:
            pulumi.set(__self__, "va_auto_provisioning", va_auto_provisioning)
        if vm_scanners is not None:
            pulumi.set(__self__, "vm_scanners", vm_scanners)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForServersAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingArcAutoProvisioningArgs']]:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @arc_auto_provisioning.setter
    def arc_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingArcAutoProvisioningArgs']]):
        pulumi.set(self, "arc_auto_provisioning", value)

    @property
    @pulumi.getter(name="defenderForServers")
    def defender_for_servers(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingDefenderForServersArgs']]:
        """
        The Defender for servers connection configuration
        """
        return pulumi.get(self, "defender_for_servers")

    @defender_for_servers.setter
    def defender_for_servers(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingDefenderForServersArgs']]):
        pulumi.set(self, "defender_for_servers", value)

    @property
    @pulumi.getter(name="mdeAutoProvisioning")
    def mde_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingMdeAutoProvisioningArgs']]:
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        return pulumi.get(self, "mde_auto_provisioning")

    @mde_auto_provisioning.setter
    def mde_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingMdeAutoProvisioningArgs']]):
        pulumi.set(self, "mde_auto_provisioning", value)

    @property
    @pulumi.getter(name="subPlan")
    def sub_plan(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingSubPlanArgs']]:
        """
        configuration for the servers offering subPlan
        """
        return pulumi.get(self, "sub_plan")

    @sub_plan.setter
    def sub_plan(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingSubPlanArgs']]):
        pulumi.set(self, "sub_plan", value)

    @property
    @pulumi.getter(name="vaAutoProvisioning")
    def va_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingVaAutoProvisioningArgs']]:
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        return pulumi.get(self, "va_auto_provisioning")

    @va_auto_provisioning.setter
    def va_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingVaAutoProvisioningArgs']]):
        pulumi.set(self, "va_auto_provisioning", value)

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional[pulumi.Input['DefenderForServersAwsOfferingVmScannersArgs']]:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")

    @vm_scanners.setter
    def vm_scanners(self, value: Optional[pulumi.Input['DefenderForServersAwsOfferingVmScannersArgs']]):
        pulumi.set(self, "vm_scanners", value)


if not MYPY:
    class DefenderForServersGcpOfferingArcAutoProvisioningArgsDict(TypedDict):
        """
        The ARC autoprovisioning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersGcpOfferingConfigurationArgsDict']]
        """
        Configuration for servers Arc auto provisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is arc auto provisioning enabled
        """
elif False:
    DefenderForServersGcpOfferingArcAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingArcAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingConfigurationArgs'] configuration: Configuration for servers Arc auto provisioning
        :param pulumi.Input[bool] enabled: Is arc auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationArgs']]:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgsDict(TypedDict):
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        exclusion_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        VM tags that indicate that VM should not be scanned
        """
        scanning_mode: NotRequired[pulumi.Input[Union[str, 'ScanningMode']]]
        """
        The scanning mode for the VM scan.
        """
elif False:
    DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs:
    def __init__(__self__, *,
                 exclusion_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 scanning_mode: Optional[pulumi.Input[Union[str, 'ScanningMode']]] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclusion_tags: VM tags that indicate that VM should not be scanned
        :param pulumi.Input[Union[str, 'ScanningMode']] scanning_mode: The scanning mode for the VM scan.
        """
        if exclusion_tags is not None:
            pulumi.set(__self__, "exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            pulumi.set(__self__, "scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        VM tags that indicate that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @exclusion_tags.setter
    def exclusion_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_tags", value)

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[pulumi.Input[Union[str, 'ScanningMode']]]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")

    @scanning_mode.setter
    def scanning_mode(self, value: Optional[pulumi.Input[Union[str, 'ScanningMode']]]):
        pulumi.set(self, "scanning_mode", value)


if not MYPY:
    class DefenderForServersGcpOfferingConfigurationConfigurationArgsDict(TypedDict):
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        type: NotRequired[pulumi.Input[Union[str, 'Type']]]
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
elif False:
    DefenderForServersGcpOfferingConfigurationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingConfigurationConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'Type']]] = None):
        """
        configuration for Vulnerability Assessment autoprovisioning
        :param pulumi.Input[Union[str, 'Type']] type: The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'Type']]]:
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'Type']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DefenderForServersGcpOfferingConfigurationArgsDict(TypedDict):
        """
        Configuration for servers Arc auto provisioning
        """
        private_link_scope: NotRequired[pulumi.Input[str]]
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        proxy: NotRequired[pulumi.Input[str]]
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
elif False:
    DefenderForServersGcpOfferingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingConfigurationArgs:
    def __init__(__self__, *,
                 private_link_scope: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None):
        """
        Configuration for servers Arc auto provisioning
        :param pulumi.Input[str] private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param pulumi.Input[str] proxy: Optional HTTP proxy endpoint to use for the Arc agent
        """
        if private_link_scope is not None:
            pulumi.set(__self__, "private_link_scope", private_link_scope)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @private_link_scope.setter
    def private_link_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_scope", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)


if not MYPY:
    class DefenderForServersGcpOfferingDefenderForServersArgsDict(TypedDict):
        """
        The Defender for servers connection configuration
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The service account email address in GCP for this feature
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The workload identity provider id in GCP for this feature
        """
elif False:
    DefenderForServersGcpOfferingDefenderForServersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingDefenderForServersArgs:
    def __init__(__self__, *,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The Defender for servers connection configuration
        :param pulumi.Input[str] service_account_email_address: The service account email address in GCP for this feature
        :param pulumi.Input[str] workload_identity_provider_id: The workload identity provider id in GCP for this feature
        """
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The service account email address in GCP for this feature
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The workload identity provider id in GCP for this feature
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class DefenderForServersGcpOfferingMdeAutoProvisioningArgsDict(TypedDict):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        configuration: NotRequired[Any]
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
elif False:
    DefenderForServersGcpOfferingMdeAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingMdeAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[Any] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        :param Any configuration: configuration for Microsoft Defender for Endpoint autoprovisioning
        :param pulumi.Input[bool] enabled: Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[Any]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersGcpOfferingSubPlanArgsDict(TypedDict):
        """
        configuration for the servers offering subPlan
        """
        type: NotRequired[pulumi.Input[Union[str, 'SubPlan']]]
        """
        The available sub plans
        """
elif False:
    DefenderForServersGcpOfferingSubPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingSubPlanArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'SubPlan']]] = None):
        """
        configuration for the servers offering subPlan
        :param pulumi.Input[Union[str, 'SubPlan']] type: The available sub plans
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'SubPlan']]]:
        """
        The available sub plans
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'SubPlan']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DefenderForServersGcpOfferingVaAutoProvisioningArgsDict(TypedDict):
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationArgsDict']]
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
elif False:
    DefenderForServersGcpOfferingVaAutoProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingVaAutoProvisioningArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Vulnerability Assessment autoprovisioning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationArgs'] configuration: configuration for Vulnerability Assessment autoprovisioning
        :param pulumi.Input[bool] enabled: Is Vulnerability Assessment auto provisioning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationArgs']]:
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersGcpOfferingVmScannersArgsDict(TypedDict):
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        configuration: NotRequired[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgsDict']]
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
elif False:
    DefenderForServersGcpOfferingVmScannersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingVmScannersArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs'] configuration: configuration for Microsoft Defender for Server VM scanning
        :param pulumi.Input[bool] enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs']]:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingConfigurationConfigurationConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DefenderForServersGcpOfferingArgsDict(TypedDict):
        """
        The Defender for Servers GCP offering configurations
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'DefenderForServersGcp'.
        """
        arc_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersGcpOfferingArcAutoProvisioningArgsDict']]
        """
        The ARC autoprovisioning configuration
        """
        defender_for_servers: NotRequired[pulumi.Input['DefenderForServersGcpOfferingDefenderForServersArgsDict']]
        """
        The Defender for servers connection configuration
        """
        mde_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersGcpOfferingMdeAutoProvisioningArgsDict']]
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        sub_plan: NotRequired[pulumi.Input['DefenderForServersGcpOfferingSubPlanArgsDict']]
        """
        configuration for the servers offering subPlan
        """
        va_auto_provisioning: NotRequired[pulumi.Input['DefenderForServersGcpOfferingVaAutoProvisioningArgsDict']]
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        vm_scanners: NotRequired[pulumi.Input['DefenderForServersGcpOfferingVmScannersArgsDict']]
        """
        The Microsoft Defender for Server VM scanning configuration
        """
elif False:
    DefenderForServersGcpOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForServersGcpOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 arc_auto_provisioning: Optional[pulumi.Input['DefenderForServersGcpOfferingArcAutoProvisioningArgs']] = None,
                 defender_for_servers: Optional[pulumi.Input['DefenderForServersGcpOfferingDefenderForServersArgs']] = None,
                 mde_auto_provisioning: Optional[pulumi.Input['DefenderForServersGcpOfferingMdeAutoProvisioningArgs']] = None,
                 sub_plan: Optional[pulumi.Input['DefenderForServersGcpOfferingSubPlanArgs']] = None,
                 va_auto_provisioning: Optional[pulumi.Input['DefenderForServersGcpOfferingVaAutoProvisioningArgs']] = None,
                 vm_scanners: Optional[pulumi.Input['DefenderForServersGcpOfferingVmScannersArgs']] = None):
        """
        The Defender for Servers GCP offering configurations
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'DefenderForServersGcp'.
        :param pulumi.Input['DefenderForServersGcpOfferingArcAutoProvisioningArgs'] arc_auto_provisioning: The ARC autoprovisioning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingDefenderForServersArgs'] defender_for_servers: The Defender for servers connection configuration
        :param pulumi.Input['DefenderForServersGcpOfferingMdeAutoProvisioningArgs'] mde_auto_provisioning: The Microsoft Defender for Endpoint autoprovisioning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingSubPlanArgs'] sub_plan: configuration for the servers offering subPlan
        :param pulumi.Input['DefenderForServersGcpOfferingVaAutoProvisioningArgs'] va_auto_provisioning: The Vulnerability Assessment autoprovisioning configuration
        :param pulumi.Input['DefenderForServersGcpOfferingVmScannersArgs'] vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        pulumi.set(__self__, "offering_type", 'DefenderForServersGcp')
        if arc_auto_provisioning is not None:
            pulumi.set(__self__, "arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_servers is not None:
            pulumi.set(__self__, "defender_for_servers", defender_for_servers)
        if mde_auto_provisioning is not None:
            pulumi.set(__self__, "mde_auto_provisioning", mde_auto_provisioning)
        if sub_plan is not None:
            pulumi.set(__self__, "sub_plan", sub_plan)
        if va_auto_provisioning is not None:
            pulumi.set(__self__, "va_auto_provisioning", va_auto_provisioning)
        if vm_scanners is not None:
            pulumi.set(__self__, "vm_scanners", vm_scanners)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'DefenderForServersGcp'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingArcAutoProvisioningArgs']]:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @arc_auto_provisioning.setter
    def arc_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingArcAutoProvisioningArgs']]):
        pulumi.set(self, "arc_auto_provisioning", value)

    @property
    @pulumi.getter(name="defenderForServers")
    def defender_for_servers(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingDefenderForServersArgs']]:
        """
        The Defender for servers connection configuration
        """
        return pulumi.get(self, "defender_for_servers")

    @defender_for_servers.setter
    def defender_for_servers(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingDefenderForServersArgs']]):
        pulumi.set(self, "defender_for_servers", value)

    @property
    @pulumi.getter(name="mdeAutoProvisioning")
    def mde_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingMdeAutoProvisioningArgs']]:
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        return pulumi.get(self, "mde_auto_provisioning")

    @mde_auto_provisioning.setter
    def mde_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingMdeAutoProvisioningArgs']]):
        pulumi.set(self, "mde_auto_provisioning", value)

    @property
    @pulumi.getter(name="subPlan")
    def sub_plan(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingSubPlanArgs']]:
        """
        configuration for the servers offering subPlan
        """
        return pulumi.get(self, "sub_plan")

    @sub_plan.setter
    def sub_plan(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingSubPlanArgs']]):
        pulumi.set(self, "sub_plan", value)

    @property
    @pulumi.getter(name="vaAutoProvisioning")
    def va_auto_provisioning(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingVaAutoProvisioningArgs']]:
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        return pulumi.get(self, "va_auto_provisioning")

    @va_auto_provisioning.setter
    def va_auto_provisioning(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingVaAutoProvisioningArgs']]):
        pulumi.set(self, "va_auto_provisioning", value)

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional[pulumi.Input['DefenderForServersGcpOfferingVmScannersArgs']]:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")

    @vm_scanners.setter
    def vm_scanners(self, value: Optional[pulumi.Input['DefenderForServersGcpOfferingVmScannersArgs']]):
        pulumi.set(self, "vm_scanners", value)


if not MYPY:
    class DefenderForStorageSettingPropertiesArgsDict(TypedDict):
        """
        Defender for Storage resource properties.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether Defender for Storage is enabled on this storage account.
        """
        malware_scanning: NotRequired[pulumi.Input['MalwareScanningPropertiesArgsDict']]
        """
        Properties of Malware Scanning.
        """
        override_subscription_level_settings: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the settings defined for this storage account should override the settings defined for the subscription.
        """
        sensitive_data_discovery: NotRequired[pulumi.Input['SensitiveDataDiscoveryPropertiesArgsDict']]
        """
        Properties of Sensitive Data Discovery.
        """
elif False:
    DefenderForStorageSettingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefenderForStorageSettingPropertiesArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 malware_scanning: Optional[pulumi.Input['MalwareScanningPropertiesArgs']] = None,
                 override_subscription_level_settings: Optional[pulumi.Input[bool]] = None,
                 sensitive_data_discovery: Optional[pulumi.Input['SensitiveDataDiscoveryPropertiesArgs']] = None):
        """
        Defender for Storage resource properties.
        :param pulumi.Input[bool] is_enabled: Indicates whether Defender for Storage is enabled on this storage account.
        :param pulumi.Input['MalwareScanningPropertiesArgs'] malware_scanning: Properties of Malware Scanning.
        :param pulumi.Input[bool] override_subscription_level_settings: Indicates whether the settings defined for this storage account should override the settings defined for the subscription.
        :param pulumi.Input['SensitiveDataDiscoveryPropertiesArgs'] sensitive_data_discovery: Properties of Sensitive Data Discovery.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if malware_scanning is not None:
            pulumi.set(__self__, "malware_scanning", malware_scanning)
        if override_subscription_level_settings is not None:
            pulumi.set(__self__, "override_subscription_level_settings", override_subscription_level_settings)
        if sensitive_data_discovery is not None:
            pulumi.set(__self__, "sensitive_data_discovery", sensitive_data_discovery)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Defender for Storage is enabled on this storage account.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="malwareScanning")
    def malware_scanning(self) -> Optional[pulumi.Input['MalwareScanningPropertiesArgs']]:
        """
        Properties of Malware Scanning.
        """
        return pulumi.get(self, "malware_scanning")

    @malware_scanning.setter
    def malware_scanning(self, value: Optional[pulumi.Input['MalwareScanningPropertiesArgs']]):
        pulumi.set(self, "malware_scanning", value)

    @property
    @pulumi.getter(name="overrideSubscriptionLevelSettings")
    def override_subscription_level_settings(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the settings defined for this storage account should override the settings defined for the subscription.
        """
        return pulumi.get(self, "override_subscription_level_settings")

    @override_subscription_level_settings.setter
    def override_subscription_level_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_subscription_level_settings", value)

    @property
    @pulumi.getter(name="sensitiveDataDiscovery")
    def sensitive_data_discovery(self) -> Optional[pulumi.Input['SensitiveDataDiscoveryPropertiesArgs']]:
        """
        Properties of Sensitive Data Discovery.
        """
        return pulumi.get(self, "sensitive_data_discovery")

    @sensitive_data_discovery.setter
    def sensitive_data_discovery(self, value: Optional[pulumi.Input['SensitiveDataDiscoveryPropertiesArgs']]):
        pulumi.set(self, "sensitive_data_discovery", value)


if not MYPY:
    class DenylistCustomAlertRuleArgsDict(TypedDict):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is denied.
        """
        denylist_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The values to deny. The format of the values depends on the rule type.
        """
        is_enabled: pulumi.Input[bool]
        """
        Status of the custom alert.
        """
        rule_type: pulumi.Input[str]
        """
        The type of the custom alert rule.
        Expected value is 'DenylistCustomAlertRule'.
        """
elif False:
    DenylistCustomAlertRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DenylistCustomAlertRuleArgs:
    def __init__(__self__, *,
                 denylist_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: pulumi.Input[bool],
                 rule_type: pulumi.Input[str]):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is denied.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] denylist_values: The values to deny. The format of the values depends on the rule type.
        :param pulumi.Input[bool] is_enabled: Status of the custom alert.
        :param pulumi.Input[str] rule_type: The type of the custom alert rule.
               Expected value is 'DenylistCustomAlertRule'.
        """
        pulumi.set(__self__, "denylist_values", denylist_values)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "rule_type", 'DenylistCustomAlertRule')

    @property
    @pulumi.getter(name="denylistValues")
    def denylist_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The values to deny. The format of the values depends on the rule type.
        """
        return pulumi.get(self, "denylist_values")

    @denylist_values.setter
    def denylist_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "denylist_values", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        The type of the custom alert rule.
        Expected value is 'DenylistCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)


if not MYPY:
    class DevOpsConfigurationPropertiesArgsDict(TypedDict):
        """
        DevOps Configuration properties.
        """
        authorization: NotRequired[pulumi.Input['AuthorizationArgsDict']]
        """
        Authorization payload.
        """
        auto_discovery: NotRequired[pulumi.Input[Union[str, 'AutoDiscovery']]]
        """
        AutoDiscovery states.
        """
        provisioning_state: NotRequired[pulumi.Input[Union[str, 'DevOpsProvisioningState']]]
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        top_level_inventory_list: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of top-level inventory to select when AutoDiscovery is disabled.
        This field is ignored when AutoDiscovery is enabled.
        """
elif False:
    DevOpsConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevOpsConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['AuthorizationArgs']] = None,
                 auto_discovery: Optional[pulumi.Input[Union[str, 'AutoDiscovery']]] = None,
                 provisioning_state: Optional[pulumi.Input[Union[str, 'DevOpsProvisioningState']]] = None,
                 top_level_inventory_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DevOps Configuration properties.
        :param pulumi.Input['AuthorizationArgs'] authorization: Authorization payload.
        :param pulumi.Input[Union[str, 'AutoDiscovery']] auto_discovery: AutoDiscovery states.
        :param pulumi.Input[Union[str, 'DevOpsProvisioningState']] provisioning_state: The provisioning state of the resource.
               
               Pending - Provisioning pending.
               Failed - Provisioning failed.
               Succeeded - Successful provisioning.
               Canceled - Provisioning canceled.
               PendingDeletion - Deletion pending.
               DeletionSuccess - Deletion successful.
               DeletionFailure - Deletion failure.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] top_level_inventory_list: List of top-level inventory to select when AutoDiscovery is disabled.
               This field is ignored when AutoDiscovery is enabled.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if auto_discovery is not None:
            pulumi.set(__self__, "auto_discovery", auto_discovery)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if top_level_inventory_list is not None:
            pulumi.set(__self__, "top_level_inventory_list", top_level_inventory_list)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['AuthorizationArgs']]:
        """
        Authorization payload.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['AuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="autoDiscovery")
    def auto_discovery(self) -> Optional[pulumi.Input[Union[str, 'AutoDiscovery']]]:
        """
        AutoDiscovery states.
        """
        return pulumi.get(self, "auto_discovery")

    @auto_discovery.setter
    def auto_discovery(self, value: Optional[pulumi.Input[Union[str, 'AutoDiscovery']]]):
        pulumi.set(self, "auto_discovery", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[Union[str, 'DevOpsProvisioningState']]]:
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[Union[str, 'DevOpsProvisioningState']]]):
        pulumi.set(self, "provisioning_state", value)

    @property
    @pulumi.getter(name="topLevelInventoryList")
    def top_level_inventory_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of top-level inventory to select when AutoDiscovery is disabled.
        This field is ignored when AutoDiscovery is enabled.
        """
        return pulumi.get(self, "top_level_inventory_list")

    @top_level_inventory_list.setter
    def top_level_inventory_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "top_level_inventory_list", value)


if not MYPY:
    class DevOpsPolicyAssignmentPropertiesArgsDict(TypedDict):
        """
        Properties of the DevOps policy assignment resource.
        """
        assigned_at: NotRequired[pulumi.Input[str]]
        """
        Gets or sets time when the assignment was created in UTC.
        """
        descendant_behavior: NotRequired[pulumi.Input[Union[str, 'DescendantBehavior']]]
        """
        The behavior of a policy on descendant resources.
        """
        policy: NotRequired[pulumi.Input['DevOpsPolicyDescriptorArgsDict']]
        """
        Condensed information to identify a DevOps Policy resource.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the Azure resource id.
        """
elif False:
    DevOpsPolicyAssignmentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevOpsPolicyAssignmentPropertiesArgs:
    def __init__(__self__, *,
                 assigned_at: Optional[pulumi.Input[str]] = None,
                 descendant_behavior: Optional[pulumi.Input[Union[str, 'DescendantBehavior']]] = None,
                 policy: Optional[pulumi.Input['DevOpsPolicyDescriptorArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Properties of the DevOps policy assignment resource.
        :param pulumi.Input[str] assigned_at: Gets or sets time when the assignment was created in UTC.
        :param pulumi.Input[Union[str, 'DescendantBehavior']] descendant_behavior: The behavior of a policy on descendant resources.
        :param pulumi.Input['DevOpsPolicyDescriptorArgs'] policy: Condensed information to identify a DevOps Policy resource.
        :param pulumi.Input[str] resource_id: Gets or sets the Azure resource id.
        """
        if assigned_at is not None:
            pulumi.set(__self__, "assigned_at", assigned_at)
        if descendant_behavior is not None:
            pulumi.set(__self__, "descendant_behavior", descendant_behavior)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="assignedAt")
    def assigned_at(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets time when the assignment was created in UTC.
        """
        return pulumi.get(self, "assigned_at")

    @assigned_at.setter
    def assigned_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assigned_at", value)

    @property
    @pulumi.getter(name="descendantBehavior")
    def descendant_behavior(self) -> Optional[pulumi.Input[Union[str, 'DescendantBehavior']]]:
        """
        The behavior of a policy on descendant resources.
        """
        return pulumi.get(self, "descendant_behavior")

    @descendant_behavior.setter
    def descendant_behavior(self, value: Optional[pulumi.Input[Union[str, 'DescendantBehavior']]]):
        pulumi.set(self, "descendant_behavior", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['DevOpsPolicyDescriptorArgs']]:
        """
        Condensed information to identify a DevOps Policy resource.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['DevOpsPolicyDescriptorArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the Azure resource id.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class DevOpsPolicyDescriptorArgsDict(TypedDict):
        """
        Condensed information to identify a DevOps Policy resource.
        """
        policy_id: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the policy GUID.
        """
        policy_name: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the policy name.
        """
        policy_type: NotRequired[pulumi.Input[Union[str, 'DevOpsPolicyType']]]
        """
        DevOps Policy resource types.
        """
        policy_version: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the version.
        """
elif False:
    DevOpsPolicyDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevOpsPolicyDescriptorArgs:
    def __init__(__self__, *,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 policy_name: Optional[pulumi.Input[str]] = None,
                 policy_type: Optional[pulumi.Input[Union[str, 'DevOpsPolicyType']]] = None,
                 policy_version: Optional[pulumi.Input[str]] = None):
        """
        Condensed information to identify a DevOps Policy resource.
        :param pulumi.Input[str] policy_id: Gets or sets the policy GUID.
        :param pulumi.Input[str] policy_name: Gets or sets the policy name.
        :param pulumi.Input[Union[str, 'DevOpsPolicyType']] policy_type: DevOps Policy resource types.
        :param pulumi.Input[str] policy_version: Gets or sets the version.
        """
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if policy_version is not None:
            pulumi.set(__self__, "policy_version", policy_version)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the policy GUID.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the policy name.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[pulumi.Input[Union[str, 'DevOpsPolicyType']]]:
        """
        DevOps Policy resource types.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: Optional[pulumi.Input[Union[str, 'DevOpsPolicyType']]]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the version.
        """
        return pulumi.get(self, "policy_version")

    @policy_version.setter
    def policy_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_version", value)


if not MYPY:
    class ExtensionArgsDict(TypedDict):
        """
        A plan's extension properties
        """
        is_enabled: pulumi.Input[Union[str, 'IsEnabled']]
        """
        Indicates whether the extension is enabled.
        """
        name: pulumi.Input[str]
        """
        The extension name. Supported values are: <br><br>**AgentlessDiscoveryForKubernetes** - API-based discovery of information about Kubernetes cluster architecture, workload objects, and setup. Required for Kubernetes inventory, identity and network exposure detection, attack path analysis and risk hunting as part of the cloud security explorer.
        Available for CloudPosture plan.<br><br>**OnUploadMalwareScanning** - Limits the GB to be scanned per month for each storage account within the subscription. Once this limit reached on a given storage account, Blobs won't be scanned during current calendar month.
        Available for StorageAccounts plan.<br><br>**SensitiveDataDiscovery** - Sensitive data discovery identifies Blob storage container with sensitive data such as credentials, credit cards, and more, to help prioritize and investigate security events.
        Available for StorageAccounts and CloudPosture plans.<br><br>**ContainerRegistriesVulnerabilityAssessments** - Provides vulnerability management for images stored in your container registries.
        Available for CloudPosture and Containers plans.
        """
        additional_extension_properties: NotRequired[Any]
        """
        Property values associated with the extension.
        """
elif False:
    ExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtensionArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[Union[str, 'IsEnabled']],
                 name: pulumi.Input[str],
                 additional_extension_properties: Optional[Any] = None):
        """
        A plan's extension properties
        :param pulumi.Input[Union[str, 'IsEnabled']] is_enabled: Indicates whether the extension is enabled.
        :param pulumi.Input[str] name: The extension name. Supported values are: <br><br>**AgentlessDiscoveryForKubernetes** - API-based discovery of information about Kubernetes cluster architecture, workload objects, and setup. Required for Kubernetes inventory, identity and network exposure detection, attack path analysis and risk hunting as part of the cloud security explorer.
               Available for CloudPosture plan.<br><br>**OnUploadMalwareScanning** - Limits the GB to be scanned per month for each storage account within the subscription. Once this limit reached on a given storage account, Blobs won't be scanned during current calendar month.
               Available for StorageAccounts plan.<br><br>**SensitiveDataDiscovery** - Sensitive data discovery identifies Blob storage container with sensitive data such as credentials, credit cards, and more, to help prioritize and investigate security events.
               Available for StorageAccounts and CloudPosture plans.<br><br>**ContainerRegistriesVulnerabilityAssessments** - Provides vulnerability management for images stored in your container registries.
               Available for CloudPosture and Containers plans.
        :param Any additional_extension_properties: Property values associated with the extension.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "name", name)
        if additional_extension_properties is not None:
            pulumi.set(__self__, "additional_extension_properties", additional_extension_properties)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[Union[str, 'IsEnabled']]:
        """
        Indicates whether the extension is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[Union[str, 'IsEnabled']]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The extension name. Supported values are: <br><br>**AgentlessDiscoveryForKubernetes** - API-based discovery of information about Kubernetes cluster architecture, workload objects, and setup. Required for Kubernetes inventory, identity and network exposure detection, attack path analysis and risk hunting as part of the cloud security explorer.
        Available for CloudPosture plan.<br><br>**OnUploadMalwareScanning** - Limits the GB to be scanned per month for each storage account within the subscription. Once this limit reached on a given storage account, Blobs won't be scanned during current calendar month.
        Available for StorageAccounts plan.<br><br>**SensitiveDataDiscovery** - Sensitive data discovery identifies Blob storage container with sensitive data such as credentials, credit cards, and more, to help prioritize and investigate security events.
        Available for StorageAccounts and CloudPosture plans.<br><br>**ContainerRegistriesVulnerabilityAssessments** - Provides vulnerability management for images stored in your container registries.
        Available for CloudPosture and Containers plans.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalExtensionProperties")
    def additional_extension_properties(self) -> Optional[Any]:
        """
        Property values associated with the extension.
        """
        return pulumi.get(self, "additional_extension_properties")

    @additional_extension_properties.setter
    def additional_extension_properties(self, value: Optional[Any]):
        pulumi.set(self, "additional_extension_properties", value)


if not MYPY:
    class GcpCredentialsDetailsPropertiesArgsDict(TypedDict):
        """
        GCP cloud account connector based service to service credentials, the credentials are composed of the organization ID and a JSON API key (write only)
        """
        auth_provider_x509_cert_url: pulumi.Input[str]
        """
        Auth provider x509 certificate URL field of the API key (write only)
        """
        auth_uri: pulumi.Input[str]
        """
        Auth URI field of the API key (write only)
        """
        authentication_type: pulumi.Input[str]
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'gcpCredentials'.
        """
        client_email: pulumi.Input[str]
        """
        Client email field of the API key (write only)
        """
        client_id: pulumi.Input[str]
        """
        Client ID field of the API key (write only)
        """
        client_x509_cert_url: pulumi.Input[str]
        """
        Client x509 certificate URL field of the API key (write only)
        """
        organization_id: pulumi.Input[str]
        """
        The organization ID of the GCP cloud account
        """
        private_key: pulumi.Input[str]
        """
        Private key field of the API key (write only)
        """
        private_key_id: pulumi.Input[str]
        """
        Private key ID field of the API key (write only)
        """
        project_id: pulumi.Input[str]
        """
        Project ID field of the API key (write only)
        """
        token_uri: pulumi.Input[str]
        """
        Token URI field of the API key (write only)
        """
        type: pulumi.Input[str]
        """
        Type field of the API key (write only)
        """
elif False:
    GcpCredentialsDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpCredentialsDetailsPropertiesArgs:
    def __init__(__self__, *,
                 auth_provider_x509_cert_url: pulumi.Input[str],
                 auth_uri: pulumi.Input[str],
                 authentication_type: pulumi.Input[str],
                 client_email: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_x509_cert_url: pulumi.Input[str],
                 organization_id: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 token_uri: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        GCP cloud account connector based service to service credentials, the credentials are composed of the organization ID and a JSON API key (write only)
        :param pulumi.Input[str] auth_provider_x509_cert_url: Auth provider x509 certificate URL field of the API key (write only)
        :param pulumi.Input[str] auth_uri: Auth URI field of the API key (write only)
        :param pulumi.Input[str] authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'gcpCredentials'.
        :param pulumi.Input[str] client_email: Client email field of the API key (write only)
        :param pulumi.Input[str] client_id: Client ID field of the API key (write only)
        :param pulumi.Input[str] client_x509_cert_url: Client x509 certificate URL field of the API key (write only)
        :param pulumi.Input[str] organization_id: The organization ID of the GCP cloud account
        :param pulumi.Input[str] private_key: Private key field of the API key (write only)
        :param pulumi.Input[str] private_key_id: Private key ID field of the API key (write only)
        :param pulumi.Input[str] project_id: Project ID field of the API key (write only)
        :param pulumi.Input[str] token_uri: Token URI field of the API key (write only)
        :param pulumi.Input[str] type: Type field of the API key (write only)
        """
        pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "authentication_type", 'gcpCredentials')
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        pulumi.set(__self__, "organization_id", organization_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "token_uri", token_uri)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> pulumi.Input[str]:
        """
        Auth provider x509 certificate URL field of the API key (write only)
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> pulumi.Input[str]:
        """
        Auth URI field of the API key (write only)
        """
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'gcpCredentials'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> pulumi.Input[str]:
        """
        Client email field of the API key (write only)
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID field of the API key (write only)
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> pulumi.Input[str]:
        """
        Client x509 certificate URL field of the API key (write only)
        """
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> pulumi.Input[str]:
        """
        The organization ID of the GCP cloud account
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_id", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key field of the API key (write only)
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        """
        Private key ID field of the API key (write only)
        """
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Project ID field of the API key (write only)
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> pulumi.Input[str]:
        """
        Token URI field of the API key (write only)
        """
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_uri", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type field of the API key (write only)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GcpOrganizationalDataMemberArgsDict(TypedDict):
        """
        The gcpOrganization data for the member account
        """
        organization_membership_type: pulumi.Input[str]
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        management_project_number: NotRequired[pulumi.Input[str]]
        """
        The GCP management project number from organizational onboarding
        """
        parent_hierarchy_id: NotRequired[pulumi.Input[str]]
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the project's parent
        """
elif False:
    GcpOrganizationalDataMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpOrganizationalDataMemberArgs:
    def __init__(__self__, *,
                 organization_membership_type: pulumi.Input[str],
                 management_project_number: Optional[pulumi.Input[str]] = None,
                 parent_hierarchy_id: Optional[pulumi.Input[str]] = None):
        """
        The gcpOrganization data for the member account
        :param pulumi.Input[str] organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Member'.
        :param pulumi.Input[str] management_project_number: The GCP management project number from organizational onboarding
        :param pulumi.Input[str] parent_hierarchy_id: If the multi cloud account is not of membership type organization, this will be the ID of the project's parent
        """
        pulumi.set(__self__, "organization_membership_type", 'Member')
        if management_project_number is not None:
            pulumi.set(__self__, "management_project_number", management_project_number)
        if parent_hierarchy_id is not None:
            pulumi.set(__self__, "parent_hierarchy_id", parent_hierarchy_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> pulumi.Input[str]:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        return pulumi.get(self, "organization_membership_type")

    @organization_membership_type.setter
    def organization_membership_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_membership_type", value)

    @property
    @pulumi.getter(name="managementProjectNumber")
    def management_project_number(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP management project number from organizational onboarding
        """
        return pulumi.get(self, "management_project_number")

    @management_project_number.setter
    def management_project_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_project_number", value)

    @property
    @pulumi.getter(name="parentHierarchyId")
    def parent_hierarchy_id(self) -> Optional[pulumi.Input[str]]:
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the project's parent
        """
        return pulumi.get(self, "parent_hierarchy_id")

    @parent_hierarchy_id.setter
    def parent_hierarchy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_hierarchy_id", value)


if not MYPY:
    class GcpOrganizationalDataOrganizationArgsDict(TypedDict):
        """
        The gcpOrganization data for the parent account
        """
        organization_membership_type: pulumi.Input[str]
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        excluded_project_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        service_account_email_address: NotRequired[pulumi.Input[str]]
        """
        The service account email address which represents the organization level permissions container.
        """
        workload_identity_provider_id: NotRequired[pulumi.Input[str]]
        """
        The GCP workload identity provider id which represents the permissions required to auto provision security connectors
        """
elif False:
    GcpOrganizationalDataOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpOrganizationalDataOrganizationArgs:
    def __init__(__self__, *,
                 organization_membership_type: pulumi.Input[str],
                 excluded_project_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_account_email_address: Optional[pulumi.Input[str]] = None,
                 workload_identity_provider_id: Optional[pulumi.Input[str]] = None):
        """
        The gcpOrganization data for the parent account
        :param pulumi.Input[str] organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Organization'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_project_numbers: If the multi cloud account is of membership type organization, list of accounts excluded from offering
        :param pulumi.Input[str] service_account_email_address: The service account email address which represents the organization level permissions container.
        :param pulumi.Input[str] workload_identity_provider_id: The GCP workload identity provider id which represents the permissions required to auto provision security connectors
        """
        pulumi.set(__self__, "organization_membership_type", 'Organization')
        if excluded_project_numbers is not None:
            pulumi.set(__self__, "excluded_project_numbers", excluded_project_numbers)
        if service_account_email_address is not None:
            pulumi.set(__self__, "service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> pulumi.Input[str]:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        return pulumi.get(self, "organization_membership_type")

    @organization_membership_type.setter
    def organization_membership_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization_membership_type", value)

    @property
    @pulumi.getter(name="excludedProjectNumbers")
    def excluded_project_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        return pulumi.get(self, "excluded_project_numbers")

    @excluded_project_numbers.setter
    def excluded_project_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_project_numbers", value)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The service account email address which represents the organization level permissions container.
        """
        return pulumi.get(self, "service_account_email_address")

    @service_account_email_address.setter
    def service_account_email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_email_address", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP workload identity provider id which represents the permissions required to auto provision security connectors
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class GcpProjectDetailsArgsDict(TypedDict):
        """
        The details about the project represented by the security connector
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The GCP Project id
        """
        project_number: NotRequired[pulumi.Input[str]]
        """
        The unique GCP Project number
        """
elif False:
    GcpProjectDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpProjectDetailsArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[str]] = None,
                 project_number: Optional[pulumi.Input[str]] = None):
        """
        The details about the project represented by the security connector
        :param pulumi.Input[str] project_id: The GCP Project id
        :param pulumi.Input[str] project_number: The unique GCP Project number
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_number is not None:
            pulumi.set(__self__, "project_number", project_number)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GCP Project id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> Optional[pulumi.Input[str]]:
        """
        The unique GCP Project number
        """
        return pulumi.get(self, "project_number")

    @project_number.setter
    def project_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_number", value)


if not MYPY:
    class GcpProjectEnvironmentDataArgsDict(TypedDict):
        """
        The GCP project connector environment data
        """
        environment_type: pulumi.Input[str]
        """
        The type of the environment data.
        Expected value is 'GcpProject'.
        """
        organizational_data: NotRequired[pulumi.Input[Union['GcpOrganizationalDataMemberArgsDict', 'GcpOrganizationalDataOrganizationArgsDict']]]
        """
        The Gcp project's organizational data
        """
        project_details: NotRequired[pulumi.Input['GcpProjectDetailsArgsDict']]
        """
        The Gcp project's details
        """
elif False:
    GcpProjectEnvironmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpProjectEnvironmentDataArgs:
    def __init__(__self__, *,
                 environment_type: pulumi.Input[str],
                 organizational_data: Optional[pulumi.Input[Union['GcpOrganizationalDataMemberArgs', 'GcpOrganizationalDataOrganizationArgs']]] = None,
                 project_details: Optional[pulumi.Input['GcpProjectDetailsArgs']] = None):
        """
        The GCP project connector environment data
        :param pulumi.Input[str] environment_type: The type of the environment data.
               Expected value is 'GcpProject'.
        :param pulumi.Input[Union['GcpOrganizationalDataMemberArgs', 'GcpOrganizationalDataOrganizationArgs']] organizational_data: The Gcp project's organizational data
        :param pulumi.Input['GcpProjectDetailsArgs'] project_details: The Gcp project's details
        """
        pulumi.set(__self__, "environment_type", 'GcpProject')
        if organizational_data is not None:
            pulumi.set(__self__, "organizational_data", organizational_data)
        if project_details is not None:
            pulumi.set(__self__, "project_details", project_details)

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> pulumi.Input[str]:
        """
        The type of the environment data.
        Expected value is 'GcpProject'.
        """
        return pulumi.get(self, "environment_type")

    @environment_type.setter
    def environment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_type", value)

    @property
    @pulumi.getter(name="organizationalData")
    def organizational_data(self) -> Optional[pulumi.Input[Union['GcpOrganizationalDataMemberArgs', 'GcpOrganizationalDataOrganizationArgs']]]:
        """
        The Gcp project's organizational data
        """
        return pulumi.get(self, "organizational_data")

    @organizational_data.setter
    def organizational_data(self, value: Optional[pulumi.Input[Union['GcpOrganizationalDataMemberArgs', 'GcpOrganizationalDataOrganizationArgs']]]):
        pulumi.set(self, "organizational_data", value)

    @property
    @pulumi.getter(name="projectDetails")
    def project_details(self) -> Optional[pulumi.Input['GcpProjectDetailsArgs']]:
        """
        The Gcp project's details
        """
        return pulumi.get(self, "project_details")

    @project_details.setter
    def project_details(self, value: Optional[pulumi.Input['GcpProjectDetailsArgs']]):
        pulumi.set(self, "project_details", value)


if not MYPY:
    class GithubScopeEnvironmentDataArgsDict(TypedDict):
        """
        The github scope connector's environment data
        """
        environment_type: pulumi.Input[str]
        """
        The type of the environment data.
        Expected value is 'GithubScope'.
        """
elif False:
    GithubScopeEnvironmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubScopeEnvironmentDataArgs:
    def __init__(__self__, *,
                 environment_type: pulumi.Input[str]):
        """
        The github scope connector's environment data
        :param pulumi.Input[str] environment_type: The type of the environment data.
               Expected value is 'GithubScope'.
        """
        pulumi.set(__self__, "environment_type", 'GithubScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> pulumi.Input[str]:
        """
        The type of the environment data.
        Expected value is 'GithubScope'.
        """
        return pulumi.get(self, "environment_type")

    @environment_type.setter
    def environment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_type", value)


if not MYPY:
    class GitlabScopeEnvironmentDataArgsDict(TypedDict):
        """
        The GitLab scope connector's environment data
        """
        environment_type: pulumi.Input[str]
        """
        The type of the environment data.
        Expected value is 'GitlabScope'.
        """
elif False:
    GitlabScopeEnvironmentDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitlabScopeEnvironmentDataArgs:
    def __init__(__self__, *,
                 environment_type: pulumi.Input[str]):
        """
        The GitLab scope connector's environment data
        :param pulumi.Input[str] environment_type: The type of the environment data.
               Expected value is 'GitlabScope'.
        """
        pulumi.set(__self__, "environment_type", 'GitlabScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> pulumi.Input[str]:
        """
        The type of the environment data.
        Expected value is 'GitlabScope'.
        """
        return pulumi.get(self, "environment_type")

    @environment_type.setter
    def environment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_type", value)


if not MYPY:
    class GovernanceAssignmentAdditionalDataArgsDict(TypedDict):
        """
        Describe the additional data of governance assignment - optional
        """
        ticket_link: NotRequired[pulumi.Input[str]]
        """
        Ticket link associated with this governance assignment - for example: https://snow.com
        """
        ticket_number: NotRequired[pulumi.Input[int]]
        """
        Ticket number associated with this governance assignment
        """
        ticket_status: NotRequired[pulumi.Input[str]]
        """
        The ticket status associated with this governance assignment - for example: Active
        """
elif False:
    GovernanceAssignmentAdditionalDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GovernanceAssignmentAdditionalDataArgs:
    def __init__(__self__, *,
                 ticket_link: Optional[pulumi.Input[str]] = None,
                 ticket_number: Optional[pulumi.Input[int]] = None,
                 ticket_status: Optional[pulumi.Input[str]] = None):
        """
        Describe the additional data of governance assignment - optional
        :param pulumi.Input[str] ticket_link: Ticket link associated with this governance assignment - for example: https://snow.com
        :param pulumi.Input[int] ticket_number: Ticket number associated with this governance assignment
        :param pulumi.Input[str] ticket_status: The ticket status associated with this governance assignment - for example: Active
        """
        if ticket_link is not None:
            pulumi.set(__self__, "ticket_link", ticket_link)
        if ticket_number is not None:
            pulumi.set(__self__, "ticket_number", ticket_number)
        if ticket_status is not None:
            pulumi.set(__self__, "ticket_status", ticket_status)

    @property
    @pulumi.getter(name="ticketLink")
    def ticket_link(self) -> Optional[pulumi.Input[str]]:
        """
        Ticket link associated with this governance assignment - for example: https://snow.com
        """
        return pulumi.get(self, "ticket_link")

    @ticket_link.setter
    def ticket_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ticket_link", value)

    @property
    @pulumi.getter(name="ticketNumber")
    def ticket_number(self) -> Optional[pulumi.Input[int]]:
        """
        Ticket number associated with this governance assignment
        """
        return pulumi.get(self, "ticket_number")

    @ticket_number.setter
    def ticket_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ticket_number", value)

    @property
    @pulumi.getter(name="ticketStatus")
    def ticket_status(self) -> Optional[pulumi.Input[str]]:
        """
        The ticket status associated with this governance assignment - for example: Active
        """
        return pulumi.get(self, "ticket_status")

    @ticket_status.setter
    def ticket_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ticket_status", value)


if not MYPY:
    class GovernanceEmailNotificationArgsDict(TypedDict):
        """
        The governance email weekly notification configuration.
        """
        disable_manager_email_notification: NotRequired[pulumi.Input[bool]]
        """
        Exclude manager from weekly email notification.
        """
        disable_owner_email_notification: NotRequired[pulumi.Input[bool]]
        """
        Exclude  owner from weekly email notification.
        """
elif False:
    GovernanceEmailNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GovernanceEmailNotificationArgs:
    def __init__(__self__, *,
                 disable_manager_email_notification: Optional[pulumi.Input[bool]] = None,
                 disable_owner_email_notification: Optional[pulumi.Input[bool]] = None):
        """
        The governance email weekly notification configuration.
        :param pulumi.Input[bool] disable_manager_email_notification: Exclude manager from weekly email notification.
        :param pulumi.Input[bool] disable_owner_email_notification: Exclude  owner from weekly email notification.
        """
        if disable_manager_email_notification is not None:
            pulumi.set(__self__, "disable_manager_email_notification", disable_manager_email_notification)
        if disable_owner_email_notification is not None:
            pulumi.set(__self__, "disable_owner_email_notification", disable_owner_email_notification)

    @property
    @pulumi.getter(name="disableManagerEmailNotification")
    def disable_manager_email_notification(self) -> Optional[pulumi.Input[bool]]:
        """
        Exclude manager from weekly email notification.
        """
        return pulumi.get(self, "disable_manager_email_notification")

    @disable_manager_email_notification.setter
    def disable_manager_email_notification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_manager_email_notification", value)

    @property
    @pulumi.getter(name="disableOwnerEmailNotification")
    def disable_owner_email_notification(self) -> Optional[pulumi.Input[bool]]:
        """
        Exclude  owner from weekly email notification.
        """
        return pulumi.get(self, "disable_owner_email_notification")

    @disable_owner_email_notification.setter
    def disable_owner_email_notification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_owner_email_notification", value)


if not MYPY:
    class GovernanceRuleEmailNotificationArgsDict(TypedDict):
        """
        The governance email weekly notification configuration
        """
        disable_manager_email_notification: NotRequired[pulumi.Input[bool]]
        """
        Defines whether manager email notifications are disabled
        """
        disable_owner_email_notification: NotRequired[pulumi.Input[bool]]
        """
        Defines whether owner email notifications are disabled
        """
elif False:
    GovernanceRuleEmailNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GovernanceRuleEmailNotificationArgs:
    def __init__(__self__, *,
                 disable_manager_email_notification: Optional[pulumi.Input[bool]] = None,
                 disable_owner_email_notification: Optional[pulumi.Input[bool]] = None):
        """
        The governance email weekly notification configuration
        :param pulumi.Input[bool] disable_manager_email_notification: Defines whether manager email notifications are disabled
        :param pulumi.Input[bool] disable_owner_email_notification: Defines whether owner email notifications are disabled
        """
        if disable_manager_email_notification is not None:
            pulumi.set(__self__, "disable_manager_email_notification", disable_manager_email_notification)
        if disable_owner_email_notification is not None:
            pulumi.set(__self__, "disable_owner_email_notification", disable_owner_email_notification)

    @property
    @pulumi.getter(name="disableManagerEmailNotification")
    def disable_manager_email_notification(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether manager email notifications are disabled
        """
        return pulumi.get(self, "disable_manager_email_notification")

    @disable_manager_email_notification.setter
    def disable_manager_email_notification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_manager_email_notification", value)

    @property
    @pulumi.getter(name="disableOwnerEmailNotification")
    def disable_owner_email_notification(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether owner email notifications are disabled
        """
        return pulumi.get(self, "disable_owner_email_notification")

    @disable_owner_email_notification.setter
    def disable_owner_email_notification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_owner_email_notification", value)


if not MYPY:
    class GovernanceRuleOwnerSourceArgsDict(TypedDict):
        """
        Describe the owner source of governance rule
        """
        type: NotRequired[pulumi.Input[Union[str, 'GovernanceRuleOwnerSourceType']]]
        """
        The owner type for the governance rule owner source
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The source value e.g. tag key like owner name or email address
        """
elif False:
    GovernanceRuleOwnerSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GovernanceRuleOwnerSourceArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'GovernanceRuleOwnerSourceType']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Describe the owner source of governance rule
        :param pulumi.Input[Union[str, 'GovernanceRuleOwnerSourceType']] type: The owner type for the governance rule owner source
        :param pulumi.Input[str] value: The source value e.g. tag key like owner name or email address
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'GovernanceRuleOwnerSourceType']]]:
        """
        The owner type for the governance rule owner source
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'GovernanceRuleOwnerSourceType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The source value e.g. tag key like owner name or email address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HybridComputeSettingsPropertiesArgsDict(TypedDict):
        """
        Settings for hybrid compute management
        """
        auto_provision: pulumi.Input[Union[str, 'AutoProvision']]
        """
        Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
        """
        proxy_server: NotRequired[pulumi.Input['ProxyServerPropertiesArgsDict']]
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The location where the metadata of machines will be stored
        """
        resource_group_name: NotRequired[pulumi.Input[str]]
        """
        The name of the resource group where Arc (Hybrid Compute) connectors are connected.
        """
        service_principal: NotRequired[pulumi.Input['ServicePrincipalPropertiesArgsDict']]
        """
        An object to access resources that are secured by an Azure AD tenant.
        """
elif False:
    HybridComputeSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HybridComputeSettingsPropertiesArgs:
    def __init__(__self__, *,
                 auto_provision: pulumi.Input[Union[str, 'AutoProvision']],
                 proxy_server: Optional[pulumi.Input['ProxyServerPropertiesArgs']] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 service_principal: Optional[pulumi.Input['ServicePrincipalPropertiesArgs']] = None):
        """
        Settings for hybrid compute management
        :param pulumi.Input[Union[str, 'AutoProvision']] auto_provision: Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
        :param pulumi.Input['ProxyServerPropertiesArgs'] proxy_server: For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        :param pulumi.Input[str] region: The location where the metadata of machines will be stored
        :param pulumi.Input[str] resource_group_name: The name of the resource group where Arc (Hybrid Compute) connectors are connected.
        :param pulumi.Input['ServicePrincipalPropertiesArgs'] service_principal: An object to access resources that are secured by an Azure AD tenant.
        """
        pulumi.set(__self__, "auto_provision", auto_provision)
        if proxy_server is not None:
            pulumi.set(__self__, "proxy_server", proxy_server)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if service_principal is not None:
            pulumi.set(__self__, "service_principal", service_principal)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> pulumi.Input[Union[str, 'AutoProvision']]:
        """
        Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
        """
        return pulumi.get(self, "auto_provision")

    @auto_provision.setter
    def auto_provision(self, value: pulumi.Input[Union[str, 'AutoProvision']]):
        pulumi.set(self, "auto_provision", value)

    @property
    @pulumi.getter(name="proxyServer")
    def proxy_server(self) -> Optional[pulumi.Input['ProxyServerPropertiesArgs']]:
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        """
        return pulumi.get(self, "proxy_server")

    @proxy_server.setter
    def proxy_server(self, value: Optional[pulumi.Input['ProxyServerPropertiesArgs']]):
        pulumi.set(self, "proxy_server", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The location where the metadata of machines will be stored
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the resource group where Arc (Hybrid Compute) connectors are connected.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional[pulumi.Input['ServicePrincipalPropertiesArgs']]:
        """
        An object to access resources that are secured by an Azure AD tenant.
        """
        return pulumi.get(self, "service_principal")

    @service_principal.setter
    def service_principal(self, value: Optional[pulumi.Input['ServicePrincipalPropertiesArgs']]):
        pulumi.set(self, "service_principal", value)


if not MYPY:
    class InformationProtectionAwsOfferingInformationProtectionArgsDict(TypedDict):
        """
        The native cloud connection configuration
        """
        cloud_role_arn: NotRequired[pulumi.Input[str]]
        """
        The cloud role ARN in AWS for this feature
        """
elif False:
    InformationProtectionAwsOfferingInformationProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InformationProtectionAwsOfferingInformationProtectionArgs:
    def __init__(__self__, *,
                 cloud_role_arn: Optional[pulumi.Input[str]] = None):
        """
        The native cloud connection configuration
        :param pulumi.Input[str] cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        if cloud_role_arn is not None:
            pulumi.set(__self__, "cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @cloud_role_arn.setter
    def cloud_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_role_arn", value)


if not MYPY:
    class InformationProtectionAwsOfferingArgsDict(TypedDict):
        """
        The information protection for AWS offering
        """
        offering_type: pulumi.Input[str]
        """
        The type of the security offering.
        Expected value is 'InformationProtectionAws'.
        """
        information_protection: NotRequired[pulumi.Input['InformationProtectionAwsOfferingInformationProtectionArgsDict']]
        """
        The native cloud connection configuration
        """
elif False:
    InformationProtectionAwsOfferingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InformationProtectionAwsOfferingArgs:
    def __init__(__self__, *,
                 offering_type: pulumi.Input[str],
                 information_protection: Optional[pulumi.Input['InformationProtectionAwsOfferingInformationProtectionArgs']] = None):
        """
        The information protection for AWS offering
        :param pulumi.Input[str] offering_type: The type of the security offering.
               Expected value is 'InformationProtectionAws'.
        :param pulumi.Input['InformationProtectionAwsOfferingInformationProtectionArgs'] information_protection: The native cloud connection configuration
        """
        pulumi.set(__self__, "offering_type", 'InformationProtectionAws')
        if information_protection is not None:
            pulumi.set(__self__, "information_protection", information_protection)

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> pulumi.Input[str]:
        """
        The type of the security offering.
        Expected value is 'InformationProtectionAws'.
        """
        return pulumi.get(self, "offering_type")

    @offering_type.setter
    def offering_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "offering_type", value)

    @property
    @pulumi.getter(name="informationProtection")
    def information_protection(self) -> Optional[pulumi.Input['InformationProtectionAwsOfferingInformationProtectionArgs']]:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "information_protection")

    @information_protection.setter
    def information_protection(self, value: Optional[pulumi.Input['InformationProtectionAwsOfferingInformationProtectionArgs']]):
        pulumi.set(self, "information_protection", value)


if not MYPY:
    class JitNetworkAccessPolicyVirtualMachineArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        ports: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessPortRuleArgsDict']]]
        """
        Port configurations for the virtual machine
        """
        public_ip_address: NotRequired[pulumi.Input[str]]
        """
        Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
elif False:
    JitNetworkAccessPolicyVirtualMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JitNetworkAccessPolicyVirtualMachineArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessPortRuleArgs']]],
                 public_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Resource ID of the virtual machine that is linked to this policy
        :param pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessPortRuleArgs']]] ports: Port configurations for the virtual machine
        :param pulumi.Input[str] public_ip_address: Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ports", ports)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessPortRuleArgs']]]:
        """
        Port configurations for the virtual machine
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessPortRuleArgs']]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class JitNetworkAccessPortRuleArgsDict(TypedDict):
        max_request_access_duration: pulumi.Input[str]
        """
        Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        """
        number: pulumi.Input[int]
        protocol: pulumi.Input[Union[str, 'Protocol']]
        allowed_source_address_prefix: NotRequired[pulumi.Input[str]]
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        allowed_source_address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
elif False:
    JitNetworkAccessPortRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JitNetworkAccessPortRuleArgs:
    def __init__(__self__, *,
                 max_request_access_duration: pulumi.Input[str],
                 number: pulumi.Input[int],
                 protocol: pulumi.Input[Union[str, 'Protocol']],
                 allowed_source_address_prefix: Optional[pulumi.Input[str]] = None,
                 allowed_source_address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] max_request_access_duration: Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        :param pulumi.Input[str] allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        pulumi.set(__self__, "max_request_access_duration", max_request_access_duration)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "protocol", protocol)
        if allowed_source_address_prefix is not None:
            pulumi.set(__self__, "allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            pulumi.set(__self__, "allowed_source_address_prefixes", allowed_source_address_prefixes)

    @property
    @pulumi.getter(name="maxRequestAccessDuration")
    def max_request_access_duration(self) -> pulumi.Input[str]:
        """
        Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        """
        return pulumi.get(self, "max_request_access_duration")

    @max_request_access_duration.setter
    def max_request_access_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_request_access_duration", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[int]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[int]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[Union[str, 'Protocol']]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[Union[str, 'Protocol']]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @allowed_source_address_prefix.setter
    def allowed_source_address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_source_address_prefix", value)

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")

    @allowed_source_address_prefixes.setter
    def allowed_source_address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_source_address_prefixes", value)


if not MYPY:
    class JitNetworkAccessRequestPortArgsDict(TypedDict):
        end_time_utc: pulumi.Input[str]
        """
        The date & time at which the request ends in UTC
        """
        number: pulumi.Input[int]
        status: pulumi.Input[Union[str, 'Status']]
        """
        The status of the port
        """
        status_reason: pulumi.Input[Union[str, 'StatusReason']]
        """
        A description of why the `status` has its value
        """
        allowed_source_address_prefix: NotRequired[pulumi.Input[str]]
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        allowed_source_address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        mapped_port: NotRequired[pulumi.Input[int]]
        """
        The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
elif False:
    JitNetworkAccessRequestPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JitNetworkAccessRequestPortArgs:
    def __init__(__self__, *,
                 end_time_utc: pulumi.Input[str],
                 number: pulumi.Input[int],
                 status: pulumi.Input[Union[str, 'Status']],
                 status_reason: pulumi.Input[Union[str, 'StatusReason']],
                 allowed_source_address_prefix: Optional[pulumi.Input[str]] = None,
                 allowed_source_address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mapped_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] end_time_utc: The date & time at which the request ends in UTC
        :param pulumi.Input[Union[str, 'Status']] status: The status of the port
        :param pulumi.Input[Union[str, 'StatusReason']] status_reason: A description of why the `status` has its value
        :param pulumi.Input[str] allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        :param pulumi.Input[int] mapped_port: The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        pulumi.set(__self__, "end_time_utc", end_time_utc)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        if allowed_source_address_prefix is not None:
            pulumi.set(__self__, "allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            pulumi.set(__self__, "allowed_source_address_prefixes", allowed_source_address_prefixes)
        if mapped_port is not None:
            pulumi.set(__self__, "mapped_port", mapped_port)

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> pulumi.Input[str]:
        """
        The date & time at which the request ends in UTC
        """
        return pulumi.get(self, "end_time_utc")

    @end_time_utc.setter
    def end_time_utc(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time_utc", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[int]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[int]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'Status']]:
        """
        The status of the port
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'Status']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> pulumi.Input[Union[str, 'StatusReason']]:
        """
        A description of why the `status` has its value
        """
        return pulumi.get(self, "status_reason")

    @status_reason.setter
    def status_reason(self, value: pulumi.Input[Union[str, 'StatusReason']]):
        pulumi.set(self, "status_reason", value)

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @allowed_source_address_prefix.setter
    def allowed_source_address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_source_address_prefix", value)

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")

    @allowed_source_address_prefixes.setter
    def allowed_source_address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_source_address_prefixes", value)

    @property
    @pulumi.getter(name="mappedPort")
    def mapped_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        return pulumi.get(self, "mapped_port")

    @mapped_port.setter
    def mapped_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mapped_port", value)


if not MYPY:
    class JitNetworkAccessRequestVirtualMachineArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        ports: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestPortArgsDict']]]
        """
        The ports that were opened for the virtual machine
        """
elif False:
    JitNetworkAccessRequestVirtualMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JitNetworkAccessRequestVirtualMachineArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestPortArgs']]]):
        """
        :param pulumi.Input[str] id: Resource ID of the virtual machine that is linked to this policy
        :param pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestPortArgs']]] ports: The ports that were opened for the virtual machine
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestPortArgs']]]:
        """
        The ports that were opened for the virtual machine
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestPortArgs']]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class JitNetworkAccessRequestArgsDict(TypedDict):
        requestor: pulumi.Input[str]
        """
        The identity of the person who made the request
        """
        start_time_utc: pulumi.Input[str]
        """
        The start time of the request in UTC
        """
        virtual_machines: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestVirtualMachineArgsDict']]]
        justification: NotRequired[pulumi.Input[str]]
        """
        The justification for making the initiate request
        """
elif False:
    JitNetworkAccessRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JitNetworkAccessRequestArgs:
    def __init__(__self__, *,
                 requestor: pulumi.Input[str],
                 start_time_utc: pulumi.Input[str],
                 virtual_machines: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestVirtualMachineArgs']]],
                 justification: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] requestor: The identity of the person who made the request
        :param pulumi.Input[str] start_time_utc: The start time of the request in UTC
        :param pulumi.Input[str] justification: The justification for making the initiate request
        """
        pulumi.set(__self__, "requestor", requestor)
        pulumi.set(__self__, "start_time_utc", start_time_utc)
        pulumi.set(__self__, "virtual_machines", virtual_machines)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)

    @property
    @pulumi.getter
    def requestor(self) -> pulumi.Input[str]:
        """
        The identity of the person who made the request
        """
        return pulumi.get(self, "requestor")

    @requestor.setter
    def requestor(self, value: pulumi.Input[str]):
        pulumi.set(self, "requestor", value)

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> pulumi.Input[str]:
        """
        The start time of the request in UTC
        """
        return pulumi.get(self, "start_time_utc")

    @start_time_utc.setter
    def start_time_utc(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time_utc", value)

    @property
    @pulumi.getter(name="virtualMachines")
    def virtual_machines(self) -> pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestVirtualMachineArgs']]]:
        return pulumi.get(self, "virtual_machines")

    @virtual_machines.setter
    def virtual_machines(self, value: pulumi.Input[Sequence[pulumi.Input['JitNetworkAccessRequestVirtualMachineArgs']]]):
        pulumi.set(self, "virtual_machines", value)

    @property
    @pulumi.getter
    def justification(self) -> Optional[pulumi.Input[str]]:
        """
        The justification for making the initiate request
        """
        return pulumi.get(self, "justification")

    @justification.setter
    def justification(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "justification", value)


if not MYPY:
    class MalwareScanningPropertiesArgsDict(TypedDict):
        """
        Properties of Malware Scanning.
        """
        on_upload: NotRequired[pulumi.Input['OnUploadPropertiesArgsDict']]
        """
        Properties of On Upload malware scanning.
        """
        scan_results_event_grid_topic_resource_id: NotRequired[pulumi.Input[str]]
        """
        Optional. Resource id of an Event Grid Topic to send scan results to.
        """
elif False:
    MalwareScanningPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MalwareScanningPropertiesArgs:
    def __init__(__self__, *,
                 on_upload: Optional[pulumi.Input['OnUploadPropertiesArgs']] = None,
                 scan_results_event_grid_topic_resource_id: Optional[pulumi.Input[str]] = None):
        """
        Properties of Malware Scanning.
        :param pulumi.Input['OnUploadPropertiesArgs'] on_upload: Properties of On Upload malware scanning.
        :param pulumi.Input[str] scan_results_event_grid_topic_resource_id: Optional. Resource id of an Event Grid Topic to send scan results to.
        """
        if on_upload is not None:
            pulumi.set(__self__, "on_upload", on_upload)
        if scan_results_event_grid_topic_resource_id is not None:
            pulumi.set(__self__, "scan_results_event_grid_topic_resource_id", scan_results_event_grid_topic_resource_id)

    @property
    @pulumi.getter(name="onUpload")
    def on_upload(self) -> Optional[pulumi.Input['OnUploadPropertiesArgs']]:
        """
        Properties of On Upload malware scanning.
        """
        return pulumi.get(self, "on_upload")

    @on_upload.setter
    def on_upload(self, value: Optional[pulumi.Input['OnUploadPropertiesArgs']]):
        pulumi.set(self, "on_upload", value)

    @property
    @pulumi.getter(name="scanResultsEventGridTopicResourceId")
    def scan_results_event_grid_topic_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Resource id of an Event Grid Topic to send scan results to.
        """
        return pulumi.get(self, "scan_results_event_grid_topic_resource_id")

    @scan_results_event_grid_topic_resource_id.setter
    def scan_results_event_grid_topic_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_results_event_grid_topic_resource_id", value)


if not MYPY:
    class OnPremiseResourceDetailsArgsDict(TypedDict):
        """
        Details of the On Premise resource that was assessed
        """
        machine_name: pulumi.Input[str]
        """
        The name of the machine
        """
        source: pulumi.Input[str]
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremise'.
        """
        source_computer_id: pulumi.Input[str]
        """
        The oms agent Id installed on the machine
        """
        vmuuid: pulumi.Input[str]
        """
        The unique Id of the machine
        """
        workspace_id: pulumi.Input[str]
        """
        Azure resource Id of the workspace the machine is attached to
        """
elif False:
    OnPremiseResourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnPremiseResourceDetailsArgs:
    def __init__(__self__, *,
                 machine_name: pulumi.Input[str],
                 source: pulumi.Input[str],
                 source_computer_id: pulumi.Input[str],
                 vmuuid: pulumi.Input[str],
                 workspace_id: pulumi.Input[str]):
        """
        Details of the On Premise resource that was assessed
        :param pulumi.Input[str] machine_name: The name of the machine
        :param pulumi.Input[str] source: The platform where the assessed resource resides
               Expected value is 'OnPremise'.
        :param pulumi.Input[str] source_computer_id: The oms agent Id installed on the machine
        :param pulumi.Input[str] vmuuid: The unique Id of the machine
        :param pulumi.Input[str] workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        pulumi.set(__self__, "machine_name", machine_name)
        pulumi.set(__self__, "source", 'OnPremise')
        pulumi.set(__self__, "source_computer_id", source_computer_id)
        pulumi.set(__self__, "vmuuid", vmuuid)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> pulumi.Input[str]:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @machine_name.setter
    def machine_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "machine_name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremise'.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> pulumi.Input[str]:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @source_computer_id.setter
    def source_computer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_computer_id", value)

    @property
    @pulumi.getter
    def vmuuid(self) -> pulumi.Input[str]:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @vmuuid.setter
    def vmuuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "vmuuid", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[str]:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class OnPremiseSqlResourceDetailsArgsDict(TypedDict):
        """
        Details of the On Premise Sql resource that was assessed
        """
        database_name: pulumi.Input[str]
        """
        The Sql database name installed on the machine
        """
        machine_name: pulumi.Input[str]
        """
        The name of the machine
        """
        server_name: pulumi.Input[str]
        """
        The Sql server name installed on the machine
        """
        source: pulumi.Input[str]
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremiseSql'.
        """
        source_computer_id: pulumi.Input[str]
        """
        The oms agent Id installed on the machine
        """
        vmuuid: pulumi.Input[str]
        """
        The unique Id of the machine
        """
        workspace_id: pulumi.Input[str]
        """
        Azure resource Id of the workspace the machine is attached to
        """
elif False:
    OnPremiseSqlResourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnPremiseSqlResourceDetailsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 machine_name: pulumi.Input[str],
                 server_name: pulumi.Input[str],
                 source: pulumi.Input[str],
                 source_computer_id: pulumi.Input[str],
                 vmuuid: pulumi.Input[str],
                 workspace_id: pulumi.Input[str]):
        """
        Details of the On Premise Sql resource that was assessed
        :param pulumi.Input[str] database_name: The Sql database name installed on the machine
        :param pulumi.Input[str] machine_name: The name of the machine
        :param pulumi.Input[str] server_name: The Sql server name installed on the machine
        :param pulumi.Input[str] source: The platform where the assessed resource resides
               Expected value is 'OnPremiseSql'.
        :param pulumi.Input[str] source_computer_id: The oms agent Id installed on the machine
        :param pulumi.Input[str] vmuuid: The unique Id of the machine
        :param pulumi.Input[str] workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "machine_name", machine_name)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "source", 'OnPremiseSql')
        pulumi.set(__self__, "source_computer_id", source_computer_id)
        pulumi.set(__self__, "vmuuid", vmuuid)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The Sql database name installed on the machine
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> pulumi.Input[str]:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @machine_name.setter
    def machine_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "machine_name", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> pulumi.Input[str]:
        """
        The Sql server name installed on the machine
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremiseSql'.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> pulumi.Input[str]:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @source_computer_id.setter
    def source_computer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_computer_id", value)

    @property
    @pulumi.getter
    def vmuuid(self) -> pulumi.Input[str]:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @vmuuid.setter
    def vmuuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "vmuuid", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[str]:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class OnUploadPropertiesArgsDict(TypedDict):
        """
        Properties of On Upload malware scanning.
        """
        cap_gb_per_month: NotRequired[pulumi.Input[int]]
        """
        Defines the max GB to be scanned per Month. Set to -1 if no capping is needed.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether On Upload malware scanning should be enabled.
        """
elif False:
    OnUploadPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnUploadPropertiesArgs:
    def __init__(__self__, *,
                 cap_gb_per_month: Optional[pulumi.Input[int]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Properties of On Upload malware scanning.
        :param pulumi.Input[int] cap_gb_per_month: Defines the max GB to be scanned per Month. Set to -1 if no capping is needed.
        :param pulumi.Input[bool] is_enabled: Indicates whether On Upload malware scanning should be enabled.
        """
        if cap_gb_per_month is not None:
            pulumi.set(__self__, "cap_gb_per_month", cap_gb_per_month)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="capGBPerMonth")
    def cap_gb_per_month(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the max GB to be scanned per Month. Set to -1 if no capping is needed.
        """
        return pulumi.get(self, "cap_gb_per_month")

    @cap_gb_per_month.setter
    def cap_gb_per_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cap_gb_per_month", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether On Upload malware scanning should be enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class PartialAssessmentPropertiesArgsDict(TypedDict):
        """
        Describes properties of an assessment as related to the standard
        """
        assessment_key: NotRequired[pulumi.Input[str]]
        """
        The assessment key
        """
elif False:
    PartialAssessmentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartialAssessmentPropertiesArgs:
    def __init__(__self__, *,
                 assessment_key: Optional[pulumi.Input[str]] = None):
        """
        Describes properties of an assessment as related to the standard
        :param pulumi.Input[str] assessment_key: The assessment key
        """
        if assessment_key is not None:
            pulumi.set(__self__, "assessment_key", assessment_key)

    @property
    @pulumi.getter(name="assessmentKey")
    def assessment_key(self) -> Optional[pulumi.Input[str]]:
        """
        The assessment key
        """
        return pulumi.get(self, "assessment_key")

    @assessment_key.setter
    def assessment_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assessment_key", value)


if not MYPY:
    class ProxyServerPropertiesArgsDict(TypedDict):
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        Proxy server IP
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Proxy server port
        """
elif False:
    ProxyServerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProxyServerPropertiesArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        :param pulumi.Input[str] ip: Proxy server IP
        :param pulumi.Input[str] port: Proxy server port
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy server IP
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RecommendationConfigurationPropertiesArgsDict(TypedDict):
        """
        The type of IoT Security recommendation.
        """
        recommendation_type: pulumi.Input[Union[str, 'RecommendationType']]
        """
        The type of IoT Security recommendation.
        """
        status: pulumi.Input[Union[str, 'RecommendationConfigStatus']]
        """
        Recommendation status. When the recommendation status is disabled recommendations are not generated.
        """
elif False:
    RecommendationConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 recommendation_type: pulumi.Input[Union[str, 'RecommendationType']],
                 status: Optional[pulumi.Input[Union[str, 'RecommendationConfigStatus']]] = None):
        """
        The type of IoT Security recommendation.
        :param pulumi.Input[Union[str, 'RecommendationType']] recommendation_type: The type of IoT Security recommendation.
        :param pulumi.Input[Union[str, 'RecommendationConfigStatus']] status: Recommendation status. When the recommendation status is disabled recommendations are not generated.
        """
        pulumi.set(__self__, "recommendation_type", recommendation_type)
        if status is None:
            status = 'Enabled'
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="recommendationType")
    def recommendation_type(self) -> pulumi.Input[Union[str, 'RecommendationType']]:
        """
        The type of IoT Security recommendation.
        """
        return pulumi.get(self, "recommendation_type")

    @recommendation_type.setter
    def recommendation_type(self, value: pulumi.Input[Union[str, 'RecommendationType']]):
        pulumi.set(self, "recommendation_type", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'RecommendationConfigStatus']]:
        """
        Recommendation status. When the recommendation status is disabled recommendations are not generated.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'RecommendationConfigStatus']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RemediationEtaArgsDict(TypedDict):
        """
        The ETA (estimated time of arrival) for remediation
        """
        eta: pulumi.Input[str]
        """
        ETA for remediation.
        """
        justification: pulumi.Input[str]
        """
        Justification for change of Eta.
        """
elif False:
    RemediationEtaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationEtaArgs:
    def __init__(__self__, *,
                 eta: pulumi.Input[str],
                 justification: pulumi.Input[str]):
        """
        The ETA (estimated time of arrival) for remediation
        :param pulumi.Input[str] eta: ETA for remediation.
        :param pulumi.Input[str] justification: Justification for change of Eta.
        """
        pulumi.set(__self__, "eta", eta)
        pulumi.set(__self__, "justification", justification)

    @property
    @pulumi.getter
    def eta(self) -> pulumi.Input[str]:
        """
        ETA for remediation.
        """
        return pulumi.get(self, "eta")

    @eta.setter
    def eta(self, value: pulumi.Input[str]):
        pulumi.set(self, "eta", value)

    @property
    @pulumi.getter
    def justification(self) -> pulumi.Input[str]:
        """
        Justification for change of Eta.
        """
        return pulumi.get(self, "justification")

    @justification.setter
    def justification(self, value: pulumi.Input[str]):
        pulumi.set(self, "justification", value)


if not MYPY:
    class ScopeElementArgsDict(TypedDict):
        """
        A more specific scope used to identify the alerts to suppress.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        The alert entity type to suppress by.
        """
elif False:
    ScopeElementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeElementArgs:
    def __init__(__self__, *,
                 field: Optional[pulumi.Input[str]] = None):
        """
        A more specific scope used to identify the alerts to suppress.
        :param pulumi.Input[str] field: The alert entity type to suppress by.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The alert entity type to suppress by.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class SecurityAssessmentMetadataPartnerDataArgsDict(TypedDict):
        """
        Describes the partner that created the assessment
        """
        partner_name: pulumi.Input[str]
        """
        Name of the company of the partner
        """
        secret: pulumi.Input[str]
        """
        Secret to authenticate the partner and verify it created the assessment - write only
        """
        product_name: NotRequired[pulumi.Input[str]]
        """
        Name of the product of the partner that created the assessment
        """
elif False:
    SecurityAssessmentMetadataPartnerDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentMetadataPartnerDataArgs:
    def __init__(__self__, *,
                 partner_name: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 product_name: Optional[pulumi.Input[str]] = None):
        """
        Describes the partner that created the assessment
        :param pulumi.Input[str] partner_name: Name of the company of the partner
        :param pulumi.Input[str] secret: Secret to authenticate the partner and verify it created the assessment - write only
        :param pulumi.Input[str] product_name: Name of the product of the partner that created the assessment
        """
        pulumi.set(__self__, "partner_name", partner_name)
        pulumi.set(__self__, "secret", secret)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> pulumi.Input[str]:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @partner_name.setter
    def partner_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "partner_name", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        Secret to authenticate the partner and verify it created the assessment - write only
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the product of the partner that created the assessment
        """
        return pulumi.get(self, "product_name")

    @product_name.setter
    def product_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product_name", value)


if not MYPY:
    class SecurityAssessmentMetadataPropertiesResponsePublishDatesArgsDict(TypedDict):
        public: pulumi.Input[str]
        g_a: NotRequired[pulumi.Input[str]]
elif False:
    SecurityAssessmentMetadataPropertiesResponsePublishDatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentMetadataPropertiesResponsePublishDatesArgs:
    def __init__(__self__, *,
                 public: pulumi.Input[str],
                 g_a: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "public", public)
        if g_a is not None:
            pulumi.set(__self__, "g_a", g_a)

    @property
    @pulumi.getter
    def public(self) -> pulumi.Input[str]:
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: pulumi.Input[str]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter(name="gA")
    def g_a(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "g_a")

    @g_a.setter
    def g_a(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "g_a", value)


if not MYPY:
    class SecurityAssessmentMetadataPropertiesArgsDict(TypedDict):
        """
        Describes properties of an assessment metadata.
        """
        assessment_type: pulumi.Input[Union[str, 'AssessmentType']]
        """
        BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        """
        display_name: pulumi.Input[str]
        """
        User friendly display name of the assessment
        """
        severity: pulumi.Input[Union[str, 'Severity']]
        """
        The severity level of the assessment
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Categories']]]]]
        description: NotRequired[pulumi.Input[str]]
        """
        Human readable description of the assessment
        """
        implementation_effort: NotRequired[pulumi.Input[Union[str, 'ImplementationEffort']]]
        """
        The implementation effort required to remediate this assessment
        """
        partner_data: NotRequired[pulumi.Input['SecurityAssessmentMetadataPartnerDataArgsDict']]
        """
        Describes the partner that created the assessment
        """
        preview: NotRequired[pulumi.Input[bool]]
        """
        True if this assessment is in preview release status
        """
        remediation_description: NotRequired[pulumi.Input[str]]
        """
        Human readable description of what you should do to mitigate this security issue
        """
        threats: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Threats']]]]]
        user_impact: NotRequired[pulumi.Input[Union[str, 'UserImpact']]]
        """
        The user impact of the assessment
        """
elif False:
    SecurityAssessmentMetadataPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentMetadataPropertiesArgs:
    def __init__(__self__, *,
                 assessment_type: pulumi.Input[Union[str, 'AssessmentType']],
                 display_name: pulumi.Input[str],
                 severity: pulumi.Input[Union[str, 'Severity']],
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Categories']]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 implementation_effort: Optional[pulumi.Input[Union[str, 'ImplementationEffort']]] = None,
                 partner_data: Optional[pulumi.Input['SecurityAssessmentMetadataPartnerDataArgs']] = None,
                 preview: Optional[pulumi.Input[bool]] = None,
                 remediation_description: Optional[pulumi.Input[str]] = None,
                 threats: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Threats']]]]] = None,
                 user_impact: Optional[pulumi.Input[Union[str, 'UserImpact']]] = None):
        """
        Describes properties of an assessment metadata.
        :param pulumi.Input[Union[str, 'AssessmentType']] assessment_type: BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        :param pulumi.Input[str] display_name: User friendly display name of the assessment
        :param pulumi.Input[Union[str, 'Severity']] severity: The severity level of the assessment
        :param pulumi.Input[str] description: Human readable description of the assessment
        :param pulumi.Input[Union[str, 'ImplementationEffort']] implementation_effort: The implementation effort required to remediate this assessment
        :param pulumi.Input['SecurityAssessmentMetadataPartnerDataArgs'] partner_data: Describes the partner that created the assessment
        :param pulumi.Input[bool] preview: True if this assessment is in preview release status
        :param pulumi.Input[str] remediation_description: Human readable description of what you should do to mitigate this security issue
        :param pulumi.Input[Union[str, 'UserImpact']] user_impact: The user impact of the assessment
        """
        pulumi.set(__self__, "assessment_type", assessment_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "severity", severity)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if implementation_effort is not None:
            pulumi.set(__self__, "implementation_effort", implementation_effort)
        if partner_data is not None:
            pulumi.set(__self__, "partner_data", partner_data)
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if remediation_description is not None:
            pulumi.set(__self__, "remediation_description", remediation_description)
        if threats is not None:
            pulumi.set(__self__, "threats", threats)
        if user_impact is not None:
            pulumi.set(__self__, "user_impact", user_impact)

    @property
    @pulumi.getter(name="assessmentType")
    def assessment_type(self) -> pulumi.Input[Union[str, 'AssessmentType']]:
        """
        BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        """
        return pulumi.get(self, "assessment_type")

    @assessment_type.setter
    def assessment_type(self, value: pulumi.Input[Union[str, 'AssessmentType']]):
        pulumi.set(self, "assessment_type", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        User friendly display name of the assessment
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[Union[str, 'Severity']]:
        """
        The severity level of the assessment
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[Union[str, 'Severity']]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Categories']]]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Categories']]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable description of the assessment
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="implementationEffort")
    def implementation_effort(self) -> Optional[pulumi.Input[Union[str, 'ImplementationEffort']]]:
        """
        The implementation effort required to remediate this assessment
        """
        return pulumi.get(self, "implementation_effort")

    @implementation_effort.setter
    def implementation_effort(self, value: Optional[pulumi.Input[Union[str, 'ImplementationEffort']]]):
        pulumi.set(self, "implementation_effort", value)

    @property
    @pulumi.getter(name="partnerData")
    def partner_data(self) -> Optional[pulumi.Input['SecurityAssessmentMetadataPartnerDataArgs']]:
        """
        Describes the partner that created the assessment
        """
        return pulumi.get(self, "partner_data")

    @partner_data.setter
    def partner_data(self, value: Optional[pulumi.Input['SecurityAssessmentMetadataPartnerDataArgs']]):
        pulumi.set(self, "partner_data", value)

    @property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input[bool]]:
        """
        True if this assessment is in preview release status
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preview", value)

    @property
    @pulumi.getter(name="remediationDescription")
    def remediation_description(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable description of what you should do to mitigate this security issue
        """
        return pulumi.get(self, "remediation_description")

    @remediation_description.setter
    def remediation_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remediation_description", value)

    @property
    @pulumi.getter
    def threats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Threats']]]]]:
        return pulumi.get(self, "threats")

    @threats.setter
    def threats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Threats']]]]]):
        pulumi.set(self, "threats", value)

    @property
    @pulumi.getter(name="userImpact")
    def user_impact(self) -> Optional[pulumi.Input[Union[str, 'UserImpact']]]:
        """
        The user impact of the assessment
        """
        return pulumi.get(self, "user_impact")

    @user_impact.setter
    def user_impact(self, value: Optional[pulumi.Input[Union[str, 'UserImpact']]]):
        pulumi.set(self, "user_impact", value)


if not MYPY:
    class SecurityAssessmentPartnerDataArgsDict(TypedDict):
        """
        Data regarding 3rd party partner integration
        """
        partner_name: pulumi.Input[str]
        """
        Name of the company of the partner
        """
        secret: pulumi.Input[str]
        """
        secret to authenticate the partner - write only
        """
elif False:
    SecurityAssessmentPartnerDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityAssessmentPartnerDataArgs:
    def __init__(__self__, *,
                 partner_name: pulumi.Input[str],
                 secret: pulumi.Input[str]):
        """
        Data regarding 3rd party partner integration
        :param pulumi.Input[str] partner_name: Name of the company of the partner
        :param pulumi.Input[str] secret: secret to authenticate the partner - write only
        """
        pulumi.set(__self__, "partner_name", partner_name)
        pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> pulumi.Input[str]:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @partner_name.setter
    def partner_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "partner_name", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret to authenticate the partner - write only
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SecurityContactPropertiesAlertNotificationsArgsDict(TypedDict):
        """
        Defines whether to send email notifications about new security alerts
        """
        minimal_severity: NotRequired[pulumi.Input[Union[str, 'MinimalSeverity']]]
        """
        Defines the minimal alert severity which will be sent as email notifications
        """
        state: NotRequired[pulumi.Input[Union[str, 'State']]]
        """
        Defines if email notifications will be sent about new security alerts
        """
elif False:
    SecurityContactPropertiesAlertNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityContactPropertiesAlertNotificationsArgs:
    def __init__(__self__, *,
                 minimal_severity: Optional[pulumi.Input[Union[str, 'MinimalSeverity']]] = None,
                 state: Optional[pulumi.Input[Union[str, 'State']]] = None):
        """
        Defines whether to send email notifications about new security alerts
        :param pulumi.Input[Union[str, 'MinimalSeverity']] minimal_severity: Defines the minimal alert severity which will be sent as email notifications
        :param pulumi.Input[Union[str, 'State']] state: Defines if email notifications will be sent about new security alerts
        """
        if minimal_severity is not None:
            pulumi.set(__self__, "minimal_severity", minimal_severity)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="minimalSeverity")
    def minimal_severity(self) -> Optional[pulumi.Input[Union[str, 'MinimalSeverity']]]:
        """
        Defines the minimal alert severity which will be sent as email notifications
        """
        return pulumi.get(self, "minimal_severity")

    @minimal_severity.setter
    def minimal_severity(self, value: Optional[pulumi.Input[Union[str, 'MinimalSeverity']]]):
        pulumi.set(self, "minimal_severity", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'State']]]:
        """
        Defines if email notifications will be sent about new security alerts
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'State']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SecurityContactPropertiesNotificationsByRoleArgsDict(TypedDict):
        """
        Defines whether to send email notifications from Microsoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Roles']]]]]
        """
        Defines which RBAC roles will get email notifications from Microsoft Defender for Cloud. List of allowed RBAC roles: 
        """
        state: NotRequired[pulumi.Input[Union[str, 'State']]]
        """
        Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
elif False:
    SecurityContactPropertiesNotificationsByRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityContactPropertiesNotificationsByRoleArgs:
    def __init__(__self__, *,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Roles']]]]] = None,
                 state: Optional[pulumi.Input[Union[str, 'State']]] = None):
        """
        Defines whether to send email notifications from Microsoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Roles']]]] roles: Defines which RBAC roles will get email notifications from Microsoft Defender for Cloud. List of allowed RBAC roles: 
        :param pulumi.Input[Union[str, 'State']] state: Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Roles']]]]]:
        """
        Defines which RBAC roles will get email notifications from Microsoft Defender for Cloud. List of allowed RBAC roles: 
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Roles']]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'State']]]:
        """
        Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'State']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SensitiveDataDiscoveryPropertiesArgsDict(TypedDict):
        """
        Properties of Sensitive Data Discovery.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether Sensitive Data Discovery should be enabled.
        """
elif False:
    SensitiveDataDiscoveryPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SensitiveDataDiscoveryPropertiesArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Properties of Sensitive Data Discovery.
        :param pulumi.Input[bool] is_enabled: Indicates whether Sensitive Data Discovery should be enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Sensitive Data Discovery should be enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ServicePrincipalPropertiesArgsDict(TypedDict):
        """
        Details of the service principal.
        """
        application_id: NotRequired[pulumi.Input[str]]
        """
        Application ID of service principal.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        A secret string that the application uses to prove its identity, also can be referred to as application password (write only).
        """
elif False:
    ServicePrincipalPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePrincipalPropertiesArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        Details of the service principal.
        :param pulumi.Input[str] application_id: Application ID of service principal.
        :param pulumi.Input[str] secret: A secret string that the application uses to prove its identity, also can be referred to as application password (write only).
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        Application ID of service principal.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        A secret string that the application uses to prove its identity, also can be referred to as application password (write only).
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class StandardAssignmentPropertiesAttestationDataArgsDict(TypedDict):
        """
        Additional data about assignment that has Attest effect
        """
        assigned_assessment: NotRequired[pulumi.Input['AssignedAssessmentItemArgsDict']]
        """
        Component item with key as applied to this standard assignment over the given scope
        """
        compliance_state: NotRequired[pulumi.Input[Union[str, 'AttestationComplianceState']]]
        """
        Attest category of this assignment
        """
        evidence: NotRequired[pulumi.Input[Sequence[pulumi.Input['AttestationEvidenceArgsDict']]]]
        """
        Array of links to attestation evidence
        """
elif False:
    StandardAssignmentPropertiesAttestationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StandardAssignmentPropertiesAttestationDataArgs:
    def __init__(__self__, *,
                 assigned_assessment: Optional[pulumi.Input['AssignedAssessmentItemArgs']] = None,
                 compliance_state: Optional[pulumi.Input[Union[str, 'AttestationComplianceState']]] = None,
                 evidence: Optional[pulumi.Input[Sequence[pulumi.Input['AttestationEvidenceArgs']]]] = None):
        """
        Additional data about assignment that has Attest effect
        :param pulumi.Input['AssignedAssessmentItemArgs'] assigned_assessment: Component item with key as applied to this standard assignment over the given scope
        :param pulumi.Input[Union[str, 'AttestationComplianceState']] compliance_state: Attest category of this assignment
        :param pulumi.Input[Sequence[pulumi.Input['AttestationEvidenceArgs']]] evidence: Array of links to attestation evidence
        """
        if assigned_assessment is not None:
            pulumi.set(__self__, "assigned_assessment", assigned_assessment)
        if compliance_state is not None:
            pulumi.set(__self__, "compliance_state", compliance_state)
        if evidence is not None:
            pulumi.set(__self__, "evidence", evidence)

    @property
    @pulumi.getter(name="assignedAssessment")
    def assigned_assessment(self) -> Optional[pulumi.Input['AssignedAssessmentItemArgs']]:
        """
        Component item with key as applied to this standard assignment over the given scope
        """
        return pulumi.get(self, "assigned_assessment")

    @assigned_assessment.setter
    def assigned_assessment(self, value: Optional[pulumi.Input['AssignedAssessmentItemArgs']]):
        pulumi.set(self, "assigned_assessment", value)

    @property
    @pulumi.getter(name="complianceState")
    def compliance_state(self) -> Optional[pulumi.Input[Union[str, 'AttestationComplianceState']]]:
        """
        Attest category of this assignment
        """
        return pulumi.get(self, "compliance_state")

    @compliance_state.setter
    def compliance_state(self, value: Optional[pulumi.Input[Union[str, 'AttestationComplianceState']]]):
        pulumi.set(self, "compliance_state", value)

    @property
    @pulumi.getter
    def evidence(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AttestationEvidenceArgs']]]]:
        """
        Array of links to attestation evidence
        """
        return pulumi.get(self, "evidence")

    @evidence.setter
    def evidence(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AttestationEvidenceArgs']]]]):
        pulumi.set(self, "evidence", value)


if not MYPY:
    class StandardAssignmentPropertiesExemptionDataArgsDict(TypedDict):
        """
        Additional data about assignment that has Exempt effect
        """
        assigned_assessment: NotRequired[pulumi.Input['AssignedAssessmentItemArgsDict']]
        """
        Component item with key as applied to this standard assignment over the given scope
        """
        exemption_category: NotRequired[pulumi.Input[Union[str, 'ExemptionCategory']]]
        """
        Exemption category of this assignment
        """
elif False:
    StandardAssignmentPropertiesExemptionDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StandardAssignmentPropertiesExemptionDataArgs:
    def __init__(__self__, *,
                 assigned_assessment: Optional[pulumi.Input['AssignedAssessmentItemArgs']] = None,
                 exemption_category: Optional[pulumi.Input[Union[str, 'ExemptionCategory']]] = None):
        """
        Additional data about assignment that has Exempt effect
        :param pulumi.Input['AssignedAssessmentItemArgs'] assigned_assessment: Component item with key as applied to this standard assignment over the given scope
        :param pulumi.Input[Union[str, 'ExemptionCategory']] exemption_category: Exemption category of this assignment
        """
        if assigned_assessment is not None:
            pulumi.set(__self__, "assigned_assessment", assigned_assessment)
        if exemption_category is not None:
            pulumi.set(__self__, "exemption_category", exemption_category)

    @property
    @pulumi.getter(name="assignedAssessment")
    def assigned_assessment(self) -> Optional[pulumi.Input['AssignedAssessmentItemArgs']]:
        """
        Component item with key as applied to this standard assignment over the given scope
        """
        return pulumi.get(self, "assigned_assessment")

    @assigned_assessment.setter
    def assigned_assessment(self, value: Optional[pulumi.Input['AssignedAssessmentItemArgs']]):
        pulumi.set(self, "assigned_assessment", value)

    @property
    @pulumi.getter(name="exemptionCategory")
    def exemption_category(self) -> Optional[pulumi.Input[Union[str, 'ExemptionCategory']]]:
        """
        Exemption category of this assignment
        """
        return pulumi.get(self, "exemption_category")

    @exemption_category.setter
    def exemption_category(self, value: Optional[pulumi.Input[Union[str, 'ExemptionCategory']]]):
        pulumi.set(self, "exemption_category", value)


if not MYPY:
    class StandardComponentPropertiesArgsDict(TypedDict):
        """
        Describes properties of an component as related to the standard
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Component Key matching componentMetadata
        """
elif False:
    StandardComponentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StandardComponentPropertiesArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None):
        """
        Describes properties of an component as related to the standard
        :param pulumi.Input[str] key: Component Key matching componentMetadata
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Component Key matching componentMetadata
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class SuppressionAlertsScopeArgsDict(TypedDict):
        all_of: pulumi.Input[Sequence[pulumi.Input['ScopeElementArgsDict']]]
        """
        All the conditions inside need to be true in order to suppress the alert
        """
elif False:
    SuppressionAlertsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SuppressionAlertsScopeArgs:
    def __init__(__self__, *,
                 all_of: pulumi.Input[Sequence[pulumi.Input['ScopeElementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScopeElementArgs']]] all_of: All the conditions inside need to be true in order to suppress the alert
        """
        pulumi.set(__self__, "all_of", all_of)

    @property
    @pulumi.getter(name="allOf")
    def all_of(self) -> pulumi.Input[Sequence[pulumi.Input['ScopeElementArgs']]]:
        """
        All the conditions inside need to be true in order to suppress the alert
        """
        return pulumi.get(self, "all_of")

    @all_of.setter
    def all_of(self, value: pulumi.Input[Sequence[pulumi.Input['ScopeElementArgs']]]):
        pulumi.set(self, "all_of", value)


if not MYPY:
    class ThresholdCustomAlertRuleArgsDict(TypedDict):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is within the given range.
        """
        is_enabled: pulumi.Input[bool]
        """
        Status of the custom alert.
        """
        max_threshold: pulumi.Input[int]
        """
        The maximum threshold.
        """
        min_threshold: pulumi.Input[int]
        """
        The minimum threshold.
        """
        rule_type: pulumi.Input[str]
        """
        The type of the custom alert rule.
        Expected value is 'ThresholdCustomAlertRule'.
        """
elif False:
    ThresholdCustomAlertRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThresholdCustomAlertRuleArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 max_threshold: pulumi.Input[int],
                 min_threshold: pulumi.Input[int],
                 rule_type: pulumi.Input[str]):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is within the given range.
        :param pulumi.Input[bool] is_enabled: Status of the custom alert.
        :param pulumi.Input[int] max_threshold: The maximum threshold.
        :param pulumi.Input[int] min_threshold: The minimum threshold.
        :param pulumi.Input[str] rule_type: The type of the custom alert rule.
               Expected value is 'ThresholdCustomAlertRule'.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "max_threshold", max_threshold)
        pulumi.set(__self__, "min_threshold", min_threshold)
        pulumi.set(__self__, "rule_type", 'ThresholdCustomAlertRule')

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxThreshold")
    def max_threshold(self) -> pulumi.Input[int]:
        """
        The maximum threshold.
        """
        return pulumi.get(self, "max_threshold")

    @max_threshold.setter
    def max_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_threshold", value)

    @property
    @pulumi.getter(name="minThreshold")
    def min_threshold(self) -> pulumi.Input[int]:
        """
        The minimum threshold.
        """
        return pulumi.get(self, "min_threshold")

    @min_threshold.setter
    def min_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_threshold", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        The type of the custom alert rule.
        Expected value is 'ThresholdCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)


if not MYPY:
    class TimeWindowCustomAlertRuleArgsDict(TypedDict):
        """
        A custom alert rule that checks if the number of activities (depends on the custom alert type) in a time window is within the given range.
        """
        is_enabled: pulumi.Input[bool]
        """
        Status of the custom alert.
        """
        max_threshold: pulumi.Input[int]
        """
        The maximum threshold.
        """
        min_threshold: pulumi.Input[int]
        """
        The minimum threshold.
        """
        rule_type: pulumi.Input[str]
        """
        The type of the custom alert rule.
        Expected value is 'TimeWindowCustomAlertRule'.
        """
        time_window_size: pulumi.Input[str]
        """
        The time window size in iso8601 format.
        """
elif False:
    TimeWindowCustomAlertRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimeWindowCustomAlertRuleArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 max_threshold: pulumi.Input[int],
                 min_threshold: pulumi.Input[int],
                 rule_type: pulumi.Input[str],
                 time_window_size: pulumi.Input[str]):
        """
        A custom alert rule that checks if the number of activities (depends on the custom alert type) in a time window is within the given range.
        :param pulumi.Input[bool] is_enabled: Status of the custom alert.
        :param pulumi.Input[int] max_threshold: The maximum threshold.
        :param pulumi.Input[int] min_threshold: The minimum threshold.
        :param pulumi.Input[str] rule_type: The type of the custom alert rule.
               Expected value is 'TimeWindowCustomAlertRule'.
        :param pulumi.Input[str] time_window_size: The time window size in iso8601 format.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "max_threshold", max_threshold)
        pulumi.set(__self__, "min_threshold", min_threshold)
        pulumi.set(__self__, "rule_type", 'TimeWindowCustomAlertRule')
        pulumi.set(__self__, "time_window_size", time_window_size)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxThreshold")
    def max_threshold(self) -> pulumi.Input[int]:
        """
        The maximum threshold.
        """
        return pulumi.get(self, "max_threshold")

    @max_threshold.setter
    def max_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_threshold", value)

    @property
    @pulumi.getter(name="minThreshold")
    def min_threshold(self) -> pulumi.Input[int]:
        """
        The minimum threshold.
        """
        return pulumi.get(self, "min_threshold")

    @min_threshold.setter
    def min_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_threshold", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        The type of the custom alert rule.
        Expected value is 'TimeWindowCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter(name="timeWindowSize")
    def time_window_size(self) -> pulumi.Input[str]:
        """
        The time window size in iso8601 format.
        """
        return pulumi.get(self, "time_window_size")

    @time_window_size.setter
    def time_window_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_window_size", value)


if not MYPY:
    class UserDefinedResourcesPropertiesArgsDict(TypedDict):
        """
        Properties of the IoT Security solution's user defined resources.
        """
        query: pulumi.Input[str]
        """
        Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
        """
        query_subscriptions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of Azure subscription ids on which the user defined resources query should be executed.
        """
elif False:
    UserDefinedResourcesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserDefinedResourcesPropertiesArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 query_subscriptions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Properties of the IoT Security solution's user defined resources.
        :param pulumi.Input[str] query: Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_subscriptions: List of Azure subscription ids on which the user defined resources query should be executed.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_subscriptions", query_subscriptions)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="querySubscriptions")
    def query_subscriptions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Azure subscription ids on which the user defined resources query should be executed.
        """
        return pulumi.get(self, "query_subscriptions")

    @query_subscriptions.setter
    def query_subscriptions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "query_subscriptions", value)


