# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActionableRemediationResponse',
    'AdaptiveApplicationControlIssueSummaryResponse',
    'AdditionalWorkspacesPropertiesResponse',
    'AllowlistCustomAlertRuleResponse',
    'AssessmentLinksResponse',
    'AssessmentStatusResponseResponse',
    'AssignedComponentItemResponse',
    'AssignedStandardItemResponse',
    'AssignmentPropertiesResponseAdditionalData',
    'AuthorizationResponse',
    'AutomationActionEventHubResponse',
    'AutomationActionLogicAppResponse',
    'AutomationActionWorkspaceResponse',
    'AutomationRuleSetResponse',
    'AutomationScopeResponse',
    'AutomationSourceResponse',
    'AutomationTriggeringRuleResponse',
    'AwAssumeRoleAuthenticationDetailsPropertiesResponse',
    'AwsCredsAuthenticationDetailsPropertiesResponse',
    'AwsEnvironmentDataResponse',
    'AwsOrganizationalDataMasterResponse',
    'AwsOrganizationalDataMemberResponse',
    'AzureDevOpsOrgPropertiesResponse',
    'AzureDevOpsOrgResponse',
    'AzureDevOpsScopeEnvironmentDataResponse',
    'AzureResourceDetailsResponse',
    'CategoryConfigurationResponse',
    'CspmMonitorAwsOfferingResponse',
    'CspmMonitorAwsOfferingResponseNativeCloudConnection',
    'CspmMonitorAzureDevOpsOfferingResponse',
    'CspmMonitorGcpOfferingResponse',
    'CspmMonitorGcpOfferingResponseNativeCloudConnection',
    'CspmMonitorGitLabOfferingResponse',
    'CspmMonitorGithubOfferingResponse',
    'DefenderCspmAwsOfferingResponse',
    'DefenderCspmAwsOfferingResponseConfiguration',
    'DefenderCspmAwsOfferingResponseDataSensitivityDiscovery',
    'DefenderCspmAwsOfferingResponseDatabasesDspm',
    'DefenderCspmAwsOfferingResponseVmScanners',
    'DefenderCspmGcpOfferingResponse',
    'DefenderFoDatabasesAwsOfferingResponse',
    'DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning',
    'DefenderFoDatabasesAwsOfferingResponseConfiguration',
    'DefenderFoDatabasesAwsOfferingResponseDatabasesDspm',
    'DefenderFoDatabasesAwsOfferingResponseRds',
    'DefenderForContainersAwsOfferingResponse',
    'DefenderForContainersAwsOfferingResponseCloudWatchToKinesis',
    'DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment',
    'DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask',
    'DefenderForContainersAwsOfferingResponseKinesisToS3',
    'DefenderForContainersAwsOfferingResponseKubernetesScubaReader',
    'DefenderForContainersAwsOfferingResponseKubernetesService',
    'DefenderForContainersGcpOfferingResponse',
    'DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection',
    'DefenderForContainersGcpOfferingResponseNativeCloudConnection',
    'DefenderForDatabasesGcpOfferingResponse',
    'DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning',
    'DefenderForDatabasesGcpOfferingResponseConfiguration',
    'DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning',
    'DefenderForDevOpsAzureDevOpsOfferingResponse',
    'DefenderForDevOpsGitLabOfferingResponse',
    'DefenderForDevOpsGithubOfferingResponse',
    'DefenderForServersAwsOfferingResponse',
    'DefenderForServersAwsOfferingResponseArcAutoProvisioning',
    'DefenderForServersAwsOfferingResponseConfiguration',
    'DefenderForServersAwsOfferingResponseConfigurationConfiguration',
    'DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration',
    'DefenderForServersAwsOfferingResponseDefenderForServers',
    'DefenderForServersAwsOfferingResponseMdeAutoProvisioning',
    'DefenderForServersAwsOfferingResponseSubPlan',
    'DefenderForServersAwsOfferingResponseVaAutoProvisioning',
    'DefenderForServersAwsOfferingResponseVmScanners',
    'DefenderForServersGcpOfferingResponse',
    'DefenderForServersGcpOfferingResponseArcAutoProvisioning',
    'DefenderForServersGcpOfferingResponseConfiguration',
    'DefenderForServersGcpOfferingResponseConfigurationConfiguration',
    'DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration',
    'DefenderForServersGcpOfferingResponseDefenderForServers',
    'DefenderForServersGcpOfferingResponseMdeAutoProvisioning',
    'DefenderForServersGcpOfferingResponseSubPlan',
    'DefenderForServersGcpOfferingResponseVaAutoProvisioning',
    'DefenderForServersGcpOfferingResponseVmScanners',
    'DenylistCustomAlertRuleResponse',
    'DevOpsConfigurationPropertiesResponse',
    'GcpCredentialsDetailsPropertiesResponse',
    'GcpOrganizationalDataMemberResponse',
    'GcpOrganizationalDataOrganizationResponse',
    'GcpProjectDetailsResponse',
    'GcpProjectEnvironmentDataResponse',
    'GitHubOwnerPropertiesResponse',
    'GitHubOwnerResponse',
    'GitLabGroupPropertiesResponse',
    'GitLabGroupResponse',
    'GithubScopeEnvironmentDataResponse',
    'GitlabScopeEnvironmentDataResponse',
    'GovernanceAssignmentAdditionalDataResponse',
    'GovernanceEmailNotificationResponse',
    'GovernanceRuleEmailNotificationResponse',
    'GovernanceRuleMetadataResponse',
    'GovernanceRuleOwnerSourceResponse',
    'HybridComputeSettingsPropertiesResponse',
    'IdentityResponse',
    'InformationProtectionAwsOfferingResponse',
    'InformationProtectionAwsOfferingResponseInformationProtection',
    'JitNetworkAccessPolicyVirtualMachineResponse',
    'JitNetworkAccessPortRuleResponse',
    'JitNetworkAccessRequestPortResponse',
    'JitNetworkAccessRequestResponse',
    'JitNetworkAccessRequestVirtualMachineResponse',
    'OnPremiseResourceDetailsResponse',
    'OnPremiseSqlResourceDetailsResponse',
    'PathRecommendationResponse',
    'ProtectionModeResponse',
    'ProxyServerPropertiesResponse',
    'PublisherInfoResponse',
    'RecommendationConfigurationPropertiesResponse',
    'RemediationEtaResponse',
    'RuleResultsPropertiesResponse',
    'ScopeElementResponse',
    'SecurityAssessmentMetadataPartnerDataResponse',
    'SecurityAssessmentMetadataPropertiesResponse',
    'SecurityAssessmentMetadataPropertiesResponseResponsePublishDates',
    'SecurityAssessmentPartnerDataResponse',
    'SecurityContactPropertiesResponseAlertNotifications',
    'SecurityContactPropertiesResponseNotificationsByRole',
    'ServicePrincipalPropertiesResponse',
    'StandardComponentPropertiesResponse',
    'SuppressionAlertsScopeResponse',
    'SystemDataResponse',
    'TargetBranchConfigurationResponse',
    'ThresholdCustomAlertRuleResponse',
    'TimeWindowCustomAlertRuleResponse',
    'UserDefinedResourcesPropertiesResponse',
    'UserRecommendationResponse',
    'VmRecommendationResponse',
]

@pulumi.output_type
class ActionableRemediationResponse(dict):
    """
    Configuration payload for PR Annotations.
    """
    def __init__(__self__, *,
                 branch_configuration: Optional['outputs.TargetBranchConfigurationResponse'] = None,
                 category_configurations: Optional[Sequence['outputs.CategoryConfigurationResponse']] = None,
                 inherit_from_parent_state: Optional[str] = None,
                 state: Optional[str] = None):
        """
        Configuration payload for PR Annotations.
        :param 'TargetBranchConfigurationResponse' branch_configuration: Repository branch configuration for PR Annotations.
        :param Sequence['CategoryConfigurationResponse'] category_configurations: Gets or sets list of categories and severity levels.
        :param str inherit_from_parent_state: Update Settings.
               
               Enabled - Resource should inherit configurations from parent.
               Disabled - Resource should not inherit configurations from parent.
        :param str state: ActionableRemediation Setting.
               None - the setting was never set.
               Enabled - ActionableRemediation is enabled.
               Disabled - ActionableRemediation is disabled.
        """
        ActionableRemediationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch_configuration=branch_configuration,
            category_configurations=category_configurations,
            inherit_from_parent_state=inherit_from_parent_state,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch_configuration: Optional['outputs.TargetBranchConfigurationResponse'] = None,
             category_configurations: Optional[Sequence['outputs.CategoryConfigurationResponse']] = None,
             inherit_from_parent_state: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if branch_configuration is None and 'branchConfiguration' in kwargs:
            branch_configuration = kwargs['branchConfiguration']
        if category_configurations is None and 'categoryConfigurations' in kwargs:
            category_configurations = kwargs['categoryConfigurations']
        if inherit_from_parent_state is None and 'inheritFromParentState' in kwargs:
            inherit_from_parent_state = kwargs['inheritFromParentState']

        if branch_configuration is not None:
            _setter("branch_configuration", branch_configuration)
        if category_configurations is not None:
            _setter("category_configurations", category_configurations)
        if inherit_from_parent_state is not None:
            _setter("inherit_from_parent_state", inherit_from_parent_state)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="branchConfiguration")
    def branch_configuration(self) -> Optional['outputs.TargetBranchConfigurationResponse']:
        """
        Repository branch configuration for PR Annotations.
        """
        return pulumi.get(self, "branch_configuration")

    @property
    @pulumi.getter(name="categoryConfigurations")
    def category_configurations(self) -> Optional[Sequence['outputs.CategoryConfigurationResponse']]:
        """
        Gets or sets list of categories and severity levels.
        """
        return pulumi.get(self, "category_configurations")

    @property
    @pulumi.getter(name="inheritFromParentState")
    def inherit_from_parent_state(self) -> Optional[str]:
        """
        Update Settings.
        
        Enabled - Resource should inherit configurations from parent.
        Disabled - Resource should not inherit configurations from parent.
        """
        return pulumi.get(self, "inherit_from_parent_state")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        ActionableRemediation Setting.
        None - the setting was never set.
        Enabled - ActionableRemediation is enabled.
        Disabled - ActionableRemediation is disabled.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AdaptiveApplicationControlIssueSummaryResponse(dict):
    """
    Represents a summary of the alerts of the machine group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfVms":
            suggest = "number_of_vms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveApplicationControlIssueSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveApplicationControlIssueSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveApplicationControlIssueSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issue: Optional[str] = None,
                 number_of_vms: Optional[float] = None):
        """
        Represents a summary of the alerts of the machine group
        :param str issue: An alert that machines within a group can have
        :param float number_of_vms: The number of machines in the group that have this alert
        """
        AdaptiveApplicationControlIssueSummaryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            issue=issue,
            number_of_vms=number_of_vms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             issue: Optional[str] = None,
             number_of_vms: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if number_of_vms is None and 'numberOfVms' in kwargs:
            number_of_vms = kwargs['numberOfVms']

        if issue is not None:
            _setter("issue", issue)
        if number_of_vms is not None:
            _setter("number_of_vms", number_of_vms)

    @property
    @pulumi.getter
    def issue(self) -> Optional[str]:
        """
        An alert that machines within a group can have
        """
        return pulumi.get(self, "issue")

    @property
    @pulumi.getter(name="numberOfVms")
    def number_of_vms(self) -> Optional[float]:
        """
        The number of machines in the group that have this alert
        """
        return pulumi.get(self, "number_of_vms")


@pulumi.output_type
class AdditionalWorkspacesPropertiesResponse(dict):
    """
    Properties of the additional workspaces.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataTypes":
            suggest = "data_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdditionalWorkspacesPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdditionalWorkspacesPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdditionalWorkspacesPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_types: Optional[Sequence[str]] = None,
                 type: Optional[str] = None,
                 workspace: Optional[str] = None):
        """
        Properties of the additional workspaces.
        :param Sequence[str] data_types: List of data types sent to workspace
        :param str type: Workspace type.
        :param str workspace: Workspace resource id
        """
        AdditionalWorkspacesPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_types=data_types,
            type=type,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_types: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             workspace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_types is None and 'dataTypes' in kwargs:
            data_types = kwargs['dataTypes']

        if data_types is not None:
            _setter("data_types", data_types)
        if type is None:
            type = 'Sentinel'
        if type is not None:
            _setter("type", type)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[Sequence[str]]:
        """
        List of data types sent to workspace
        """
        return pulumi.get(self, "data_types")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Workspace type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def workspace(self) -> Optional[str]:
        """
        Workspace resource id
        """
        return pulumi.get(self, "workspace")


@pulumi.output_type
class AllowlistCustomAlertRuleResponse(dict):
    """
    A custom alert rule that checks if a value (depends on the custom alert type) is allowed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowlistValues":
            suggest = "allowlist_values"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowlistCustomAlertRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowlistCustomAlertRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowlistCustomAlertRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowlist_values: Sequence[str],
                 description: str,
                 display_name: str,
                 is_enabled: bool,
                 rule_type: str,
                 value_type: str):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is allowed.
        :param Sequence[str] allowlist_values: The values to allow. The format of the values depends on the rule type.
        :param str description: The description of the custom alert.
        :param str display_name: The display name of the custom alert.
        :param bool is_enabled: Status of the custom alert.
        :param str rule_type: The type of the custom alert rule.
               Expected value is 'AllowlistCustomAlertRule'.
        :param str value_type: The value type of the items in the list.
        """
        AllowlistCustomAlertRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowlist_values=allowlist_values,
            description=description,
            display_name=display_name,
            is_enabled=is_enabled,
            rule_type=rule_type,
            value_type=value_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowlist_values: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             rule_type: Optional[str] = None,
             value_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowlist_values is None and 'allowlistValues' in kwargs:
            allowlist_values = kwargs['allowlistValues']
        if allowlist_values is None:
            raise TypeError("Missing 'allowlist_values' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if rule_type is None and 'ruleType' in kwargs:
            rule_type = kwargs['ruleType']
        if rule_type is None:
            raise TypeError("Missing 'rule_type' argument")
        if value_type is None and 'valueType' in kwargs:
            value_type = kwargs['valueType']
        if value_type is None:
            raise TypeError("Missing 'value_type' argument")

        _setter("allowlist_values", allowlist_values)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("is_enabled", is_enabled)
        _setter("rule_type", 'AllowlistCustomAlertRule')
        _setter("value_type", value_type)

    @property
    @pulumi.getter(name="allowlistValues")
    def allowlist_values(self) -> Sequence[str]:
        """
        The values to allow. The format of the values depends on the rule type.
        """
        return pulumi.get(self, "allowlist_values")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the custom alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the custom alert.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the custom alert rule.
        Expected value is 'AllowlistCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        The value type of the items in the list.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class AssessmentLinksResponse(dict):
    """
    Links relevant to the assessment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azurePortalUri":
            suggest = "azure_portal_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssessmentLinksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssessmentLinksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssessmentLinksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_portal_uri: str):
        """
        Links relevant to the assessment
        :param str azure_portal_uri: Link to assessment in Azure Portal
        """
        AssessmentLinksResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_portal_uri=azure_portal_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_portal_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_portal_uri is None and 'azurePortalUri' in kwargs:
            azure_portal_uri = kwargs['azurePortalUri']
        if azure_portal_uri is None:
            raise TypeError("Missing 'azure_portal_uri' argument")

        _setter("azure_portal_uri", azure_portal_uri)

    @property
    @pulumi.getter(name="azurePortalUri")
    def azure_portal_uri(self) -> str:
        """
        Link to assessment in Azure Portal
        """
        return pulumi.get(self, "azure_portal_uri")


@pulumi.output_type
class AssessmentStatusResponseResponse(dict):
    """
    The result of the assessment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstEvaluationDate":
            suggest = "first_evaluation_date"
        elif key == "statusChangeDate":
            suggest = "status_change_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssessmentStatusResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssessmentStatusResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssessmentStatusResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: str,
                 first_evaluation_date: str,
                 status_change_date: str,
                 cause: Optional[str] = None,
                 description: Optional[str] = None):
        """
        The result of the assessment
        :param str code: Programmatic code for the status of the assessment
        :param str first_evaluation_date: The time that the assessment was created and first evaluated. Returned as UTC time in ISO 8601 format
        :param str status_change_date: The time that the status of the assessment last changed. Returned as UTC time in ISO 8601 format
        :param str cause: Programmatic code for the cause of the assessment status
        :param str description: Human readable description of the assessment status
        """
        AssessmentStatusResponseResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            first_evaluation_date=first_evaluation_date,
            status_change_date=status_change_date,
            cause=cause,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             first_evaluation_date: Optional[str] = None,
             status_change_date: Optional[str] = None,
             cause: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code is None:
            raise TypeError("Missing 'code' argument")
        if first_evaluation_date is None and 'firstEvaluationDate' in kwargs:
            first_evaluation_date = kwargs['firstEvaluationDate']
        if first_evaluation_date is None:
            raise TypeError("Missing 'first_evaluation_date' argument")
        if status_change_date is None and 'statusChangeDate' in kwargs:
            status_change_date = kwargs['statusChangeDate']
        if status_change_date is None:
            raise TypeError("Missing 'status_change_date' argument")

        _setter("code", code)
        _setter("first_evaluation_date", first_evaluation_date)
        _setter("status_change_date", status_change_date)
        if cause is not None:
            _setter("cause", cause)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Programmatic code for the status of the assessment
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="firstEvaluationDate")
    def first_evaluation_date(self) -> str:
        """
        The time that the assessment was created and first evaluated. Returned as UTC time in ISO 8601 format
        """
        return pulumi.get(self, "first_evaluation_date")

    @property
    @pulumi.getter(name="statusChangeDate")
    def status_change_date(self) -> str:
        """
        The time that the status of the assessment last changed. Returned as UTC time in ISO 8601 format
        """
        return pulumi.get(self, "status_change_date")

    @property
    @pulumi.getter
    def cause(self) -> Optional[str]:
        """
        Programmatic code for the cause of the assessment status
        """
        return pulumi.get(self, "cause")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Human readable description of the assessment status
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AssignedComponentItemResponse(dict):
    """
    describe the properties of a security assessment object reference (by key)
    """
    def __init__(__self__, *,
                 key: Optional[str] = None):
        """
        describe the properties of a security assessment object reference (by key)
        :param str key: unique key to a security assessment object
        """
        AssignedComponentItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        unique key to a security assessment object
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class AssignedStandardItemResponse(dict):
    """
    describe the properties of a of a security standard object reference
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        describe the properties of a of a security standard object reference
        :param str id: full resourceId of the Microsoft.Security/standard object
        """
        AssignedStandardItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        full resourceId of the Microsoft.Security/standard object
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AssignmentPropertiesResponseAdditionalData(dict):
    """
    Additional data about the assignment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exemptionCategory":
            suggest = "exemption_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssignmentPropertiesResponseAdditionalData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssignmentPropertiesResponseAdditionalData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssignmentPropertiesResponseAdditionalData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exemption_category: Optional[str] = None):
        """
        Additional data about the assignment
        :param str exemption_category: Exemption category of this assignment
        """
        AssignmentPropertiesResponseAdditionalData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exemption_category=exemption_category,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exemption_category: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exemption_category is None and 'exemptionCategory' in kwargs:
            exemption_category = kwargs['exemptionCategory']

        if exemption_category is not None:
            _setter("exemption_category", exemption_category)

    @property
    @pulumi.getter(name="exemptionCategory")
    def exemption_category(self) -> Optional[str]:
        """
        Exemption category of this assignment
        """
        return pulumi.get(self, "exemption_category")


@pulumi.output_type
class AuthorizationResponse(dict):
    """
    Authorization payload.
    """
    def __init__(__self__, *,
                 code: Optional[str] = None):
        """
        Authorization payload.
        :param str code: Gets or sets one-time OAuth code to exchange for refresh and access tokens.
               
               Only used during PUT/PATCH operations. The secret is cleared during GET.
        """
        AuthorizationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Gets or sets one-time OAuth code to exchange for refresh and access tokens.
        
        Only used during PUT/PATCH operations. The secret is cleared during GET.
        """
        return pulumi.get(self, "code")


@pulumi.output_type
class AutomationActionEventHubResponse(dict):
    """
    The target Event Hub to which event data will be exported. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "sasPolicyName":
            suggest = "sas_policy_name"
        elif key == "connectionString":
            suggest = "connection_string"
        elif key == "eventHubResourceId":
            suggest = "event_hub_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationActionEventHubResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationActionEventHubResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationActionEventHubResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 sas_policy_name: str,
                 connection_string: Optional[str] = None,
                 event_hub_resource_id: Optional[str] = None):
        """
        The target Event Hub to which event data will be exported. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        :param str action_type: The type of the action that will be triggered by the Automation
               Expected value is 'EventHub'.
        :param str sas_policy_name: The target Event Hub SAS policy name.
        :param str connection_string: The target Event Hub connection string (it will not be included in any response).
        :param str event_hub_resource_id: The target Event Hub Azure Resource ID.
        """
        AutomationActionEventHubResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            sas_policy_name=sas_policy_name,
            connection_string=connection_string,
            event_hub_resource_id=event_hub_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             sas_policy_name: Optional[str] = None,
             connection_string: Optional[str] = None,
             event_hub_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if sas_policy_name is None and 'sasPolicyName' in kwargs:
            sas_policy_name = kwargs['sasPolicyName']
        if sas_policy_name is None:
            raise TypeError("Missing 'sas_policy_name' argument")
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if event_hub_resource_id is None and 'eventHubResourceId' in kwargs:
            event_hub_resource_id = kwargs['eventHubResourceId']

        _setter("action_type", 'EventHub')
        _setter("sas_policy_name", sas_policy_name)
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if event_hub_resource_id is not None:
            _setter("event_hub_resource_id", event_hub_resource_id)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'EventHub'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="sasPolicyName")
    def sas_policy_name(self) -> str:
        """
        The target Event Hub SAS policy name.
        """
        return pulumi.get(self, "sas_policy_name")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        The target Event Hub connection string (it will not be included in any response).
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="eventHubResourceId")
    def event_hub_resource_id(self) -> Optional[str]:
        """
        The target Event Hub Azure Resource ID.
        """
        return pulumi.get(self, "event_hub_resource_id")


@pulumi.output_type
class AutomationActionLogicAppResponse(dict):
    """
    The logic app action that should be triggered. To learn more about Microsoft Defender for Cloud's Workflow Automation capabilities, visit https://aka.ms/ASCWorkflowAutomationLearnMore
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "logicAppResourceId":
            suggest = "logic_app_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationActionLogicAppResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationActionLogicAppResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationActionLogicAppResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 logic_app_resource_id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        The logic app action that should be triggered. To learn more about Microsoft Defender for Cloud's Workflow Automation capabilities, visit https://aka.ms/ASCWorkflowAutomationLearnMore
        :param str action_type: The type of the action that will be triggered by the Automation
               Expected value is 'LogicApp'.
        :param str logic_app_resource_id: The triggered Logic App Azure Resource ID. This can also reside on other subscriptions, given that you have permissions to trigger the Logic App
        :param str uri: The Logic App trigger URI endpoint (it will not be included in any response).
        """
        AutomationActionLogicAppResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            logic_app_resource_id=logic_app_resource_id,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             logic_app_resource_id: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if logic_app_resource_id is None and 'logicAppResourceId' in kwargs:
            logic_app_resource_id = kwargs['logicAppResourceId']

        _setter("action_type", 'LogicApp')
        if logic_app_resource_id is not None:
            _setter("logic_app_resource_id", logic_app_resource_id)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'LogicApp'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> Optional[str]:
        """
        The triggered Logic App Azure Resource ID. This can also reside on other subscriptions, given that you have permissions to trigger the Logic App
        """
        return pulumi.get(self, "logic_app_resource_id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The Logic App trigger URI endpoint (it will not be included in any response).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class AutomationActionWorkspaceResponse(dict):
    """
    The Log Analytics Workspace to which event data will be exported. Security alerts data will reside in the 'SecurityAlert' table and the assessments data will reside in the 'SecurityRecommendation' table (under the 'Security'/'SecurityCenterFree' solutions). Note that in order to view the data in the workspace, the Security Center Log Analytics free/standard solution needs to be enabled on that workspace. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "workspaceResourceId":
            suggest = "workspace_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationActionWorkspaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationActionWorkspaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationActionWorkspaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 workspace_resource_id: Optional[str] = None):
        """
        The Log Analytics Workspace to which event data will be exported. Security alerts data will reside in the 'SecurityAlert' table and the assessments data will reside in the 'SecurityRecommendation' table (under the 'Security'/'SecurityCenterFree' solutions). Note that in order to view the data in the workspace, the Security Center Log Analytics free/standard solution needs to be enabled on that workspace. To learn more about Microsoft Defender for Cloud continuous export capabilities, visit https://aka.ms/ASCExportLearnMore
        :param str action_type: The type of the action that will be triggered by the Automation
               Expected value is 'Workspace'.
        :param str workspace_resource_id: The fully qualified Log Analytics Workspace Azure Resource ID.
        """
        AutomationActionWorkspaceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            workspace_resource_id=workspace_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             workspace_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if workspace_resource_id is None and 'workspaceResourceId' in kwargs:
            workspace_resource_id = kwargs['workspaceResourceId']

        _setter("action_type", 'Workspace')
        if workspace_resource_id is not None:
            _setter("workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the action that will be triggered by the Automation
        Expected value is 'Workspace'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[str]:
        """
        The fully qualified Log Analytics Workspace Azure Resource ID.
        """
        return pulumi.get(self, "workspace_resource_id")


@pulumi.output_type
class AutomationRuleSetResponse(dict):
    """
    A rule set which evaluates all its rules upon an event interception. Only when all the included rules in the rule set will be evaluated as 'true', will the event trigger the defined actions.
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AutomationTriggeringRuleResponse']] = None):
        """
        A rule set which evaluates all its rules upon an event interception. Only when all the included rules in the rule set will be evaluated as 'true', will the event trigger the defined actions.
        """
        AutomationRuleSetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['outputs.AutomationTriggeringRuleResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AutomationTriggeringRuleResponse']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutomationScopeResponse(dict):
    """
    A single automation scope.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopePath":
            suggest = "scope_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationScopeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationScopeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationScopeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 scope_path: Optional[str] = None):
        """
        A single automation scope.
        :param str description: The resources scope description.
        :param str scope_path: The resources scope path. Can be the subscription on which the automation is defined on or a resource group under that subscription (fully qualified Azure resource IDs).
        """
        AutomationScopeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            scope_path=scope_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             scope_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scope_path is None and 'scopePath' in kwargs:
            scope_path = kwargs['scopePath']

        if description is not None:
            _setter("description", description)
        if scope_path is not None:
            _setter("scope_path", scope_path)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The resources scope description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="scopePath")
    def scope_path(self) -> Optional[str]:
        """
        The resources scope path. Can be the subscription on which the automation is defined on or a resource group under that subscription (fully qualified Azure resource IDs).
        """
        return pulumi.get(self, "scope_path")


@pulumi.output_type
class AutomationSourceResponse(dict):
    """
    The source event types which evaluate the security automation set of rules. For example - security alerts and security assessments. To learn more about the supported security events data models schemas - please visit https://aka.ms/ASCAutomationSchemas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSource":
            suggest = "event_source"
        elif key == "ruleSets":
            suggest = "rule_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_source: Optional[str] = None,
                 rule_sets: Optional[Sequence['outputs.AutomationRuleSetResponse']] = None):
        """
        The source event types which evaluate the security automation set of rules. For example - security alerts and security assessments. To learn more about the supported security events data models schemas - please visit https://aka.ms/ASCAutomationSchemas.
        :param str event_source: A valid event source type.
        :param Sequence['AutomationRuleSetResponse'] rule_sets: A set of rules which evaluate upon event interception. A logical disjunction is applied between defined rule sets (logical 'or').
        """
        AutomationSourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_source=event_source,
            rule_sets=rule_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_source: Optional[str] = None,
             rule_sets: Optional[Sequence['outputs.AutomationRuleSetResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if event_source is None and 'eventSource' in kwargs:
            event_source = kwargs['eventSource']
        if rule_sets is None and 'ruleSets' in kwargs:
            rule_sets = kwargs['ruleSets']

        if event_source is not None:
            _setter("event_source", event_source)
        if rule_sets is not None:
            _setter("rule_sets", rule_sets)

    @property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[str]:
        """
        A valid event source type.
        """
        return pulumi.get(self, "event_source")

    @property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Optional[Sequence['outputs.AutomationRuleSetResponse']]:
        """
        A set of rules which evaluate upon event interception. A logical disjunction is applied between defined rule sets (logical 'or').
        """
        return pulumi.get(self, "rule_sets")


@pulumi.output_type
class AutomationTriggeringRuleResponse(dict):
    """
    A rule which is evaluated upon event interception. The rule is configured by comparing a specific value from the event model to an expected value. This comparison is done by using one of the supported operators set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedValue":
            suggest = "expected_value"
        elif key == "propertyJPath":
            suggest = "property_j_path"
        elif key == "propertyType":
            suggest = "property_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationTriggeringRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationTriggeringRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationTriggeringRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expected_value: Optional[str] = None,
                 operator: Optional[str] = None,
                 property_j_path: Optional[str] = None,
                 property_type: Optional[str] = None):
        """
        A rule which is evaluated upon event interception. The rule is configured by comparing a specific value from the event model to an expected value. This comparison is done by using one of the supported operators set.
        :param str expected_value: The expected value.
        :param str operator: A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
        :param str property_j_path: The JPath of the entity model property that should be checked.
        :param str property_type: The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
        """
        AutomationTriggeringRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expected_value=expected_value,
            operator=operator,
            property_j_path=property_j_path,
            property_type=property_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expected_value: Optional[str] = None,
             operator: Optional[str] = None,
             property_j_path: Optional[str] = None,
             property_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expected_value is None and 'expectedValue' in kwargs:
            expected_value = kwargs['expectedValue']
        if property_j_path is None and 'propertyJPath' in kwargs:
            property_j_path = kwargs['propertyJPath']
        if property_type is None and 'propertyType' in kwargs:
            property_type = kwargs['propertyType']

        if expected_value is not None:
            _setter("expected_value", expected_value)
        if operator is not None:
            _setter("operator", operator)
        if property_j_path is not None:
            _setter("property_j_path", property_j_path)
        if property_type is not None:
            _setter("property_type", property_type)

    @property
    @pulumi.getter(name="expectedValue")
    def expected_value(self) -> Optional[str]:
        """
        The expected value.
        """
        return pulumi.get(self, "expected_value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="propertyJPath")
    def property_j_path(self) -> Optional[str]:
        """
        The JPath of the entity model property that should be checked.
        """
        return pulumi.get(self, "property_j_path")

    @property
    @pulumi.getter(name="propertyType")
    def property_type(self) -> Optional[str]:
        """
        The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
        """
        return pulumi.get(self, "property_type")


@pulumi.output_type
class AwAssumeRoleAuthenticationDetailsPropertiesResponse(dict):
    """
    AWS cloud account connector based assume role, the role enables delegating access to your AWS resources. The role is composed of role Amazon Resource Name (ARN) and external ID. For more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user.html">Creating a Role to Delegate Permissions to an IAM User (write only)</a>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "authenticationProvisioningState":
            suggest = "authentication_provisioning_state"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "awsAssumeRoleArn":
            suggest = "aws_assume_role_arn"
        elif key == "awsExternalId":
            suggest = "aws_external_id"
        elif key == "grantedPermissions":
            suggest = "granted_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwAssumeRoleAuthenticationDetailsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwAssumeRoleAuthenticationDetailsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwAssumeRoleAuthenticationDetailsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 authentication_provisioning_state: str,
                 authentication_type: str,
                 aws_assume_role_arn: str,
                 aws_external_id: str,
                 granted_permissions: Sequence[str]):
        """
        AWS cloud account connector based assume role, the role enables delegating access to your AWS resources. The role is composed of role Amazon Resource Name (ARN) and external ID. For more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user.html">Creating a Role to Delegate Permissions to an IAM User (write only)</a>
        :param str account_id: The ID of the cloud account
        :param str authentication_provisioning_state: State of the multi-cloud connector
        :param str authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'awsAssumeRole'.
        :param str aws_assume_role_arn: Assumed role ID is an identifier that you can use to create temporary security credentials.
        :param str aws_external_id: A unique identifier that is required when you assume a role in another account.
        :param Sequence[str] granted_permissions: The permissions detected in the cloud account.
        """
        AwAssumeRoleAuthenticationDetailsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            authentication_provisioning_state=authentication_provisioning_state,
            authentication_type=authentication_type,
            aws_assume_role_arn=aws_assume_role_arn,
            aws_external_id=aws_external_id,
            granted_permissions=granted_permissions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             authentication_provisioning_state: Optional[str] = None,
             authentication_type: Optional[str] = None,
             aws_assume_role_arn: Optional[str] = None,
             aws_external_id: Optional[str] = None,
             granted_permissions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if authentication_provisioning_state is None and 'authenticationProvisioningState' in kwargs:
            authentication_provisioning_state = kwargs['authenticationProvisioningState']
        if authentication_provisioning_state is None:
            raise TypeError("Missing 'authentication_provisioning_state' argument")
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if aws_assume_role_arn is None and 'awsAssumeRoleArn' in kwargs:
            aws_assume_role_arn = kwargs['awsAssumeRoleArn']
        if aws_assume_role_arn is None:
            raise TypeError("Missing 'aws_assume_role_arn' argument")
        if aws_external_id is None and 'awsExternalId' in kwargs:
            aws_external_id = kwargs['awsExternalId']
        if aws_external_id is None:
            raise TypeError("Missing 'aws_external_id' argument")
        if granted_permissions is None and 'grantedPermissions' in kwargs:
            granted_permissions = kwargs['grantedPermissions']
        if granted_permissions is None:
            raise TypeError("Missing 'granted_permissions' argument")

        _setter("account_id", account_id)
        _setter("authentication_provisioning_state", authentication_provisioning_state)
        _setter("authentication_type", 'awsAssumeRole')
        _setter("aws_assume_role_arn", aws_assume_role_arn)
        _setter("aws_external_id", aws_external_id)
        _setter("granted_permissions", granted_permissions)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The ID of the cloud account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="authenticationProvisioningState")
    def authentication_provisioning_state(self) -> str:
        """
        State of the multi-cloud connector
        """
        return pulumi.get(self, "authentication_provisioning_state")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsAssumeRole'.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="awsAssumeRoleArn")
    def aws_assume_role_arn(self) -> str:
        """
        Assumed role ID is an identifier that you can use to create temporary security credentials.
        """
        return pulumi.get(self, "aws_assume_role_arn")

    @property
    @pulumi.getter(name="awsExternalId")
    def aws_external_id(self) -> str:
        """
        A unique identifier that is required when you assume a role in another account.
        """
        return pulumi.get(self, "aws_external_id")

    @property
    @pulumi.getter(name="grantedPermissions")
    def granted_permissions(self) -> Sequence[str]:
        """
        The permissions detected in the cloud account.
        """
        return pulumi.get(self, "granted_permissions")


@pulumi.output_type
class AwsCredsAuthenticationDetailsPropertiesResponse(dict):
    """
    AWS cloud account connector based credentials, the credentials is composed of access key ID and secret key, for more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html">Creating an IAM User in Your AWS Account (write only)</a>
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "authenticationProvisioningState":
            suggest = "authentication_provisioning_state"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "grantedPermissions":
            suggest = "granted_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredsAuthenticationDetailsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredsAuthenticationDetailsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredsAuthenticationDetailsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 authentication_provisioning_state: str,
                 authentication_type: str,
                 aws_access_key_id: str,
                 aws_secret_access_key: str,
                 granted_permissions: Sequence[str]):
        """
        AWS cloud account connector based credentials, the credentials is composed of access key ID and secret key, for more details, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html">Creating an IAM User in Your AWS Account (write only)</a>
        :param str account_id: The ID of the cloud account
        :param str authentication_provisioning_state: State of the multi-cloud connector
        :param str authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'awsCreds'.
        :param str aws_access_key_id: Public key element of the AWS credential object (write only)
        :param str aws_secret_access_key: Secret key element of the AWS credential object (write only)
        :param Sequence[str] granted_permissions: The permissions detected in the cloud account.
        """
        AwsCredsAuthenticationDetailsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            authentication_provisioning_state=authentication_provisioning_state,
            authentication_type=authentication_type,
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key,
            granted_permissions=granted_permissions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             authentication_provisioning_state: Optional[str] = None,
             authentication_type: Optional[str] = None,
             aws_access_key_id: Optional[str] = None,
             aws_secret_access_key: Optional[str] = None,
             granted_permissions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if authentication_provisioning_state is None and 'authenticationProvisioningState' in kwargs:
            authentication_provisioning_state = kwargs['authenticationProvisioningState']
        if authentication_provisioning_state is None:
            raise TypeError("Missing 'authentication_provisioning_state' argument")
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if aws_access_key_id is None and 'awsAccessKeyId' in kwargs:
            aws_access_key_id = kwargs['awsAccessKeyId']
        if aws_access_key_id is None:
            raise TypeError("Missing 'aws_access_key_id' argument")
        if aws_secret_access_key is None and 'awsSecretAccessKey' in kwargs:
            aws_secret_access_key = kwargs['awsSecretAccessKey']
        if aws_secret_access_key is None:
            raise TypeError("Missing 'aws_secret_access_key' argument")
        if granted_permissions is None and 'grantedPermissions' in kwargs:
            granted_permissions = kwargs['grantedPermissions']
        if granted_permissions is None:
            raise TypeError("Missing 'granted_permissions' argument")

        _setter("account_id", account_id)
        _setter("authentication_provisioning_state", authentication_provisioning_state)
        _setter("authentication_type", 'awsCreds')
        _setter("aws_access_key_id", aws_access_key_id)
        _setter("aws_secret_access_key", aws_secret_access_key)
        _setter("granted_permissions", granted_permissions)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The ID of the cloud account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="authenticationProvisioningState")
    def authentication_provisioning_state(self) -> str:
        """
        State of the multi-cloud connector
        """
        return pulumi.get(self, "authentication_provisioning_state")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'awsCreds'.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> str:
        """
        Public key element of the AWS credential object (write only)
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> str:
        """
        Secret key element of the AWS credential object (write only)
        """
        return pulumi.get(self, "aws_secret_access_key")

    @property
    @pulumi.getter(name="grantedPermissions")
    def granted_permissions(self) -> Sequence[str]:
        """
        The permissions detected in the cloud account.
        """
        return pulumi.get(self, "granted_permissions")


@pulumi.output_type
class AwsEnvironmentDataResponse(dict):
    """
    The AWS connector environment data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "environmentType":
            suggest = "environment_type"
        elif key == "organizationalData":
            suggest = "organizational_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEnvironmentDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEnvironmentDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEnvironmentDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 environment_type: str,
                 organizational_data: Optional[Any] = None,
                 regions: Optional[Sequence[str]] = None):
        """
        The AWS connector environment data
        :param str account_name: The AWS account name
        :param str environment_type: The type of the environment data.
               Expected value is 'AwsAccount'.
        :param Union['AwsOrganizationalDataMasterResponse', 'AwsOrganizationalDataMemberResponse'] organizational_data: The AWS account's organizational data
        :param Sequence[str] regions: list of regions to scan
        """
        AwsEnvironmentDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            environment_type=environment_type,
            organizational_data=organizational_data,
            regions=regions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             environment_type: Optional[str] = None,
             organizational_data: Optional[Any] = None,
             regions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")
        if organizational_data is None and 'organizationalData' in kwargs:
            organizational_data = kwargs['organizationalData']

        _setter("account_name", account_name)
        _setter("environment_type", 'AwsAccount')
        if organizational_data is not None:
            _setter("organizational_data", organizational_data)
        if regions is not None:
            _setter("regions", regions)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The AWS account name
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        The type of the environment data.
        Expected value is 'AwsAccount'.
        """
        return pulumi.get(self, "environment_type")

    @property
    @pulumi.getter(name="organizationalData")
    def organizational_data(self) -> Optional[Any]:
        """
        The AWS account's organizational data
        """
        return pulumi.get(self, "organizational_data")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        """
        list of regions to scan
        """
        return pulumi.get(self, "regions")


@pulumi.output_type
class AwsOrganizationalDataMasterResponse(dict):
    """
    The AWS organization data for the master account
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationMembershipType":
            suggest = "organization_membership_type"
        elif key == "excludedAccountIds":
            suggest = "excluded_account_ids"
        elif key == "stacksetName":
            suggest = "stackset_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsOrganizationalDataMasterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsOrganizationalDataMasterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsOrganizationalDataMasterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organization_membership_type: str,
                 excluded_account_ids: Optional[Sequence[str]] = None,
                 stackset_name: Optional[str] = None):
        """
        The AWS organization data for the master account
        :param str organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Organization'.
        :param Sequence[str] excluded_account_ids: If the multi cloud account is of membership type organization, list of accounts excluded from offering
        :param str stackset_name: If the multi cloud account is of membership type organization, this will be the name of the onboarding stackset
        """
        AwsOrganizationalDataMasterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            organization_membership_type=organization_membership_type,
            excluded_account_ids=excluded_account_ids,
            stackset_name=stackset_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             organization_membership_type: Optional[str] = None,
             excluded_account_ids: Optional[Sequence[str]] = None,
             stackset_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if organization_membership_type is None and 'organizationMembershipType' in kwargs:
            organization_membership_type = kwargs['organizationMembershipType']
        if organization_membership_type is None:
            raise TypeError("Missing 'organization_membership_type' argument")
        if excluded_account_ids is None and 'excludedAccountIds' in kwargs:
            excluded_account_ids = kwargs['excludedAccountIds']
        if stackset_name is None and 'stacksetName' in kwargs:
            stackset_name = kwargs['stacksetName']

        _setter("organization_membership_type", 'Organization')
        if excluded_account_ids is not None:
            _setter("excluded_account_ids", excluded_account_ids)
        if stackset_name is not None:
            _setter("stackset_name", stackset_name)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> str:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        return pulumi.get(self, "organization_membership_type")

    @property
    @pulumi.getter(name="excludedAccountIds")
    def excluded_account_ids(self) -> Optional[Sequence[str]]:
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        return pulumi.get(self, "excluded_account_ids")

    @property
    @pulumi.getter(name="stacksetName")
    def stackset_name(self) -> Optional[str]:
        """
        If the multi cloud account is of membership type organization, this will be the name of the onboarding stackset
        """
        return pulumi.get(self, "stackset_name")


@pulumi.output_type
class AwsOrganizationalDataMemberResponse(dict):
    """
    The AWS organization data for the member account
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationMembershipType":
            suggest = "organization_membership_type"
        elif key == "parentHierarchyId":
            suggest = "parent_hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsOrganizationalDataMemberResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsOrganizationalDataMemberResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsOrganizationalDataMemberResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organization_membership_type: str,
                 parent_hierarchy_id: Optional[str] = None):
        """
        The AWS organization data for the member account
        :param str organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Member'.
        :param str parent_hierarchy_id: If the multi cloud account is not of membership type organization, this will be the ID of the account's parent
        """
        AwsOrganizationalDataMemberResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            organization_membership_type=organization_membership_type,
            parent_hierarchy_id=parent_hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             organization_membership_type: Optional[str] = None,
             parent_hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if organization_membership_type is None and 'organizationMembershipType' in kwargs:
            organization_membership_type = kwargs['organizationMembershipType']
        if organization_membership_type is None:
            raise TypeError("Missing 'organization_membership_type' argument")
        if parent_hierarchy_id is None and 'parentHierarchyId' in kwargs:
            parent_hierarchy_id = kwargs['parentHierarchyId']

        _setter("organization_membership_type", 'Member')
        if parent_hierarchy_id is not None:
            _setter("parent_hierarchy_id", parent_hierarchy_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> str:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        return pulumi.get(self, "organization_membership_type")

    @property
    @pulumi.getter(name="parentHierarchyId")
    def parent_hierarchy_id(self) -> Optional[str]:
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the account's parent
        """
        return pulumi.get(self, "parent_hierarchy_id")


@pulumi.output_type
class AzureDevOpsOrgPropertiesResponse(dict):
    """
    Azure DevOps Organization properties.
    """
    def __init__(__self__, *,
                 provisioning_status_message: str,
                 provisioning_status_update_time_utc: str,
                 actionable_remediation: Optional['outputs.ActionableRemediationResponse'] = None,
                 onboarding_state: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        Azure DevOps Organization properties.
        :param str provisioning_status_message: Gets or sets resource status message.
        :param str provisioning_status_update_time_utc: Gets or sets time when resource was last checked.
        :param 'ActionableRemediationResponse' actionable_remediation: Configuration payload for PR Annotations.
        :param str onboarding_state: Details about resource onboarding status across all connectors.
               
               OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
               Onboarded - this resource has already been onboarded by the specified connector.
               NotOnboarded - this resource has not been onboarded to any connector.
               NotApplicable - the onboarding state is not applicable to the current endpoint.
        :param str provisioning_state: The provisioning state of the resource.
               
               Pending - Provisioning pending.
               Failed - Provisioning failed.
               Succeeded - Successful provisioning.
               Canceled - Provisioning canceled.
               PendingDeletion - Deletion pending.
               DeletionSuccess - Deletion successful.
               DeletionFailure - Deletion failure.
        """
        AzureDevOpsOrgPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_status_message=provisioning_status_message,
            provisioning_status_update_time_utc=provisioning_status_update_time_utc,
            actionable_remediation=actionable_remediation,
            onboarding_state=onboarding_state,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_status_message: Optional[str] = None,
             provisioning_status_update_time_utc: Optional[str] = None,
             actionable_remediation: Optional['outputs.ActionableRemediationResponse'] = None,
             onboarding_state: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_status_message is None and 'provisioningStatusMessage' in kwargs:
            provisioning_status_message = kwargs['provisioningStatusMessage']
        if provisioning_status_message is None:
            raise TypeError("Missing 'provisioning_status_message' argument")
        if provisioning_status_update_time_utc is None and 'provisioningStatusUpdateTimeUtc' in kwargs:
            provisioning_status_update_time_utc = kwargs['provisioningStatusUpdateTimeUtc']
        if provisioning_status_update_time_utc is None:
            raise TypeError("Missing 'provisioning_status_update_time_utc' argument")
        if actionable_remediation is None and 'actionableRemediation' in kwargs:
            actionable_remediation = kwargs['actionableRemediation']
        if onboarding_state is None and 'onboardingState' in kwargs:
            onboarding_state = kwargs['onboardingState']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("provisioning_status_message", provisioning_status_message)
        _setter("provisioning_status_update_time_utc", provisioning_status_update_time_utc)
        if actionable_remediation is not None:
            _setter("actionable_remediation", actionable_remediation)
        if onboarding_state is not None:
            _setter("onboarding_state", onboarding_state)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="provisioningStatusMessage")
    def provisioning_status_message(self) -> str:
        """
        Gets or sets resource status message.
        """
        return pulumi.get(self, "provisioning_status_message")

    @property
    @pulumi.getter(name="provisioningStatusUpdateTimeUtc")
    def provisioning_status_update_time_utc(self) -> str:
        """
        Gets or sets time when resource was last checked.
        """
        return pulumi.get(self, "provisioning_status_update_time_utc")

    @property
    @pulumi.getter(name="actionableRemediation")
    def actionable_remediation(self) -> Optional['outputs.ActionableRemediationResponse']:
        """
        Configuration payload for PR Annotations.
        """
        return pulumi.get(self, "actionable_remediation")

    @property
    @pulumi.getter(name="onboardingState")
    def onboarding_state(self) -> Optional[str]:
        """
        Details about resource onboarding status across all connectors.
        
        OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
        Onboarded - this resource has already been onboarded by the specified connector.
        NotOnboarded - this resource has not been onboarded to any connector.
        NotApplicable - the onboarding state is not applicable to the current endpoint.
        """
        return pulumi.get(self, "onboarding_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class AzureDevOpsOrgResponse(dict):
    """
    Azure DevOps Organization resource.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.AzureDevOpsOrgPropertiesResponse'] = None):
        """
        Azure DevOps Organization resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'AzureDevOpsOrgPropertiesResponse' properties: Azure DevOps Organization properties.
        """
        AzureDevOpsOrgResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             system_data: Optional['outputs.SystemDataResponse'] = None,
             type: Optional[str] = None,
             properties: Optional['outputs.AzureDevOpsOrgPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if system_data is None and 'systemData' in kwargs:
            system_data = kwargs['systemData']
        if system_data is None:
            raise TypeError("Missing 'system_data' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.AzureDevOpsOrgPropertiesResponse']:
        """
        Azure DevOps Organization properties.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class AzureDevOpsScopeEnvironmentDataResponse(dict):
    """
    The AzureDevOps scope connector's environment data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDevOpsScopeEnvironmentDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDevOpsScopeEnvironmentDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDevOpsScopeEnvironmentDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: str):
        """
        The AzureDevOps scope connector's environment data
        :param str environment_type: The type of the environment data.
               Expected value is 'AzureDevOpsScope'.
        """
        AzureDevOpsScopeEnvironmentDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_type=environment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")

        _setter("environment_type", 'AzureDevOpsScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        The type of the environment data.
        Expected value is 'AzureDevOpsScope'.
        """
        return pulumi.get(self, "environment_type")


@pulumi.output_type
class AzureResourceDetailsResponse(dict):
    """
    Details of the Azure resource that was assessed
    """
    def __init__(__self__, *,
                 id: str,
                 source: str):
        """
        Details of the Azure resource that was assessed
        :param str id: Azure resource Id of the assessed resource
        :param str source: The platform where the assessed resource resides
               Expected value is 'Azure'.
        """
        AzureResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")

        _setter("id", id)
        _setter("source", 'Azure')

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Azure resource Id of the assessed resource
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'Azure'.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class CategoryConfigurationResponse(dict):
    """
    Severity level per category configuration for PR Annotations.
    """
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 minimum_severity_level: Optional[str] = None):
        """
        Severity level per category configuration for PR Annotations.
        :param str category: Rule categories.
               Code - code scanning results.
               Artifact scanning results.
               Dependencies scanning results.
               IaC results.
               Secrets scanning results.
               Container scanning results.
        :param str minimum_severity_level: Gets or sets minimum severity level for a given category.
        """
        CategoryConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            minimum_severity_level=minimum_severity_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             minimum_severity_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if minimum_severity_level is None and 'minimumSeverityLevel' in kwargs:
            minimum_severity_level = kwargs['minimumSeverityLevel']

        if category is not None:
            _setter("category", category)
        if minimum_severity_level is not None:
            _setter("minimum_severity_level", minimum_severity_level)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Rule categories.
        Code - code scanning results.
        Artifact scanning results.
        Dependencies scanning results.
        IaC results.
        Secrets scanning results.
        Container scanning results.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="minimumSeverityLevel")
    def minimum_severity_level(self) -> Optional[str]:
        """
        Gets or sets minimum severity level for a given category.
        """
        return pulumi.get(self, "minimum_severity_level")


@pulumi.output_type
class CspmMonitorAwsOfferingResponse(dict):
    """
    The CSPM monitoring for AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "nativeCloudConnection":
            suggest = "native_cloud_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 native_cloud_connection: Optional['outputs.CspmMonitorAwsOfferingResponseNativeCloudConnection'] = None):
        """
        The CSPM monitoring for AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'CspmMonitorAws'.
        :param 'CspmMonitorAwsOfferingResponseNativeCloudConnection' native_cloud_connection: The native cloud connection configuration
        """
        CspmMonitorAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            native_cloud_connection=native_cloud_connection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             native_cloud_connection: Optional['outputs.CspmMonitorAwsOfferingResponseNativeCloudConnection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if native_cloud_connection is None and 'nativeCloudConnection' in kwargs:
            native_cloud_connection = kwargs['nativeCloudConnection']

        _setter("description", description)
        _setter("offering_type", 'CspmMonitorAws')
        if native_cloud_connection is not None:
            _setter("native_cloud_connection", native_cloud_connection)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional['outputs.CspmMonitorAwsOfferingResponseNativeCloudConnection']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")


@pulumi.output_type
class CspmMonitorAwsOfferingResponseNativeCloudConnection(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorAwsOfferingResponseNativeCloudConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorAwsOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorAwsOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        CspmMonitorAwsOfferingResponseNativeCloudConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class CspmMonitorAzureDevOpsOfferingResponse(dict):
    """
    The CSPM monitoring for AzureDevOps offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorAzureDevOpsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorAzureDevOpsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorAzureDevOpsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The CSPM monitoring for AzureDevOps offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'CspmMonitorAzureDevOps'.
        """
        CspmMonitorAzureDevOpsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'CspmMonitorAzureDevOps')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorAzureDevOps'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class CspmMonitorGcpOfferingResponse(dict):
    """
    The CSPM monitoring for GCP offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "nativeCloudConnection":
            suggest = "native_cloud_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorGcpOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorGcpOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorGcpOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 native_cloud_connection: Optional['outputs.CspmMonitorGcpOfferingResponseNativeCloudConnection'] = None):
        """
        The CSPM monitoring for GCP offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGcp'.
        :param 'CspmMonitorGcpOfferingResponseNativeCloudConnection' native_cloud_connection: The native cloud connection configuration
        """
        CspmMonitorGcpOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            native_cloud_connection=native_cloud_connection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             native_cloud_connection: Optional['outputs.CspmMonitorGcpOfferingResponseNativeCloudConnection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if native_cloud_connection is None and 'nativeCloudConnection' in kwargs:
            native_cloud_connection = kwargs['nativeCloudConnection']

        _setter("description", description)
        _setter("offering_type", 'CspmMonitorGcp')
        if native_cloud_connection is not None:
            _setter("native_cloud_connection", native_cloud_connection)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGcp'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional['outputs.CspmMonitorGcpOfferingResponseNativeCloudConnection']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")


@pulumi.output_type
class CspmMonitorGcpOfferingResponseNativeCloudConnection(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorGcpOfferingResponseNativeCloudConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorGcpOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorGcpOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str service_account_email_address: The service account email address in GCP for this offering
        :param str workload_identity_provider_id: The GCP workload identity provider id for the offering
        """
        CspmMonitorGcpOfferingResponseNativeCloudConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The GCP workload identity provider id for the offering
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class CspmMonitorGitLabOfferingResponse(dict):
    """
    The CSPM (Cloud security posture management) monitoring for gitlab offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorGitLabOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorGitLabOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorGitLabOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The CSPM (Cloud security posture management) monitoring for gitlab offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGitLab'.
        """
        CspmMonitorGitLabOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'CspmMonitorGitLab')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGitLab'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class CspmMonitorGithubOfferingResponse(dict):
    """
    The CSPM monitoring for github offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspmMonitorGithubOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspmMonitorGithubOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspmMonitorGithubOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The CSPM monitoring for github offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'CspmMonitorGithub'.
        """
        CspmMonitorGithubOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'CspmMonitorGithub')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'CspmMonitorGithub'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class DefenderCspmAwsOfferingResponse(dict):
    """
    The CSPM P1 for AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "dataSensitivityDiscovery":
            suggest = "data_sensitivity_discovery"
        elif key == "databasesDspm":
            suggest = "databases_dspm"
        elif key == "vmScanners":
            suggest = "vm_scanners"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderCspmAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderCspmAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderCspmAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 data_sensitivity_discovery: Optional['outputs.DefenderCspmAwsOfferingResponseDataSensitivityDiscovery'] = None,
                 databases_dspm: Optional['outputs.DefenderCspmAwsOfferingResponseDatabasesDspm'] = None,
                 vm_scanners: Optional['outputs.DefenderCspmAwsOfferingResponseVmScanners'] = None):
        """
        The CSPM P1 for AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderCspmAws'.
        :param 'DefenderCspmAwsOfferingResponseDataSensitivityDiscovery' data_sensitivity_discovery: The Microsoft Defender Data Sensitivity discovery configuration
        :param 'DefenderCspmAwsOfferingResponseDatabasesDspm' databases_dspm: The databases DSPM configuration
        :param 'DefenderCspmAwsOfferingResponseVmScanners' vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        DefenderCspmAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            data_sensitivity_discovery=data_sensitivity_discovery,
            databases_dspm=databases_dspm,
            vm_scanners=vm_scanners,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             data_sensitivity_discovery: Optional['outputs.DefenderCspmAwsOfferingResponseDataSensitivityDiscovery'] = None,
             databases_dspm: Optional['outputs.DefenderCspmAwsOfferingResponseDatabasesDspm'] = None,
             vm_scanners: Optional['outputs.DefenderCspmAwsOfferingResponseVmScanners'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if data_sensitivity_discovery is None and 'dataSensitivityDiscovery' in kwargs:
            data_sensitivity_discovery = kwargs['dataSensitivityDiscovery']
        if databases_dspm is None and 'databasesDspm' in kwargs:
            databases_dspm = kwargs['databasesDspm']
        if vm_scanners is None and 'vmScanners' in kwargs:
            vm_scanners = kwargs['vmScanners']

        _setter("description", description)
        _setter("offering_type", 'DefenderCspmAws')
        if data_sensitivity_discovery is not None:
            _setter("data_sensitivity_discovery", data_sensitivity_discovery)
        if databases_dspm is not None:
            _setter("databases_dspm", databases_dspm)
        if vm_scanners is not None:
            _setter("vm_scanners", vm_scanners)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderCspmAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="dataSensitivityDiscovery")
    def data_sensitivity_discovery(self) -> Optional['outputs.DefenderCspmAwsOfferingResponseDataSensitivityDiscovery']:
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        """
        return pulumi.get(self, "data_sensitivity_discovery")

    @property
    @pulumi.getter(name="databasesDspm")
    def databases_dspm(self) -> Optional['outputs.DefenderCspmAwsOfferingResponseDatabasesDspm']:
        """
        The databases DSPM configuration
        """
        return pulumi.get(self, "databases_dspm")

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional['outputs.DefenderCspmAwsOfferingResponseVmScanners']:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")


@pulumi.output_type
class DefenderCspmAwsOfferingResponseConfiguration(dict):
    """
    configuration for Microsoft Defender for Server VM scanning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"
        elif key == "exclusionTags":
            suggest = "exclusion_tags"
        elif key == "scanningMode":
            suggest = "scanning_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderCspmAwsOfferingResponseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderCspmAwsOfferingResponseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderCspmAwsOfferingResponseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 exclusion_tags: Optional[Mapping[str, str]] = None,
                 scanning_mode: Optional[str] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param Mapping[str, str] exclusion_tags: VM tags that indicates that VM should not be scanned
        :param str scanning_mode: The scanning mode for the VM scan.
        """
        DefenderCspmAwsOfferingResponseConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            exclusion_tags=exclusion_tags,
            scanning_mode=scanning_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             exclusion_tags: Optional[Mapping[str, str]] = None,
             scanning_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']
        if exclusion_tags is None and 'exclusionTags' in kwargs:
            exclusion_tags = kwargs['exclusionTags']
        if scanning_mode is None and 'scanningMode' in kwargs:
            scanning_mode = kwargs['scanningMode']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if exclusion_tags is not None:
            _setter("exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            _setter("scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[Mapping[str, str]]:
        """
        VM tags that indicates that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[str]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")


@pulumi.output_type
class DefenderCspmAwsOfferingResponseDataSensitivityDiscovery(dict):
    """
    The Microsoft Defender Data Sensitivity discovery configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderCspmAwsOfferingResponseDataSensitivityDiscovery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderCspmAwsOfferingResponseDataSensitivityDiscovery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderCspmAwsOfferingResponseDataSensitivityDiscovery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender Data Sensitivity discovery configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param bool enabled: Is Microsoft Defender Data Sensitivity discovery enabled
        """
        DefenderCspmAwsOfferingResponseDataSensitivityDiscovery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender Data Sensitivity discovery enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderCspmAwsOfferingResponseDatabasesDspm(dict):
    """
    The databases DSPM configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderCspmAwsOfferingResponseDatabasesDspm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderCspmAwsOfferingResponseDatabasesDspm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderCspmAwsOfferingResponseDatabasesDspm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        The databases DSPM configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param bool enabled: Is databases DSPM protection enabled
        """
        DefenderCspmAwsOfferingResponseDatabasesDspm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is databases DSPM protection enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderCspmAwsOfferingResponseVmScanners(dict):
    """
    The Microsoft Defender for Server VM scanning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderCspmAwsOfferingResponseConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param 'DefenderCspmAwsOfferingResponseConfiguration' configuration: configuration for Microsoft Defender for Server VM scanning
        :param bool enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        DefenderCspmAwsOfferingResponseVmScanners._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderCspmAwsOfferingResponseConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderCspmAwsOfferingResponseConfiguration']:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderCspmGcpOfferingResponse(dict):
    """
    The CSPM P1 for GCP offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderCspmGcpOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderCspmGcpOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderCspmGcpOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The CSPM P1 for GCP offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderCspmGcp'.
        """
        DefenderCspmGcpOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'DefenderCspmGcp')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderCspmGcp'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class DefenderFoDatabasesAwsOfferingResponse(dict):
    """
    The Defender for Databases AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "arcAutoProvisioning":
            suggest = "arc_auto_provisioning"
        elif key == "databasesDspm":
            suggest = "databases_dspm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderFoDatabasesAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderFoDatabasesAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderFoDatabasesAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 arc_auto_provisioning: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning'] = None,
                 databases_dspm: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseDatabasesDspm'] = None,
                 rds: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseRds'] = None):
        """
        The Defender for Databases AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForDatabasesAws'.
        :param 'DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning' arc_auto_provisioning: The ARC autoprovisioning configuration
        :param 'DefenderFoDatabasesAwsOfferingResponseDatabasesDspm' databases_dspm: The databases data security posture management (DSPM) configuration
        :param 'DefenderFoDatabasesAwsOfferingResponseRds' rds: The RDS configuration
        """
        DefenderFoDatabasesAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            arc_auto_provisioning=arc_auto_provisioning,
            databases_dspm=databases_dspm,
            rds=rds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             arc_auto_provisioning: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning'] = None,
             databases_dspm: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseDatabasesDspm'] = None,
             rds: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseRds'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if arc_auto_provisioning is None and 'arcAutoProvisioning' in kwargs:
            arc_auto_provisioning = kwargs['arcAutoProvisioning']
        if databases_dspm is None and 'databasesDspm' in kwargs:
            databases_dspm = kwargs['databasesDspm']

        _setter("description", description)
        _setter("offering_type", 'DefenderForDatabasesAws')
        if arc_auto_provisioning is not None:
            _setter("arc_auto_provisioning", arc_auto_provisioning)
        if databases_dspm is not None:
            _setter("databases_dspm", databases_dspm)
        if rds is not None:
            _setter("rds", rds)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional['outputs.DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning']:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @property
    @pulumi.getter(name="databasesDspm")
    def databases_dspm(self) -> Optional['outputs.DefenderFoDatabasesAwsOfferingResponseDatabasesDspm']:
        """
        The databases data security posture management (DSPM) configuration
        """
        return pulumi.get(self, "databases_dspm")

    @property
    @pulumi.getter
    def rds(self) -> Optional['outputs.DefenderFoDatabasesAwsOfferingResponseRds']:
        """
        The RDS configuration
        """
        return pulumi.get(self, "rds")


@pulumi.output_type
class DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning(dict):
    """
    The ARC autoprovisioning configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 configuration: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The ARC autoprovisioning configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param 'DefenderFoDatabasesAwsOfferingResponseConfiguration' configuration: Configuration for servers Arc auto provisioning
        :param bool enabled: Is arc auto provisioning enabled
        """
        DefenderFoDatabasesAwsOfferingResponseArcAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             configuration: Optional['outputs.DefenderFoDatabasesAwsOfferingResponseConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderFoDatabasesAwsOfferingResponseConfiguration']:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderFoDatabasesAwsOfferingResponseConfiguration(dict):
    """
    Configuration for servers Arc auto provisioning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkScope":
            suggest = "private_link_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderFoDatabasesAwsOfferingResponseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderFoDatabasesAwsOfferingResponseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderFoDatabasesAwsOfferingResponseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_scope: Optional[str] = None,
                 proxy: Optional[str] = None):
        """
        Configuration for servers Arc auto provisioning
        :param str private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param str proxy: Optional http proxy endpoint to use for the Arc agent
        """
        DefenderFoDatabasesAwsOfferingResponseConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_scope=private_link_scope,
            proxy=proxy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_scope: Optional[str] = None,
             proxy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_scope is None and 'privateLinkScope' in kwargs:
            private_link_scope = kwargs['privateLinkScope']

        if private_link_scope is not None:
            _setter("private_link_scope", private_link_scope)
        if proxy is not None:
            _setter("proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[str]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Optional http proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")


@pulumi.output_type
class DefenderFoDatabasesAwsOfferingResponseDatabasesDspm(dict):
    """
    The databases data security posture management (DSPM) configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderFoDatabasesAwsOfferingResponseDatabasesDspm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderFoDatabasesAwsOfferingResponseDatabasesDspm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderFoDatabasesAwsOfferingResponseDatabasesDspm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        The databases data security posture management (DSPM) configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param bool enabled: Is databases data security posture management (DSPM) protection enabled
        """
        DefenderFoDatabasesAwsOfferingResponseDatabasesDspm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is databases data security posture management (DSPM) protection enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderFoDatabasesAwsOfferingResponseRds(dict):
    """
    The RDS configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderFoDatabasesAwsOfferingResponseRds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderFoDatabasesAwsOfferingResponseRds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderFoDatabasesAwsOfferingResponseRds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        The RDS configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param bool enabled: Is RDS protection enabled
        """
        DefenderFoDatabasesAwsOfferingResponseRds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is RDS protection enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponse(dict):
    """
    The Defender for Containers AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "autoProvisioning":
            suggest = "auto_provisioning"
        elif key == "cloudWatchToKinesis":
            suggest = "cloud_watch_to_kinesis"
        elif key == "containerVulnerabilityAssessment":
            suggest = "container_vulnerability_assessment"
        elif key == "containerVulnerabilityAssessmentTask":
            suggest = "container_vulnerability_assessment_task"
        elif key == "enableContainerVulnerabilityAssessment":
            suggest = "enable_container_vulnerability_assessment"
        elif key == "kinesisToS3":
            suggest = "kinesis_to_s3"
        elif key == "kubeAuditRetentionTime":
            suggest = "kube_audit_retention_time"
        elif key == "kubernetesScubaReader":
            suggest = "kubernetes_scuba_reader"
        elif key == "kubernetesService":
            suggest = "kubernetes_service"
        elif key == "scubaExternalId":
            suggest = "scuba_external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 auto_provisioning: Optional[bool] = None,
                 cloud_watch_to_kinesis: Optional['outputs.DefenderForContainersAwsOfferingResponseCloudWatchToKinesis'] = None,
                 container_vulnerability_assessment: Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment'] = None,
                 container_vulnerability_assessment_task: Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask'] = None,
                 enable_container_vulnerability_assessment: Optional[bool] = None,
                 kinesis_to_s3: Optional['outputs.DefenderForContainersAwsOfferingResponseKinesisToS3'] = None,
                 kube_audit_retention_time: Optional[float] = None,
                 kubernetes_scuba_reader: Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesScubaReader'] = None,
                 kubernetes_service: Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesService'] = None,
                 scuba_external_id: Optional[str] = None):
        """
        The Defender for Containers AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForContainersAws'.
        :param bool auto_provisioning: Is audit logs pipeline auto provisioning enabled
        :param 'DefenderForContainersAwsOfferingResponseCloudWatchToKinesis' cloud_watch_to_kinesis: The cloudwatch to kinesis connection configuration
        :param 'DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment' container_vulnerability_assessment: The container vulnerability assessment configuration
        :param 'DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask' container_vulnerability_assessment_task: The container vulnerability assessment task configuration
        :param bool enable_container_vulnerability_assessment: Enable container vulnerability assessment feature
        :param 'DefenderForContainersAwsOfferingResponseKinesisToS3' kinesis_to_s3: The kinesis to s3 connection configuration
        :param float kube_audit_retention_time: The retention time in days of kube audit logs set on the CloudWatch log group
        :param 'DefenderForContainersAwsOfferingResponseKubernetesScubaReader' kubernetes_scuba_reader: The kubernetes to scuba connection configuration
        :param 'DefenderForContainersAwsOfferingResponseKubernetesService' kubernetes_service: The kubernetes service connection configuration
        :param str scuba_external_id: The externalId used by the data reader to prevent the confused deputy attack
        """
        DefenderForContainersAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            auto_provisioning=auto_provisioning,
            cloud_watch_to_kinesis=cloud_watch_to_kinesis,
            container_vulnerability_assessment=container_vulnerability_assessment,
            container_vulnerability_assessment_task=container_vulnerability_assessment_task,
            enable_container_vulnerability_assessment=enable_container_vulnerability_assessment,
            kinesis_to_s3=kinesis_to_s3,
            kube_audit_retention_time=kube_audit_retention_time,
            kubernetes_scuba_reader=kubernetes_scuba_reader,
            kubernetes_service=kubernetes_service,
            scuba_external_id=scuba_external_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             auto_provisioning: Optional[bool] = None,
             cloud_watch_to_kinesis: Optional['outputs.DefenderForContainersAwsOfferingResponseCloudWatchToKinesis'] = None,
             container_vulnerability_assessment: Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment'] = None,
             container_vulnerability_assessment_task: Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask'] = None,
             enable_container_vulnerability_assessment: Optional[bool] = None,
             kinesis_to_s3: Optional['outputs.DefenderForContainersAwsOfferingResponseKinesisToS3'] = None,
             kube_audit_retention_time: Optional[float] = None,
             kubernetes_scuba_reader: Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesScubaReader'] = None,
             kubernetes_service: Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesService'] = None,
             scuba_external_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if auto_provisioning is None and 'autoProvisioning' in kwargs:
            auto_provisioning = kwargs['autoProvisioning']
        if cloud_watch_to_kinesis is None and 'cloudWatchToKinesis' in kwargs:
            cloud_watch_to_kinesis = kwargs['cloudWatchToKinesis']
        if container_vulnerability_assessment is None and 'containerVulnerabilityAssessment' in kwargs:
            container_vulnerability_assessment = kwargs['containerVulnerabilityAssessment']
        if container_vulnerability_assessment_task is None and 'containerVulnerabilityAssessmentTask' in kwargs:
            container_vulnerability_assessment_task = kwargs['containerVulnerabilityAssessmentTask']
        if enable_container_vulnerability_assessment is None and 'enableContainerVulnerabilityAssessment' in kwargs:
            enable_container_vulnerability_assessment = kwargs['enableContainerVulnerabilityAssessment']
        if kinesis_to_s3 is None and 'kinesisToS3' in kwargs:
            kinesis_to_s3 = kwargs['kinesisToS3']
        if kube_audit_retention_time is None and 'kubeAuditRetentionTime' in kwargs:
            kube_audit_retention_time = kwargs['kubeAuditRetentionTime']
        if kubernetes_scuba_reader is None and 'kubernetesScubaReader' in kwargs:
            kubernetes_scuba_reader = kwargs['kubernetesScubaReader']
        if kubernetes_service is None and 'kubernetesService' in kwargs:
            kubernetes_service = kwargs['kubernetesService']
        if scuba_external_id is None and 'scubaExternalId' in kwargs:
            scuba_external_id = kwargs['scubaExternalId']

        _setter("description", description)
        _setter("offering_type", 'DefenderForContainersAws')
        if auto_provisioning is not None:
            _setter("auto_provisioning", auto_provisioning)
        if cloud_watch_to_kinesis is not None:
            _setter("cloud_watch_to_kinesis", cloud_watch_to_kinesis)
        if container_vulnerability_assessment is not None:
            _setter("container_vulnerability_assessment", container_vulnerability_assessment)
        if container_vulnerability_assessment_task is not None:
            _setter("container_vulnerability_assessment_task", container_vulnerability_assessment_task)
        if enable_container_vulnerability_assessment is not None:
            _setter("enable_container_vulnerability_assessment", enable_container_vulnerability_assessment)
        if kinesis_to_s3 is not None:
            _setter("kinesis_to_s3", kinesis_to_s3)
        if kube_audit_retention_time is not None:
            _setter("kube_audit_retention_time", kube_audit_retention_time)
        if kubernetes_scuba_reader is not None:
            _setter("kubernetes_scuba_reader", kubernetes_scuba_reader)
        if kubernetes_service is not None:
            _setter("kubernetes_service", kubernetes_service)
        if scuba_external_id is not None:
            _setter("scuba_external_id", scuba_external_id)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="autoProvisioning")
    def auto_provisioning(self) -> Optional[bool]:
        """
        Is audit logs pipeline auto provisioning enabled
        """
        return pulumi.get(self, "auto_provisioning")

    @property
    @pulumi.getter(name="cloudWatchToKinesis")
    def cloud_watch_to_kinesis(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseCloudWatchToKinesis']:
        """
        The cloudwatch to kinesis connection configuration
        """
        return pulumi.get(self, "cloud_watch_to_kinesis")

    @property
    @pulumi.getter(name="containerVulnerabilityAssessment")
    def container_vulnerability_assessment(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment']:
        """
        The container vulnerability assessment configuration
        """
        return pulumi.get(self, "container_vulnerability_assessment")

    @property
    @pulumi.getter(name="containerVulnerabilityAssessmentTask")
    def container_vulnerability_assessment_task(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask']:
        """
        The container vulnerability assessment task configuration
        """
        return pulumi.get(self, "container_vulnerability_assessment_task")

    @property
    @pulumi.getter(name="enableContainerVulnerabilityAssessment")
    def enable_container_vulnerability_assessment(self) -> Optional[bool]:
        """
        Enable container vulnerability assessment feature
        """
        return pulumi.get(self, "enable_container_vulnerability_assessment")

    @property
    @pulumi.getter(name="kinesisToS3")
    def kinesis_to_s3(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseKinesisToS3']:
        """
        The kinesis to s3 connection configuration
        """
        return pulumi.get(self, "kinesis_to_s3")

    @property
    @pulumi.getter(name="kubeAuditRetentionTime")
    def kube_audit_retention_time(self) -> Optional[float]:
        """
        The retention time in days of kube audit logs set on the CloudWatch log group
        """
        return pulumi.get(self, "kube_audit_retention_time")

    @property
    @pulumi.getter(name="kubernetesScubaReader")
    def kubernetes_scuba_reader(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesScubaReader']:
        """
        The kubernetes to scuba connection configuration
        """
        return pulumi.get(self, "kubernetes_scuba_reader")

    @property
    @pulumi.getter(name="kubernetesService")
    def kubernetes_service(self) -> Optional['outputs.DefenderForContainersAwsOfferingResponseKubernetesService']:
        """
        The kubernetes service connection configuration
        """
        return pulumi.get(self, "kubernetes_service")

    @property
    @pulumi.getter(name="scubaExternalId")
    def scuba_external_id(self) -> Optional[str]:
        """
        The externalId used by the data reader to prevent the confused deputy attack
        """
        return pulumi.get(self, "scuba_external_id")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseCloudWatchToKinesis(dict):
    """
    The cloudwatch to kinesis connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseCloudWatchToKinesis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseCloudWatchToKinesis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseCloudWatchToKinesis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The cloudwatch to kinesis connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS used by CloudWatch to transfer data into Kinesis
        """
        DefenderForContainersAwsOfferingResponseCloudWatchToKinesis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS used by CloudWatch to transfer data into Kinesis
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment(dict):
    """
    The container vulnerability assessment configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The container vulnerability assessment configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask(dict):
    """
    The container vulnerability assessment task configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The container vulnerability assessment task configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        DefenderForContainersAwsOfferingResponseContainerVulnerabilityAssessmentTask._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseKinesisToS3(dict):
    """
    The kinesis to s3 connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseKinesisToS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseKinesisToS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseKinesisToS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The kinesis to s3 connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS used by Kinesis to transfer data into S3
        """
        DefenderForContainersAwsOfferingResponseKinesisToS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS used by Kinesis to transfer data into S3
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseKubernetesScubaReader(dict):
    """
    The kubernetes to scuba connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseKubernetesScubaReader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseKubernetesScubaReader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseKubernetesScubaReader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The kubernetes to scuba connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature used for reading data
        """
        DefenderForContainersAwsOfferingResponseKubernetesScubaReader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature used for reading data
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersAwsOfferingResponseKubernetesService(dict):
    """
    The kubernetes service connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersAwsOfferingResponseKubernetesService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersAwsOfferingResponseKubernetesService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersAwsOfferingResponseKubernetesService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The kubernetes service connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature used for provisioning resources
        """
        DefenderForContainersAwsOfferingResponseKubernetesService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature used for provisioning resources
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForContainersGcpOfferingResponse(dict):
    """
    The containers GCP offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "auditLogsAutoProvisioningFlag":
            suggest = "audit_logs_auto_provisioning_flag"
        elif key == "dataPipelineNativeCloudConnection":
            suggest = "data_pipeline_native_cloud_connection"
        elif key == "defenderAgentAutoProvisioningFlag":
            suggest = "defender_agent_auto_provisioning_flag"
        elif key == "nativeCloudConnection":
            suggest = "native_cloud_connection"
        elif key == "policyAgentAutoProvisioningFlag":
            suggest = "policy_agent_auto_provisioning_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersGcpOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersGcpOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersGcpOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 audit_logs_auto_provisioning_flag: Optional[bool] = None,
                 data_pipeline_native_cloud_connection: Optional['outputs.DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection'] = None,
                 defender_agent_auto_provisioning_flag: Optional[bool] = None,
                 native_cloud_connection: Optional['outputs.DefenderForContainersGcpOfferingResponseNativeCloudConnection'] = None,
                 policy_agent_auto_provisioning_flag: Optional[bool] = None):
        """
        The containers GCP offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForContainersGcp'.
        :param bool audit_logs_auto_provisioning_flag: Is audit logs data collection enabled
        :param 'DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection' data_pipeline_native_cloud_connection: The native cloud connection configuration
        :param bool defender_agent_auto_provisioning_flag: Is Microsoft Defender for Cloud Kubernetes agent auto provisioning enabled
        :param 'DefenderForContainersGcpOfferingResponseNativeCloudConnection' native_cloud_connection: The native cloud connection configuration
        :param bool policy_agent_auto_provisioning_flag: Is Policy Kubernetes agent auto provisioning enabled
        """
        DefenderForContainersGcpOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            audit_logs_auto_provisioning_flag=audit_logs_auto_provisioning_flag,
            data_pipeline_native_cloud_connection=data_pipeline_native_cloud_connection,
            defender_agent_auto_provisioning_flag=defender_agent_auto_provisioning_flag,
            native_cloud_connection=native_cloud_connection,
            policy_agent_auto_provisioning_flag=policy_agent_auto_provisioning_flag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             audit_logs_auto_provisioning_flag: Optional[bool] = None,
             data_pipeline_native_cloud_connection: Optional['outputs.DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection'] = None,
             defender_agent_auto_provisioning_flag: Optional[bool] = None,
             native_cloud_connection: Optional['outputs.DefenderForContainersGcpOfferingResponseNativeCloudConnection'] = None,
             policy_agent_auto_provisioning_flag: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if audit_logs_auto_provisioning_flag is None and 'auditLogsAutoProvisioningFlag' in kwargs:
            audit_logs_auto_provisioning_flag = kwargs['auditLogsAutoProvisioningFlag']
        if data_pipeline_native_cloud_connection is None and 'dataPipelineNativeCloudConnection' in kwargs:
            data_pipeline_native_cloud_connection = kwargs['dataPipelineNativeCloudConnection']
        if defender_agent_auto_provisioning_flag is None and 'defenderAgentAutoProvisioningFlag' in kwargs:
            defender_agent_auto_provisioning_flag = kwargs['defenderAgentAutoProvisioningFlag']
        if native_cloud_connection is None and 'nativeCloudConnection' in kwargs:
            native_cloud_connection = kwargs['nativeCloudConnection']
        if policy_agent_auto_provisioning_flag is None and 'policyAgentAutoProvisioningFlag' in kwargs:
            policy_agent_auto_provisioning_flag = kwargs['policyAgentAutoProvisioningFlag']

        _setter("description", description)
        _setter("offering_type", 'DefenderForContainersGcp')
        if audit_logs_auto_provisioning_flag is not None:
            _setter("audit_logs_auto_provisioning_flag", audit_logs_auto_provisioning_flag)
        if data_pipeline_native_cloud_connection is not None:
            _setter("data_pipeline_native_cloud_connection", data_pipeline_native_cloud_connection)
        if defender_agent_auto_provisioning_flag is not None:
            _setter("defender_agent_auto_provisioning_flag", defender_agent_auto_provisioning_flag)
        if native_cloud_connection is not None:
            _setter("native_cloud_connection", native_cloud_connection)
        if policy_agent_auto_provisioning_flag is not None:
            _setter("policy_agent_auto_provisioning_flag", policy_agent_auto_provisioning_flag)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForContainersGcp'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="auditLogsAutoProvisioningFlag")
    def audit_logs_auto_provisioning_flag(self) -> Optional[bool]:
        """
        Is audit logs data collection enabled
        """
        return pulumi.get(self, "audit_logs_auto_provisioning_flag")

    @property
    @pulumi.getter(name="dataPipelineNativeCloudConnection")
    def data_pipeline_native_cloud_connection(self) -> Optional['outputs.DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "data_pipeline_native_cloud_connection")

    @property
    @pulumi.getter(name="defenderAgentAutoProvisioningFlag")
    def defender_agent_auto_provisioning_flag(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Cloud Kubernetes agent auto provisioning enabled
        """
        return pulumi.get(self, "defender_agent_auto_provisioning_flag")

    @property
    @pulumi.getter(name="nativeCloudConnection")
    def native_cloud_connection(self) -> Optional['outputs.DefenderForContainersGcpOfferingResponseNativeCloudConnection']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "native_cloud_connection")

    @property
    @pulumi.getter(name="policyAgentAutoProvisioningFlag")
    def policy_agent_auto_provisioning_flag(self) -> Optional[bool]:
        """
        Is Policy Kubernetes agent auto provisioning enabled
        """
        return pulumi.get(self, "policy_agent_auto_provisioning_flag")


@pulumi.output_type
class DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str service_account_email_address: The data collection service account email address in GCP for this offering
        :param str workload_identity_provider_id: The data collection GCP workload identity provider id for this offering
        """
        DefenderForContainersGcpOfferingResponseDataPipelineNativeCloudConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The data collection service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The data collection GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class DefenderForContainersGcpOfferingResponseNativeCloudConnection(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForContainersGcpOfferingResponseNativeCloudConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForContainersGcpOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForContainersGcpOfferingResponseNativeCloudConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str service_account_email_address: The service account email address in GCP for this offering
        :param str workload_identity_provider_id: The GCP workload identity provider id for this offering
        """
        DefenderForContainersGcpOfferingResponseNativeCloudConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class DefenderForDatabasesGcpOfferingResponse(dict):
    """
    The Defender for Databases GCP offering configurations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "arcAutoProvisioning":
            suggest = "arc_auto_provisioning"
        elif key == "defenderForDatabasesArcAutoProvisioning":
            suggest = "defender_for_databases_arc_auto_provisioning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDatabasesGcpOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDatabasesGcpOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDatabasesGcpOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 arc_auto_provisioning: Optional['outputs.DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning'] = None,
                 defender_for_databases_arc_auto_provisioning: Optional['outputs.DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning'] = None):
        """
        The Defender for Databases GCP offering configurations
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForDatabasesGcp'.
        :param 'DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning' arc_auto_provisioning: The ARC autoprovisioning configuration
        :param 'DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning' defender_for_databases_arc_auto_provisioning: The native cloud connection configuration
        """
        DefenderForDatabasesGcpOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            arc_auto_provisioning=arc_auto_provisioning,
            defender_for_databases_arc_auto_provisioning=defender_for_databases_arc_auto_provisioning,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             arc_auto_provisioning: Optional['outputs.DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning'] = None,
             defender_for_databases_arc_auto_provisioning: Optional['outputs.DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if arc_auto_provisioning is None and 'arcAutoProvisioning' in kwargs:
            arc_auto_provisioning = kwargs['arcAutoProvisioning']
        if defender_for_databases_arc_auto_provisioning is None and 'defenderForDatabasesArcAutoProvisioning' in kwargs:
            defender_for_databases_arc_auto_provisioning = kwargs['defenderForDatabasesArcAutoProvisioning']

        _setter("description", description)
        _setter("offering_type", 'DefenderForDatabasesGcp')
        if arc_auto_provisioning is not None:
            _setter("arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_databases_arc_auto_provisioning is not None:
            _setter("defender_for_databases_arc_auto_provisioning", defender_for_databases_arc_auto_provisioning)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForDatabasesGcp'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional['outputs.DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning']:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @property
    @pulumi.getter(name="defenderForDatabasesArcAutoProvisioning")
    def defender_for_databases_arc_auto_provisioning(self) -> Optional['outputs.DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "defender_for_databases_arc_auto_provisioning")


@pulumi.output_type
class DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning(dict):
    """
    The ARC autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForDatabasesGcpOfferingResponseConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The ARC autoprovisioning configuration
        :param 'DefenderForDatabasesGcpOfferingResponseConfiguration' configuration: Configuration for servers Arc auto provisioning
        :param bool enabled: Is arc auto provisioning enabled
        """
        DefenderForDatabasesGcpOfferingResponseArcAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForDatabasesGcpOfferingResponseConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForDatabasesGcpOfferingResponseConfiguration']:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForDatabasesGcpOfferingResponseConfiguration(dict):
    """
    Configuration for servers Arc auto provisioning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkScope":
            suggest = "private_link_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDatabasesGcpOfferingResponseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDatabasesGcpOfferingResponseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDatabasesGcpOfferingResponseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_scope: Optional[str] = None,
                 proxy: Optional[str] = None):
        """
        Configuration for servers Arc auto provisioning
        :param str private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param str proxy: Optional http proxy endpoint to use for the Arc agent
        """
        DefenderForDatabasesGcpOfferingResponseConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_scope=private_link_scope,
            proxy=proxy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_scope: Optional[str] = None,
             proxy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_scope is None and 'privateLinkScope' in kwargs:
            private_link_scope = kwargs['privateLinkScope']

        if private_link_scope is not None:
            _setter("private_link_scope", private_link_scope)
        if proxy is not None:
            _setter("proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[str]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Optional http proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")


@pulumi.output_type
class DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str service_account_email_address: The service account email address in GCP for this offering
        :param str workload_identity_provider_id: The GCP workload identity provider id for this offering
        """
        DefenderForDatabasesGcpOfferingResponseDefenderForDatabasesArcAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The service account email address in GCP for this offering
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The GCP workload identity provider id for this offering
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class DefenderForDevOpsAzureDevOpsOfferingResponse(dict):
    """
    The Defender for DevOps for Azure DevOps offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDevOpsAzureDevOpsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDevOpsAzureDevOpsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDevOpsAzureDevOpsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The Defender for DevOps for Azure DevOps offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsAzureDevOps'.
        """
        DefenderForDevOpsAzureDevOpsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'DefenderForDevOpsAzureDevOps')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsAzureDevOps'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class DefenderForDevOpsGitLabOfferingResponse(dict):
    """
    The Defender for DevOps for Gitlab offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDevOpsGitLabOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDevOpsGitLabOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDevOpsGitLabOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The Defender for DevOps for Gitlab offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsGitLab'.
        """
        DefenderForDevOpsGitLabOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'DefenderForDevOpsGitLab')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGitLab'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class DefenderForDevOpsGithubOfferingResponse(dict):
    """
    The Defender for DevOps for Github offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForDevOpsGithubOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForDevOpsGithubOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForDevOpsGithubOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str):
        """
        The Defender for DevOps for Github offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForDevOpsGithub'.
        """
        DefenderForDevOpsGithubOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")

        _setter("description", description)
        _setter("offering_type", 'DefenderForDevOpsGithub')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForDevOpsGithub'.
        """
        return pulumi.get(self, "offering_type")


@pulumi.output_type
class DefenderForServersAwsOfferingResponse(dict):
    """
    The Defender for Servers AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "arcAutoProvisioning":
            suggest = "arc_auto_provisioning"
        elif key == "defenderForServers":
            suggest = "defender_for_servers"
        elif key == "mdeAutoProvisioning":
            suggest = "mde_auto_provisioning"
        elif key == "subPlan":
            suggest = "sub_plan"
        elif key == "vaAutoProvisioning":
            suggest = "va_auto_provisioning"
        elif key == "vmScanners":
            suggest = "vm_scanners"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 arc_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseArcAutoProvisioning'] = None,
                 defender_for_servers: Optional['outputs.DefenderForServersAwsOfferingResponseDefenderForServers'] = None,
                 mde_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseMdeAutoProvisioning'] = None,
                 sub_plan: Optional['outputs.DefenderForServersAwsOfferingResponseSubPlan'] = None,
                 va_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseVaAutoProvisioning'] = None,
                 vm_scanners: Optional['outputs.DefenderForServersAwsOfferingResponseVmScanners'] = None):
        """
        The Defender for Servers AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForServersAws'.
        :param 'DefenderForServersAwsOfferingResponseArcAutoProvisioning' arc_auto_provisioning: The ARC autoprovisioning configuration
        :param 'DefenderForServersAwsOfferingResponseDefenderForServers' defender_for_servers: The Defender for servers connection configuration
        :param 'DefenderForServersAwsOfferingResponseMdeAutoProvisioning' mde_auto_provisioning: The Microsoft Defender for Endpoint autoprovisioning configuration
        :param 'DefenderForServersAwsOfferingResponseSubPlan' sub_plan: configuration for the servers offering subPlan
        :param 'DefenderForServersAwsOfferingResponseVaAutoProvisioning' va_auto_provisioning: The Vulnerability Assessment autoprovisioning configuration
        :param 'DefenderForServersAwsOfferingResponseVmScanners' vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        DefenderForServersAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            arc_auto_provisioning=arc_auto_provisioning,
            defender_for_servers=defender_for_servers,
            mde_auto_provisioning=mde_auto_provisioning,
            sub_plan=sub_plan,
            va_auto_provisioning=va_auto_provisioning,
            vm_scanners=vm_scanners,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             arc_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseArcAutoProvisioning'] = None,
             defender_for_servers: Optional['outputs.DefenderForServersAwsOfferingResponseDefenderForServers'] = None,
             mde_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseMdeAutoProvisioning'] = None,
             sub_plan: Optional['outputs.DefenderForServersAwsOfferingResponseSubPlan'] = None,
             va_auto_provisioning: Optional['outputs.DefenderForServersAwsOfferingResponseVaAutoProvisioning'] = None,
             vm_scanners: Optional['outputs.DefenderForServersAwsOfferingResponseVmScanners'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if arc_auto_provisioning is None and 'arcAutoProvisioning' in kwargs:
            arc_auto_provisioning = kwargs['arcAutoProvisioning']
        if defender_for_servers is None and 'defenderForServers' in kwargs:
            defender_for_servers = kwargs['defenderForServers']
        if mde_auto_provisioning is None and 'mdeAutoProvisioning' in kwargs:
            mde_auto_provisioning = kwargs['mdeAutoProvisioning']
        if sub_plan is None and 'subPlan' in kwargs:
            sub_plan = kwargs['subPlan']
        if va_auto_provisioning is None and 'vaAutoProvisioning' in kwargs:
            va_auto_provisioning = kwargs['vaAutoProvisioning']
        if vm_scanners is None and 'vmScanners' in kwargs:
            vm_scanners = kwargs['vmScanners']

        _setter("description", description)
        _setter("offering_type", 'DefenderForServersAws')
        if arc_auto_provisioning is not None:
            _setter("arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_servers is not None:
            _setter("defender_for_servers", defender_for_servers)
        if mde_auto_provisioning is not None:
            _setter("mde_auto_provisioning", mde_auto_provisioning)
        if sub_plan is not None:
            _setter("sub_plan", sub_plan)
        if va_auto_provisioning is not None:
            _setter("va_auto_provisioning", va_auto_provisioning)
        if vm_scanners is not None:
            _setter("vm_scanners", vm_scanners)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForServersAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseArcAutoProvisioning']:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @property
    @pulumi.getter(name="defenderForServers")
    def defender_for_servers(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseDefenderForServers']:
        """
        The Defender for servers connection configuration
        """
        return pulumi.get(self, "defender_for_servers")

    @property
    @pulumi.getter(name="mdeAutoProvisioning")
    def mde_auto_provisioning(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseMdeAutoProvisioning']:
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        return pulumi.get(self, "mde_auto_provisioning")

    @property
    @pulumi.getter(name="subPlan")
    def sub_plan(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseSubPlan']:
        """
        configuration for the servers offering subPlan
        """
        return pulumi.get(self, "sub_plan")

    @property
    @pulumi.getter(name="vaAutoProvisioning")
    def va_auto_provisioning(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseVaAutoProvisioning']:
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        return pulumi.get(self, "va_auto_provisioning")

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseVmScanners']:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseArcAutoProvisioning(dict):
    """
    The ARC autoprovisioning configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersAwsOfferingResponseArcAutoProvisioning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersAwsOfferingResponseArcAutoProvisioning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersAwsOfferingResponseArcAutoProvisioning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The ARC autoprovisioning configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param 'DefenderForServersAwsOfferingResponseConfiguration' configuration: Configuration for servers Arc auto provisioning
        :param bool enabled: Is arc auto provisioning enabled
        """
        DefenderForServersAwsOfferingResponseArcAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseConfiguration']:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseConfiguration(dict):
    """
    Configuration for servers Arc auto provisioning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkScope":
            suggest = "private_link_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersAwsOfferingResponseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersAwsOfferingResponseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersAwsOfferingResponseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_scope: Optional[str] = None,
                 proxy: Optional[str] = None):
        """
        Configuration for servers Arc auto provisioning
        :param str private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param str proxy: Optional HTTP proxy endpoint to use for the Arc agent
        """
        DefenderForServersAwsOfferingResponseConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_scope=private_link_scope,
            proxy=proxy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_scope: Optional[str] = None,
             proxy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_scope is None and 'privateLinkScope' in kwargs:
            private_link_scope = kwargs['privateLinkScope']

        if private_link_scope is not None:
            _setter("private_link_scope", private_link_scope)
        if proxy is not None:
            _setter("proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[str]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseConfigurationConfiguration(dict):
    """
    configuration for Vulnerability Assessment autoprovisioning
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        configuration for Vulnerability Assessment autoprovisioning
        :param str type: The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        DefenderForServersAwsOfferingResponseConfigurationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration(dict):
    """
    configuration for Microsoft Defender for Server VM scanning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"
        elif key == "exclusionTags":
            suggest = "exclusion_tags"
        elif key == "scanningMode":
            suggest = "scanning_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None,
                 exclusion_tags: Optional[Mapping[str, str]] = None,
                 scanning_mode: Optional[str] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        :param Mapping[str, str] exclusion_tags: VM tags that indicates that VM should not be scanned
        :param str scanning_mode: The scanning mode for the VM scan.
        """
        DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
            exclusion_tags=exclusion_tags,
            scanning_mode=scanning_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             exclusion_tags: Optional[Mapping[str, str]] = None,
             scanning_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']
        if exclusion_tags is None and 'exclusionTags' in kwargs:
            exclusion_tags = kwargs['exclusionTags']
        if scanning_mode is None and 'scanningMode' in kwargs:
            scanning_mode = kwargs['scanningMode']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)
        if exclusion_tags is not None:
            _setter("exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            _setter("scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[Mapping[str, str]]:
        """
        VM tags that indicates that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[str]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseDefenderForServers(dict):
    """
    The Defender for servers connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersAwsOfferingResponseDefenderForServers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersAwsOfferingResponseDefenderForServers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersAwsOfferingResponseDefenderForServers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The Defender for servers connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        DefenderForServersAwsOfferingResponseDefenderForServers._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseMdeAutoProvisioning(dict):
    """
    The Microsoft Defender for Endpoint autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional[Any] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        :param Any configuration: configuration for Microsoft Defender for Endpoint autoprovisioning
        :param bool enabled: Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        DefenderForServersAwsOfferingResponseMdeAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional[Any] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseSubPlan(dict):
    """
    configuration for the servers offering subPlan
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        configuration for the servers offering subPlan
        :param str type: The available sub plans
        """
        DefenderForServersAwsOfferingResponseSubPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The available sub plans
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseVaAutoProvisioning(dict):
    """
    The Vulnerability Assessment autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The Vulnerability Assessment autoprovisioning configuration
        :param 'DefenderForServersAwsOfferingResponseConfigurationConfiguration' configuration: configuration for Vulnerability Assessment autoprovisioning
        :param bool enabled: Is Vulnerability Assessment auto provisioning enabled
        """
        DefenderForServersAwsOfferingResponseVaAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfiguration']:
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersAwsOfferingResponseVmScanners(dict):
    """
    The Microsoft Defender for Server VM scanning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param 'DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration' configuration: configuration for Microsoft Defender for Server VM scanning
        :param bool enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        DefenderForServersAwsOfferingResponseVmScanners._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersAwsOfferingResponseConfigurationConfigurationConfiguration']:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersGcpOfferingResponse(dict):
    """
    The Defender for Servers GCP offering configurations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "arcAutoProvisioning":
            suggest = "arc_auto_provisioning"
        elif key == "defenderForServers":
            suggest = "defender_for_servers"
        elif key == "mdeAutoProvisioning":
            suggest = "mde_auto_provisioning"
        elif key == "subPlan":
            suggest = "sub_plan"
        elif key == "vaAutoProvisioning":
            suggest = "va_auto_provisioning"
        elif key == "vmScanners":
            suggest = "vm_scanners"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersGcpOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersGcpOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersGcpOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 arc_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseArcAutoProvisioning'] = None,
                 defender_for_servers: Optional['outputs.DefenderForServersGcpOfferingResponseDefenderForServers'] = None,
                 mde_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseMdeAutoProvisioning'] = None,
                 sub_plan: Optional['outputs.DefenderForServersGcpOfferingResponseSubPlan'] = None,
                 va_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseVaAutoProvisioning'] = None,
                 vm_scanners: Optional['outputs.DefenderForServersGcpOfferingResponseVmScanners'] = None):
        """
        The Defender for Servers GCP offering configurations
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'DefenderForServersGcp'.
        :param 'DefenderForServersGcpOfferingResponseArcAutoProvisioning' arc_auto_provisioning: The ARC autoprovisioning configuration
        :param 'DefenderForServersGcpOfferingResponseDefenderForServers' defender_for_servers: The Defender for servers connection configuration
        :param 'DefenderForServersGcpOfferingResponseMdeAutoProvisioning' mde_auto_provisioning: The Microsoft Defender for Endpoint autoprovisioning configuration
        :param 'DefenderForServersGcpOfferingResponseSubPlan' sub_plan: configuration for the servers offering subPlan
        :param 'DefenderForServersGcpOfferingResponseVaAutoProvisioning' va_auto_provisioning: The Vulnerability Assessment autoprovisioning configuration
        :param 'DefenderForServersGcpOfferingResponseVmScanners' vm_scanners: The Microsoft Defender for Server VM scanning configuration
        """
        DefenderForServersGcpOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            arc_auto_provisioning=arc_auto_provisioning,
            defender_for_servers=defender_for_servers,
            mde_auto_provisioning=mde_auto_provisioning,
            sub_plan=sub_plan,
            va_auto_provisioning=va_auto_provisioning,
            vm_scanners=vm_scanners,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             arc_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseArcAutoProvisioning'] = None,
             defender_for_servers: Optional['outputs.DefenderForServersGcpOfferingResponseDefenderForServers'] = None,
             mde_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseMdeAutoProvisioning'] = None,
             sub_plan: Optional['outputs.DefenderForServersGcpOfferingResponseSubPlan'] = None,
             va_auto_provisioning: Optional['outputs.DefenderForServersGcpOfferingResponseVaAutoProvisioning'] = None,
             vm_scanners: Optional['outputs.DefenderForServersGcpOfferingResponseVmScanners'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if arc_auto_provisioning is None and 'arcAutoProvisioning' in kwargs:
            arc_auto_provisioning = kwargs['arcAutoProvisioning']
        if defender_for_servers is None and 'defenderForServers' in kwargs:
            defender_for_servers = kwargs['defenderForServers']
        if mde_auto_provisioning is None and 'mdeAutoProvisioning' in kwargs:
            mde_auto_provisioning = kwargs['mdeAutoProvisioning']
        if sub_plan is None and 'subPlan' in kwargs:
            sub_plan = kwargs['subPlan']
        if va_auto_provisioning is None and 'vaAutoProvisioning' in kwargs:
            va_auto_provisioning = kwargs['vaAutoProvisioning']
        if vm_scanners is None and 'vmScanners' in kwargs:
            vm_scanners = kwargs['vmScanners']

        _setter("description", description)
        _setter("offering_type", 'DefenderForServersGcp')
        if arc_auto_provisioning is not None:
            _setter("arc_auto_provisioning", arc_auto_provisioning)
        if defender_for_servers is not None:
            _setter("defender_for_servers", defender_for_servers)
        if mde_auto_provisioning is not None:
            _setter("mde_auto_provisioning", mde_auto_provisioning)
        if sub_plan is not None:
            _setter("sub_plan", sub_plan)
        if va_auto_provisioning is not None:
            _setter("va_auto_provisioning", va_auto_provisioning)
        if vm_scanners is not None:
            _setter("vm_scanners", vm_scanners)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'DefenderForServersGcp'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="arcAutoProvisioning")
    def arc_auto_provisioning(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseArcAutoProvisioning']:
        """
        The ARC autoprovisioning configuration
        """
        return pulumi.get(self, "arc_auto_provisioning")

    @property
    @pulumi.getter(name="defenderForServers")
    def defender_for_servers(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseDefenderForServers']:
        """
        The Defender for servers connection configuration
        """
        return pulumi.get(self, "defender_for_servers")

    @property
    @pulumi.getter(name="mdeAutoProvisioning")
    def mde_auto_provisioning(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseMdeAutoProvisioning']:
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        """
        return pulumi.get(self, "mde_auto_provisioning")

    @property
    @pulumi.getter(name="subPlan")
    def sub_plan(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseSubPlan']:
        """
        configuration for the servers offering subPlan
        """
        return pulumi.get(self, "sub_plan")

    @property
    @pulumi.getter(name="vaAutoProvisioning")
    def va_auto_provisioning(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseVaAutoProvisioning']:
        """
        The Vulnerability Assessment autoprovisioning configuration
        """
        return pulumi.get(self, "va_auto_provisioning")

    @property
    @pulumi.getter(name="vmScanners")
    def vm_scanners(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseVmScanners']:
        """
        The Microsoft Defender for Server VM scanning configuration
        """
        return pulumi.get(self, "vm_scanners")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseArcAutoProvisioning(dict):
    """
    The ARC autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The ARC autoprovisioning configuration
        :param 'DefenderForServersGcpOfferingResponseConfiguration' configuration: Configuration for servers Arc auto provisioning
        :param bool enabled: Is arc auto provisioning enabled
        """
        DefenderForServersGcpOfferingResponseArcAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseConfiguration']:
        """
        Configuration for servers Arc auto provisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is arc auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseConfiguration(dict):
    """
    Configuration for servers Arc auto provisioning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkScope":
            suggest = "private_link_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersGcpOfferingResponseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersGcpOfferingResponseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersGcpOfferingResponseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_scope: Optional[str] = None,
                 proxy: Optional[str] = None):
        """
        Configuration for servers Arc auto provisioning
        :param str private_link_scope: Optional Arc private link scope resource id to link the Arc agent
        :param str proxy: Optional HTTP proxy endpoint to use for the Arc agent
        """
        DefenderForServersGcpOfferingResponseConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_link_scope=private_link_scope,
            proxy=proxy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_link_scope: Optional[str] = None,
             proxy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_link_scope is None and 'privateLinkScope' in kwargs:
            private_link_scope = kwargs['privateLinkScope']

        if private_link_scope is not None:
            _setter("private_link_scope", private_link_scope)
        if proxy is not None:
            _setter("proxy", proxy)

    @property
    @pulumi.getter(name="privateLinkScope")
    def private_link_scope(self) -> Optional[str]:
        """
        Optional Arc private link scope resource id to link the Arc agent
        """
        return pulumi.get(self, "private_link_scope")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Optional HTTP proxy endpoint to use for the Arc agent
        """
        return pulumi.get(self, "proxy")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseConfigurationConfiguration(dict):
    """
    configuration for Vulnerability Assessment autoprovisioning
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        configuration for Vulnerability Assessment autoprovisioning
        :param str type: The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        DefenderForServersGcpOfferingResponseConfigurationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration(dict):
    """
    configuration for Microsoft Defender for Server VM scanning
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exclusionTags":
            suggest = "exclusion_tags"
        elif key == "scanningMode":
            suggest = "scanning_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclusion_tags: Optional[Mapping[str, str]] = None,
                 scanning_mode: Optional[str] = None):
        """
        configuration for Microsoft Defender for Server VM scanning
        :param Mapping[str, str] exclusion_tags: VM tags that indicate that VM should not be scanned
        :param str scanning_mode: The scanning mode for the VM scan.
        """
        DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusion_tags=exclusion_tags,
            scanning_mode=scanning_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusion_tags: Optional[Mapping[str, str]] = None,
             scanning_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exclusion_tags is None and 'exclusionTags' in kwargs:
            exclusion_tags = kwargs['exclusionTags']
        if scanning_mode is None and 'scanningMode' in kwargs:
            scanning_mode = kwargs['scanningMode']

        if exclusion_tags is not None:
            _setter("exclusion_tags", exclusion_tags)
        if scanning_mode is not None:
            _setter("scanning_mode", scanning_mode)

    @property
    @pulumi.getter(name="exclusionTags")
    def exclusion_tags(self) -> Optional[Mapping[str, str]]:
        """
        VM tags that indicate that VM should not be scanned
        """
        return pulumi.get(self, "exclusion_tags")

    @property
    @pulumi.getter(name="scanningMode")
    def scanning_mode(self) -> Optional[str]:
        """
        The scanning mode for the VM scan.
        """
        return pulumi.get(self, "scanning_mode")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseDefenderForServers(dict):
    """
    The Defender for servers connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefenderForServersGcpOfferingResponseDefenderForServers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefenderForServersGcpOfferingResponseDefenderForServers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefenderForServersGcpOfferingResponseDefenderForServers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The Defender for servers connection configuration
        :param str service_account_email_address: The service account email address in GCP for this feature
        :param str workload_identity_provider_id: The workload identity provider id in GCP for this feature
        """
        DefenderForServersGcpOfferingResponseDefenderForServers._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The service account email address in GCP for this feature
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The workload identity provider id in GCP for this feature
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseMdeAutoProvisioning(dict):
    """
    The Microsoft Defender for Endpoint autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional[Any] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender for Endpoint autoprovisioning configuration
        :param Any configuration: configuration for Microsoft Defender for Endpoint autoprovisioning
        :param bool enabled: Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        DefenderForServersGcpOfferingResponseMdeAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional[Any] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        configuration for Microsoft Defender for Endpoint autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Endpoint auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseSubPlan(dict):
    """
    configuration for the servers offering subPlan
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        configuration for the servers offering subPlan
        :param str type: The available sub plans
        """
        DefenderForServersGcpOfferingResponseSubPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The available sub plans
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseVaAutoProvisioning(dict):
    """
    The Vulnerability Assessment autoprovisioning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The Vulnerability Assessment autoprovisioning configuration
        :param 'DefenderForServersGcpOfferingResponseConfigurationConfiguration' configuration: configuration for Vulnerability Assessment autoprovisioning
        :param bool enabled: Is Vulnerability Assessment auto provisioning enabled
        """
        DefenderForServersGcpOfferingResponseVaAutoProvisioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfiguration']:
        """
        configuration for Vulnerability Assessment autoprovisioning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Vulnerability Assessment auto provisioning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefenderForServersGcpOfferingResponseVmScanners(dict):
    """
    The Microsoft Defender for Server VM scanning configuration
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        The Microsoft Defender for Server VM scanning configuration
        :param 'DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration' configuration: configuration for Microsoft Defender for Server VM scanning
        :param bool enabled: Is Microsoft Defender for Server VM scanning enabled
        """
        DefenderForServersGcpOfferingResponseVmScanners._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.DefenderForServersGcpOfferingResponseConfigurationConfigurationConfiguration']:
        """
        configuration for Microsoft Defender for Server VM scanning
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is Microsoft Defender for Server VM scanning enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DenylistCustomAlertRuleResponse(dict):
    """
    A custom alert rule that checks if a value (depends on the custom alert type) is denied.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "denylistValues":
            suggest = "denylist_values"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DenylistCustomAlertRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DenylistCustomAlertRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DenylistCustomAlertRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 denylist_values: Sequence[str],
                 description: str,
                 display_name: str,
                 is_enabled: bool,
                 rule_type: str,
                 value_type: str):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is denied.
        :param Sequence[str] denylist_values: The values to deny. The format of the values depends on the rule type.
        :param str description: The description of the custom alert.
        :param str display_name: The display name of the custom alert.
        :param bool is_enabled: Status of the custom alert.
        :param str rule_type: The type of the custom alert rule.
               Expected value is 'DenylistCustomAlertRule'.
        :param str value_type: The value type of the items in the list.
        """
        DenylistCustomAlertRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            denylist_values=denylist_values,
            description=description,
            display_name=display_name,
            is_enabled=is_enabled,
            rule_type=rule_type,
            value_type=value_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             denylist_values: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             rule_type: Optional[str] = None,
             value_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if denylist_values is None and 'denylistValues' in kwargs:
            denylist_values = kwargs['denylistValues']
        if denylist_values is None:
            raise TypeError("Missing 'denylist_values' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if rule_type is None and 'ruleType' in kwargs:
            rule_type = kwargs['ruleType']
        if rule_type is None:
            raise TypeError("Missing 'rule_type' argument")
        if value_type is None and 'valueType' in kwargs:
            value_type = kwargs['valueType']
        if value_type is None:
            raise TypeError("Missing 'value_type' argument")

        _setter("denylist_values", denylist_values)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("is_enabled", is_enabled)
        _setter("rule_type", 'DenylistCustomAlertRule')
        _setter("value_type", value_type)

    @property
    @pulumi.getter(name="denylistValues")
    def denylist_values(self) -> Sequence[str]:
        """
        The values to deny. The format of the values depends on the rule type.
        """
        return pulumi.get(self, "denylist_values")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the custom alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the custom alert.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the custom alert rule.
        Expected value is 'DenylistCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        The value type of the items in the list.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class DevOpsConfigurationPropertiesResponse(dict):
    """
    DevOps Configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningStatusMessage":
            suggest = "provisioning_status_message"
        elif key == "provisioningStatusUpdateTimeUtc":
            suggest = "provisioning_status_update_time_utc"
        elif key == "autoDiscovery":
            suggest = "auto_discovery"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "topLevelInventoryList":
            suggest = "top_level_inventory_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevOpsConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevOpsConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevOpsConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_status_message: str,
                 provisioning_status_update_time_utc: str,
                 authorization: Optional['outputs.AuthorizationResponse'] = None,
                 auto_discovery: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 top_level_inventory_list: Optional[Sequence[str]] = None):
        """
        DevOps Configuration properties.
        :param str provisioning_status_message: Gets or sets resource status message.
        :param str provisioning_status_update_time_utc: Gets or sets time when resource was last checked.
        :param 'AuthorizationResponse' authorization: Authorization payload.
        :param str auto_discovery: AutoDiscovery states.
        :param str provisioning_state: The provisioning state of the resource.
               
               Pending - Provisioning pending.
               Failed - Provisioning failed.
               Succeeded - Successful provisioning.
               Canceled - Provisioning canceled.
               PendingDeletion - Deletion pending.
               DeletionSuccess - Deletion successful.
               DeletionFailure - Deletion failure.
        :param Sequence[str] top_level_inventory_list: List of top-level inventory to select when AutoDiscovery is disabled.
               This field is ignored when AutoDiscovery is enabled.
        """
        DevOpsConfigurationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_status_message=provisioning_status_message,
            provisioning_status_update_time_utc=provisioning_status_update_time_utc,
            authorization=authorization,
            auto_discovery=auto_discovery,
            provisioning_state=provisioning_state,
            top_level_inventory_list=top_level_inventory_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_status_message: Optional[str] = None,
             provisioning_status_update_time_utc: Optional[str] = None,
             authorization: Optional['outputs.AuthorizationResponse'] = None,
             auto_discovery: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             top_level_inventory_list: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_status_message is None and 'provisioningStatusMessage' in kwargs:
            provisioning_status_message = kwargs['provisioningStatusMessage']
        if provisioning_status_message is None:
            raise TypeError("Missing 'provisioning_status_message' argument")
        if provisioning_status_update_time_utc is None and 'provisioningStatusUpdateTimeUtc' in kwargs:
            provisioning_status_update_time_utc = kwargs['provisioningStatusUpdateTimeUtc']
        if provisioning_status_update_time_utc is None:
            raise TypeError("Missing 'provisioning_status_update_time_utc' argument")
        if auto_discovery is None and 'autoDiscovery' in kwargs:
            auto_discovery = kwargs['autoDiscovery']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if top_level_inventory_list is None and 'topLevelInventoryList' in kwargs:
            top_level_inventory_list = kwargs['topLevelInventoryList']

        _setter("provisioning_status_message", provisioning_status_message)
        _setter("provisioning_status_update_time_utc", provisioning_status_update_time_utc)
        if authorization is not None:
            _setter("authorization", authorization)
        if auto_discovery is not None:
            _setter("auto_discovery", auto_discovery)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if top_level_inventory_list is not None:
            _setter("top_level_inventory_list", top_level_inventory_list)

    @property
    @pulumi.getter(name="provisioningStatusMessage")
    def provisioning_status_message(self) -> str:
        """
        Gets or sets resource status message.
        """
        return pulumi.get(self, "provisioning_status_message")

    @property
    @pulumi.getter(name="provisioningStatusUpdateTimeUtc")
    def provisioning_status_update_time_utc(self) -> str:
        """
        Gets or sets time when resource was last checked.
        """
        return pulumi.get(self, "provisioning_status_update_time_utc")

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.AuthorizationResponse']:
        """
        Authorization payload.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="autoDiscovery")
    def auto_discovery(self) -> Optional[str]:
        """
        AutoDiscovery states.
        """
        return pulumi.get(self, "auto_discovery")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="topLevelInventoryList")
    def top_level_inventory_list(self) -> Optional[Sequence[str]]:
        """
        List of top-level inventory to select when AutoDiscovery is disabled.
        This field is ignored when AutoDiscovery is enabled.
        """
        return pulumi.get(self, "top_level_inventory_list")


@pulumi.output_type
class GcpCredentialsDetailsPropertiesResponse(dict):
    """
    GCP cloud account connector based service to service credentials, the credentials are composed of the organization ID and a JSON API key (write only)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "authenticationProvisioningState":
            suggest = "authentication_provisioning_state"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "grantedPermissions":
            suggest = "granted_permissions"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpCredentialsDetailsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpCredentialsDetailsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpCredentialsDetailsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_provider_x509_cert_url: str,
                 auth_uri: str,
                 authentication_provisioning_state: str,
                 authentication_type: str,
                 client_email: str,
                 client_id: str,
                 client_x509_cert_url: str,
                 granted_permissions: Sequence[str],
                 organization_id: str,
                 private_key: str,
                 private_key_id: str,
                 project_id: str,
                 token_uri: str,
                 type: str):
        """
        GCP cloud account connector based service to service credentials, the credentials are composed of the organization ID and a JSON API key (write only)
        :param str auth_provider_x509_cert_url: Auth provider x509 certificate URL field of the API key (write only)
        :param str auth_uri: Auth URI field of the API key (write only)
        :param str authentication_provisioning_state: State of the multi-cloud connector
        :param str authentication_type: Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
               Expected value is 'gcpCredentials'.
        :param str client_email: Client email field of the API key (write only)
        :param str client_id: Client ID field of the API key (write only)
        :param str client_x509_cert_url: Client x509 certificate URL field of the API key (write only)
        :param Sequence[str] granted_permissions: The permissions detected in the cloud account.
        :param str organization_id: The organization ID of the GCP cloud account
        :param str private_key: Private key field of the API key (write only)
        :param str private_key_id: Private key ID field of the API key (write only)
        :param str project_id: Project ID field of the API key (write only)
        :param str token_uri: Token URI field of the API key (write only)
        :param str type: Type field of the API key (write only)
        """
        GcpCredentialsDetailsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_provider_x509_cert_url=auth_provider_x509_cert_url,
            auth_uri=auth_uri,
            authentication_provisioning_state=authentication_provisioning_state,
            authentication_type=authentication_type,
            client_email=client_email,
            client_id=client_id,
            client_x509_cert_url=client_x509_cert_url,
            granted_permissions=granted_permissions,
            organization_id=organization_id,
            private_key=private_key,
            private_key_id=private_key_id,
            project_id=project_id,
            token_uri=token_uri,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_provider_x509_cert_url: Optional[str] = None,
             auth_uri: Optional[str] = None,
             authentication_provisioning_state: Optional[str] = None,
             authentication_type: Optional[str] = None,
             client_email: Optional[str] = None,
             client_id: Optional[str] = None,
             client_x509_cert_url: Optional[str] = None,
             granted_permissions: Optional[Sequence[str]] = None,
             organization_id: Optional[str] = None,
             private_key: Optional[str] = None,
             private_key_id: Optional[str] = None,
             project_id: Optional[str] = None,
             token_uri: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_provider_x509_cert_url is None and 'authProviderX509CertUrl' in kwargs:
            auth_provider_x509_cert_url = kwargs['authProviderX509CertUrl']
        if auth_provider_x509_cert_url is None:
            raise TypeError("Missing 'auth_provider_x509_cert_url' argument")
        if auth_uri is None and 'authUri' in kwargs:
            auth_uri = kwargs['authUri']
        if auth_uri is None:
            raise TypeError("Missing 'auth_uri' argument")
        if authentication_provisioning_state is None and 'authenticationProvisioningState' in kwargs:
            authentication_provisioning_state = kwargs['authenticationProvisioningState']
        if authentication_provisioning_state is None:
            raise TypeError("Missing 'authentication_provisioning_state' argument")
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if client_email is None and 'clientEmail' in kwargs:
            client_email = kwargs['clientEmail']
        if client_email is None:
            raise TypeError("Missing 'client_email' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_x509_cert_url is None and 'clientX509CertUrl' in kwargs:
            client_x509_cert_url = kwargs['clientX509CertUrl']
        if client_x509_cert_url is None:
            raise TypeError("Missing 'client_x509_cert_url' argument")
        if granted_permissions is None and 'grantedPermissions' in kwargs:
            granted_permissions = kwargs['grantedPermissions']
        if granted_permissions is None:
            raise TypeError("Missing 'granted_permissions' argument")
        if organization_id is None and 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if organization_id is None:
            raise TypeError("Missing 'organization_id' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")
        if private_key_id is None and 'privateKeyId' in kwargs:
            private_key_id = kwargs['privateKeyId']
        if private_key_id is None:
            raise TypeError("Missing 'private_key_id' argument")
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")
        if token_uri is None and 'tokenUri' in kwargs:
            token_uri = kwargs['tokenUri']
        if token_uri is None:
            raise TypeError("Missing 'token_uri' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        _setter("auth_uri", auth_uri)
        _setter("authentication_provisioning_state", authentication_provisioning_state)
        _setter("authentication_type", 'gcpCredentials')
        _setter("client_email", client_email)
        _setter("client_id", client_id)
        _setter("client_x509_cert_url", client_x509_cert_url)
        _setter("granted_permissions", granted_permissions)
        _setter("organization_id", organization_id)
        _setter("private_key", private_key)
        _setter("private_key_id", private_key_id)
        _setter("project_id", project_id)
        _setter("token_uri", token_uri)
        _setter("type", type)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> str:
        """
        Auth provider x509 certificate URL field of the API key (write only)
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> str:
        """
        Auth URI field of the API key (write only)
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="authenticationProvisioningState")
    def authentication_provisioning_state(self) -> str:
        """
        State of the multi-cloud connector
        """
        return pulumi.get(self, "authentication_provisioning_state")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Connect to your cloud account, for AWS use either account credentials or role-based authentication. For GCP use account organization credentials.
        Expected value is 'gcpCredentials'.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Client email field of the API key (write only)
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID field of the API key (write only)
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> str:
        """
        Client x509 certificate URL field of the API key (write only)
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="grantedPermissions")
    def granted_permissions(self) -> Sequence[str]:
        """
        The permissions detected in the cloud account.
        """
        return pulumi.get(self, "granted_permissions")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID of the GCP cloud account
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private key field of the API key (write only)
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> str:
        """
        Private key ID field of the API key (write only)
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID field of the API key (write only)
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> str:
        """
        Token URI field of the API key (write only)
        """
        return pulumi.get(self, "token_uri")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type field of the API key (write only)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpOrganizationalDataMemberResponse(dict):
    """
    The gcpOrganization data for the member account
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationMembershipType":
            suggest = "organization_membership_type"
        elif key == "managementProjectNumber":
            suggest = "management_project_number"
        elif key == "parentHierarchyId":
            suggest = "parent_hierarchy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpOrganizationalDataMemberResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpOrganizationalDataMemberResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpOrganizationalDataMemberResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organization_membership_type: str,
                 management_project_number: Optional[str] = None,
                 parent_hierarchy_id: Optional[str] = None):
        """
        The gcpOrganization data for the member account
        :param str organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Member'.
        :param str management_project_number: The GCP management project number from organizational onboarding
        :param str parent_hierarchy_id: If the multi cloud account is not of membership type organization, this will be the ID of the project's parent
        """
        GcpOrganizationalDataMemberResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            organization_membership_type=organization_membership_type,
            management_project_number=management_project_number,
            parent_hierarchy_id=parent_hierarchy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             organization_membership_type: Optional[str] = None,
             management_project_number: Optional[str] = None,
             parent_hierarchy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if organization_membership_type is None and 'organizationMembershipType' in kwargs:
            organization_membership_type = kwargs['organizationMembershipType']
        if organization_membership_type is None:
            raise TypeError("Missing 'organization_membership_type' argument")
        if management_project_number is None and 'managementProjectNumber' in kwargs:
            management_project_number = kwargs['managementProjectNumber']
        if parent_hierarchy_id is None and 'parentHierarchyId' in kwargs:
            parent_hierarchy_id = kwargs['parentHierarchyId']

        _setter("organization_membership_type", 'Member')
        if management_project_number is not None:
            _setter("management_project_number", management_project_number)
        if parent_hierarchy_id is not None:
            _setter("parent_hierarchy_id", parent_hierarchy_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> str:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Member'.
        """
        return pulumi.get(self, "organization_membership_type")

    @property
    @pulumi.getter(name="managementProjectNumber")
    def management_project_number(self) -> Optional[str]:
        """
        The GCP management project number from organizational onboarding
        """
        return pulumi.get(self, "management_project_number")

    @property
    @pulumi.getter(name="parentHierarchyId")
    def parent_hierarchy_id(self) -> Optional[str]:
        """
        If the multi cloud account is not of membership type organization, this will be the ID of the project's parent
        """
        return pulumi.get(self, "parent_hierarchy_id")


@pulumi.output_type
class GcpOrganizationalDataOrganizationResponse(dict):
    """
    The gcpOrganization data for the parent account
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationMembershipType":
            suggest = "organization_membership_type"
        elif key == "organizationName":
            suggest = "organization_name"
        elif key == "excludedProjectNumbers":
            suggest = "excluded_project_numbers"
        elif key == "serviceAccountEmailAddress":
            suggest = "service_account_email_address"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpOrganizationalDataOrganizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpOrganizationalDataOrganizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpOrganizationalDataOrganizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organization_membership_type: str,
                 organization_name: str,
                 excluded_project_numbers: Optional[Sequence[str]] = None,
                 service_account_email_address: Optional[str] = None,
                 workload_identity_provider_id: Optional[str] = None):
        """
        The gcpOrganization data for the parent account
        :param str organization_membership_type: The multi cloud account's membership type in the organization
               Expected value is 'Organization'.
        :param str organization_name: GCP organization name
        :param Sequence[str] excluded_project_numbers: If the multi cloud account is of membership type organization, list of accounts excluded from offering
        :param str service_account_email_address: The service account email address which represents the organization level permissions container.
        :param str workload_identity_provider_id: The GCP workload identity provider id which represents the permissions required to auto provision security connectors
        """
        GcpOrganizationalDataOrganizationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            organization_membership_type=organization_membership_type,
            organization_name=organization_name,
            excluded_project_numbers=excluded_project_numbers,
            service_account_email_address=service_account_email_address,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             organization_membership_type: Optional[str] = None,
             organization_name: Optional[str] = None,
             excluded_project_numbers: Optional[Sequence[str]] = None,
             service_account_email_address: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if organization_membership_type is None and 'organizationMembershipType' in kwargs:
            organization_membership_type = kwargs['organizationMembershipType']
        if organization_membership_type is None:
            raise TypeError("Missing 'organization_membership_type' argument")
        if organization_name is None and 'organizationName' in kwargs:
            organization_name = kwargs['organizationName']
        if organization_name is None:
            raise TypeError("Missing 'organization_name' argument")
        if excluded_project_numbers is None and 'excludedProjectNumbers' in kwargs:
            excluded_project_numbers = kwargs['excludedProjectNumbers']
        if service_account_email_address is None and 'serviceAccountEmailAddress' in kwargs:
            service_account_email_address = kwargs['serviceAccountEmailAddress']
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']

        _setter("organization_membership_type", 'Organization')
        _setter("organization_name", organization_name)
        if excluded_project_numbers is not None:
            _setter("excluded_project_numbers", excluded_project_numbers)
        if service_account_email_address is not None:
            _setter("service_account_email_address", service_account_email_address)
        if workload_identity_provider_id is not None:
            _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="organizationMembershipType")
    def organization_membership_type(self) -> str:
        """
        The multi cloud account's membership type in the organization
        Expected value is 'Organization'.
        """
        return pulumi.get(self, "organization_membership_type")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> str:
        """
        GCP organization name
        """
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter(name="excludedProjectNumbers")
    def excluded_project_numbers(self) -> Optional[Sequence[str]]:
        """
        If the multi cloud account is of membership type organization, list of accounts excluded from offering
        """
        return pulumi.get(self, "excluded_project_numbers")

    @property
    @pulumi.getter(name="serviceAccountEmailAddress")
    def service_account_email_address(self) -> Optional[str]:
        """
        The service account email address which represents the organization level permissions container.
        """
        return pulumi.get(self, "service_account_email_address")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> Optional[str]:
        """
        The GCP workload identity provider id which represents the permissions required to auto provision security connectors
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class GcpProjectDetailsResponse(dict):
    """
    The details about the project represented by the security connector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectName":
            suggest = "project_name"
        elif key == "workloadIdentityPoolId":
            suggest = "workload_identity_pool_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "projectNumber":
            suggest = "project_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpProjectDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpProjectDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpProjectDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_name: str,
                 workload_identity_pool_id: str,
                 project_id: Optional[str] = None,
                 project_number: Optional[str] = None):
        """
        The details about the project represented by the security connector
        :param str project_name: GCP project name
        :param str workload_identity_pool_id: The GCP workload identity federation pool id
        :param str project_id: The GCP Project id
        :param str project_number: The unique GCP Project number
        """
        GcpProjectDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_name=project_name,
            workload_identity_pool_id=workload_identity_pool_id,
            project_id=project_id,
            project_number=project_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_name: Optional[str] = None,
             workload_identity_pool_id: Optional[str] = None,
             project_id: Optional[str] = None,
             project_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project_name is None and 'projectName' in kwargs:
            project_name = kwargs['projectName']
        if project_name is None:
            raise TypeError("Missing 'project_name' argument")
        if workload_identity_pool_id is None and 'workloadIdentityPoolId' in kwargs:
            workload_identity_pool_id = kwargs['workloadIdentityPoolId']
        if workload_identity_pool_id is None:
            raise TypeError("Missing 'workload_identity_pool_id' argument")
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_number is None and 'projectNumber' in kwargs:
            project_number = kwargs['projectNumber']

        _setter("project_name", project_name)
        _setter("workload_identity_pool_id", workload_identity_pool_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if project_number is not None:
            _setter("project_number", project_number)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        GCP project name
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="workloadIdentityPoolId")
    def workload_identity_pool_id(self) -> str:
        """
        The GCP workload identity federation pool id
        """
        return pulumi.get(self, "workload_identity_pool_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The GCP Project id
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> Optional[str]:
        """
        The unique GCP Project number
        """
        return pulumi.get(self, "project_number")


@pulumi.output_type
class GcpProjectEnvironmentDataResponse(dict):
    """
    The GCP project connector environment data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"
        elif key == "organizationalData":
            suggest = "organizational_data"
        elif key == "projectDetails":
            suggest = "project_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpProjectEnvironmentDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpProjectEnvironmentDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpProjectEnvironmentDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: str,
                 organizational_data: Optional[Any] = None,
                 project_details: Optional['outputs.GcpProjectDetailsResponse'] = None):
        """
        The GCP project connector environment data
        :param str environment_type: The type of the environment data.
               Expected value is 'GcpProject'.
        :param Union['GcpOrganizationalDataMemberResponse', 'GcpOrganizationalDataOrganizationResponse'] organizational_data: The Gcp project's organizational data
        :param 'GcpProjectDetailsResponse' project_details: The Gcp project's details
        """
        GcpProjectEnvironmentDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_type=environment_type,
            organizational_data=organizational_data,
            project_details=project_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_type: Optional[str] = None,
             organizational_data: Optional[Any] = None,
             project_details: Optional['outputs.GcpProjectDetailsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")
        if organizational_data is None and 'organizationalData' in kwargs:
            organizational_data = kwargs['organizationalData']
        if project_details is None and 'projectDetails' in kwargs:
            project_details = kwargs['projectDetails']

        _setter("environment_type", 'GcpProject')
        if organizational_data is not None:
            _setter("organizational_data", organizational_data)
        if project_details is not None:
            _setter("project_details", project_details)

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        The type of the environment data.
        Expected value is 'GcpProject'.
        """
        return pulumi.get(self, "environment_type")

    @property
    @pulumi.getter(name="organizationalData")
    def organizational_data(self) -> Optional[Any]:
        """
        The Gcp project's organizational data
        """
        return pulumi.get(self, "organizational_data")

    @property
    @pulumi.getter(name="projectDetails")
    def project_details(self) -> Optional['outputs.GcpProjectDetailsResponse']:
        """
        The Gcp project's details
        """
        return pulumi.get(self, "project_details")


@pulumi.output_type
class GitHubOwnerPropertiesResponse(dict):
    """
    GitHub Owner properties.
    """
    def __init__(__self__, *,
                 git_hub_internal_id: str,
                 owner_url: str,
                 provisioning_status_message: str,
                 provisioning_status_update_time_utc: str,
                 onboarding_state: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        GitHub Owner properties.
        :param str git_hub_internal_id: Gets or sets internal GitHub id.
        :param str owner_url: Gets or sets GitHub Owner url.
        :param str provisioning_status_message: Gets or sets resource status message.
        :param str provisioning_status_update_time_utc: Gets or sets time when resource was last checked.
        :param str onboarding_state: Details about resource onboarding status across all connectors.
               
               OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
               Onboarded - this resource has already been onboarded by the specified connector.
               NotOnboarded - this resource has not been onboarded to any connector.
               NotApplicable - the onboarding state is not applicable to the current endpoint.
        :param str provisioning_state: The provisioning state of the resource.
               
               Pending - Provisioning pending.
               Failed - Provisioning failed.
               Succeeded - Successful provisioning.
               Canceled - Provisioning canceled.
               PendingDeletion - Deletion pending.
               DeletionSuccess - Deletion successful.
               DeletionFailure - Deletion failure.
        """
        GitHubOwnerPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            git_hub_internal_id=git_hub_internal_id,
            owner_url=owner_url,
            provisioning_status_message=provisioning_status_message,
            provisioning_status_update_time_utc=provisioning_status_update_time_utc,
            onboarding_state=onboarding_state,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             git_hub_internal_id: Optional[str] = None,
             owner_url: Optional[str] = None,
             provisioning_status_message: Optional[str] = None,
             provisioning_status_update_time_utc: Optional[str] = None,
             onboarding_state: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if git_hub_internal_id is None and 'gitHubInternalId' in kwargs:
            git_hub_internal_id = kwargs['gitHubInternalId']
        if git_hub_internal_id is None:
            raise TypeError("Missing 'git_hub_internal_id' argument")
        if owner_url is None and 'ownerUrl' in kwargs:
            owner_url = kwargs['ownerUrl']
        if owner_url is None:
            raise TypeError("Missing 'owner_url' argument")
        if provisioning_status_message is None and 'provisioningStatusMessage' in kwargs:
            provisioning_status_message = kwargs['provisioningStatusMessage']
        if provisioning_status_message is None:
            raise TypeError("Missing 'provisioning_status_message' argument")
        if provisioning_status_update_time_utc is None and 'provisioningStatusUpdateTimeUtc' in kwargs:
            provisioning_status_update_time_utc = kwargs['provisioningStatusUpdateTimeUtc']
        if provisioning_status_update_time_utc is None:
            raise TypeError("Missing 'provisioning_status_update_time_utc' argument")
        if onboarding_state is None and 'onboardingState' in kwargs:
            onboarding_state = kwargs['onboardingState']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("git_hub_internal_id", git_hub_internal_id)
        _setter("owner_url", owner_url)
        _setter("provisioning_status_message", provisioning_status_message)
        _setter("provisioning_status_update_time_utc", provisioning_status_update_time_utc)
        if onboarding_state is not None:
            _setter("onboarding_state", onboarding_state)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="gitHubInternalId")
    def git_hub_internal_id(self) -> str:
        """
        Gets or sets internal GitHub id.
        """
        return pulumi.get(self, "git_hub_internal_id")

    @property
    @pulumi.getter(name="ownerUrl")
    def owner_url(self) -> str:
        """
        Gets or sets GitHub Owner url.
        """
        return pulumi.get(self, "owner_url")

    @property
    @pulumi.getter(name="provisioningStatusMessage")
    def provisioning_status_message(self) -> str:
        """
        Gets or sets resource status message.
        """
        return pulumi.get(self, "provisioning_status_message")

    @property
    @pulumi.getter(name="provisioningStatusUpdateTimeUtc")
    def provisioning_status_update_time_utc(self) -> str:
        """
        Gets or sets time when resource was last checked.
        """
        return pulumi.get(self, "provisioning_status_update_time_utc")

    @property
    @pulumi.getter(name="onboardingState")
    def onboarding_state(self) -> Optional[str]:
        """
        Details about resource onboarding status across all connectors.
        
        OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
        Onboarded - this resource has already been onboarded by the specified connector.
        NotOnboarded - this resource has not been onboarded to any connector.
        NotApplicable - the onboarding state is not applicable to the current endpoint.
        """
        return pulumi.get(self, "onboarding_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class GitHubOwnerResponse(dict):
    """
    GitHub Owner resource.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.GitHubOwnerPropertiesResponse'] = None):
        """
        GitHub Owner resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'GitHubOwnerPropertiesResponse' properties: GitHub Owner properties.
        """
        GitHubOwnerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             system_data: Optional['outputs.SystemDataResponse'] = None,
             type: Optional[str] = None,
             properties: Optional['outputs.GitHubOwnerPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if system_data is None and 'systemData' in kwargs:
            system_data = kwargs['systemData']
        if system_data is None:
            raise TypeError("Missing 'system_data' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.GitHubOwnerPropertiesResponse']:
        """
        GitHub Owner properties.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GitLabGroupPropertiesResponse(dict):
    """
    GitLab Group properties.
    """
    def __init__(__self__, *,
                 fully_qualified_friendly_name: str,
                 fully_qualified_name: str,
                 provisioning_status_message: str,
                 provisioning_status_update_time_utc: str,
                 url: str,
                 onboarding_state: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        GitLab Group properties.
        :param str fully_qualified_friendly_name: Gets or sets the human readable fully-qualified name of the Group object.
               
               This contains the entire namespace hierarchy as seen on GitLab UI where namespaces are separated by the '/' character.
        :param str fully_qualified_name: Gets or sets the fully-qualified name of the Group object.
               
               This contains the entire namespace hierarchy where namespaces are separated by the '$' character.
        :param str provisioning_status_message: Gets or sets resource status message.
        :param str provisioning_status_update_time_utc: Gets or sets time when resource was last checked.
        :param str url: Gets or sets the url of the GitLab Group.
        :param str onboarding_state: Details about resource onboarding status across all connectors.
               
               OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
               Onboarded - this resource has already been onboarded by the specified connector.
               NotOnboarded - this resource has not been onboarded to any connector.
               NotApplicable - the onboarding state is not applicable to the current endpoint.
        :param str provisioning_state: The provisioning state of the resource.
               
               Pending - Provisioning pending.
               Failed - Provisioning failed.
               Succeeded - Successful provisioning.
               Canceled - Provisioning canceled.
               PendingDeletion - Deletion pending.
               DeletionSuccess - Deletion successful.
               DeletionFailure - Deletion failure.
        """
        GitLabGroupPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fully_qualified_friendly_name=fully_qualified_friendly_name,
            fully_qualified_name=fully_qualified_name,
            provisioning_status_message=provisioning_status_message,
            provisioning_status_update_time_utc=provisioning_status_update_time_utc,
            url=url,
            onboarding_state=onboarding_state,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fully_qualified_friendly_name: Optional[str] = None,
             fully_qualified_name: Optional[str] = None,
             provisioning_status_message: Optional[str] = None,
             provisioning_status_update_time_utc: Optional[str] = None,
             url: Optional[str] = None,
             onboarding_state: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fully_qualified_friendly_name is None and 'fullyQualifiedFriendlyName' in kwargs:
            fully_qualified_friendly_name = kwargs['fullyQualifiedFriendlyName']
        if fully_qualified_friendly_name is None:
            raise TypeError("Missing 'fully_qualified_friendly_name' argument")
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if provisioning_status_message is None and 'provisioningStatusMessage' in kwargs:
            provisioning_status_message = kwargs['provisioningStatusMessage']
        if provisioning_status_message is None:
            raise TypeError("Missing 'provisioning_status_message' argument")
        if provisioning_status_update_time_utc is None and 'provisioningStatusUpdateTimeUtc' in kwargs:
            provisioning_status_update_time_utc = kwargs['provisioningStatusUpdateTimeUtc']
        if provisioning_status_update_time_utc is None:
            raise TypeError("Missing 'provisioning_status_update_time_utc' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if onboarding_state is None and 'onboardingState' in kwargs:
            onboarding_state = kwargs['onboardingState']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("fully_qualified_friendly_name", fully_qualified_friendly_name)
        _setter("fully_qualified_name", fully_qualified_name)
        _setter("provisioning_status_message", provisioning_status_message)
        _setter("provisioning_status_update_time_utc", provisioning_status_update_time_utc)
        _setter("url", url)
        if onboarding_state is not None:
            _setter("onboarding_state", onboarding_state)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="fullyQualifiedFriendlyName")
    def fully_qualified_friendly_name(self) -> str:
        """
        Gets or sets the human readable fully-qualified name of the Group object.
        
        This contains the entire namespace hierarchy as seen on GitLab UI where namespaces are separated by the '/' character.
        """
        return pulumi.get(self, "fully_qualified_friendly_name")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        """
        Gets or sets the fully-qualified name of the Group object.
        
        This contains the entire namespace hierarchy where namespaces are separated by the '$' character.
        """
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="provisioningStatusMessage")
    def provisioning_status_message(self) -> str:
        """
        Gets or sets resource status message.
        """
        return pulumi.get(self, "provisioning_status_message")

    @property
    @pulumi.getter(name="provisioningStatusUpdateTimeUtc")
    def provisioning_status_update_time_utc(self) -> str:
        """
        Gets or sets time when resource was last checked.
        """
        return pulumi.get(self, "provisioning_status_update_time_utc")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Gets or sets the url of the GitLab Group.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="onboardingState")
    def onboarding_state(self) -> Optional[str]:
        """
        Details about resource onboarding status across all connectors.
        
        OnboardedByOtherConnector - this resource has already been onboarded to another connector. This is only applicable to top-level resources.
        Onboarded - this resource has already been onboarded by the specified connector.
        NotOnboarded - this resource has not been onboarded to any connector.
        NotApplicable - the onboarding state is not applicable to the current endpoint.
        """
        return pulumi.get(self, "onboarding_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        
        Pending - Provisioning pending.
        Failed - Provisioning failed.
        Succeeded - Successful provisioning.
        Canceled - Provisioning canceled.
        PendingDeletion - Deletion pending.
        DeletionSuccess - Deletion successful.
        DeletionFailure - Deletion failure.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class GitLabGroupResponse(dict):
    """
    GitLab Group resource.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.GitLabGroupPropertiesResponse'] = None):
        """
        GitLab Group resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'GitLabGroupPropertiesResponse' properties: GitLab Group properties.
        """
        GitLabGroupResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             system_data: Optional['outputs.SystemDataResponse'] = None,
             type: Optional[str] = None,
             properties: Optional['outputs.GitLabGroupPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if system_data is None and 'systemData' in kwargs:
            system_data = kwargs['systemData']
        if system_data is None:
            raise TypeError("Missing 'system_data' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.GitLabGroupPropertiesResponse']:
        """
        GitLab Group properties.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GithubScopeEnvironmentDataResponse(dict):
    """
    The github scope connector's environment data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubScopeEnvironmentDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubScopeEnvironmentDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubScopeEnvironmentDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: str):
        """
        The github scope connector's environment data
        :param str environment_type: The type of the environment data.
               Expected value is 'GithubScope'.
        """
        GithubScopeEnvironmentDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_type=environment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")

        _setter("environment_type", 'GithubScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        The type of the environment data.
        Expected value is 'GithubScope'.
        """
        return pulumi.get(self, "environment_type")


@pulumi.output_type
class GitlabScopeEnvironmentDataResponse(dict):
    """
    The GitLab scope connector's environment data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitlabScopeEnvironmentDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitlabScopeEnvironmentDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitlabScopeEnvironmentDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: str):
        """
        The GitLab scope connector's environment data
        :param str environment_type: The type of the environment data.
               Expected value is 'GitlabScope'.
        """
        GitlabScopeEnvironmentDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_type=environment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")

        _setter("environment_type", 'GitlabScope')

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        The type of the environment data.
        Expected value is 'GitlabScope'.
        """
        return pulumi.get(self, "environment_type")


@pulumi.output_type
class GovernanceAssignmentAdditionalDataResponse(dict):
    """
    Describe the additional data of governance assignment - optional
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketLink":
            suggest = "ticket_link"
        elif key == "ticketNumber":
            suggest = "ticket_number"
        elif key == "ticketStatus":
            suggest = "ticket_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GovernanceAssignmentAdditionalDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GovernanceAssignmentAdditionalDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GovernanceAssignmentAdditionalDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_link: Optional[str] = None,
                 ticket_number: Optional[int] = None,
                 ticket_status: Optional[str] = None):
        """
        Describe the additional data of governance assignment - optional
        :param str ticket_link: Ticket link associated with this governance assignment - for example: https://snow.com
        :param int ticket_number: Ticket number associated with this governance assignment
        :param str ticket_status: The ticket status associated with this governance assignment - for example: Active
        """
        GovernanceAssignmentAdditionalDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ticket_link=ticket_link,
            ticket_number=ticket_number,
            ticket_status=ticket_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ticket_link: Optional[str] = None,
             ticket_number: Optional[int] = None,
             ticket_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ticket_link is None and 'ticketLink' in kwargs:
            ticket_link = kwargs['ticketLink']
        if ticket_number is None and 'ticketNumber' in kwargs:
            ticket_number = kwargs['ticketNumber']
        if ticket_status is None and 'ticketStatus' in kwargs:
            ticket_status = kwargs['ticketStatus']

        if ticket_link is not None:
            _setter("ticket_link", ticket_link)
        if ticket_number is not None:
            _setter("ticket_number", ticket_number)
        if ticket_status is not None:
            _setter("ticket_status", ticket_status)

    @property
    @pulumi.getter(name="ticketLink")
    def ticket_link(self) -> Optional[str]:
        """
        Ticket link associated with this governance assignment - for example: https://snow.com
        """
        return pulumi.get(self, "ticket_link")

    @property
    @pulumi.getter(name="ticketNumber")
    def ticket_number(self) -> Optional[int]:
        """
        Ticket number associated with this governance assignment
        """
        return pulumi.get(self, "ticket_number")

    @property
    @pulumi.getter(name="ticketStatus")
    def ticket_status(self) -> Optional[str]:
        """
        The ticket status associated with this governance assignment - for example: Active
        """
        return pulumi.get(self, "ticket_status")


@pulumi.output_type
class GovernanceEmailNotificationResponse(dict):
    """
    The governance email weekly notification configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableManagerEmailNotification":
            suggest = "disable_manager_email_notification"
        elif key == "disableOwnerEmailNotification":
            suggest = "disable_owner_email_notification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GovernanceEmailNotificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GovernanceEmailNotificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GovernanceEmailNotificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_manager_email_notification: Optional[bool] = None,
                 disable_owner_email_notification: Optional[bool] = None):
        """
        The governance email weekly notification configuration.
        :param bool disable_manager_email_notification: Exclude manager from weekly email notification.
        :param bool disable_owner_email_notification: Exclude  owner from weekly email notification.
        """
        GovernanceEmailNotificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_manager_email_notification=disable_manager_email_notification,
            disable_owner_email_notification=disable_owner_email_notification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_manager_email_notification: Optional[bool] = None,
             disable_owner_email_notification: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_manager_email_notification is None and 'disableManagerEmailNotification' in kwargs:
            disable_manager_email_notification = kwargs['disableManagerEmailNotification']
        if disable_owner_email_notification is None and 'disableOwnerEmailNotification' in kwargs:
            disable_owner_email_notification = kwargs['disableOwnerEmailNotification']

        if disable_manager_email_notification is not None:
            _setter("disable_manager_email_notification", disable_manager_email_notification)
        if disable_owner_email_notification is not None:
            _setter("disable_owner_email_notification", disable_owner_email_notification)

    @property
    @pulumi.getter(name="disableManagerEmailNotification")
    def disable_manager_email_notification(self) -> Optional[bool]:
        """
        Exclude manager from weekly email notification.
        """
        return pulumi.get(self, "disable_manager_email_notification")

    @property
    @pulumi.getter(name="disableOwnerEmailNotification")
    def disable_owner_email_notification(self) -> Optional[bool]:
        """
        Exclude  owner from weekly email notification.
        """
        return pulumi.get(self, "disable_owner_email_notification")


@pulumi.output_type
class GovernanceRuleEmailNotificationResponse(dict):
    """
    The governance email weekly notification configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableManagerEmailNotification":
            suggest = "disable_manager_email_notification"
        elif key == "disableOwnerEmailNotification":
            suggest = "disable_owner_email_notification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GovernanceRuleEmailNotificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GovernanceRuleEmailNotificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GovernanceRuleEmailNotificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_manager_email_notification: Optional[bool] = None,
                 disable_owner_email_notification: Optional[bool] = None):
        """
        The governance email weekly notification configuration
        :param bool disable_manager_email_notification: Defines whether manager email notifications are disabled
        :param bool disable_owner_email_notification: Defines whether owner email notifications are disabled
        """
        GovernanceRuleEmailNotificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_manager_email_notification=disable_manager_email_notification,
            disable_owner_email_notification=disable_owner_email_notification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_manager_email_notification: Optional[bool] = None,
             disable_owner_email_notification: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_manager_email_notification is None and 'disableManagerEmailNotification' in kwargs:
            disable_manager_email_notification = kwargs['disableManagerEmailNotification']
        if disable_owner_email_notification is None and 'disableOwnerEmailNotification' in kwargs:
            disable_owner_email_notification = kwargs['disableOwnerEmailNotification']

        if disable_manager_email_notification is not None:
            _setter("disable_manager_email_notification", disable_manager_email_notification)
        if disable_owner_email_notification is not None:
            _setter("disable_owner_email_notification", disable_owner_email_notification)

    @property
    @pulumi.getter(name="disableManagerEmailNotification")
    def disable_manager_email_notification(self) -> Optional[bool]:
        """
        Defines whether manager email notifications are disabled
        """
        return pulumi.get(self, "disable_manager_email_notification")

    @property
    @pulumi.getter(name="disableOwnerEmailNotification")
    def disable_owner_email_notification(self) -> Optional[bool]:
        """
        Defines whether owner email notifications are disabled
        """
        return pulumi.get(self, "disable_owner_email_notification")


@pulumi.output_type
class GovernanceRuleMetadataResponse(dict):
    """
    The governance rule metadata
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdBy":
            suggest = "created_by"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "updatedBy":
            suggest = "updated_by"
        elif key == "updatedOn":
            suggest = "updated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GovernanceRuleMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GovernanceRuleMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GovernanceRuleMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_by: str,
                 created_on: str,
                 updated_by: str,
                 updated_on: str):
        """
        The governance rule metadata
        :param str created_by: Governance rule Created by object id (GUID)
        :param str created_on: Governance rule creation date
        :param str updated_by: Governance rule last updated by object id (GUID)
        :param str updated_on: Governance rule last update date
        """
        GovernanceRuleMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_by=created_by,
            created_on=created_on,
            updated_by=updated_by,
            updated_on=updated_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_by: Optional[str] = None,
             created_on: Optional[str] = None,
             updated_by: Optional[str] = None,
             updated_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by is None:
            raise TypeError("Missing 'created_by' argument")
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']
        if created_on is None:
            raise TypeError("Missing 'created_on' argument")
        if updated_by is None and 'updatedBy' in kwargs:
            updated_by = kwargs['updatedBy']
        if updated_by is None:
            raise TypeError("Missing 'updated_by' argument")
        if updated_on is None and 'updatedOn' in kwargs:
            updated_on = kwargs['updatedOn']
        if updated_on is None:
            raise TypeError("Missing 'updated_on' argument")

        _setter("created_by", created_by)
        _setter("created_on", created_on)
        _setter("updated_by", updated_by)
        _setter("updated_on", updated_on)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        Governance rule Created by object id (GUID)
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        Governance rule creation date
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> str:
        """
        Governance rule last updated by object id (GUID)
        """
        return pulumi.get(self, "updated_by")

    @property
    @pulumi.getter(name="updatedOn")
    def updated_on(self) -> str:
        """
        Governance rule last update date
        """
        return pulumi.get(self, "updated_on")


@pulumi.output_type
class GovernanceRuleOwnerSourceResponse(dict):
    """
    Describe the owner source of governance rule
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Describe the owner source of governance rule
        :param str type: The owner type for the governance rule owner source
        :param str value: The source value e.g. tag key like owner name or email address
        """
        GovernanceRuleOwnerSourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The owner type for the governance rule owner source
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The source value e.g. tag key like owner name or email address
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HybridComputeSettingsPropertiesResponse(dict):
    """
    Settings for hybrid compute management
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoProvision":
            suggest = "auto_provision"
        elif key == "hybridComputeProvisioningState":
            suggest = "hybrid_compute_provisioning_state"
        elif key == "proxyServer":
            suggest = "proxy_server"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "servicePrincipal":
            suggest = "service_principal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridComputeSettingsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridComputeSettingsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridComputeSettingsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_provision: str,
                 hybrid_compute_provisioning_state: str,
                 proxy_server: Optional['outputs.ProxyServerPropertiesResponse'] = None,
                 region: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 service_principal: Optional['outputs.ServicePrincipalPropertiesResponse'] = None):
        """
        Settings for hybrid compute management
        :param str auto_provision: Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
        :param str hybrid_compute_provisioning_state: State of the service principal and its secret
        :param 'ProxyServerPropertiesResponse' proxy_server: For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        :param str region: The location where the metadata of machines will be stored
        :param str resource_group_name: The name of the resource group where Arc (Hybrid Compute) connectors are connected.
        :param 'ServicePrincipalPropertiesResponse' service_principal: An object to access resources that are secured by an Azure AD tenant.
        """
        HybridComputeSettingsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_provision=auto_provision,
            hybrid_compute_provisioning_state=hybrid_compute_provisioning_state,
            proxy_server=proxy_server,
            region=region,
            resource_group_name=resource_group_name,
            service_principal=service_principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_provision: Optional[str] = None,
             hybrid_compute_provisioning_state: Optional[str] = None,
             proxy_server: Optional['outputs.ProxyServerPropertiesResponse'] = None,
             region: Optional[str] = None,
             resource_group_name: Optional[str] = None,
             service_principal: Optional['outputs.ServicePrincipalPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_provision is None and 'autoProvision' in kwargs:
            auto_provision = kwargs['autoProvision']
        if auto_provision is None:
            raise TypeError("Missing 'auto_provision' argument")
        if hybrid_compute_provisioning_state is None and 'hybridComputeProvisioningState' in kwargs:
            hybrid_compute_provisioning_state = kwargs['hybridComputeProvisioningState']
        if hybrid_compute_provisioning_state is None:
            raise TypeError("Missing 'hybrid_compute_provisioning_state' argument")
        if proxy_server is None and 'proxyServer' in kwargs:
            proxy_server = kwargs['proxyServer']
        if resource_group_name is None and 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']
        if service_principal is None and 'servicePrincipal' in kwargs:
            service_principal = kwargs['servicePrincipal']

        _setter("auto_provision", auto_provision)
        _setter("hybrid_compute_provisioning_state", hybrid_compute_provisioning_state)
        if proxy_server is not None:
            _setter("proxy_server", proxy_server)
        if region is not None:
            _setter("region", region)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if service_principal is not None:
            _setter("service_principal", service_principal)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> str:
        """
        Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
        """
        return pulumi.get(self, "auto_provision")

    @property
    @pulumi.getter(name="hybridComputeProvisioningState")
    def hybrid_compute_provisioning_state(self) -> str:
        """
        State of the service principal and its secret
        """
        return pulumi.get(self, "hybrid_compute_provisioning_state")

    @property
    @pulumi.getter(name="proxyServer")
    def proxy_server(self) -> Optional['outputs.ProxyServerPropertiesResponse']:
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        """
        return pulumi.get(self, "proxy_server")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The location where the metadata of machines will be stored
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The name of the resource group where Arc (Hybrid Compute) connectors are connected.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional['outputs.ServicePrincipalPropertiesResponse']:
        """
        An object to access resources that are secured by an Azure AD tenant.
        """
        return pulumi.get(self, "service_principal")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        """
        IdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InformationProtectionAwsOfferingResponse(dict):
    """
    The information protection for AWS offering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offeringType":
            suggest = "offering_type"
        elif key == "informationProtection":
            suggest = "information_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InformationProtectionAwsOfferingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InformationProtectionAwsOfferingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InformationProtectionAwsOfferingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 offering_type: str,
                 information_protection: Optional['outputs.InformationProtectionAwsOfferingResponseInformationProtection'] = None):
        """
        The information protection for AWS offering
        :param str description: The offering description.
        :param str offering_type: The type of the security offering.
               Expected value is 'InformationProtectionAws'.
        :param 'InformationProtectionAwsOfferingResponseInformationProtection' information_protection: The native cloud connection configuration
        """
        InformationProtectionAwsOfferingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            offering_type=offering_type,
            information_protection=information_protection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             offering_type: Optional[str] = None,
             information_protection: Optional['outputs.InformationProtectionAwsOfferingResponseInformationProtection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if offering_type is None and 'offeringType' in kwargs:
            offering_type = kwargs['offeringType']
        if offering_type is None:
            raise TypeError("Missing 'offering_type' argument")
        if information_protection is None and 'informationProtection' in kwargs:
            information_protection = kwargs['informationProtection']

        _setter("description", description)
        _setter("offering_type", 'InformationProtectionAws')
        if information_protection is not None:
            _setter("information_protection", information_protection)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The offering description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="offeringType")
    def offering_type(self) -> str:
        """
        The type of the security offering.
        Expected value is 'InformationProtectionAws'.
        """
        return pulumi.get(self, "offering_type")

    @property
    @pulumi.getter(name="informationProtection")
    def information_protection(self) -> Optional['outputs.InformationProtectionAwsOfferingResponseInformationProtection']:
        """
        The native cloud connection configuration
        """
        return pulumi.get(self, "information_protection")


@pulumi.output_type
class InformationProtectionAwsOfferingResponseInformationProtection(dict):
    """
    The native cloud connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRoleArn":
            suggest = "cloud_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InformationProtectionAwsOfferingResponseInformationProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InformationProtectionAwsOfferingResponseInformationProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InformationProtectionAwsOfferingResponseInformationProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_role_arn: Optional[str] = None):
        """
        The native cloud connection configuration
        :param str cloud_role_arn: The cloud role ARN in AWS for this feature
        """
        InformationProtectionAwsOfferingResponseInformationProtection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_role_arn=cloud_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_role_arn is None and 'cloudRoleArn' in kwargs:
            cloud_role_arn = kwargs['cloudRoleArn']

        if cloud_role_arn is not None:
            _setter("cloud_role_arn", cloud_role_arn)

    @property
    @pulumi.getter(name="cloudRoleArn")
    def cloud_role_arn(self) -> Optional[str]:
        """
        The cloud role ARN in AWS for this feature
        """
        return pulumi.get(self, "cloud_role_arn")


@pulumi.output_type
class JitNetworkAccessPolicyVirtualMachineResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessPolicyVirtualMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessPolicyVirtualMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessPolicyVirtualMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 ports: Sequence['outputs.JitNetworkAccessPortRuleResponse'],
                 public_ip_address: Optional[str] = None):
        """
        :param str id: Resource ID of the virtual machine that is linked to this policy
        :param Sequence['JitNetworkAccessPortRuleResponse'] ports: Port configurations for the virtual machine
        :param str public_ip_address: Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        JitNetworkAccessPolicyVirtualMachineResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ports=ports,
            public_ip_address=public_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ports: Optional[Sequence['outputs.JitNetworkAccessPortRuleResponse']] = None,
             public_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if public_ip_address is None and 'publicIpAddress' in kwargs:
            public_ip_address = kwargs['publicIpAddress']

        _setter("id", id)
        _setter("ports", ports)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.JitNetworkAccessPortRuleResponse']:
        """
        Port configurations for the virtual machine
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class JitNetworkAccessPortRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequestAccessDuration":
            suggest = "max_request_access_duration"
        elif key == "allowedSourceAddressPrefix":
            suggest = "allowed_source_address_prefix"
        elif key == "allowedSourceAddressPrefixes":
            suggest = "allowed_source_address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessPortRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessPortRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessPortRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_request_access_duration: str,
                 number: int,
                 protocol: str,
                 allowed_source_address_prefix: Optional[str] = None,
                 allowed_source_address_prefixes: Optional[Sequence[str]] = None):
        """
        :param str max_request_access_duration: Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        :param str allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param Sequence[str] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        JitNetworkAccessPortRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_request_access_duration=max_request_access_duration,
            number=number,
            protocol=protocol,
            allowed_source_address_prefix=allowed_source_address_prefix,
            allowed_source_address_prefixes=allowed_source_address_prefixes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_request_access_duration: Optional[str] = None,
             number: Optional[int] = None,
             protocol: Optional[str] = None,
             allowed_source_address_prefix: Optional[str] = None,
             allowed_source_address_prefixes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_request_access_duration is None and 'maxRequestAccessDuration' in kwargs:
            max_request_access_duration = kwargs['maxRequestAccessDuration']
        if max_request_access_duration is None:
            raise TypeError("Missing 'max_request_access_duration' argument")
        if number is None:
            raise TypeError("Missing 'number' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if allowed_source_address_prefix is None and 'allowedSourceAddressPrefix' in kwargs:
            allowed_source_address_prefix = kwargs['allowedSourceAddressPrefix']
        if allowed_source_address_prefixes is None and 'allowedSourceAddressPrefixes' in kwargs:
            allowed_source_address_prefixes = kwargs['allowedSourceAddressPrefixes']

        _setter("max_request_access_duration", max_request_access_duration)
        _setter("number", number)
        _setter("protocol", protocol)
        if allowed_source_address_prefix is not None:
            _setter("allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            _setter("allowed_source_address_prefixes", allowed_source_address_prefixes)

    @property
    @pulumi.getter(name="maxRequestAccessDuration")
    def max_request_access_duration(self) -> str:
        """
        Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        """
        return pulumi.get(self, "max_request_access_duration")

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[str]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")


@pulumi.output_type
class JitNetworkAccessRequestPortResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeUtc":
            suggest = "end_time_utc"
        elif key == "statusReason":
            suggest = "status_reason"
        elif key == "allowedSourceAddressPrefix":
            suggest = "allowed_source_address_prefix"
        elif key == "allowedSourceAddressPrefixes":
            suggest = "allowed_source_address_prefixes"
        elif key == "mappedPort":
            suggest = "mapped_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessRequestPortResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessRequestPortResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessRequestPortResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time_utc: str,
                 number: int,
                 status: str,
                 status_reason: str,
                 allowed_source_address_prefix: Optional[str] = None,
                 allowed_source_address_prefixes: Optional[Sequence[str]] = None,
                 mapped_port: Optional[int] = None):
        """
        :param str end_time_utc: The date & time at which the request ends in UTC
        :param str status: The status of the port
        :param str status_reason: A description of why the `status` has its value
        :param str allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param Sequence[str] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        :param int mapped_port: The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        JitNetworkAccessRequestPortResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time_utc=end_time_utc,
            number=number,
            status=status,
            status_reason=status_reason,
            allowed_source_address_prefix=allowed_source_address_prefix,
            allowed_source_address_prefixes=allowed_source_address_prefixes,
            mapped_port=mapped_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time_utc: Optional[str] = None,
             number: Optional[int] = None,
             status: Optional[str] = None,
             status_reason: Optional[str] = None,
             allowed_source_address_prefix: Optional[str] = None,
             allowed_source_address_prefixes: Optional[Sequence[str]] = None,
             mapped_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if number is None:
            raise TypeError("Missing 'number' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_reason is None and 'statusReason' in kwargs:
            status_reason = kwargs['statusReason']
        if status_reason is None:
            raise TypeError("Missing 'status_reason' argument")
        if allowed_source_address_prefix is None and 'allowedSourceAddressPrefix' in kwargs:
            allowed_source_address_prefix = kwargs['allowedSourceAddressPrefix']
        if allowed_source_address_prefixes is None and 'allowedSourceAddressPrefixes' in kwargs:
            allowed_source_address_prefixes = kwargs['allowedSourceAddressPrefixes']
        if mapped_port is None and 'mappedPort' in kwargs:
            mapped_port = kwargs['mappedPort']

        _setter("end_time_utc", end_time_utc)
        _setter("number", number)
        _setter("status", status)
        _setter("status_reason", status_reason)
        if allowed_source_address_prefix is not None:
            _setter("allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            _setter("allowed_source_address_prefixes", allowed_source_address_prefixes)
        if mapped_port is not None:
            _setter("mapped_port", mapped_port)

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The date & time at which the request ends in UTC
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the port
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> str:
        """
        A description of why the `status` has its value
        """
        return pulumi.get(self, "status_reason")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[str]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")

    @property
    @pulumi.getter(name="mappedPort")
    def mapped_port(self) -> Optional[int]:
        """
        The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        return pulumi.get(self, "mapped_port")


@pulumi.output_type
class JitNetworkAccessRequestResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTimeUtc":
            suggest = "start_time_utc"
        elif key == "virtualMachines":
            suggest = "virtual_machines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessRequestResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessRequestResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessRequestResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requestor: str,
                 start_time_utc: str,
                 virtual_machines: Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse'],
                 justification: Optional[str] = None):
        """
        :param str requestor: The identity of the person who made the request
        :param str start_time_utc: The start time of the request in UTC
        :param str justification: The justification for making the initiate request
        """
        JitNetworkAccessRequestResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requestor=requestor,
            start_time_utc=start_time_utc,
            virtual_machines=virtual_machines,
            justification=justification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requestor: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             virtual_machines: Optional[Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse']] = None,
             justification: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if requestor is None:
            raise TypeError("Missing 'requestor' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if virtual_machines is None and 'virtualMachines' in kwargs:
            virtual_machines = kwargs['virtualMachines']
        if virtual_machines is None:
            raise TypeError("Missing 'virtual_machines' argument")

        _setter("requestor", requestor)
        _setter("start_time_utc", start_time_utc)
        _setter("virtual_machines", virtual_machines)
        if justification is not None:
            _setter("justification", justification)

    @property
    @pulumi.getter
    def requestor(self) -> str:
        """
        The identity of the person who made the request
        """
        return pulumi.get(self, "requestor")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The start time of the request in UTC
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="virtualMachines")
    def virtual_machines(self) -> Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse']:
        return pulumi.get(self, "virtual_machines")

    @property
    @pulumi.getter
    def justification(self) -> Optional[str]:
        """
        The justification for making the initiate request
        """
        return pulumi.get(self, "justification")


@pulumi.output_type
class JitNetworkAccessRequestVirtualMachineResponse(dict):
    def __init__(__self__, *,
                 id: str,
                 ports: Sequence['outputs.JitNetworkAccessRequestPortResponse']):
        """
        :param str id: Resource ID of the virtual machine that is linked to this policy
        :param Sequence['JitNetworkAccessRequestPortResponse'] ports: The ports that were opened for the virtual machine
        """
        JitNetworkAccessRequestVirtualMachineResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ports: Optional[Sequence['outputs.JitNetworkAccessRequestPortResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")

        _setter("id", id)
        _setter("ports", ports)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.JitNetworkAccessRequestPortResponse']:
        """
        The ports that were opened for the virtual machine
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class OnPremiseResourceDetailsResponse(dict):
    """
    Details of the On Premise resource that was assessed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineName":
            suggest = "machine_name"
        elif key == "sourceComputerId":
            suggest = "source_computer_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnPremiseResourceDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnPremiseResourceDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnPremiseResourceDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_name: str,
                 source: str,
                 source_computer_id: str,
                 vmuuid: str,
                 workspace_id: str):
        """
        Details of the On Premise resource that was assessed
        :param str machine_name: The name of the machine
        :param str source: The platform where the assessed resource resides
               Expected value is 'OnPremise'.
        :param str source_computer_id: The oms agent Id installed on the machine
        :param str vmuuid: The unique Id of the machine
        :param str workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        OnPremiseResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            machine_name=machine_name,
            source=source,
            source_computer_id=source_computer_id,
            vmuuid=vmuuid,
            workspace_id=workspace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             machine_name: Optional[str] = None,
             source: Optional[str] = None,
             source_computer_id: Optional[str] = None,
             vmuuid: Optional[str] = None,
             workspace_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if machine_name is None and 'machineName' in kwargs:
            machine_name = kwargs['machineName']
        if machine_name is None:
            raise TypeError("Missing 'machine_name' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_computer_id is None and 'sourceComputerId' in kwargs:
            source_computer_id = kwargs['sourceComputerId']
        if source_computer_id is None:
            raise TypeError("Missing 'source_computer_id' argument")
        if vmuuid is None:
            raise TypeError("Missing 'vmuuid' argument")
        if workspace_id is None and 'workspaceId' in kwargs:
            workspace_id = kwargs['workspaceId']
        if workspace_id is None:
            raise TypeError("Missing 'workspace_id' argument")

        _setter("machine_name", machine_name)
        _setter("source", 'OnPremise')
        _setter("source_computer_id", source_computer_id)
        _setter("vmuuid", vmuuid)
        _setter("workspace_id", workspace_id)

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> str:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremise'.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> str:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @property
    @pulumi.getter
    def vmuuid(self) -> str:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class OnPremiseSqlResourceDetailsResponse(dict):
    """
    Details of the On Premise Sql resource that was assessed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "machineName":
            suggest = "machine_name"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "sourceComputerId":
            suggest = "source_computer_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnPremiseSqlResourceDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnPremiseSqlResourceDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnPremiseSqlResourceDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 machine_name: str,
                 server_name: str,
                 source: str,
                 source_computer_id: str,
                 vmuuid: str,
                 workspace_id: str):
        """
        Details of the On Premise Sql resource that was assessed
        :param str database_name: The Sql database name installed on the machine
        :param str machine_name: The name of the machine
        :param str server_name: The Sql server name installed on the machine
        :param str source: The platform where the assessed resource resides
               Expected value is 'OnPremiseSql'.
        :param str source_computer_id: The oms agent Id installed on the machine
        :param str vmuuid: The unique Id of the machine
        :param str workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        OnPremiseSqlResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            machine_name=machine_name,
            server_name=server_name,
            source=source,
            source_computer_id=source_computer_id,
            vmuuid=vmuuid,
            workspace_id=workspace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             machine_name: Optional[str] = None,
             server_name: Optional[str] = None,
             source: Optional[str] = None,
             source_computer_id: Optional[str] = None,
             vmuuid: Optional[str] = None,
             workspace_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if machine_name is None and 'machineName' in kwargs:
            machine_name = kwargs['machineName']
        if machine_name is None:
            raise TypeError("Missing 'machine_name' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_computer_id is None and 'sourceComputerId' in kwargs:
            source_computer_id = kwargs['sourceComputerId']
        if source_computer_id is None:
            raise TypeError("Missing 'source_computer_id' argument")
        if vmuuid is None:
            raise TypeError("Missing 'vmuuid' argument")
        if workspace_id is None and 'workspaceId' in kwargs:
            workspace_id = kwargs['workspaceId']
        if workspace_id is None:
            raise TypeError("Missing 'workspace_id' argument")

        _setter("database_name", database_name)
        _setter("machine_name", machine_name)
        _setter("server_name", server_name)
        _setter("source", 'OnPremiseSql')
        _setter("source_computer_id", source_computer_id)
        _setter("vmuuid", vmuuid)
        _setter("workspace_id", workspace_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The Sql database name installed on the machine
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> str:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        The Sql server name installed on the machine
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremiseSql'.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> str:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @property
    @pulumi.getter
    def vmuuid(self) -> str:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class PathRecommendationResponse(dict):
    """
    Represents a path that is recommended to be allowed and its properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationStatus":
            suggest = "configuration_status"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "publisherInfo":
            suggest = "publisher_info"
        elif key == "userSids":
            suggest = "user_sids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PathRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PathRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PathRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 common: Optional[bool] = None,
                 configuration_status: Optional[str] = None,
                 file_type: Optional[str] = None,
                 path: Optional[str] = None,
                 publisher_info: Optional['outputs.PublisherInfoResponse'] = None,
                 type: Optional[str] = None,
                 user_sids: Optional[Sequence[str]] = None,
                 usernames: Optional[Sequence['outputs.UserRecommendationResponse']] = None):
        """
        Represents a path that is recommended to be allowed and its properties
        :param str action: The recommendation action of the machine or rule
        :param bool common: Whether the application is commonly run on the machine
        :param str configuration_status: The configuration status of the machines group or machine or rule
        :param str file_type: The type of the file (for Linux files - Executable is used)
        :param str path: The full path of the file, or an identifier of the application
        :param 'PublisherInfoResponse' publisher_info: Represents the publisher information of a process/rule
        :param str type: The type of the rule to be allowed
        """
        PathRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            common=common,
            configuration_status=configuration_status,
            file_type=file_type,
            path=path,
            publisher_info=publisher_info,
            type=type,
            user_sids=user_sids,
            usernames=usernames,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             common: Optional[bool] = None,
             configuration_status: Optional[str] = None,
             file_type: Optional[str] = None,
             path: Optional[str] = None,
             publisher_info: Optional['outputs.PublisherInfoResponse'] = None,
             type: Optional[str] = None,
             user_sids: Optional[Sequence[str]] = None,
             usernames: Optional[Sequence['outputs.UserRecommendationResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_status is None and 'configurationStatus' in kwargs:
            configuration_status = kwargs['configurationStatus']
        if file_type is None and 'fileType' in kwargs:
            file_type = kwargs['fileType']
        if publisher_info is None and 'publisherInfo' in kwargs:
            publisher_info = kwargs['publisherInfo']
        if user_sids is None and 'userSids' in kwargs:
            user_sids = kwargs['userSids']

        if action is not None:
            _setter("action", action)
        if common is not None:
            _setter("common", common)
        if configuration_status is not None:
            _setter("configuration_status", configuration_status)
        if file_type is not None:
            _setter("file_type", file_type)
        if path is not None:
            _setter("path", path)
        if publisher_info is not None:
            _setter("publisher_info", publisher_info)
        if type is not None:
            _setter("type", type)
        if user_sids is not None:
            _setter("user_sids", user_sids)
        if usernames is not None:
            _setter("usernames", usernames)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def common(self) -> Optional[bool]:
        """
        Whether the application is commonly run on the machine
        """
        return pulumi.get(self, "common")

    @property
    @pulumi.getter(name="configurationStatus")
    def configuration_status(self) -> Optional[str]:
        """
        The configuration status of the machines group or machine or rule
        """
        return pulumi.get(self, "configuration_status")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        The type of the file (for Linux files - Executable is used)
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The full path of the file, or an identifier of the application
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="publisherInfo")
    def publisher_info(self) -> Optional['outputs.PublisherInfoResponse']:
        """
        Represents the publisher information of a process/rule
        """
        return pulumi.get(self, "publisher_info")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the rule to be allowed
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userSids")
    def user_sids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_sids")

    @property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence['outputs.UserRecommendationResponse']]:
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ProtectionModeResponse(dict):
    """
    The protection mode of the collection/file types. Exe/Msi/Script are used for Windows, Executable is used for Linux.
    """
    def __init__(__self__, *,
                 exe: Optional[str] = None,
                 executable: Optional[str] = None,
                 msi: Optional[str] = None,
                 script: Optional[str] = None):
        """
        The protection mode of the collection/file types. Exe/Msi/Script are used for Windows, Executable is used for Linux.
        :param str exe: The application control policy enforcement/protection mode of the machine group
        :param str executable: The application control policy enforcement/protection mode of the machine group
        :param str msi: The application control policy enforcement/protection mode of the machine group
        :param str script: The application control policy enforcement/protection mode of the machine group
        """
        ProtectionModeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exe=exe,
            executable=executable,
            msi=msi,
            script=script,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exe: Optional[str] = None,
             executable: Optional[str] = None,
             msi: Optional[str] = None,
             script: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exe is not None:
            _setter("exe", exe)
        if executable is not None:
            _setter("executable", executable)
        if msi is not None:
            _setter("msi", msi)
        if script is not None:
            _setter("script", script)

    @property
    @pulumi.getter
    def exe(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "exe")

    @property
    @pulumi.getter
    def executable(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def msi(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "msi")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class ProxyServerPropertiesResponse(dict):
    """
    For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
    """
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[str] = None):
        """
        For a non-Azure machine that is not connected directly to the internet, specify a proxy server that the non-Azure machine can use.
        :param str ip: Proxy server IP
        :param str port: Proxy server port
        """
        ProxyServerPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: Optional[str] = None,
             port: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if ip is not None:
            _setter("ip", ip)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Proxy server IP
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Proxy server port
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class PublisherInfoResponse(dict):
    """
    Represents the publisher information of a process/rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binaryName":
            suggest = "binary_name"
        elif key == "productName":
            suggest = "product_name"
        elif key == "publisherName":
            suggest = "publisher_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublisherInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublisherInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublisherInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binary_name: Optional[str] = None,
                 product_name: Optional[str] = None,
                 publisher_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Represents the publisher information of a process/rule
        :param str binary_name: The "OriginalName" field taken from the file's version resource
        :param str product_name: The product name taken from the file's version resource
        :param str publisher_name: The Subject field of the x.509 certificate used to sign the code, using the following fields -  O = Organization, L = Locality, S = State or Province, and C = Country
        :param str version: The binary file version taken from the file's version resource
        """
        PublisherInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binary_name=binary_name,
            product_name=product_name,
            publisher_name=publisher_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binary_name: Optional[str] = None,
             product_name: Optional[str] = None,
             publisher_name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if binary_name is None and 'binaryName' in kwargs:
            binary_name = kwargs['binaryName']
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']
        if publisher_name is None and 'publisherName' in kwargs:
            publisher_name = kwargs['publisherName']

        if binary_name is not None:
            _setter("binary_name", binary_name)
        if product_name is not None:
            _setter("product_name", product_name)
        if publisher_name is not None:
            _setter("publisher_name", publisher_name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="binaryName")
    def binary_name(self) -> Optional[str]:
        """
        The "OriginalName" field taken from the file's version resource
        """
        return pulumi.get(self, "binary_name")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The product name taken from the file's version resource
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="publisherName")
    def publisher_name(self) -> Optional[str]:
        """
        The Subject field of the x.509 certificate used to sign the code, using the following fields -  O = Organization, L = Locality, S = State or Province, and C = Country
        """
        return pulumi.get(self, "publisher_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The binary file version taken from the file's version resource
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RecommendationConfigurationPropertiesResponse(dict):
    """
    The type of IoT Security recommendation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recommendationType":
            suggest = "recommendation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 recommendation_type: str,
                 status: Optional[str] = None):
        """
        The type of IoT Security recommendation.
        :param str recommendation_type: The type of IoT Security recommendation.
        :param str status: Recommendation status. When the recommendation status is disabled recommendations are not generated.
        """
        RecommendationConfigurationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            recommendation_type=recommendation_type,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             recommendation_type: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if recommendation_type is None and 'recommendationType' in kwargs:
            recommendation_type = kwargs['recommendationType']
        if recommendation_type is None:
            raise TypeError("Missing 'recommendation_type' argument")

        _setter("name", name)
        _setter("recommendation_type", recommendation_type)
        if status is None:
            status = 'Enabled'
        _setter("status", status)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recommendationType")
    def recommendation_type(self) -> str:
        """
        The type of IoT Security recommendation.
        """
        return pulumi.get(self, "recommendation_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Recommendation status. When the recommendation status is disabled recommendations are not generated.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RemediationEtaResponse(dict):
    """
    The ETA (estimated time of arrival) for remediation
    """
    def __init__(__self__, *,
                 eta: str,
                 justification: str):
        """
        The ETA (estimated time of arrival) for remediation
        :param str eta: ETA for remediation.
        :param str justification: Justification for change of Eta.
        """
        RemediationEtaResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eta=eta,
            justification=justification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eta: Optional[str] = None,
             justification: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if eta is None:
            raise TypeError("Missing 'eta' argument")
        if justification is None:
            raise TypeError("Missing 'justification' argument")

        _setter("eta", eta)
        _setter("justification", justification)

    @property
    @pulumi.getter
    def eta(self) -> str:
        """
        ETA for remediation.
        """
        return pulumi.get(self, "eta")

    @property
    @pulumi.getter
    def justification(self) -> str:
        """
        Justification for change of Eta.
        """
        return pulumi.get(self, "justification")


@pulumi.output_type
class RuleResultsPropertiesResponse(dict):
    """
    Rule results properties.
    """
    def __init__(__self__, *,
                 results: Optional[Sequence[Sequence[str]]] = None):
        """
        Rule results properties.
        :param Sequence[Sequence[str]] results: Expected results in the baseline.
        """
        RuleResultsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            results=results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             results: Optional[Sequence[Sequence[str]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if results is not None:
            _setter("results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence[Sequence[str]]]:
        """
        Expected results in the baseline.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class ScopeElementResponse(dict):
    """
    A more specific scope used to identify the alerts to suppress.
    """
    def __init__(__self__, *,
                 field: Optional[str] = None):
        """
        A more specific scope used to identify the alerts to suppress.
        :param str field: The alert entity type to suppress by.
        """
        ScopeElementResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The alert entity type to suppress by.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class SecurityAssessmentMetadataPartnerDataResponse(dict):
    """
    Describes the partner that created the assessment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerName":
            suggest = "partner_name"
        elif key == "productName":
            suggest = "product_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentMetadataPartnerDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentMetadataPartnerDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentMetadataPartnerDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_name: str,
                 secret: str,
                 product_name: Optional[str] = None):
        """
        Describes the partner that created the assessment
        :param str partner_name: Name of the company of the partner
        :param str secret: Secret to authenticate the partner and verify it created the assessment - write only
        :param str product_name: Name of the product of the partner that created the assessment
        """
        SecurityAssessmentMetadataPartnerDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partner_name=partner_name,
            secret=secret,
            product_name=product_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partner_name: Optional[str] = None,
             secret: Optional[str] = None,
             product_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if partner_name is None and 'partnerName' in kwargs:
            partner_name = kwargs['partnerName']
        if partner_name is None:
            raise TypeError("Missing 'partner_name' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("partner_name", partner_name)
        _setter("secret", secret)
        if product_name is not None:
            _setter("product_name", product_name)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> str:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Secret to authenticate the partner and verify it created the assessment - write only
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        Name of the product of the partner that created the assessment
        """
        return pulumi.get(self, "product_name")


@pulumi.output_type
class SecurityAssessmentMetadataPropertiesResponse(dict):
    """
    Describes properties of an assessment metadata.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assessmentType":
            suggest = "assessment_type"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "policyDefinitionId":
            suggest = "policy_definition_id"
        elif key == "implementationEffort":
            suggest = "implementation_effort"
        elif key == "partnerData":
            suggest = "partner_data"
        elif key == "remediationDescription":
            suggest = "remediation_description"
        elif key == "userImpact":
            suggest = "user_impact"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assessment_type: str,
                 display_name: str,
                 policy_definition_id: str,
                 severity: str,
                 categories: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 implementation_effort: Optional[str] = None,
                 partner_data: Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse'] = None,
                 preview: Optional[bool] = None,
                 remediation_description: Optional[str] = None,
                 threats: Optional[Sequence[str]] = None,
                 user_impact: Optional[str] = None):
        """
        Describes properties of an assessment metadata.
        :param str assessment_type: BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        :param str display_name: User friendly display name of the assessment
        :param str policy_definition_id: Azure resource ID of the policy definition that turns this assessment calculation on
        :param str severity: The severity level of the assessment
        :param str description: Human readable description of the assessment
        :param str implementation_effort: The implementation effort required to remediate this assessment
        :param 'SecurityAssessmentMetadataPartnerDataResponse' partner_data: Describes the partner that created the assessment
        :param bool preview: True if this assessment is in preview release status
        :param str remediation_description: Human readable description of what you should do to mitigate this security issue
        :param str user_impact: The user impact of the assessment
        """
        SecurityAssessmentMetadataPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_type=assessment_type,
            display_name=display_name,
            policy_definition_id=policy_definition_id,
            severity=severity,
            categories=categories,
            description=description,
            implementation_effort=implementation_effort,
            partner_data=partner_data,
            preview=preview,
            remediation_description=remediation_description,
            threats=threats,
            user_impact=user_impact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_type: Optional[str] = None,
             display_name: Optional[str] = None,
             policy_definition_id: Optional[str] = None,
             severity: Optional[str] = None,
             categories: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             implementation_effort: Optional[str] = None,
             partner_data: Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse'] = None,
             preview: Optional[bool] = None,
             remediation_description: Optional[str] = None,
             threats: Optional[Sequence[str]] = None,
             user_impact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_type is None and 'assessmentType' in kwargs:
            assessment_type = kwargs['assessmentType']
        if assessment_type is None:
            raise TypeError("Missing 'assessment_type' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if policy_definition_id is None and 'policyDefinitionId' in kwargs:
            policy_definition_id = kwargs['policyDefinitionId']
        if policy_definition_id is None:
            raise TypeError("Missing 'policy_definition_id' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if implementation_effort is None and 'implementationEffort' in kwargs:
            implementation_effort = kwargs['implementationEffort']
        if partner_data is None and 'partnerData' in kwargs:
            partner_data = kwargs['partnerData']
        if remediation_description is None and 'remediationDescription' in kwargs:
            remediation_description = kwargs['remediationDescription']
        if user_impact is None and 'userImpact' in kwargs:
            user_impact = kwargs['userImpact']

        _setter("assessment_type", assessment_type)
        _setter("display_name", display_name)
        _setter("policy_definition_id", policy_definition_id)
        _setter("severity", severity)
        if categories is not None:
            _setter("categories", categories)
        if description is not None:
            _setter("description", description)
        if implementation_effort is not None:
            _setter("implementation_effort", implementation_effort)
        if partner_data is not None:
            _setter("partner_data", partner_data)
        if preview is not None:
            _setter("preview", preview)
        if remediation_description is not None:
            _setter("remediation_description", remediation_description)
        if threats is not None:
            _setter("threats", threats)
        if user_impact is not None:
            _setter("user_impact", user_impact)

    @property
    @pulumi.getter(name="assessmentType")
    def assessment_type(self) -> str:
        """
        BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        """
        return pulumi.get(self, "assessment_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User friendly display name of the assessment
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="policyDefinitionId")
    def policy_definition_id(self) -> str:
        """
        Azure resource ID of the policy definition that turns this assessment calculation on
        """
        return pulumi.get(self, "policy_definition_id")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity level of the assessment
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Human readable description of the assessment
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="implementationEffort")
    def implementation_effort(self) -> Optional[str]:
        """
        The implementation effort required to remediate this assessment
        """
        return pulumi.get(self, "implementation_effort")

    @property
    @pulumi.getter(name="partnerData")
    def partner_data(self) -> Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse']:
        """
        Describes the partner that created the assessment
        """
        return pulumi.get(self, "partner_data")

    @property
    @pulumi.getter
    def preview(self) -> Optional[bool]:
        """
        True if this assessment is in preview release status
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter(name="remediationDescription")
    def remediation_description(self) -> Optional[str]:
        """
        Human readable description of what you should do to mitigate this security issue
        """
        return pulumi.get(self, "remediation_description")

    @property
    @pulumi.getter
    def threats(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "threats")

    @property
    @pulumi.getter(name="userImpact")
    def user_impact(self) -> Optional[str]:
        """
        The user impact of the assessment
        """
        return pulumi.get(self, "user_impact")


@pulumi.output_type
class SecurityAssessmentMetadataPropertiesResponseResponsePublishDates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gA":
            suggest = "g_a"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentMetadataPropertiesResponseResponsePublishDates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentMetadataPropertiesResponseResponsePublishDates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentMetadataPropertiesResponseResponsePublishDates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public: str,
                 g_a: Optional[str] = None):
        SecurityAssessmentMetadataPropertiesResponseResponsePublishDates._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public=public,
            g_a=g_a,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public: Optional[str] = None,
             g_a: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public is None:
            raise TypeError("Missing 'public' argument")
        if g_a is None and 'gA' in kwargs:
            g_a = kwargs['gA']

        _setter("public", public)
        if g_a is not None:
            _setter("g_a", g_a)

    @property
    @pulumi.getter
    def public(self) -> str:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="gA")
    def g_a(self) -> Optional[str]:
        return pulumi.get(self, "g_a")


@pulumi.output_type
class SecurityAssessmentPartnerDataResponse(dict):
    """
    Data regarding 3rd party partner integration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerName":
            suggest = "partner_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentPartnerDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentPartnerDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentPartnerDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_name: str,
                 secret: str):
        """
        Data regarding 3rd party partner integration
        :param str partner_name: Name of the company of the partner
        :param str secret: secret to authenticate the partner - write only
        """
        SecurityAssessmentPartnerDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partner_name=partner_name,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partner_name: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if partner_name is None and 'partnerName' in kwargs:
            partner_name = kwargs['partnerName']
        if partner_name is None:
            raise TypeError("Missing 'partner_name' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("partner_name", partner_name)
        _setter("secret", secret)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> str:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret to authenticate the partner - write only
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SecurityContactPropertiesResponseAlertNotifications(dict):
    """
    Defines whether to send email notifications about new security alerts
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimalSeverity":
            suggest = "minimal_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityContactPropertiesResponseAlertNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityContactPropertiesResponseAlertNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityContactPropertiesResponseAlertNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimal_severity: Optional[str] = None,
                 state: Optional[str] = None):
        """
        Defines whether to send email notifications about new security alerts
        :param str minimal_severity: Defines the minimal alert severity which will be sent as email notifications
        :param str state: Defines if email notifications will be sent about new security alerts
        """
        SecurityContactPropertiesResponseAlertNotifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            minimal_severity=minimal_severity,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             minimal_severity: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if minimal_severity is None and 'minimalSeverity' in kwargs:
            minimal_severity = kwargs['minimalSeverity']

        if minimal_severity is not None:
            _setter("minimal_severity", minimal_severity)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="minimalSeverity")
    def minimal_severity(self) -> Optional[str]:
        """
        Defines the minimal alert severity which will be sent as email notifications
        """
        return pulumi.get(self, "minimal_severity")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Defines if email notifications will be sent about new security alerts
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SecurityContactPropertiesResponseNotificationsByRole(dict):
    """
    Defines whether to send email notifications from Microsoft Defender for Cloud to persons with specific RBAC roles on the subscription.
    """
    def __init__(__self__, *,
                 roles: Optional[Sequence[str]] = None,
                 state: Optional[str] = None):
        """
        Defines whether to send email notifications from Microsoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        :param Sequence[str] roles: Defines which RBAC roles will get email notifications from Microsoft Defender for Cloud. List of allowed RBAC roles: 
        :param str state: Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
        SecurityContactPropertiesResponseNotificationsByRole._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            roles=roles,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             roles: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if roles is not None:
            _setter("roles", roles)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Defines which RBAC roles will get email notifications from Microsoft Defender for Cloud. List of allowed RBAC roles: 
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ServicePrincipalPropertiesResponse(dict):
    """
    Details of the service principal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        Details of the service principal.
        :param str application_id: Application ID of service principal.
        :param str secret: A secret string that the application uses to prove its identity, also can be referred to as application password (write only).
        """
        ServicePrincipalPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']

        if application_id is not None:
            _setter("application_id", application_id)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        Application ID of service principal.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        A secret string that the application uses to prove its identity, also can be referred to as application password (write only).
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class StandardComponentPropertiesResponse(dict):
    """
    Describes properties of an component as related to the standard
    """
    def __init__(__self__, *,
                 key: Optional[str] = None):
        """
        Describes properties of an component as related to the standard
        :param str key: Component Key matching componentMetadata
        """
        StandardComponentPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Component Key matching componentMetadata
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class SuppressionAlertsScopeResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allOf":
            suggest = "all_of"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionAlertsScopeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionAlertsScopeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionAlertsScopeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_of: Sequence['outputs.ScopeElementResponse']):
        """
        :param Sequence['ScopeElementResponse'] all_of: All the conditions inside need to be true in order to suppress the alert
        """
        SuppressionAlertsScopeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_of=all_of,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_of: Optional[Sequence['outputs.ScopeElementResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_of is None and 'allOf' in kwargs:
            all_of = kwargs['allOf']
        if all_of is None:
            raise TypeError("Missing 'all_of' argument")

        _setter("all_of", all_of)

    @property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Sequence['outputs.ScopeElementResponse']:
        """
        All the conditions inside need to be true in order to suppress the alert
        """
        return pulumi.get(self, "all_of")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TargetBranchConfigurationResponse(dict):
    """
    Repository branch configuration for PR Annotations.
    """
    def __init__(__self__, *,
                 annotate_default_branch: Optional[str] = None,
                 branch_names: Optional[Sequence[str]] = None):
        """
        Repository branch configuration for PR Annotations.
        :param str annotate_default_branch: Configuration of PR Annotations on default branch.
               
               Enabled - PR Annotations are enabled on the resource's default branch.
               Disabled - PR Annotations are disabled on the resource's default branch.
        :param Sequence[str] branch_names: Gets or sets branches that should have annotations.
        """
        TargetBranchConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotate_default_branch=annotate_default_branch,
            branch_names=branch_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotate_default_branch: Optional[str] = None,
             branch_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if annotate_default_branch is None and 'annotateDefaultBranch' in kwargs:
            annotate_default_branch = kwargs['annotateDefaultBranch']
        if branch_names is None and 'branchNames' in kwargs:
            branch_names = kwargs['branchNames']

        if annotate_default_branch is not None:
            _setter("annotate_default_branch", annotate_default_branch)
        if branch_names is not None:
            _setter("branch_names", branch_names)

    @property
    @pulumi.getter(name="annotateDefaultBranch")
    def annotate_default_branch(self) -> Optional[str]:
        """
        Configuration of PR Annotations on default branch.
        
        Enabled - PR Annotations are enabled on the resource's default branch.
        Disabled - PR Annotations are disabled on the resource's default branch.
        """
        return pulumi.get(self, "annotate_default_branch")

    @property
    @pulumi.getter(name="branchNames")
    def branch_names(self) -> Optional[Sequence[str]]:
        """
        Gets or sets branches that should have annotations.
        """
        return pulumi.get(self, "branch_names")


@pulumi.output_type
class ThresholdCustomAlertRuleResponse(dict):
    """
    A custom alert rule that checks if a value (depends on the custom alert type) is within the given range.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "maxThreshold":
            suggest = "max_threshold"
        elif key == "minThreshold":
            suggest = "min_threshold"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThresholdCustomAlertRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThresholdCustomAlertRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThresholdCustomAlertRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 display_name: str,
                 is_enabled: bool,
                 max_threshold: int,
                 min_threshold: int,
                 rule_type: str):
        """
        A custom alert rule that checks if a value (depends on the custom alert type) is within the given range.
        :param str description: The description of the custom alert.
        :param str display_name: The display name of the custom alert.
        :param bool is_enabled: Status of the custom alert.
        :param int max_threshold: The maximum threshold.
        :param int min_threshold: The minimum threshold.
        :param str rule_type: The type of the custom alert rule.
               Expected value is 'ThresholdCustomAlertRule'.
        """
        ThresholdCustomAlertRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            display_name=display_name,
            is_enabled=is_enabled,
            max_threshold=max_threshold,
            min_threshold=min_threshold,
            rule_type=rule_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             max_threshold: Optional[int] = None,
             min_threshold: Optional[int] = None,
             rule_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if max_threshold is None and 'maxThreshold' in kwargs:
            max_threshold = kwargs['maxThreshold']
        if max_threshold is None:
            raise TypeError("Missing 'max_threshold' argument")
        if min_threshold is None and 'minThreshold' in kwargs:
            min_threshold = kwargs['minThreshold']
        if min_threshold is None:
            raise TypeError("Missing 'min_threshold' argument")
        if rule_type is None and 'ruleType' in kwargs:
            rule_type = kwargs['ruleType']
        if rule_type is None:
            raise TypeError("Missing 'rule_type' argument")

        _setter("description", description)
        _setter("display_name", display_name)
        _setter("is_enabled", is_enabled)
        _setter("max_threshold", max_threshold)
        _setter("min_threshold", min_threshold)
        _setter("rule_type", 'ThresholdCustomAlertRule')

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the custom alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the custom alert.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxThreshold")
    def max_threshold(self) -> int:
        """
        The maximum threshold.
        """
        return pulumi.get(self, "max_threshold")

    @property
    @pulumi.getter(name="minThreshold")
    def min_threshold(self) -> int:
        """
        The minimum threshold.
        """
        return pulumi.get(self, "min_threshold")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the custom alert rule.
        Expected value is 'ThresholdCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")


@pulumi.output_type
class TimeWindowCustomAlertRuleResponse(dict):
    """
    A custom alert rule that checks if the number of activities (depends on the custom alert type) in a time window is within the given range.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "maxThreshold":
            suggest = "max_threshold"
        elif key == "minThreshold":
            suggest = "min_threshold"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "timeWindowSize":
            suggest = "time_window_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeWindowCustomAlertRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeWindowCustomAlertRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeWindowCustomAlertRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 display_name: str,
                 is_enabled: bool,
                 max_threshold: int,
                 min_threshold: int,
                 rule_type: str,
                 time_window_size: str):
        """
        A custom alert rule that checks if the number of activities (depends on the custom alert type) in a time window is within the given range.
        :param str description: The description of the custom alert.
        :param str display_name: The display name of the custom alert.
        :param bool is_enabled: Status of the custom alert.
        :param int max_threshold: The maximum threshold.
        :param int min_threshold: The minimum threshold.
        :param str rule_type: The type of the custom alert rule.
               Expected value is 'TimeWindowCustomAlertRule'.
        :param str time_window_size: The time window size in iso8601 format.
        """
        TimeWindowCustomAlertRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            display_name=display_name,
            is_enabled=is_enabled,
            max_threshold=max_threshold,
            min_threshold=min_threshold,
            rule_type=rule_type,
            time_window_size=time_window_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             max_threshold: Optional[int] = None,
             min_threshold: Optional[int] = None,
             rule_type: Optional[str] = None,
             time_window_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if max_threshold is None and 'maxThreshold' in kwargs:
            max_threshold = kwargs['maxThreshold']
        if max_threshold is None:
            raise TypeError("Missing 'max_threshold' argument")
        if min_threshold is None and 'minThreshold' in kwargs:
            min_threshold = kwargs['minThreshold']
        if min_threshold is None:
            raise TypeError("Missing 'min_threshold' argument")
        if rule_type is None and 'ruleType' in kwargs:
            rule_type = kwargs['ruleType']
        if rule_type is None:
            raise TypeError("Missing 'rule_type' argument")
        if time_window_size is None and 'timeWindowSize' in kwargs:
            time_window_size = kwargs['timeWindowSize']
        if time_window_size is None:
            raise TypeError("Missing 'time_window_size' argument")

        _setter("description", description)
        _setter("display_name", display_name)
        _setter("is_enabled", is_enabled)
        _setter("max_threshold", max_threshold)
        _setter("min_threshold", min_threshold)
        _setter("rule_type", 'TimeWindowCustomAlertRule')
        _setter("time_window_size", time_window_size)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the custom alert.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the custom alert.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Status of the custom alert.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxThreshold")
    def max_threshold(self) -> int:
        """
        The maximum threshold.
        """
        return pulumi.get(self, "max_threshold")

    @property
    @pulumi.getter(name="minThreshold")
    def min_threshold(self) -> int:
        """
        The minimum threshold.
        """
        return pulumi.get(self, "min_threshold")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the custom alert rule.
        Expected value is 'TimeWindowCustomAlertRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="timeWindowSize")
    def time_window_size(self) -> str:
        """
        The time window size in iso8601 format.
        """
        return pulumi.get(self, "time_window_size")


@pulumi.output_type
class UserDefinedResourcesPropertiesResponse(dict):
    """
    Properties of the IoT Security solution's user defined resources.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "querySubscriptions":
            suggest = "query_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDefinedResourcesPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDefinedResourcesPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDefinedResourcesPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 query_subscriptions: Sequence[str]):
        """
        Properties of the IoT Security solution's user defined resources.
        :param str query: Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
        :param Sequence[str] query_subscriptions: List of Azure subscription ids on which the user defined resources query should be executed.
        """
        UserDefinedResourcesPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            query_subscriptions=query_subscriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: Optional[str] = None,
             query_subscriptions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query is None:
            raise TypeError("Missing 'query' argument")
        if query_subscriptions is None and 'querySubscriptions' in kwargs:
            query_subscriptions = kwargs['querySubscriptions']
        if query_subscriptions is None:
            raise TypeError("Missing 'query_subscriptions' argument")

        _setter("query", query)
        _setter("query_subscriptions", query_subscriptions)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="querySubscriptions")
    def query_subscriptions(self) -> Sequence[str]:
        """
        List of Azure subscription ids on which the user defined resources query should be executed.
        """
        return pulumi.get(self, "query_subscriptions")


@pulumi.output_type
class UserRecommendationResponse(dict):
    """
    Represents a user that is recommended to be allowed for a certain rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recommendationAction":
            suggest = "recommendation_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recommendation_action: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Represents a user that is recommended to be allowed for a certain rule
        :param str recommendation_action: The recommendation action of the machine or rule
        :param str username: Represents a user that is recommended to be allowed for a certain rule
        """
        UserRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recommendation_action=recommendation_action,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recommendation_action: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if recommendation_action is None and 'recommendationAction' in kwargs:
            recommendation_action = kwargs['recommendationAction']

        if recommendation_action is not None:
            _setter("recommendation_action", recommendation_action)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="recommendationAction")
    def recommendation_action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "recommendation_action")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Represents a user that is recommended to be allowed for a certain rule
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VmRecommendationResponse(dict):
    """
    Represents a machine that is part of a machine group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationStatus":
            suggest = "configuration_status"
        elif key == "enforcementSupport":
            suggest = "enforcement_support"
        elif key == "recommendationAction":
            suggest = "recommendation_action"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_status: Optional[str] = None,
                 enforcement_support: Optional[str] = None,
                 recommendation_action: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Represents a machine that is part of a machine group
        :param str configuration_status: The configuration status of the machines group or machine or rule
        :param str enforcement_support: The machine supportability of Enforce feature
        :param str recommendation_action: The recommendation action of the machine or rule
        :param str resource_id: The full resource id of the machine
        """
        VmRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_status=configuration_status,
            enforcement_support=enforcement_support,
            recommendation_action=recommendation_action,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_status: Optional[str] = None,
             enforcement_support: Optional[str] = None,
             recommendation_action: Optional[str] = None,
             resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_status is None and 'configurationStatus' in kwargs:
            configuration_status = kwargs['configurationStatus']
        if enforcement_support is None and 'enforcementSupport' in kwargs:
            enforcement_support = kwargs['enforcementSupport']
        if recommendation_action is None and 'recommendationAction' in kwargs:
            recommendation_action = kwargs['recommendationAction']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        if configuration_status is not None:
            _setter("configuration_status", configuration_status)
        if enforcement_support is not None:
            _setter("enforcement_support", enforcement_support)
        if recommendation_action is not None:
            _setter("recommendation_action", recommendation_action)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="configurationStatus")
    def configuration_status(self) -> Optional[str]:
        """
        The configuration status of the machines group or machine or rule
        """
        return pulumi.get(self, "configuration_status")

    @property
    @pulumi.getter(name="enforcementSupport")
    def enforcement_support(self) -> Optional[str]:
        """
        The machine supportability of Enforce feature
        """
        return pulumi.get(self, "enforcement_support")

    @property
    @pulumi.getter(name="recommendationAction")
    def recommendation_action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "recommendation_action")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The full resource id of the machine
        """
        return pulumi.get(self, "resource_id")


