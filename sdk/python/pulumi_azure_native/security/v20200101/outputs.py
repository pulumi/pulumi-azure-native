# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdaptiveApplicationControlIssueSummaryResponse',
    'AssessmentLinksResponse',
    'AssessmentStatusResponse',
    'AzureResourceDetailsResponse',
    'JitNetworkAccessPolicyVirtualMachineResponse',
    'JitNetworkAccessPortRuleResponse',
    'JitNetworkAccessRequestPortResponse',
    'JitNetworkAccessRequestResponse',
    'JitNetworkAccessRequestVirtualMachineResponse',
    'OnPremiseResourceDetailsResponse',
    'OnPremiseSqlResourceDetailsResponse',
    'PathRecommendationResponse',
    'ProtectionModeResponse',
    'PublisherInfoResponse',
    'SecurityAssessmentMetadataPartnerDataResponse',
    'SecurityAssessmentMetadataPropertiesResponse',
    'SecurityAssessmentPartnerDataResponse',
    'UserRecommendationResponse',
    'VmRecommendationResponse',
]

@pulumi.output_type
class AdaptiveApplicationControlIssueSummaryResponse(dict):
    """
    Represents a summary of the alerts of the machine group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfVms":
            suggest = "number_of_vms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveApplicationControlIssueSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveApplicationControlIssueSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveApplicationControlIssueSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issue: Optional[str] = None,
                 number_of_vms: Optional[float] = None):
        """
        Represents a summary of the alerts of the machine group
        :param str issue: An alert that machines within a group can have
        :param float number_of_vms: The number of machines in the group that have this alert
        """
        AdaptiveApplicationControlIssueSummaryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            issue=issue,
            number_of_vms=number_of_vms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             issue: Optional[str] = None,
             number_of_vms: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if number_of_vms is None and 'numberOfVms' in kwargs:
            number_of_vms = kwargs['numberOfVms']

        if issue is not None:
            _setter("issue", issue)
        if number_of_vms is not None:
            _setter("number_of_vms", number_of_vms)

    @property
    @pulumi.getter
    def issue(self) -> Optional[str]:
        """
        An alert that machines within a group can have
        """
        return pulumi.get(self, "issue")

    @property
    @pulumi.getter(name="numberOfVms")
    def number_of_vms(self) -> Optional[float]:
        """
        The number of machines in the group that have this alert
        """
        return pulumi.get(self, "number_of_vms")


@pulumi.output_type
class AssessmentLinksResponse(dict):
    """
    Links relevant to the assessment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azurePortalUri":
            suggest = "azure_portal_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssessmentLinksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssessmentLinksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssessmentLinksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_portal_uri: str):
        """
        Links relevant to the assessment
        :param str azure_portal_uri: Link to assessment in Azure Portal
        """
        AssessmentLinksResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_portal_uri=azure_portal_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_portal_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_portal_uri is None and 'azurePortalUri' in kwargs:
            azure_portal_uri = kwargs['azurePortalUri']
        if azure_portal_uri is None:
            raise TypeError("Missing 'azure_portal_uri' argument")

        _setter("azure_portal_uri", azure_portal_uri)

    @property
    @pulumi.getter(name="azurePortalUri")
    def azure_portal_uri(self) -> str:
        """
        Link to assessment in Azure Portal
        """
        return pulumi.get(self, "azure_portal_uri")


@pulumi.output_type
class AssessmentStatusResponse(dict):
    """
    The result of the assessment
    """
    def __init__(__self__, *,
                 code: str,
                 cause: Optional[str] = None,
                 description: Optional[str] = None):
        """
        The result of the assessment
        :param str code: Programmatic code for the status of the assessment
        :param str cause: Programmatic code for the cause of the assessment status
        :param str description: Human readable description of the assessment status
        """
        AssessmentStatusResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            cause=cause,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             cause: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code is None:
            raise TypeError("Missing 'code' argument")

        _setter("code", code)
        if cause is not None:
            _setter("cause", cause)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Programmatic code for the status of the assessment
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def cause(self) -> Optional[str]:
        """
        Programmatic code for the cause of the assessment status
        """
        return pulumi.get(self, "cause")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Human readable description of the assessment status
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AzureResourceDetailsResponse(dict):
    """
    Details of the Azure resource that was assessed
    """
    def __init__(__self__, *,
                 id: str,
                 source: str):
        """
        Details of the Azure resource that was assessed
        :param str id: Azure resource Id of the assessed resource
        :param str source: The platform where the assessed resource resides
               Expected value is 'Azure'.
        """
        AzureResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")

        _setter("id", id)
        _setter("source", 'Azure')

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Azure resource Id of the assessed resource
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'Azure'.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JitNetworkAccessPolicyVirtualMachineResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessPolicyVirtualMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessPolicyVirtualMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessPolicyVirtualMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 ports: Sequence['outputs.JitNetworkAccessPortRuleResponse'],
                 public_ip_address: Optional[str] = None):
        """
        :param str id: Resource ID of the virtual machine that is linked to this policy
        :param Sequence['JitNetworkAccessPortRuleResponse'] ports: Port configurations for the virtual machine
        :param str public_ip_address: Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        JitNetworkAccessPolicyVirtualMachineResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ports=ports,
            public_ip_address=public_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ports: Optional[Sequence['outputs.JitNetworkAccessPortRuleResponse']] = None,
             public_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")
        if public_ip_address is None and 'publicIpAddress' in kwargs:
            public_ip_address = kwargs['publicIpAddress']

        _setter("id", id)
        _setter("ports", ports)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.JitNetworkAccessPortRuleResponse']:
        """
        Port configurations for the virtual machine
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        Public IP address of the Azure Firewall that is linked to this policy, if applicable
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class JitNetworkAccessPortRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRequestAccessDuration":
            suggest = "max_request_access_duration"
        elif key == "allowedSourceAddressPrefix":
            suggest = "allowed_source_address_prefix"
        elif key == "allowedSourceAddressPrefixes":
            suggest = "allowed_source_address_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessPortRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessPortRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessPortRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_request_access_duration: str,
                 number: int,
                 protocol: str,
                 allowed_source_address_prefix: Optional[str] = None,
                 allowed_source_address_prefixes: Optional[Sequence[str]] = None):
        """
        :param str max_request_access_duration: Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        :param str allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param Sequence[str] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        JitNetworkAccessPortRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_request_access_duration=max_request_access_duration,
            number=number,
            protocol=protocol,
            allowed_source_address_prefix=allowed_source_address_prefix,
            allowed_source_address_prefixes=allowed_source_address_prefixes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_request_access_duration: Optional[str] = None,
             number: Optional[int] = None,
             protocol: Optional[str] = None,
             allowed_source_address_prefix: Optional[str] = None,
             allowed_source_address_prefixes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_request_access_duration is None and 'maxRequestAccessDuration' in kwargs:
            max_request_access_duration = kwargs['maxRequestAccessDuration']
        if max_request_access_duration is None:
            raise TypeError("Missing 'max_request_access_duration' argument")
        if number is None:
            raise TypeError("Missing 'number' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if allowed_source_address_prefix is None and 'allowedSourceAddressPrefix' in kwargs:
            allowed_source_address_prefix = kwargs['allowedSourceAddressPrefix']
        if allowed_source_address_prefixes is None and 'allowedSourceAddressPrefixes' in kwargs:
            allowed_source_address_prefixes = kwargs['allowedSourceAddressPrefixes']

        _setter("max_request_access_duration", max_request_access_duration)
        _setter("number", number)
        _setter("protocol", protocol)
        if allowed_source_address_prefix is not None:
            _setter("allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            _setter("allowed_source_address_prefixes", allowed_source_address_prefixes)

    @property
    @pulumi.getter(name="maxRequestAccessDuration")
    def max_request_access_duration(self) -> str:
        """
        Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
        """
        return pulumi.get(self, "max_request_access_duration")

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[str]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")


@pulumi.output_type
class JitNetworkAccessRequestPortResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeUtc":
            suggest = "end_time_utc"
        elif key == "statusReason":
            suggest = "status_reason"
        elif key == "allowedSourceAddressPrefix":
            suggest = "allowed_source_address_prefix"
        elif key == "allowedSourceAddressPrefixes":
            suggest = "allowed_source_address_prefixes"
        elif key == "mappedPort":
            suggest = "mapped_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessRequestPortResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessRequestPortResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessRequestPortResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time_utc: str,
                 number: int,
                 status: str,
                 status_reason: str,
                 allowed_source_address_prefix: Optional[str] = None,
                 allowed_source_address_prefixes: Optional[Sequence[str]] = None,
                 mapped_port: Optional[int] = None):
        """
        :param str end_time_utc: The date & time at which the request ends in UTC
        :param str status: The status of the port
        :param str status_reason: A description of why the `status` has its value
        :param str allowed_source_address_prefix: Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        :param Sequence[str] allowed_source_address_prefixes: Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        :param int mapped_port: The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        JitNetworkAccessRequestPortResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time_utc=end_time_utc,
            number=number,
            status=status,
            status_reason=status_reason,
            allowed_source_address_prefix=allowed_source_address_prefix,
            allowed_source_address_prefixes=allowed_source_address_prefixes,
            mapped_port=mapped_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time_utc: Optional[str] = None,
             number: Optional[int] = None,
             status: Optional[str] = None,
             status_reason: Optional[str] = None,
             allowed_source_address_prefix: Optional[str] = None,
             allowed_source_address_prefixes: Optional[Sequence[str]] = None,
             mapped_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if number is None:
            raise TypeError("Missing 'number' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_reason is None and 'statusReason' in kwargs:
            status_reason = kwargs['statusReason']
        if status_reason is None:
            raise TypeError("Missing 'status_reason' argument")
        if allowed_source_address_prefix is None and 'allowedSourceAddressPrefix' in kwargs:
            allowed_source_address_prefix = kwargs['allowedSourceAddressPrefix']
        if allowed_source_address_prefixes is None and 'allowedSourceAddressPrefixes' in kwargs:
            allowed_source_address_prefixes = kwargs['allowedSourceAddressPrefixes']
        if mapped_port is None and 'mappedPort' in kwargs:
            mapped_port = kwargs['mappedPort']

        _setter("end_time_utc", end_time_utc)
        _setter("number", number)
        _setter("status", status)
        _setter("status_reason", status_reason)
        if allowed_source_address_prefix is not None:
            _setter("allowed_source_address_prefix", allowed_source_address_prefix)
        if allowed_source_address_prefixes is not None:
            _setter("allowed_source_address_prefixes", allowed_source_address_prefixes)
        if mapped_port is not None:
            _setter("mapped_port", mapped_port)

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The date & time at which the request ends in UTC
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the port
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> str:
        """
        A description of why the `status` has its value
        """
        return pulumi.get(self, "status_reason")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefix")
    def allowed_source_address_prefix(self) -> Optional[str]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
        """
        return pulumi.get(self, "allowed_source_address_prefix")

    @property
    @pulumi.getter(name="allowedSourceAddressPrefixes")
    def allowed_source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
        """
        return pulumi.get(self, "allowed_source_address_prefixes")

    @property
    @pulumi.getter(name="mappedPort")
    def mapped_port(self) -> Optional[int]:
        """
        The port which is mapped to this port's `number` in the Azure Firewall, if applicable
        """
        return pulumi.get(self, "mapped_port")


@pulumi.output_type
class JitNetworkAccessRequestResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTimeUtc":
            suggest = "start_time_utc"
        elif key == "virtualMachines":
            suggest = "virtual_machines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JitNetworkAccessRequestResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JitNetworkAccessRequestResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JitNetworkAccessRequestResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requestor: str,
                 start_time_utc: str,
                 virtual_machines: Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse'],
                 justification: Optional[str] = None):
        """
        :param str requestor: The identity of the person who made the request
        :param str start_time_utc: The start time of the request in UTC
        :param str justification: The justification for making the initiate request
        """
        JitNetworkAccessRequestResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requestor=requestor,
            start_time_utc=start_time_utc,
            virtual_machines=virtual_machines,
            justification=justification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requestor: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             virtual_machines: Optional[Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse']] = None,
             justification: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if requestor is None:
            raise TypeError("Missing 'requestor' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if virtual_machines is None and 'virtualMachines' in kwargs:
            virtual_machines = kwargs['virtualMachines']
        if virtual_machines is None:
            raise TypeError("Missing 'virtual_machines' argument")

        _setter("requestor", requestor)
        _setter("start_time_utc", start_time_utc)
        _setter("virtual_machines", virtual_machines)
        if justification is not None:
            _setter("justification", justification)

    @property
    @pulumi.getter
    def requestor(self) -> str:
        """
        The identity of the person who made the request
        """
        return pulumi.get(self, "requestor")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The start time of the request in UTC
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="virtualMachines")
    def virtual_machines(self) -> Sequence['outputs.JitNetworkAccessRequestVirtualMachineResponse']:
        return pulumi.get(self, "virtual_machines")

    @property
    @pulumi.getter
    def justification(self) -> Optional[str]:
        """
        The justification for making the initiate request
        """
        return pulumi.get(self, "justification")


@pulumi.output_type
class JitNetworkAccessRequestVirtualMachineResponse(dict):
    def __init__(__self__, *,
                 id: str,
                 ports: Sequence['outputs.JitNetworkAccessRequestPortResponse']):
        """
        :param str id: Resource ID of the virtual machine that is linked to this policy
        :param Sequence['JitNetworkAccessRequestPortResponse'] ports: The ports that were opened for the virtual machine
        """
        JitNetworkAccessRequestVirtualMachineResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ports: Optional[Sequence['outputs.JitNetworkAccessRequestPortResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ports is None:
            raise TypeError("Missing 'ports' argument")

        _setter("id", id)
        _setter("ports", ports)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource ID of the virtual machine that is linked to this policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.JitNetworkAccessRequestPortResponse']:
        """
        The ports that were opened for the virtual machine
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class OnPremiseResourceDetailsResponse(dict):
    """
    Details of the On Premise resource that was assessed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineName":
            suggest = "machine_name"
        elif key == "sourceComputerId":
            suggest = "source_computer_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnPremiseResourceDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnPremiseResourceDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnPremiseResourceDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_name: str,
                 source: str,
                 source_computer_id: str,
                 vmuuid: str,
                 workspace_id: str):
        """
        Details of the On Premise resource that was assessed
        :param str machine_name: The name of the machine
        :param str source: The platform where the assessed resource resides
               Expected value is 'OnPremise'.
        :param str source_computer_id: The oms agent Id installed on the machine
        :param str vmuuid: The unique Id of the machine
        :param str workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        OnPremiseResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            machine_name=machine_name,
            source=source,
            source_computer_id=source_computer_id,
            vmuuid=vmuuid,
            workspace_id=workspace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             machine_name: Optional[str] = None,
             source: Optional[str] = None,
             source_computer_id: Optional[str] = None,
             vmuuid: Optional[str] = None,
             workspace_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if machine_name is None and 'machineName' in kwargs:
            machine_name = kwargs['machineName']
        if machine_name is None:
            raise TypeError("Missing 'machine_name' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_computer_id is None and 'sourceComputerId' in kwargs:
            source_computer_id = kwargs['sourceComputerId']
        if source_computer_id is None:
            raise TypeError("Missing 'source_computer_id' argument")
        if vmuuid is None:
            raise TypeError("Missing 'vmuuid' argument")
        if workspace_id is None and 'workspaceId' in kwargs:
            workspace_id = kwargs['workspaceId']
        if workspace_id is None:
            raise TypeError("Missing 'workspace_id' argument")

        _setter("machine_name", machine_name)
        _setter("source", 'OnPremise')
        _setter("source_computer_id", source_computer_id)
        _setter("vmuuid", vmuuid)
        _setter("workspace_id", workspace_id)

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> str:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremise'.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> str:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @property
    @pulumi.getter
    def vmuuid(self) -> str:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class OnPremiseSqlResourceDetailsResponse(dict):
    """
    Details of the On Premise Sql resource that was assessed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "machineName":
            suggest = "machine_name"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "sourceComputerId":
            suggest = "source_computer_id"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnPremiseSqlResourceDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnPremiseSqlResourceDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnPremiseSqlResourceDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 machine_name: str,
                 server_name: str,
                 source: str,
                 source_computer_id: str,
                 vmuuid: str,
                 workspace_id: str):
        """
        Details of the On Premise Sql resource that was assessed
        :param str database_name: The Sql database name installed on the machine
        :param str machine_name: The name of the machine
        :param str server_name: The Sql server name installed on the machine
        :param str source: The platform where the assessed resource resides
               Expected value is 'OnPremiseSql'.
        :param str source_computer_id: The oms agent Id installed on the machine
        :param str vmuuid: The unique Id of the machine
        :param str workspace_id: Azure resource Id of the workspace the machine is attached to
        """
        OnPremiseSqlResourceDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            machine_name=machine_name,
            server_name=server_name,
            source=source,
            source_computer_id=source_computer_id,
            vmuuid=vmuuid,
            workspace_id=workspace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             machine_name: Optional[str] = None,
             server_name: Optional[str] = None,
             source: Optional[str] = None,
             source_computer_id: Optional[str] = None,
             vmuuid: Optional[str] = None,
             workspace_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if machine_name is None and 'machineName' in kwargs:
            machine_name = kwargs['machineName']
        if machine_name is None:
            raise TypeError("Missing 'machine_name' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_computer_id is None and 'sourceComputerId' in kwargs:
            source_computer_id = kwargs['sourceComputerId']
        if source_computer_id is None:
            raise TypeError("Missing 'source_computer_id' argument")
        if vmuuid is None:
            raise TypeError("Missing 'vmuuid' argument")
        if workspace_id is None and 'workspaceId' in kwargs:
            workspace_id = kwargs['workspaceId']
        if workspace_id is None:
            raise TypeError("Missing 'workspace_id' argument")

        _setter("database_name", database_name)
        _setter("machine_name", machine_name)
        _setter("server_name", server_name)
        _setter("source", 'OnPremiseSql')
        _setter("source_computer_id", source_computer_id)
        _setter("vmuuid", vmuuid)
        _setter("workspace_id", workspace_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The Sql database name installed on the machine
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> str:
        """
        The name of the machine
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        The Sql server name installed on the machine
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The platform where the assessed resource resides
        Expected value is 'OnPremiseSql'.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceComputerId")
    def source_computer_id(self) -> str:
        """
        The oms agent Id installed on the machine
        """
        return pulumi.get(self, "source_computer_id")

    @property
    @pulumi.getter
    def vmuuid(self) -> str:
        """
        The unique Id of the machine
        """
        return pulumi.get(self, "vmuuid")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        Azure resource Id of the workspace the machine is attached to
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class PathRecommendationResponse(dict):
    """
    Represents a path that is recommended to be allowed and its properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationStatus":
            suggest = "configuration_status"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "publisherInfo":
            suggest = "publisher_info"
        elif key == "userSids":
            suggest = "user_sids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PathRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PathRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PathRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 common: Optional[bool] = None,
                 configuration_status: Optional[str] = None,
                 file_type: Optional[str] = None,
                 path: Optional[str] = None,
                 publisher_info: Optional['outputs.PublisherInfoResponse'] = None,
                 type: Optional[str] = None,
                 user_sids: Optional[Sequence[str]] = None,
                 usernames: Optional[Sequence['outputs.UserRecommendationResponse']] = None):
        """
        Represents a path that is recommended to be allowed and its properties
        :param str action: The recommendation action of the machine or rule
        :param bool common: Whether the application is commonly run on the machine
        :param str configuration_status: The configuration status of the machines group or machine or rule
        :param str file_type: The type of the file (for Linux files - Executable is used)
        :param str path: The full path of the file, or an identifier of the application
        :param 'PublisherInfoResponse' publisher_info: Represents the publisher information of a process/rule
        :param str type: The type of the rule to be allowed
        """
        PathRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            common=common,
            configuration_status=configuration_status,
            file_type=file_type,
            path=path,
            publisher_info=publisher_info,
            type=type,
            user_sids=user_sids,
            usernames=usernames,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             common: Optional[bool] = None,
             configuration_status: Optional[str] = None,
             file_type: Optional[str] = None,
             path: Optional[str] = None,
             publisher_info: Optional['outputs.PublisherInfoResponse'] = None,
             type: Optional[str] = None,
             user_sids: Optional[Sequence[str]] = None,
             usernames: Optional[Sequence['outputs.UserRecommendationResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_status is None and 'configurationStatus' in kwargs:
            configuration_status = kwargs['configurationStatus']
        if file_type is None and 'fileType' in kwargs:
            file_type = kwargs['fileType']
        if publisher_info is None and 'publisherInfo' in kwargs:
            publisher_info = kwargs['publisherInfo']
        if user_sids is None and 'userSids' in kwargs:
            user_sids = kwargs['userSids']

        if action is not None:
            _setter("action", action)
        if common is not None:
            _setter("common", common)
        if configuration_status is not None:
            _setter("configuration_status", configuration_status)
        if file_type is not None:
            _setter("file_type", file_type)
        if path is not None:
            _setter("path", path)
        if publisher_info is not None:
            _setter("publisher_info", publisher_info)
        if type is not None:
            _setter("type", type)
        if user_sids is not None:
            _setter("user_sids", user_sids)
        if usernames is not None:
            _setter("usernames", usernames)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def common(self) -> Optional[bool]:
        """
        Whether the application is commonly run on the machine
        """
        return pulumi.get(self, "common")

    @property
    @pulumi.getter(name="configurationStatus")
    def configuration_status(self) -> Optional[str]:
        """
        The configuration status of the machines group or machine or rule
        """
        return pulumi.get(self, "configuration_status")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        The type of the file (for Linux files - Executable is used)
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The full path of the file, or an identifier of the application
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="publisherInfo")
    def publisher_info(self) -> Optional['outputs.PublisherInfoResponse']:
        """
        Represents the publisher information of a process/rule
        """
        return pulumi.get(self, "publisher_info")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the rule to be allowed
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userSids")
    def user_sids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_sids")

    @property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence['outputs.UserRecommendationResponse']]:
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ProtectionModeResponse(dict):
    """
    The protection mode of the collection/file types. Exe/Msi/Script are used for Windows, Executable is used for Linux.
    """
    def __init__(__self__, *,
                 exe: Optional[str] = None,
                 executable: Optional[str] = None,
                 msi: Optional[str] = None,
                 script: Optional[str] = None):
        """
        The protection mode of the collection/file types. Exe/Msi/Script are used for Windows, Executable is used for Linux.
        :param str exe: The application control policy enforcement/protection mode of the machine group
        :param str executable: The application control policy enforcement/protection mode of the machine group
        :param str msi: The application control policy enforcement/protection mode of the machine group
        :param str script: The application control policy enforcement/protection mode of the machine group
        """
        ProtectionModeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exe=exe,
            executable=executable,
            msi=msi,
            script=script,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exe: Optional[str] = None,
             executable: Optional[str] = None,
             msi: Optional[str] = None,
             script: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exe is not None:
            _setter("exe", exe)
        if executable is not None:
            _setter("executable", executable)
        if msi is not None:
            _setter("msi", msi)
        if script is not None:
            _setter("script", script)

    @property
    @pulumi.getter
    def exe(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "exe")

    @property
    @pulumi.getter
    def executable(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "executable")

    @property
    @pulumi.getter
    def msi(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "msi")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        The application control policy enforcement/protection mode of the machine group
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class PublisherInfoResponse(dict):
    """
    Represents the publisher information of a process/rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binaryName":
            suggest = "binary_name"
        elif key == "productName":
            suggest = "product_name"
        elif key == "publisherName":
            suggest = "publisher_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublisherInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublisherInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublisherInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binary_name: Optional[str] = None,
                 product_name: Optional[str] = None,
                 publisher_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Represents the publisher information of a process/rule
        :param str binary_name: The "OriginalName" field taken from the file's version resource
        :param str product_name: The product name taken from the file's version resource
        :param str publisher_name: The Subject field of the x.509 certificate used to sign the code, using the following fields -  O = Organization, L = Locality, S = State or Province, and C = Country
        :param str version: The binary file version taken from the file's version resource
        """
        PublisherInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binary_name=binary_name,
            product_name=product_name,
            publisher_name=publisher_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binary_name: Optional[str] = None,
             product_name: Optional[str] = None,
             publisher_name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if binary_name is None and 'binaryName' in kwargs:
            binary_name = kwargs['binaryName']
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']
        if publisher_name is None and 'publisherName' in kwargs:
            publisher_name = kwargs['publisherName']

        if binary_name is not None:
            _setter("binary_name", binary_name)
        if product_name is not None:
            _setter("product_name", product_name)
        if publisher_name is not None:
            _setter("publisher_name", publisher_name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="binaryName")
    def binary_name(self) -> Optional[str]:
        """
        The "OriginalName" field taken from the file's version resource
        """
        return pulumi.get(self, "binary_name")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The product name taken from the file's version resource
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="publisherName")
    def publisher_name(self) -> Optional[str]:
        """
        The Subject field of the x.509 certificate used to sign the code, using the following fields -  O = Organization, L = Locality, S = State or Province, and C = Country
        """
        return pulumi.get(self, "publisher_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The binary file version taken from the file's version resource
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SecurityAssessmentMetadataPartnerDataResponse(dict):
    """
    Describes the partner that created the assessment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerName":
            suggest = "partner_name"
        elif key == "productName":
            suggest = "product_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentMetadataPartnerDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentMetadataPartnerDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentMetadataPartnerDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_name: str,
                 secret: str,
                 product_name: Optional[str] = None):
        """
        Describes the partner that created the assessment
        :param str partner_name: Name of the company of the partner
        :param str secret: Secret to authenticate the partner and verify it created the assessment - write only
        :param str product_name: Name of the product of the partner that created the assessment
        """
        SecurityAssessmentMetadataPartnerDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partner_name=partner_name,
            secret=secret,
            product_name=product_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partner_name: Optional[str] = None,
             secret: Optional[str] = None,
             product_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if partner_name is None and 'partnerName' in kwargs:
            partner_name = kwargs['partnerName']
        if partner_name is None:
            raise TypeError("Missing 'partner_name' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("partner_name", partner_name)
        _setter("secret", secret)
        if product_name is not None:
            _setter("product_name", product_name)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> str:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Secret to authenticate the partner and verify it created the assessment - write only
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        Name of the product of the partner that created the assessment
        """
        return pulumi.get(self, "product_name")


@pulumi.output_type
class SecurityAssessmentMetadataPropertiesResponse(dict):
    """
    Describes properties of an assessment metadata.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assessmentType":
            suggest = "assessment_type"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "policyDefinitionId":
            suggest = "policy_definition_id"
        elif key == "implementationEffort":
            suggest = "implementation_effort"
        elif key == "partnerData":
            suggest = "partner_data"
        elif key == "remediationDescription":
            suggest = "remediation_description"
        elif key == "userImpact":
            suggest = "user_impact"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assessment_type: str,
                 display_name: str,
                 policy_definition_id: str,
                 severity: str,
                 categories: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 implementation_effort: Optional[str] = None,
                 partner_data: Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse'] = None,
                 preview: Optional[bool] = None,
                 remediation_description: Optional[str] = None,
                 threats: Optional[Sequence[str]] = None,
                 user_impact: Optional[str] = None):
        """
        Describes properties of an assessment metadata.
        :param str assessment_type: BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        :param str display_name: User friendly display name of the assessment
        :param str policy_definition_id: Azure resource ID of the policy definition that turns this assessment calculation on
        :param str severity: The severity level of the assessment
        :param str description: Human readable description of the assessment
        :param str implementation_effort: The implementation effort required to remediate this assessment
        :param 'SecurityAssessmentMetadataPartnerDataResponse' partner_data: Describes the partner that created the assessment
        :param bool preview: True if this assessment is in preview release status
        :param str remediation_description: Human readable description of what you should do to mitigate this security issue
        :param str user_impact: The user impact of the assessment
        """
        SecurityAssessmentMetadataPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_type=assessment_type,
            display_name=display_name,
            policy_definition_id=policy_definition_id,
            severity=severity,
            categories=categories,
            description=description,
            implementation_effort=implementation_effort,
            partner_data=partner_data,
            preview=preview,
            remediation_description=remediation_description,
            threats=threats,
            user_impact=user_impact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_type: Optional[str] = None,
             display_name: Optional[str] = None,
             policy_definition_id: Optional[str] = None,
             severity: Optional[str] = None,
             categories: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             implementation_effort: Optional[str] = None,
             partner_data: Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse'] = None,
             preview: Optional[bool] = None,
             remediation_description: Optional[str] = None,
             threats: Optional[Sequence[str]] = None,
             user_impact: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_type is None and 'assessmentType' in kwargs:
            assessment_type = kwargs['assessmentType']
        if assessment_type is None:
            raise TypeError("Missing 'assessment_type' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if policy_definition_id is None and 'policyDefinitionId' in kwargs:
            policy_definition_id = kwargs['policyDefinitionId']
        if policy_definition_id is None:
            raise TypeError("Missing 'policy_definition_id' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if implementation_effort is None and 'implementationEffort' in kwargs:
            implementation_effort = kwargs['implementationEffort']
        if partner_data is None and 'partnerData' in kwargs:
            partner_data = kwargs['partnerData']
        if remediation_description is None and 'remediationDescription' in kwargs:
            remediation_description = kwargs['remediationDescription']
        if user_impact is None and 'userImpact' in kwargs:
            user_impact = kwargs['userImpact']

        _setter("assessment_type", assessment_type)
        _setter("display_name", display_name)
        _setter("policy_definition_id", policy_definition_id)
        _setter("severity", severity)
        if categories is not None:
            _setter("categories", categories)
        if description is not None:
            _setter("description", description)
        if implementation_effort is not None:
            _setter("implementation_effort", implementation_effort)
        if partner_data is not None:
            _setter("partner_data", partner_data)
        if preview is not None:
            _setter("preview", preview)
        if remediation_description is not None:
            _setter("remediation_description", remediation_description)
        if threats is not None:
            _setter("threats", threats)
        if user_impact is not None:
            _setter("user_impact", user_impact)

    @property
    @pulumi.getter(name="assessmentType")
    def assessment_type(self) -> str:
        """
        BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
        """
        return pulumi.get(self, "assessment_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User friendly display name of the assessment
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="policyDefinitionId")
    def policy_definition_id(self) -> str:
        """
        Azure resource ID of the policy definition that turns this assessment calculation on
        """
        return pulumi.get(self, "policy_definition_id")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The severity level of the assessment
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Human readable description of the assessment
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="implementationEffort")
    def implementation_effort(self) -> Optional[str]:
        """
        The implementation effort required to remediate this assessment
        """
        return pulumi.get(self, "implementation_effort")

    @property
    @pulumi.getter(name="partnerData")
    def partner_data(self) -> Optional['outputs.SecurityAssessmentMetadataPartnerDataResponse']:
        """
        Describes the partner that created the assessment
        """
        return pulumi.get(self, "partner_data")

    @property
    @pulumi.getter
    def preview(self) -> Optional[bool]:
        """
        True if this assessment is in preview release status
        """
        return pulumi.get(self, "preview")

    @property
    @pulumi.getter(name="remediationDescription")
    def remediation_description(self) -> Optional[str]:
        """
        Human readable description of what you should do to mitigate this security issue
        """
        return pulumi.get(self, "remediation_description")

    @property
    @pulumi.getter
    def threats(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "threats")

    @property
    @pulumi.getter(name="userImpact")
    def user_impact(self) -> Optional[str]:
        """
        The user impact of the assessment
        """
        return pulumi.get(self, "user_impact")


@pulumi.output_type
class SecurityAssessmentPartnerDataResponse(dict):
    """
    Data regarding 3rd party partner integration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerName":
            suggest = "partner_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityAssessmentPartnerDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityAssessmentPartnerDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityAssessmentPartnerDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_name: str,
                 secret: str):
        """
        Data regarding 3rd party partner integration
        :param str partner_name: Name of the company of the partner
        :param str secret: secret to authenticate the partner - write only
        """
        SecurityAssessmentPartnerDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partner_name=partner_name,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partner_name: Optional[str] = None,
             secret: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if partner_name is None and 'partnerName' in kwargs:
            partner_name = kwargs['partnerName']
        if partner_name is None:
            raise TypeError("Missing 'partner_name' argument")
        if secret is None:
            raise TypeError("Missing 'secret' argument")

        _setter("partner_name", partner_name)
        _setter("secret", secret)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> str:
        """
        Name of the company of the partner
        """
        return pulumi.get(self, "partner_name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret to authenticate the partner - write only
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class UserRecommendationResponse(dict):
    """
    Represents a user that is recommended to be allowed for a certain rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recommendationAction":
            suggest = "recommendation_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recommendation_action: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Represents a user that is recommended to be allowed for a certain rule
        :param str recommendation_action: The recommendation action of the machine or rule
        :param str username: Represents a user that is recommended to be allowed for a certain rule
        """
        UserRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recommendation_action=recommendation_action,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recommendation_action: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if recommendation_action is None and 'recommendationAction' in kwargs:
            recommendation_action = kwargs['recommendationAction']

        if recommendation_action is not None:
            _setter("recommendation_action", recommendation_action)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="recommendationAction")
    def recommendation_action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "recommendation_action")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Represents a user that is recommended to be allowed for a certain rule
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VmRecommendationResponse(dict):
    """
    Represents a machine that is part of a machine group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationStatus":
            suggest = "configuration_status"
        elif key == "enforcementSupport":
            suggest = "enforcement_support"
        elif key == "recommendationAction":
            suggest = "recommendation_action"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmRecommendationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmRecommendationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmRecommendationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_status: Optional[str] = None,
                 enforcement_support: Optional[str] = None,
                 recommendation_action: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Represents a machine that is part of a machine group
        :param str configuration_status: The configuration status of the machines group or machine or rule
        :param str enforcement_support: The machine supportability of Enforce feature
        :param str recommendation_action: The recommendation action of the machine or rule
        :param str resource_id: The full resource id of the machine
        """
        VmRecommendationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_status=configuration_status,
            enforcement_support=enforcement_support,
            recommendation_action=recommendation_action,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_status: Optional[str] = None,
             enforcement_support: Optional[str] = None,
             recommendation_action: Optional[str] = None,
             resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_status is None and 'configurationStatus' in kwargs:
            configuration_status = kwargs['configurationStatus']
        if enforcement_support is None and 'enforcementSupport' in kwargs:
            enforcement_support = kwargs['enforcementSupport']
        if recommendation_action is None and 'recommendationAction' in kwargs:
            recommendation_action = kwargs['recommendationAction']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        if configuration_status is not None:
            _setter("configuration_status", configuration_status)
        if enforcement_support is not None:
            _setter("enforcement_support", enforcement_support)
        if recommendation_action is not None:
            _setter("recommendation_action", recommendation_action)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="configurationStatus")
    def configuration_status(self) -> Optional[str]:
        """
        The configuration status of the machines group or machine or rule
        """
        return pulumi.get(self, "configuration_status")

    @property
    @pulumi.getter(name="enforcementSupport")
    def enforcement_support(self) -> Optional[str]:
        """
        The machine supportability of Enforce feature
        """
        return pulumi.get(self, "enforcement_support")

    @property
    @pulumi.getter(name="recommendationAction")
    def recommendation_action(self) -> Optional[str]:
        """
        The recommendation action of the machine or rule
        """
        return pulumi.get(self, "recommendation_action")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The full resource id of the machine
        """
        return pulumi.get(self, "resource_id")


