# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'ActivityDependencyArgs',
    'ActivityPolicyArgs',
    'AmazonMWSLinkedServiceArgs',
    'AmazonMWSObjectDatasetArgs',
    'AmazonMWSSourceArgs',
    'AmazonRdsForOracleLinkedServiceArgs',
    'AmazonRdsForOraclePartitionSettingsArgs',
    'AmazonRdsForOracleSourceArgs',
    'AmazonRdsForOracleTableDatasetArgs',
    'AmazonRdsForSqlServerLinkedServiceArgs',
    'AmazonRdsForSqlServerSourceArgs',
    'AmazonRdsForSqlServerTableDatasetArgs',
    'AmazonRedshiftLinkedServiceArgs',
    'AmazonRedshiftSourceArgs',
    'AmazonRedshiftTableDatasetArgs',
    'AmazonS3CompatibleLinkedServiceArgs',
    'AmazonS3CompatibleLocationArgs',
    'AmazonS3CompatibleReadSettingsArgs',
    'AmazonS3DatasetArgs',
    'AmazonS3LinkedServiceArgs',
    'AmazonS3LocationArgs',
    'AmazonS3ReadSettingsArgs',
    'AppendVariableActivityArgs',
    'AvroDatasetArgs',
    'AvroFormatArgs',
    'AvroSinkArgs',
    'AvroSourceArgs',
    'AvroWriteSettingsArgs',
    'AzPowerShellSetupArgs',
    'AzureBatchLinkedServiceArgs',
    'AzureBlobDatasetArgs',
    'AzureBlobFSDatasetArgs',
    'AzureBlobFSLinkedServiceArgs',
    'AzureBlobFSLocationArgs',
    'AzureBlobFSReadSettingsArgs',
    'AzureBlobFSSinkArgs',
    'AzureBlobFSSourceArgs',
    'AzureBlobFSWriteSettingsArgs',
    'AzureBlobStorageLinkedServiceArgs',
    'AzureBlobStorageLocationArgs',
    'AzureBlobStorageReadSettingsArgs',
    'AzureBlobStorageWriteSettingsArgs',
    'AzureDataExplorerCommandActivityArgs',
    'AzureDataExplorerLinkedServiceArgs',
    'AzureDataExplorerSinkArgs',
    'AzureDataExplorerSourceArgs',
    'AzureDataExplorerTableDatasetArgs',
    'AzureDataLakeAnalyticsLinkedServiceArgs',
    'AzureDataLakeStoreDatasetArgs',
    'AzureDataLakeStoreLinkedServiceArgs',
    'AzureDataLakeStoreLocationArgs',
    'AzureDataLakeStoreReadSettingsArgs',
    'AzureDataLakeStoreSinkArgs',
    'AzureDataLakeStoreSourceArgs',
    'AzureDataLakeStoreWriteSettingsArgs',
    'AzureDatabricksDeltaLakeDatasetArgs',
    'AzureDatabricksDeltaLakeExportCommandArgs',
    'AzureDatabricksDeltaLakeImportCommandArgs',
    'AzureDatabricksDeltaLakeLinkedServiceArgs',
    'AzureDatabricksDeltaLakeSinkArgs',
    'AzureDatabricksDeltaLakeSourceArgs',
    'AzureDatabricksLinkedServiceArgs',
    'AzureFileStorageLinkedServiceArgs',
    'AzureFileStorageLocationArgs',
    'AzureFileStorageReadSettingsArgs',
    'AzureFileStorageWriteSettingsArgs',
    'AzureFunctionActivityArgs',
    'AzureFunctionLinkedServiceArgs',
    'AzureKeyVaultLinkedServiceArgs',
    'AzureKeyVaultSecretReferenceArgs',
    'AzureMLBatchExecutionActivityArgs',
    'AzureMLExecutePipelineActivityArgs',
    'AzureMLLinkedServiceArgs',
    'AzureMLServiceLinkedServiceArgs',
    'AzureMLUpdateResourceActivityArgs',
    'AzureMLWebServiceFileArgs',
    'AzureMariaDBLinkedServiceArgs',
    'AzureMariaDBSourceArgs',
    'AzureMariaDBTableDatasetArgs',
    'AzureMySqlLinkedServiceArgs',
    'AzureMySqlSinkArgs',
    'AzureMySqlSourceArgs',
    'AzureMySqlTableDatasetArgs',
    'AzurePostgreSqlLinkedServiceArgs',
    'AzurePostgreSqlSinkArgs',
    'AzurePostgreSqlSourceArgs',
    'AzurePostgreSqlTableDatasetArgs',
    'AzureQueueSinkArgs',
    'AzureSearchIndexDatasetArgs',
    'AzureSearchIndexSinkArgs',
    'AzureSearchLinkedServiceArgs',
    'AzureSqlDWLinkedServiceArgs',
    'AzureSqlDWTableDatasetArgs',
    'AzureSqlDatabaseLinkedServiceArgs',
    'AzureSqlMILinkedServiceArgs',
    'AzureSqlMITableDatasetArgs',
    'AzureSqlSinkArgs',
    'AzureSqlSourceArgs',
    'AzureSqlTableDatasetArgs',
    'AzureStorageLinkedServiceArgs',
    'AzureTableDatasetArgs',
    'AzureTableSinkArgs',
    'AzureTableSourceArgs',
    'AzureTableStorageLinkedServiceArgs',
    'BinaryDatasetArgs',
    'BinaryReadSettingsArgs',
    'BinarySinkArgs',
    'BinarySourceArgs',
    'BlobEventsTriggerArgs',
    'BlobSinkArgs',
    'BlobSourceArgs',
    'BlobTriggerArgs',
    'CMKIdentityDefinitionArgs',
    'CassandraLinkedServiceArgs',
    'CassandraSourceArgs',
    'CassandraTableDatasetArgs',
    'ChainingTriggerArgs',
    'CmdkeySetupArgs',
    'CommonDataServiceForAppsEntityDatasetArgs',
    'CommonDataServiceForAppsLinkedServiceArgs',
    'CommonDataServiceForAppsSinkArgs',
    'CommonDataServiceForAppsSourceArgs',
    'ComponentSetupArgs',
    'ConcurLinkedServiceArgs',
    'ConcurObjectDatasetArgs',
    'ConcurSourceArgs',
    'ControlActivityArgs',
    'CopyActivityLogSettingsArgs',
    'CopyActivityArgs',
    'CosmosDbLinkedServiceArgs',
    'CosmosDbMongoDbApiCollectionDatasetArgs',
    'CosmosDbMongoDbApiLinkedServiceArgs',
    'CosmosDbMongoDbApiSinkArgs',
    'CosmosDbMongoDbApiSourceArgs',
    'CosmosDbSqlApiCollectionDatasetArgs',
    'CosmosDbSqlApiSinkArgs',
    'CosmosDbSqlApiSourceArgs',
    'CouchbaseLinkedServiceArgs',
    'CouchbaseSourceArgs',
    'CouchbaseTableDatasetArgs',
    'CredentialReferenceArgs',
    'CustomActivityReferenceObjectArgs',
    'CustomActivityArgs',
    'CustomDataSourceLinkedServiceArgs',
    'CustomDatasetArgs',
    'CustomEventsTriggerArgs',
    'DWCopyCommandDefaultValueArgs',
    'DWCopyCommandSettingsArgs',
    'DataFlowFolderArgs',
    'DataFlowReferenceArgs',
    'DataFlowSinkArgs',
    'DataFlowSourceArgs',
    'DataFlowStagingInfoArgs',
    'DataLakeAnalyticsUSQLActivityArgs',
    'DatabricksNotebookActivityArgs',
    'DatabricksSparkJarActivityArgs',
    'DatabricksSparkPythonActivityArgs',
    'DatasetBZip2CompressionArgs',
    'DatasetDeflateCompressionArgs',
    'DatasetFolderArgs',
    'DatasetGZipCompressionArgs',
    'DatasetReferenceArgs',
    'DatasetTarCompressionArgs',
    'DatasetTarGZipCompressionArgs',
    'DatasetZipDeflateCompressionArgs',
    'Db2LinkedServiceArgs',
    'Db2SourceArgs',
    'Db2TableDatasetArgs',
    'DeleteActivityArgs',
    'DelimitedTextDatasetArgs',
    'DelimitedTextReadSettingsArgs',
    'DelimitedTextSinkArgs',
    'DelimitedTextSourceArgs',
    'DelimitedTextWriteSettingsArgs',
    'DistcpSettingsArgs',
    'DocumentDbCollectionDatasetArgs',
    'DocumentDbCollectionSinkArgs',
    'DocumentDbCollectionSourceArgs',
    'DrillLinkedServiceArgs',
    'DrillSourceArgs',
    'DrillTableDatasetArgs',
    'DynamicsAXLinkedServiceArgs',
    'DynamicsAXResourceDatasetArgs',
    'DynamicsAXSourceArgs',
    'DynamicsCrmEntityDatasetArgs',
    'DynamicsCrmLinkedServiceArgs',
    'DynamicsCrmSinkArgs',
    'DynamicsCrmSourceArgs',
    'DynamicsEntityDatasetArgs',
    'DynamicsLinkedServiceArgs',
    'DynamicsSinkArgs',
    'DynamicsSourceArgs',
    'EloquaLinkedServiceArgs',
    'EloquaObjectDatasetArgs',
    'EloquaSourceArgs',
    'EncryptionConfigurationArgs',
    'EntityReferenceArgs',
    'EnvironmentVariableSetupArgs',
    'ExcelDatasetArgs',
    'ExcelSourceArgs',
    'ExecuteDataFlowActivityTypePropertiesComputeArgs',
    'ExecuteDataFlowActivityArgs',
    'ExecutePipelineActivityArgs',
    'ExecuteSSISPackageActivityArgs',
    'ExecuteWranglingDataflowActivityArgs',
    'ExecutionActivityArgs',
    'ExpressionArgs',
    'FactoryGitHubConfigurationArgs',
    'FactoryIdentityArgs',
    'FactoryVSTSConfigurationArgs',
    'FileServerLinkedServiceArgs',
    'FileServerLocationArgs',
    'FileServerReadSettingsArgs',
    'FileServerWriteSettingsArgs',
    'FileShareDatasetArgs',
    'FileSystemSinkArgs',
    'FileSystemSourceArgs',
    'FilterActivityArgs',
    'FlowletArgs',
    'ForEachActivityArgs',
    'FtpReadSettingsArgs',
    'FtpServerLinkedServiceArgs',
    'FtpServerLocationArgs',
    'GetMetadataActivityArgs',
    'GitHubClientSecret',
    'GitHubClientSecretArgs',
    'GlobalParameterSpecificationArgs',
    'GoogleAdWordsLinkedServiceArgs',
    'GoogleAdWordsObjectDatasetArgs',
    'GoogleAdWordsSourceArgs',
    'GoogleBigQueryLinkedServiceArgs',
    'GoogleBigQueryObjectDatasetArgs',
    'GoogleBigQuerySourceArgs',
    'GoogleCloudStorageLinkedServiceArgs',
    'GoogleCloudStorageLocationArgs',
    'GoogleCloudStorageReadSettingsArgs',
    'GreenplumLinkedServiceArgs',
    'GreenplumSourceArgs',
    'GreenplumTableDatasetArgs',
    'HBaseLinkedServiceArgs',
    'HBaseObjectDatasetArgs',
    'HBaseSourceArgs',
    'HDInsightHiveActivityArgs',
    'HDInsightLinkedServiceArgs',
    'HDInsightMapReduceActivityArgs',
    'HDInsightOnDemandLinkedServiceArgs',
    'HDInsightPigActivityArgs',
    'HDInsightSparkActivityArgs',
    'HDInsightStreamingActivityArgs',
    'HdfsLinkedServiceArgs',
    'HdfsLocationArgs',
    'HdfsReadSettingsArgs',
    'HdfsSourceArgs',
    'HiveLinkedServiceArgs',
    'HiveObjectDatasetArgs',
    'HiveSourceArgs',
    'HttpDatasetArgs',
    'HttpLinkedServiceArgs',
    'HttpReadSettingsArgs',
    'HttpServerLocationArgs',
    'HttpSourceArgs',
    'HubspotLinkedServiceArgs',
    'HubspotObjectDatasetArgs',
    'HubspotSourceArgs',
    'IfConditionActivityArgs',
    'ImpalaLinkedServiceArgs',
    'ImpalaObjectDatasetArgs',
    'ImpalaSourceArgs',
    'InformixLinkedServiceArgs',
    'InformixSinkArgs',
    'InformixSourceArgs',
    'InformixTableDatasetArgs',
    'IntegrationRuntimeComputePropertiesArgs',
    'IntegrationRuntimeCustomSetupScriptPropertiesArgs',
    'IntegrationRuntimeCustomerVirtualNetworkArgs',
    'IntegrationRuntimeDataFlowPropertiesArgs',
    'IntegrationRuntimeDataProxyPropertiesArgs',
    'IntegrationRuntimeReferenceArgs',
    'IntegrationRuntimeSsisCatalogInfoArgs',
    'IntegrationRuntimeSsisPropertiesArgs',
    'IntegrationRuntimeVNetPropertiesArgs',
    'JiraLinkedServiceArgs',
    'JiraObjectDatasetArgs',
    'JiraSourceArgs',
    'JsonDatasetArgs',
    'JsonFormatArgs',
    'JsonReadSettingsArgs',
    'JsonSinkArgs',
    'JsonSourceArgs',
    'JsonWriteSettingsArgs',
    'LinkedIntegrationRuntimeKeyAuthorizationArgs',
    'LinkedIntegrationRuntimeRbacAuthorizationArgs',
    'LinkedServiceReferenceArgs',
    'LogLocationSettingsArgs',
    'LogSettingsArgs',
    'LogStorageSettingsArgs',
    'LookupActivityArgs',
    'MagentoLinkedServiceArgs',
    'MagentoObjectDatasetArgs',
    'MagentoSourceArgs',
    'ManagedIntegrationRuntimeArgs',
    'ManagedPrivateEndpointArgs',
    'ManagedVirtualNetworkReferenceArgs',
    'MappingDataFlowArgs',
    'MariaDBLinkedServiceArgs',
    'MariaDBSourceArgs',
    'MariaDBTableDatasetArgs',
    'MarketoLinkedServiceArgs',
    'MarketoObjectDatasetArgs',
    'MarketoSourceArgs',
    'MetadataItemArgs',
    'MicrosoftAccessLinkedServiceArgs',
    'MicrosoftAccessSinkArgs',
    'MicrosoftAccessSourceArgs',
    'MicrosoftAccessTableDatasetArgs',
    'MongoDbAtlasCollectionDatasetArgs',
    'MongoDbAtlasLinkedServiceArgs',
    'MongoDbAtlasSinkArgs',
    'MongoDbAtlasSourceArgs',
    'MongoDbCollectionDatasetArgs',
    'MongoDbCursorMethodsPropertiesArgs',
    'MongoDbLinkedServiceArgs',
    'MongoDbSourceArgs',
    'MongoDbV2CollectionDatasetArgs',
    'MongoDbV2LinkedServiceArgs',
    'MongoDbV2SinkArgs',
    'MongoDbV2SourceArgs',
    'MultiplePipelineTriggerArgs',
    'MySqlLinkedServiceArgs',
    'MySqlSourceArgs',
    'MySqlTableDatasetArgs',
    'NetezzaLinkedServiceArgs',
    'NetezzaPartitionSettingsArgs',
    'NetezzaSourceArgs',
    'NetezzaTableDatasetArgs',
    'ODataLinkedServiceArgs',
    'ODataResourceDatasetArgs',
    'ODataSourceArgs',
    'OdbcLinkedServiceArgs',
    'OdbcSinkArgs',
    'OdbcSourceArgs',
    'OdbcTableDatasetArgs',
    'Office365DatasetArgs',
    'Office365LinkedServiceArgs',
    'Office365SourceArgs',
    'OracleCloudStorageLinkedServiceArgs',
    'OracleCloudStorageLocationArgs',
    'OracleCloudStorageReadSettingsArgs',
    'OracleLinkedServiceArgs',
    'OraclePartitionSettingsArgs',
    'OracleServiceCloudLinkedServiceArgs',
    'OracleServiceCloudObjectDatasetArgs',
    'OracleServiceCloudSourceArgs',
    'OracleSinkArgs',
    'OracleSourceArgs',
    'OracleTableDatasetArgs',
    'OrcDatasetArgs',
    'OrcFormatArgs',
    'OrcSinkArgs',
    'OrcSourceArgs',
    'OrcWriteSettingsArgs',
    'PackageStoreArgs',
    'ParameterSpecificationArgs',
    'ParquetDatasetArgs',
    'ParquetFormatArgs',
    'ParquetSinkArgs',
    'ParquetSourceArgs',
    'ParquetWriteSettingsArgs',
    'PaypalLinkedServiceArgs',
    'PaypalObjectDatasetArgs',
    'PaypalSourceArgs',
    'PhoenixLinkedServiceArgs',
    'PhoenixObjectDatasetArgs',
    'PhoenixSourceArgs',
    'PipelineElapsedTimeMetricPolicyArgs',
    'PipelineFolderArgs',
    'PipelinePolicyArgs',
    'PipelineReferenceArgs',
    'PolybaseSettingsArgs',
    'PostgreSqlLinkedServiceArgs',
    'PostgreSqlSourceArgs',
    'PostgreSqlTableDatasetArgs',
    'PowerQuerySinkMappingArgs',
    'PowerQuerySinkArgs',
    'PowerQuerySourceArgs',
    'PrestoLinkedServiceArgs',
    'PrestoObjectDatasetArgs',
    'PrestoSourceArgs',
    'PrivateLinkConnectionApprovalRequestArgs',
    'PrivateLinkConnectionStateArgs',
    'QuickBooksLinkedServiceArgs',
    'QuickBooksObjectDatasetArgs',
    'QuickBooksSourceArgs',
    'RecurrenceScheduleOccurrenceArgs',
    'RecurrenceScheduleArgs',
    'RedirectIncompatibleRowSettingsArgs',
    'RedshiftUnloadSettingsArgs',
    'RelationalSourceArgs',
    'RelationalTableDatasetArgs',
    'RerunTumblingWindowTriggerArgs',
    'ResponsysLinkedServiceArgs',
    'ResponsysObjectDatasetArgs',
    'ResponsysSourceArgs',
    'RestResourceDatasetArgs',
    'RestServiceLinkedServiceArgs',
    'RestSinkArgs',
    'RestSourceArgs',
    'RetryPolicyArgs',
    'SSISAccessCredentialArgs',
    'SSISChildPackageArgs',
    'SSISExecutionCredentialArgs',
    'SSISExecutionParameterArgs',
    'SSISLogLocationArgs',
    'SSISPackageLocationArgs',
    'SSISPropertyOverrideArgs',
    'SalesforceLinkedServiceArgs',
    'SalesforceMarketingCloudLinkedServiceArgs',
    'SalesforceMarketingCloudObjectDatasetArgs',
    'SalesforceMarketingCloudSourceArgs',
    'SalesforceObjectDatasetArgs',
    'SalesforceServiceCloudLinkedServiceArgs',
    'SalesforceServiceCloudObjectDatasetArgs',
    'SalesforceServiceCloudSinkArgs',
    'SalesforceServiceCloudSourceArgs',
    'SalesforceSinkArgs',
    'SalesforceSourceArgs',
    'SapBWLinkedServiceArgs',
    'SapBwCubeDatasetArgs',
    'SapBwSourceArgs',
    'SapCloudForCustomerLinkedServiceArgs',
    'SapCloudForCustomerResourceDatasetArgs',
    'SapCloudForCustomerSinkArgs',
    'SapCloudForCustomerSourceArgs',
    'SapEccLinkedServiceArgs',
    'SapEccResourceDatasetArgs',
    'SapEccSourceArgs',
    'SapHanaLinkedServiceArgs',
    'SapHanaPartitionSettingsArgs',
    'SapHanaSourceArgs',
    'SapHanaTableDatasetArgs',
    'SapOpenHubLinkedServiceArgs',
    'SapOpenHubSourceArgs',
    'SapOpenHubTableDatasetArgs',
    'SapTableLinkedServiceArgs',
    'SapTablePartitionSettingsArgs',
    'SapTableResourceDatasetArgs',
    'SapTableSourceArgs',
    'ScheduleTriggerRecurrenceArgs',
    'ScheduleTriggerArgs',
    'ScriptActionArgs',
    'SecureStringArgs',
    'SelfDependencyTumblingWindowTriggerReferenceArgs',
    'SelfHostedIntegrationRuntimeArgs',
    'ServiceNowLinkedServiceArgs',
    'ServiceNowObjectDatasetArgs',
    'ServiceNowSourceArgs',
    'SetVariableActivityArgs',
    'SftpLocationArgs',
    'SftpReadSettingsArgs',
    'SftpServerLinkedServiceArgs',
    'SftpWriteSettingsArgs',
    'SharePointOnlineListLinkedServiceArgs',
    'SharePointOnlineListResourceDatasetArgs',
    'SharePointOnlineListSourceArgs',
    'ShopifyLinkedServiceArgs',
    'ShopifyObjectDatasetArgs',
    'ShopifySourceArgs',
    'SkipErrorFileArgs',
    'SnowflakeDatasetArgs',
    'SnowflakeExportCopyCommandArgs',
    'SnowflakeImportCopyCommandArgs',
    'SnowflakeLinkedServiceArgs',
    'SnowflakeSinkArgs',
    'SnowflakeSourceArgs',
    'SparkLinkedServiceArgs',
    'SparkObjectDatasetArgs',
    'SparkSourceArgs',
    'SqlAlwaysEncryptedPropertiesArgs',
    'SqlDWSinkArgs',
    'SqlDWSourceArgs',
    'SqlDWUpsertSettingsArgs',
    'SqlMISinkArgs',
    'SqlMISourceArgs',
    'SqlPartitionSettingsArgs',
    'SqlServerLinkedServiceArgs',
    'SqlServerSinkArgs',
    'SqlServerSourceArgs',
    'SqlServerStoredProcedureActivityArgs',
    'SqlServerTableDatasetArgs',
    'SqlSinkArgs',
    'SqlSourceArgs',
    'SqlUpsertSettingsArgs',
    'SquareLinkedServiceArgs',
    'SquareObjectDatasetArgs',
    'SquareSourceArgs',
    'StagingSettingsArgs',
    'StoredProcedureParameterArgs',
    'SwitchActivityArgs',
    'SwitchCaseArgs',
    'SybaseLinkedServiceArgs',
    'SybaseSourceArgs',
    'SybaseTableDatasetArgs',
    'TabularSourceArgs',
    'TarGZipReadSettingsArgs',
    'TarReadSettingsArgs',
    'TeradataLinkedServiceArgs',
    'TeradataPartitionSettingsArgs',
    'TeradataSourceArgs',
    'TeradataTableDatasetArgs',
    'TextFormatArgs',
    'TransformationArgs',
    'TriggerDependencyReferenceArgs',
    'TriggerPipelineReferenceArgs',
    'TriggerReferenceArgs',
    'TumblingWindowTriggerDependencyReferenceArgs',
    'TumblingWindowTriggerArgs',
    'UntilActivityArgs',
    'UserPropertyArgs',
    'ValidationActivityArgs',
    'VariableSpecificationArgs',
    'VerticaLinkedServiceArgs',
    'VerticaSourceArgs',
    'VerticaTableDatasetArgs',
    'WaitActivityArgs',
    'WebActivityAuthenticationArgs',
    'WebActivityArgs',
    'WebAnonymousAuthenticationArgs',
    'WebBasicAuthenticationArgs',
    'WebClientCertificateAuthenticationArgs',
    'WebHookActivityArgs',
    'WebLinkedServiceArgs',
    'WebSourceArgs',
    'WebTableDatasetArgs',
    'WranglingDataFlowArgs',
    'XeroLinkedServiceArgs',
    'XeroObjectDatasetArgs',
    'XeroSourceArgs',
    'XmlDatasetArgs',
    'XmlReadSettingsArgs',
    'XmlSourceArgs',
    'ZipDeflateReadSettingsArgs',
    'ZohoLinkedServiceArgs',
    'ZohoObjectDatasetArgs',
    'ZohoSourceArgs',
]

@pulumi.input_type
class ActivityDependencyArgs:
    def __init__(__self__, *,
                 activity: pulumi.Input[str],
                 dependency_conditions: pulumi.Input[Sequence[pulumi.Input[Union[str, 'DependencyCondition']]]]):
        """
        Activity dependency information.
        :param pulumi.Input[str] activity: Activity name.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'DependencyCondition']]]] dependency_conditions: Match-Condition for the dependency.
        """
        pulumi.set(__self__, "activity", activity)
        pulumi.set(__self__, "dependency_conditions", dependency_conditions)

    @property
    @pulumi.getter
    def activity(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "activity")

    @activity.setter
    def activity(self, value: pulumi.Input[str]):
        pulumi.set(self, "activity", value)

    @property
    @pulumi.getter(name="dependencyConditions")
    def dependency_conditions(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'DependencyCondition']]]]:
        """
        Match-Condition for the dependency.
        """
        return pulumi.get(self, "dependency_conditions")

    @dependency_conditions.setter
    def dependency_conditions(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'DependencyCondition']]]]):
        pulumi.set(self, "dependency_conditions", value)


@pulumi.input_type
class ActivityPolicyArgs:
    def __init__(__self__, *,
                 retry: Optional[Any] = None,
                 retry_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 secure_input: Optional[pulumi.Input[bool]] = None,
                 secure_output: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[Any] = None):
        """
        Execution policy for an activity.
        :param Any retry: Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[int] retry_interval_in_seconds: Interval between each retry attempt (in seconds). The default is 30 sec.
        :param pulumi.Input[bool] secure_input: When set to true, Input from activity is considered as secure and will not be logged to monitoring.
        :param pulumi.Input[bool] secure_output: When set to true, Output from activity is considered as secure and will not be logged to monitoring.
        :param Any timeout: Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if secure_input is not None:
            pulumi.set(__self__, "secure_input", secure_input)
        if secure_output is not None:
            pulumi.set(__self__, "secure_output", secure_output)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def retry(self) -> Optional[Any]:
        """
        Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[Any]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between each retry attempt (in seconds). The default is 30 sec.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @retry_interval_in_seconds.setter
    def retry_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_interval_in_seconds", value)

    @property
    @pulumi.getter(name="secureInput")
    def secure_input(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, Input from activity is considered as secure and will not be logged to monitoring.
        """
        return pulumi.get(self, "secure_input")

    @secure_input.setter
    def secure_input(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure_input", value)

    @property
    @pulumi.getter(name="secureOutput")
    def secure_output(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, Output from activity is considered as secure and will not be logged to monitoring.
        """
        return pulumi.get(self, "secure_output")

    @secure_output.setter
    def secure_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure_output", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[Any]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class AmazonMWSLinkedServiceArgs:
    def __init__(__self__, *,
                 access_key_id: Any,
                 endpoint: Any,
                 marketplace_id: Any,
                 seller_id: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 mws_auth_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 secret_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Amazon Marketplace Web Service linked service.
        :param Any access_key_id: The access key id used to access data.
        :param Any endpoint: The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
        :param Any marketplace_id: The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
        :param Any seller_id: The Amazon seller ID.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonMWS'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] mws_auth_token: The Amazon MWS authentication token.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] secret_key: The secret key used to access data.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "marketplace_id", marketplace_id)
        pulumi.set(__self__, "seller_id", seller_id)
        pulumi.set(__self__, "type", 'AmazonMWS')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if mws_auth_token is not None:
            pulumi.set(__self__, "mws_auth_token", mws_auth_token)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Any:
        """
        The access key id used to access data.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Any):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="marketplaceID")
    def marketplace_id(self) -> Any:
        """
        The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
        """
        return pulumi.get(self, "marketplace_id")

    @marketplace_id.setter
    def marketplace_id(self, value: Any):
        pulumi.set(self, "marketplace_id", value)

    @property
    @pulumi.getter(name="sellerID")
    def seller_id(self) -> Any:
        """
        The Amazon seller ID.
        """
        return pulumi.get(self, "seller_id")

    @seller_id.setter
    def seller_id(self, value: Any):
        pulumi.set(self, "seller_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonMWS'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="mwsAuthToken")
    def mws_auth_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Amazon MWS authentication token.
        """
        return pulumi.get(self, "mws_auth_token")

    @mws_auth_token.setter
    def mws_auth_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "mws_auth_token", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The secret key used to access data.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class AmazonMWSObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Amazon Marketplace Web Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AmazonMWSObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonMWSObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AmazonMWSObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AmazonMWSSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Amazon Marketplace Web Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AmazonMWSSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AmazonMWSSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AmazonMWSSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AmazonRdsForOracleLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None):
        """
        AmazonRdsForOracle database.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonRdsForOracle'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AmazonRdsForOracle')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonRdsForOracle'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class AmazonRdsForOraclePartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_names: Optional[pulumi.Input[Sequence[Any]]] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for AmazonRdsForOracle source partitioning.
        :param Any partition_column_name: The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] partition_names: Names of the physical partitions of AmazonRdsForOracle table. 
        :param Any partition_upper_bound: The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_names is not None:
            pulumi.set(__self__, "partition_names", partition_names)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionNames")
    def partition_names(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Names of the physical partitions of AmazonRdsForOracle table. 
        """
        return pulumi.get(self, "partition_names")

    @partition_names.setter
    def partition_names(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "partition_names", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class AmazonRdsForOracleSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 oracle_reader_query: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['AmazonRdsForOraclePartitionSettingsArgs']] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity AmazonRdsForOracle source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AmazonRdsForOracleSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any oracle_reader_query: AmazonRdsForOracle reader query. Type: string (or Expression with resultType string).
        :param Any partition_option: The partition mechanism that will be used for AmazonRdsForOracle read in parallel. Type: string (or Expression with resultType string).
        :param pulumi.Input['AmazonRdsForOraclePartitionSettingsArgs'] partition_settings: The settings that will be leveraged for AmazonRdsForOracle source partitioning.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AmazonRdsForOracleSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if oracle_reader_query is not None:
            pulumi.set(__self__, "oracle_reader_query", oracle_reader_query)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AmazonRdsForOracleSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="oracleReaderQuery")
    def oracle_reader_query(self) -> Optional[Any]:
        """
        AmazonRdsForOracle reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "oracle_reader_query")

    @oracle_reader_query.setter
    def oracle_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "oracle_reader_query", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for AmazonRdsForOracle read in parallel. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['AmazonRdsForOraclePartitionSettingsArgs']]:
        """
        The settings that will be leveraged for AmazonRdsForOracle source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['AmazonRdsForOraclePartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AmazonRdsForOracleTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The AmazonRdsForOracle database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AmazonRdsForOracleTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the AmazonRdsForOracle database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonRdsForOracleTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AmazonRdsForOracleTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the AmazonRdsForOracle database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class AmazonRdsForSqlServerLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 always_encrypted_settings: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Amazon RDS for SQL Server linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonRdsForSqlServer'.
        :param pulumi.Input['SqlAlwaysEncryptedPropertiesArgs'] always_encrypted_settings: Sql always encrypted properties.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The on-premises Windows authentication password.
        :param Any user_name: The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AmazonRdsForSqlServer')
        if always_encrypted_settings is not None:
            pulumi.set(__self__, "always_encrypted_settings", always_encrypted_settings)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonRdsForSqlServer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="alwaysEncryptedSettings")
    def always_encrypted_settings(self) -> Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]:
        """
        Sql always encrypted properties.
        """
        return pulumi.get(self, "always_encrypted_settings")

    @always_encrypted_settings.setter
    def always_encrypted_settings(self, value: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]):
        pulumi.set(self, "always_encrypted_settings", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The on-premises Windows authentication password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class AmazonRdsForSqlServerSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 produce_additional_types: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None):
        """
        A copy activity Amazon RDS for SQL Server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AmazonRdsForSqlServerSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any produce_additional_types: Which additional types to produce.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        pulumi.set(__self__, "type", 'AmazonRdsForSqlServerSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if produce_additional_types is not None:
            pulumi.set(__self__, "produce_additional_types", produce_additional_types)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AmazonRdsForSqlServerSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="produceAdditionalTypes")
    def produce_additional_types(self) -> Optional[Any]:
        """
        Which additional types to produce.
        """
        return pulumi.get(self, "produce_additional_types")

    @produce_additional_types.setter
    def produce_additional_types(self, value: Optional[Any]):
        pulumi.set(self, "produce_additional_types", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class AmazonRdsForSqlServerTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The Amazon RDS for SQL Server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AmazonRdsForSqlServerTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonRdsForSqlServerTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AmazonRdsForSqlServerTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class AmazonRedshiftLinkedServiceArgs:
    def __init__(__self__, *,
                 database: Any,
                 server: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Amazon Redshift.
        :param Any database: The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
        :param Any server: The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonRedshift'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password of the Amazon Redshift source.
        :param Any port: The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type: integer (or Expression with resultType integer).
        :param Any username: The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'AmazonRedshift')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Any):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonRedshift'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password of the Amazon Redshift source.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class AmazonRedshiftSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 redshift_unload_settings: Optional[pulumi.Input['RedshiftUnloadSettingsArgs']] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for Amazon Redshift Source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AmazonRedshiftSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input['RedshiftUnloadSettingsArgs'] redshift_unload_settings: The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data from Amazon Redshift source will be unloaded into S3 first and then copied into the targeted sink from the interim S3.
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AmazonRedshiftSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if redshift_unload_settings is not None:
            pulumi.set(__self__, "redshift_unload_settings", redshift_unload_settings)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AmazonRedshiftSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="redshiftUnloadSettings")
    def redshift_unload_settings(self) -> Optional[pulumi.Input['RedshiftUnloadSettingsArgs']]:
        """
        The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data from Amazon Redshift source will be unloaded into S3 first and then copied into the targeted sink from the interim S3.
        """
        return pulumi.get(self, "redshift_unload_settings")

    @redshift_unload_settings.setter
    def redshift_unload_settings(self, value: Optional[pulumi.Input['RedshiftUnloadSettingsArgs']]):
        pulumi.set(self, "redshift_unload_settings", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AmazonRedshiftTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Amazon Redshift table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AmazonRedshiftTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The Amazon Redshift table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonRedshiftTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AmazonRedshiftTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The Amazon Redshift table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AmazonS3CompatibleLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 force_path_style: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 secret_access_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_url: Optional[Any] = None):
        """
        Linked service for Amazon S3 Compatible.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonS3Compatible'.
        :param Any access_key_id: The access key identifier of the Amazon S3 Compatible Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any force_path_style: If true, use S3 path-style access instead of virtual hosted-style access. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] secret_access_key: The secret access key of the Amazon S3 Compatible Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the Amazon S3 Compatible Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3Compatible')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if force_path_style is not None:
            pulumi.set(__self__, "force_path_style", force_path_style)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonS3Compatible'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Amazon S3 Compatible Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[Any]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="forcePathStyle")
    def force_path_style(self) -> Optional[Any]:
        """
        If true, use S3 path-style access instead of virtual hosted-style access. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "force_path_style")

    @force_path_style.setter
    def force_path_style(self, value: Optional[Any]):
        pulumi.set(self, "force_path_style", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The secret access key of the Amazon S3 Compatible Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the Amazon S3 Compatible Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[Any]):
        pulumi.set(self, "service_url", value)


@pulumi.input_type
class AmazonS3CompatibleLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of Amazon S3 Compatible dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AmazonS3CompatibleLocation'.
        :param Any bucket_name: Specify the bucketName of Amazon S3 Compatible. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of Amazon S3 Compatible. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3CompatibleLocation')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AmazonS3CompatibleLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of Amazon S3 Compatible. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[Any]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of Amazon S3 Compatible. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class AmazonS3CompatibleReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Amazon S3 Compatible read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AmazonS3CompatibleReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the S3 Compatible object name. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Amazon S3 Compatible wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Amazon S3 Compatible wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3CompatibleReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AmazonS3CompatibleReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the S3 Compatible object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Amazon S3 Compatible wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Amazon S3 Compatible wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AmazonS3DatasetArgs:
    def __init__(__self__, *,
                 bucket_name: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 key: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 prefix: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        A single Amazon Simple Storage Service (S3) object or a set of S3 objects.
        :param Any bucket_name: The name of the Amazon S3 bucket. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AmazonS3Object'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the Amazon S3 object.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of files.
        :param Any key: The key of the Amazon S3 object. Type: string (or Expression with resultType string).
        :param Any modified_datetime_end: The end of S3 object's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of S3 object's modified datetime. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any prefix: The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any version: The version for the S3 object. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonS3Object')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Any:
        """
        The name of the Amazon S3 bucket. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Any):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AmazonS3Object'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the Amazon S3 object.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of files.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[Any]:
        """
        The key of the Amazon S3 object. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[Any]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of S3 object's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of S3 object's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        The version for the S3 object. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class AmazonS3LinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 secret_access_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_url: Optional[Any] = None,
                 session_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None):
        """
        Linked service for Amazon S3.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AmazonS3'.
        :param Any access_key_id: The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: The authentication type of S3. Allowed value: AccessKey (default) or TemporarySecurityCredentials. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] secret_access_key: The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] session_token: The session token for the S3 temporary security credential.
        """
        pulumi.set(__self__, "type", 'AmazonS3')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AmazonS3'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[Any]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        The authentication type of S3. Allowed value: AccessKey (default) or TemporarySecurityCredentials. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[Any]):
        pulumi.set(self, "service_url", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The session token for the S3 temporary security credential.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "session_token", value)


@pulumi.input_type
class AmazonS3LocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of amazon S3 dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AmazonS3Location'.
        :param Any bucket_name: Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of amazon S3. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3Location')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AmazonS3Location'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[Any]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of amazon S3. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class AmazonS3ReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Amazon S3 read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AmazonS3ReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: AmazonS3 wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: AmazonS3 wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3ReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AmazonS3ReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        AmazonS3 wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        AmazonS3 wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AppendVariableActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 value: Optional[Any] = None,
                 variable_name: Optional[pulumi.Input[str]] = None):
        """
        Append value for a Variable of type Array.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AppendVariable'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param Any value: Value to be appended. Could be a static value or Expression
        :param pulumi.Input[str] variable_name: Name of the variable whose value needs to be appended to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'AppendVariable')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable_name is not None:
            pulumi.set(__self__, "variable_name", variable_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AppendVariable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Value to be appended. Could be a static value or Expression
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="variableName")
    def variable_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the variable whose value needs to be appended to.
        """
        return pulumi.get(self, "variable_name")

    @variable_name.setter
    def variable_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variable_name", value)


@pulumi.input_type
class AvroDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 avro_compression_codec: Optional[Any] = None,
                 avro_compression_level: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Avro dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the avro storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Avro'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any avro_compression_codec: The data avroCompressionCodec. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Avro')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if avro_compression_codec is not None:
            pulumi.set(__self__, "avro_compression_codec", avro_compression_codec)
        if avro_compression_level is not None:
            pulumi.set(__self__, "avro_compression_level", avro_compression_level)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the avro storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Avro'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="avroCompressionCodec")
    def avro_compression_codec(self) -> Optional[Any]:
        """
        The data avroCompressionCodec. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "avro_compression_codec")

    @avro_compression_codec.setter
    def avro_compression_codec(self, value: Optional[Any]):
        pulumi.set(self, "avro_compression_codec", value)

    @property
    @pulumi.getter(name="avroCompressionLevel")
    def avro_compression_level(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "avro_compression_level")

    @avro_compression_level.setter
    def avro_compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "avro_compression_level", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class AvroFormatArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Avro format.
        :param pulumi.Input[str] type: Type of dataset storage format.
               Expected value is 'AvroFormat'.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AvroFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage format.
        Expected value is 'AvroFormat'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @deserializer.setter
    def deserializer(self, value: Optional[Any]):
        pulumi.set(self, "deserializer", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[Any]):
        pulumi.set(self, "serializer", value)


@pulumi.input_type
class AvroSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['AvroWriteSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Avro sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AvroSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['AvroWriteSettingsArgs'] format_settings: Avro format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: Avro store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AvroSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AvroSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['AvroWriteSettingsArgs']]:
        """
        Avro format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['AvroWriteSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        Avro store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AvroSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity Avro source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AvroSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Avro store settings.
        """
        pulumi.set(__self__, "type", 'AvroSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AvroSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Avro store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class AvroWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name_prefix: Optional[Any] = None,
                 max_rows_per_file: Optional[Any] = None,
                 record_name: Optional[pulumi.Input[str]] = None,
                 record_namespace: Optional[pulumi.Input[str]] = None):
        """
        Avro write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'AvroWriteSettings'.
        :param Any file_name_prefix: Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        :param Any max_rows_per_file: Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        :param pulumi.Input[str] record_name: Top level record name in write result, which is required in AVRO spec.
        :param pulumi.Input[str] record_namespace: Record namespace in the write result.
        """
        pulumi.set(__self__, "type", 'AvroWriteSettings')
        if file_name_prefix is not None:
            pulumi.set(__self__, "file_name_prefix", file_name_prefix)
        if max_rows_per_file is not None:
            pulumi.set(__self__, "max_rows_per_file", max_rows_per_file)
        if record_name is not None:
            pulumi.set(__self__, "record_name", record_name)
        if record_namespace is not None:
            pulumi.set(__self__, "record_namespace", record_namespace)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'AvroWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileNamePrefix")
    def file_name_prefix(self) -> Optional[Any]:
        """
        Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name_prefix")

    @file_name_prefix.setter
    def file_name_prefix(self, value: Optional[Any]):
        pulumi.set(self, "file_name_prefix", value)

    @property
    @pulumi.getter(name="maxRowsPerFile")
    def max_rows_per_file(self) -> Optional[Any]:
        """
        Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_rows_per_file")

    @max_rows_per_file.setter
    def max_rows_per_file(self, value: Optional[Any]):
        pulumi.set(self, "max_rows_per_file", value)

    @property
    @pulumi.getter(name="recordName")
    def record_name(self) -> Optional[pulumi.Input[str]]:
        """
        Top level record name in write result, which is required in AVRO spec.
        """
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_name", value)

    @property
    @pulumi.getter(name="recordNamespace")
    def record_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Record namespace in the write result.
        """
        return pulumi.get(self, "record_namespace")

    @record_namespace.setter
    def record_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_namespace", value)


@pulumi.input_type
class AzPowerShellSetupArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        The express custom setup of installing Azure PowerShell.
        :param pulumi.Input[str] type: The type of custom setup.
               Expected value is 'AzPowerShellSetup'.
        :param pulumi.Input[str] version: The required version of Azure PowerShell to install.
        """
        pulumi.set(__self__, "type", 'AzPowerShellSetup')
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of custom setup.
        Expected value is 'AzPowerShellSetup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The required version of Azure PowerShell to install.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class AzureBatchLinkedServiceArgs:
    def __init__(__self__, *,
                 account_name: Any,
                 batch_uri: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 pool_name: Any,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Azure Batch linked service.
        :param Any account_name: The Azure Batch account name. Type: string (or Expression with resultType string).
        :param Any batch_uri: The Azure Batch URI. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: The Azure Storage linked service reference.
        :param Any pool_name: The Azure Batch pool name. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureBatch'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_key: The Azure Batch account access key.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "batch_uri", batch_uri)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "pool_name", pool_name)
        pulumi.set(__self__, "type", 'AzureBatch')
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Any:
        """
        The Azure Batch account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Any):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="batchUri")
    def batch_uri(self) -> Any:
        """
        The Azure Batch URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "batch_uri")

    @batch_uri.setter
    def batch_uri(self, value: Any):
        pulumi.set(self, "batch_uri", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        The Azure Storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Any:
        """
        The Azure Batch pool name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pool_name")

    @pool_name.setter
    def pool_name(self, value: Any):
        pulumi.set(self, "pool_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureBatch'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Azure Batch account access key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AzureBlobDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_root_location: Optional[Any] = None):
        """
        The Azure Blob storage.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureBlob'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the blob storage.
        :param pulumi.Input[str] description: Dataset description.
        :param Any file_name: The name of the Azure Blob. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the Azure Blob storage. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of the Azure Blob storage.
        :param Any modified_datetime_end: The end of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_root_location: The root of blob path. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureBlob')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_root_location is not None:
            pulumi.set(__self__, "table_root_location", table_root_location)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureBlob'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the blob storage.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the Azure Blob. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the Azure Blob storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of the Azure Blob storage.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableRootLocation")
    def table_root_location(self) -> Optional[Any]:
        """
        The root of blob path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_root_location")

    @table_root_location.setter
    def table_root_location(self, value: Optional[Any]):
        pulumi.set(self, "table_root_location", value)


@pulumi.input_type
class AzureBlobFSDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Data Lake Storage Gen2 storage.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureBlobFSFile'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the blob storage.
        :param pulumi.Input[str] description: Dataset description.
        :param Any file_name: The name of the Azure Data Lake Storage Gen2. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the Azure Data Lake Storage Gen2 storage. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of the Azure Data Lake Storage Gen2 storage.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureBlobFSFile')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureBlobFSFile'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the blob storage.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the Azure Data Lake Storage Gen2. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the Azure Data Lake Storage Gen2 storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of the Azure Data Lake Storage Gen2 storage.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class AzureBlobFSLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 account_key: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Azure Data Lake Storage Gen2 linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureBlobFS'.
        :param Any url: Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        :param Any account_key: Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobFS')
        pulumi.set(__self__, "url", url)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureBlobFS'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[Any]:
        """
        Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[Any]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureBlobFSLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 file_system: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure blobFS dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AzureBlobFSLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any file_system: Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureBlobFSLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AzureBlobFSLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[Any]:
        """
        Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[Any]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class AzureBlobFSReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Azure blobFS read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AzureBlobFSReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Azure blobFS wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Azure blobFS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobFSReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AzureBlobFSReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Azure blobFS wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Azure blobFS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AzureBlobFSSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 metadata: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Data Lake Storage Gen2 sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureBlobFSSink'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]] metadata: Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureBlobFSSink')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureBlobFSSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]]:
        """
        Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureBlobFSSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 skip_header_line_count: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 treat_empty_as_null: Optional[Any] = None):
        """
        A copy activity Azure BlobFS source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureBlobFSSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any skip_header_line_count: Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any treat_empty_as_null: Treat empty as null. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'AzureBlobFSSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if skip_header_line_count is not None:
            pulumi.set(__self__, "skip_header_line_count", skip_header_line_count)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if treat_empty_as_null is not None:
            pulumi.set(__self__, "treat_empty_as_null", treat_empty_as_null)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureBlobFSSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="skipHeaderLineCount")
    def skip_header_line_count(self) -> Optional[Any]:
        """
        Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip_header_line_count")

    @skip_header_line_count.setter
    def skip_header_line_count(self, value: Optional[Any]):
        pulumi.set(self, "skip_header_line_count", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="treatEmptyAsNull")
    def treat_empty_as_null(self) -> Optional[Any]:
        """
        Treat empty as null. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "treat_empty_as_null")

    @treat_empty_as_null.setter
    def treat_empty_as_null(self, value: Optional[Any]):
        pulumi.set(self, "treat_empty_as_null", value)


@pulumi.input_type
class AzureBlobFSWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 block_size_in_mb: Optional[Any] = None,
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None):
        """
        Azure blobFS write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'AzureBlobFSWriteSettings'.
        :param Any block_size_in_mb: Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'AzureBlobFSWriteSettings')
        if block_size_in_mb is not None:
            pulumi.set(__self__, "block_size_in_mb", block_size_in_mb)
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'AzureBlobFSWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="blockSizeInMB")
    def block_size_in_mb(self) -> Optional[Any]:
        """
        Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "block_size_in_mb")

    @block_size_in_mb.setter
    def block_size_in_mb(self, value: Optional[Any]):
        pulumi.set(self, "block_size_in_mb", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)


@pulumi.input_type
class AzureBlobStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 account_key: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 account_kind: Optional[pulumi.Input[str]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 sas_token: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 sas_uri: Optional[Any] = None,
                 service_endpoint: Optional[pulumi.Input[str]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        The azure blob storage linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureBlobStorage'.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] account_key: The Azure key vault secret reference of accountKey in connection string.
        :param pulumi.Input[str] account_kind: Specify the kind of your storage account. Allowed values are: Storage (general purpose v1), StorageV2 (general purpose v2), BlobStorage, or BlockBlobStorage. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[str] encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] service_endpoint: Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_kind is not None:
            pulumi.set(__self__, "account_kind", account_kind)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)
        if service_endpoint is not None:
            pulumi.set(__self__, "service_endpoint", service_endpoint)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureBlobStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="accountKind")
    def account_kind(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the kind of your storage account. Allowed values are: Storage (general purpose v1), StorageV2 (general purpose v2), BlobStorage, or BlockBlobStorage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_kind")

    @account_kind.setter
    def account_kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_kind", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[pulumi.Input[str]]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @sas_uri.setter
    def sas_uri(self, value: Optional[Any]):
        pulumi.set(self, "sas_uri", value)

    @property
    @pulumi.getter(name="serviceEndpoint")
    def service_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
        """
        return pulumi.get(self, "service_endpoint")

    @service_endpoint.setter
    def service_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_endpoint", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureBlobStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 container: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure blob dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AzureBlobStorageLocation'.
        :param Any container: Specify the container of azure blob. Type: string (or Expression with resultType string).
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureBlobStorageLocation')
        if container is not None:
            pulumi.set(__self__, "container", container)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AzureBlobStorageLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[Any]:
        """
        Specify the container of azure blob. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[Any]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class AzureBlobStorageReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Azure blob read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AzureBlobStorageReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the Azure Blob name. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Azure blob wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Azure blob wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobStorageReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AzureBlobStorageReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the Azure Blob name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Azure blob wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Azure blob wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AzureBlobStorageWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 block_size_in_mb: Optional[Any] = None,
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None):
        """
        Azure blob write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'AzureBlobStorageWriteSettings'.
        :param Any block_size_in_mb: Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'AzureBlobStorageWriteSettings')
        if block_size_in_mb is not None:
            pulumi.set(__self__, "block_size_in_mb", block_size_in_mb)
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'AzureBlobStorageWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="blockSizeInMB")
    def block_size_in_mb(self) -> Optional[Any]:
        """
        Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "block_size_in_mb")

    @block_size_in_mb.setter
    def block_size_in_mb(self, value: Optional[Any]):
        pulumi.set(self, "block_size_in_mb", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)


@pulumi.input_type
class AzureDataExplorerCommandActivityArgs:
    def __init__(__self__, *,
                 command: Any,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 command_timeout: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Azure Data Explorer command activity.
        :param Any command: A control command, according to the Azure Data Explorer command syntax. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AzureDataExplorerCommand'.
        :param Any command_timeout: Control command timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..)
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'AzureDataExplorerCommand')
        if command_timeout is not None:
            pulumi.set(__self__, "command_timeout", command_timeout)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def command(self) -> Any:
        """
        A control command, according to the Azure Data Explorer command syntax. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Any):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AzureDataExplorerCommand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="commandTimeout")
    def command_timeout(self) -> Optional[Any]:
        """
        Control command timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..)
        """
        return pulumi.get(self, "command_timeout")

    @command_timeout.setter
    def command_timeout(self, value: Optional[Any]):
        pulumi.set(self, "command_timeout", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class AzureDataExplorerLinkedServiceArgs:
    def __init__(__self__, *,
                 database: Any,
                 endpoint: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Azure Data Explorer (Kusto) linked service.
        :param Any database: Database name for connection. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://<clusterName>.<regionName>.kusto.windows.net. Type: string (or Expression with resultType string)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureDataExplorer'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Kusto.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'AzureDataExplorer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        Database name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://<clusterName>.<regionName>.kusto.windows.net. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureDataExplorer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Kusto.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureDataExplorerSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 flush_immediately: Optional[Any] = None,
                 ingestion_mapping_as_json: Optional[Any] = None,
                 ingestion_mapping_name: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Data Explorer sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureDataExplorerSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any flush_immediately: If set to true, any aggregation will be skipped. Default is false. Type: boolean.
        :param Any ingestion_mapping_as_json: An explicit column mapping description provided in a json format. Type: string.
        :param Any ingestion_mapping_name: A name of a pre-created csv mapping that was defined on the target Kusto table. Type: string.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureDataExplorerSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if flush_immediately is not None:
            pulumi.set(__self__, "flush_immediately", flush_immediately)
        if ingestion_mapping_as_json is not None:
            pulumi.set(__self__, "ingestion_mapping_as_json", ingestion_mapping_as_json)
        if ingestion_mapping_name is not None:
            pulumi.set(__self__, "ingestion_mapping_name", ingestion_mapping_name)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureDataExplorerSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="flushImmediately")
    def flush_immediately(self) -> Optional[Any]:
        """
        If set to true, any aggregation will be skipped. Default is false. Type: boolean.
        """
        return pulumi.get(self, "flush_immediately")

    @flush_immediately.setter
    def flush_immediately(self, value: Optional[Any]):
        pulumi.set(self, "flush_immediately", value)

    @property
    @pulumi.getter(name="ingestionMappingAsJson")
    def ingestion_mapping_as_json(self) -> Optional[Any]:
        """
        An explicit column mapping description provided in a json format. Type: string.
        """
        return pulumi.get(self, "ingestion_mapping_as_json")

    @ingestion_mapping_as_json.setter
    def ingestion_mapping_as_json(self, value: Optional[Any]):
        pulumi.set(self, "ingestion_mapping_as_json", value)

    @property
    @pulumi.getter(name="ingestionMappingName")
    def ingestion_mapping_name(self) -> Optional[Any]:
        """
        A name of a pre-created csv mapping that was defined on the target Kusto table. Type: string.
        """
        return pulumi.get(self, "ingestion_mapping_name")

    @ingestion_mapping_name.setter
    def ingestion_mapping_name(self, value: Optional[Any]):
        pulumi.set(self, "ingestion_mapping_name", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureDataExplorerSourceArgs:
    def __init__(__self__, *,
                 query: Any,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 no_truncation: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure Data Explorer (Kusto) source.
        :param Any query: Database query. Should be a Kusto Query Language (KQL) query. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureDataExplorerSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any no_truncation: The name of the Boolean option that controls whether truncation is applied to result-sets that go beyond a certain row-count limit.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", 'AzureDataExplorerSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if no_truncation is not None:
            pulumi.set(__self__, "no_truncation", no_truncation)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def query(self) -> Any:
        """
        Database query. Should be a Kusto Query Language (KQL) query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Any):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureDataExplorerSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="noTruncation")
    def no_truncation(self) -> Optional[Any]:
        """
        The name of the Boolean option that controls whether truncation is applied to result-sets that go beyond a certain row-count limit.
        """
        return pulumi.get(self, "no_truncation")

    @no_truncation.setter
    def no_truncation(self, value: Optional[Any]):
        pulumi.set(self, "no_truncation", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureDataExplorerTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The Azure Data Explorer (Kusto) dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureDataExplorerTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDataExplorerTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureDataExplorerTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class AzureDataLakeAnalyticsLinkedServiceArgs:
    def __init__(__self__, *,
                 account_name: Any,
                 tenant: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 data_lake_analytics_uri: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 resource_group_name: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 subscription_id: Optional[Any] = None):
        """
        Azure Data Lake Analytics linked service.
        :param Any account_name: The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureDataLakeAnalytics'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any data_lake_analytics_uri: Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any resource_group_name: Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Analytics account.
        :param Any subscription_id: Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "type", 'AzureDataLakeAnalytics')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if data_lake_analytics_uri is not None:
            pulumi.set(__self__, "data_lake_analytics_uri", data_lake_analytics_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Any:
        """
        The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Any):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Any):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureDataLakeAnalytics'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="dataLakeAnalyticsUri")
    def data_lake_analytics_uri(self) -> Optional[Any]:
        """
        Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "data_lake_analytics_uri")

    @data_lake_analytics_uri.setter
    def data_lake_analytics_uri(self, value: Optional[Any]):
        pulumi.set(self, "data_lake_analytics_uri", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[Any]:
        """
        Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[Any]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Analytics account.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[Any]:
        """
        Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[Any]):
        pulumi.set(self, "subscription_id", value)


@pulumi.input_type
class AzureDataLakeStoreDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Azure Data Lake Store dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureDataLakeStoreFile'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the item(s) in the Azure Data Lake Store.
        :param pulumi.Input[str] description: Dataset description.
        :param Any file_name: The name of the file in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: Path to the folder in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of the Data Lake Store.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDataLakeStoreFile')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureDataLakeStoreFile'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the item(s) in the Azure Data Lake Store.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the file in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Path to the folder in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of the Data Lake Store.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class AzureDataLakeStoreLinkedServiceArgs:
    def __init__(__self__, *,
                 data_lake_store_uri: Any,
                 type: pulumi.Input[str],
                 account_name: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 resource_group_name: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 subscription_id: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure Data Lake Store linked service.
        :param Any data_lake_store_uri: Data Lake Store service URI. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureDataLakeStore'.
        :param Any account_name: Data Lake Store account name. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any resource_group_name: Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Store account.
        :param Any subscription_id: Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "data_lake_store_uri", data_lake_store_uri)
        pulumi.set(__self__, "type", 'AzureDataLakeStore')
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="dataLakeStoreUri")
    def data_lake_store_uri(self) -> Any:
        """
        Data Lake Store service URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "data_lake_store_uri")

    @data_lake_store_uri.setter
    def data_lake_store_uri(self, value: Any):
        pulumi.set(self, "data_lake_store_uri", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureDataLakeStore'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[Any]:
        """
        Data Lake Store account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[Any]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[Any]:
        """
        Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[Any]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Store account.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[Any]:
        """
        Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[Any]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureDataLakeStoreLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure data lake store dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AzureDataLakeStoreLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AzureDataLakeStoreLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class AzureDataLakeStoreReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 list_after: Optional[Any] = None,
                 list_before: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Azure data lake store read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AzureDataLakeStoreReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any list_after: Lists files after the value (exclusive) based on file/folder names lexicographical order. Applies under the folderPath in data set, and filter files/sub-folders under the folderPath. Type: string (or Expression with resultType string).
        :param Any list_before: Lists files before the value (inclusive) based on file/folder names lexicographical order. Applies under the folderPath in data set, and filter files/sub-folders under the folderPath. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: ADLS wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: ADLS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if list_after is not None:
            pulumi.set(__self__, "list_after", list_after)
        if list_before is not None:
            pulumi.set(__self__, "list_before", list_before)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AzureDataLakeStoreReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="listAfter")
    def list_after(self) -> Optional[Any]:
        """
        Lists files after the value (exclusive) based on file/folder names lexicographical order. Applies under the folderPath in data set, and filter files/sub-folders under the folderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "list_after")

    @list_after.setter
    def list_after(self, value: Optional[Any]):
        pulumi.set(self, "list_after", value)

    @property
    @pulumi.getter(name="listBefore")
    def list_before(self) -> Optional[Any]:
        """
        Lists files before the value (inclusive) based on file/folder names lexicographical order. Applies under the folderPath in data set, and filter files/sub-folders under the folderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "list_before")

    @list_before.setter
    def list_before(self, value: Optional[Any]):
        pulumi.set(self, "list_before", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        ADLS wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        ADLS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AzureDataLakeStoreSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_adls_single_file_parallel: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Data Lake Store sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureDataLakeStoreSink'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any enable_adls_single_file_parallel: Single File Parallel.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreSink')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_adls_single_file_parallel is not None:
            pulumi.set(__self__, "enable_adls_single_file_parallel", enable_adls_single_file_parallel)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureDataLakeStoreSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enableAdlsSingleFileParallel")
    def enable_adls_single_file_parallel(self) -> Optional[Any]:
        """
        Single File Parallel.
        """
        return pulumi.get(self, "enable_adls_single_file_parallel")

    @enable_adls_single_file_parallel.setter
    def enable_adls_single_file_parallel(self, value: Optional[Any]):
        pulumi.set(self, "enable_adls_single_file_parallel", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureDataLakeStoreSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure Data Lake source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureDataLakeStoreSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureDataLakeStoreSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureDataLakeStoreWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 expiry_date_time: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None):
        """
        Azure data lake store write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'AzureDataLakeStoreWriteSettings'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any expiry_date_time: Specifies the expiry time of the written files. The time is applied to the UTC time zone in the format of "2018-12-01T05:00:00Z". Default value is NULL. Type: integer (or Expression with resultType integer).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreWriteSettings')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if expiry_date_time is not None:
            pulumi.set(__self__, "expiry_date_time", expiry_date_time)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'AzureDataLakeStoreWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="expiryDateTime")
    def expiry_date_time(self) -> Optional[Any]:
        """
        Specifies the expiry time of the written files. The time is applied to the UTC time zone in the format of "2018-12-01T05:00:00Z". Default value is NULL. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "expiry_date_time")

    @expiry_date_time.setter
    def expiry_date_time(self, value: Optional[Any]):
        pulumi.set(self, "expiry_date_time", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 database: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        Azure Databricks Delta Lake dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureDatabricksDeltaLakeDataset'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any database: The database name of delta table. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The name of delta table. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeDataset')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureDatabricksDeltaLakeDataset'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The database name of delta table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[Any]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The name of delta table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeExportCommandArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date_format: Optional[Any] = None,
                 timestamp_format: Optional[Any] = None):
        """
        Azure Databricks Delta Lake export command settings.
        :param pulumi.Input[str] type: The export setting type.
               Expected value is 'AzureDatabricksDeltaLakeExportCommand'.
        :param Any date_format: Specify the date format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        :param Any timestamp_format: Specify the timestamp format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeExportCommand')
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The export setting type.
        Expected value is 'AzureDatabricksDeltaLakeExportCommand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[Any]:
        """
        Specify the date format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "date_format")

    @date_format.setter
    def date_format(self, value: Optional[Any]):
        pulumi.set(self, "date_format", value)

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[Any]:
        """
        Specify the timestamp format for the csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[Any]):
        pulumi.set(self, "timestamp_format", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeImportCommandArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date_format: Optional[Any] = None,
                 timestamp_format: Optional[Any] = None):
        """
        Azure Databricks Delta Lake import command settings.
        :param pulumi.Input[str] type: The import setting type.
               Expected value is 'AzureDatabricksDeltaLakeImportCommand'.
        :param Any date_format: Specify the date format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        :param Any timestamp_format: Specify the timestamp format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeImportCommand')
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The import setting type.
        Expected value is 'AzureDatabricksDeltaLakeImportCommand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[Any]:
        """
        Specify the date format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "date_format")

    @date_format.setter
    def date_format(self, value: Optional[Any]):
        pulumi.set(self, "date_format", value)

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[Any]:
        """
        Specify the timestamp format for csv in Azure Databricks Delta Lake Copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[Any]):
        pulumi.set(self, "timestamp_format", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeLinkedServiceArgs:
    def __init__(__self__, *,
                 domain: Any,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 cluster_id: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Azure Databricks Delta Lake linked service.
        :param Any domain: <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureDatabricksDeltaLake'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any cluster_id: The id of an existing interactive cluster that will be used for all runs of this job. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLake')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Any):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureDatabricksDeltaLake'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[Any]:
        """
        The id of an existing interactive cluster that will be used for all runs of this job. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[Any]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 import_settings: Optional[pulumi.Input['AzureDatabricksDeltaLakeImportCommandArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Databricks Delta Lake sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureDatabricksDeltaLakeSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['AzureDatabricksDeltaLakeImportCommandArgs'] import_settings: Azure Databricks Delta Lake import settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if import_settings is not None:
            pulumi.set(__self__, "import_settings", import_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureDatabricksDeltaLakeSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="importSettings")
    def import_settings(self) -> Optional[pulumi.Input['AzureDatabricksDeltaLakeImportCommandArgs']]:
        """
        Azure Databricks Delta Lake import settings.
        """
        return pulumi.get(self, "import_settings")

    @import_settings.setter
    def import_settings(self, value: Optional[pulumi.Input['AzureDatabricksDeltaLakeImportCommandArgs']]):
        pulumi.set(self, "import_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureDatabricksDeltaLakeSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 export_settings: Optional[pulumi.Input['AzureDatabricksDeltaLakeExportCommandArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure Databricks Delta Lake source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureDatabricksDeltaLakeSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['AzureDatabricksDeltaLakeExportCommandArgs'] export_settings: Azure Databricks Delta Lake export settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Azure Databricks Delta Lake Sql query. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if export_settings is not None:
            pulumi.set(__self__, "export_settings", export_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureDatabricksDeltaLakeSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="exportSettings")
    def export_settings(self) -> Optional[pulumi.Input['AzureDatabricksDeltaLakeExportCommandArgs']]:
        """
        Azure Databricks Delta Lake export settings.
        """
        return pulumi.get(self, "export_settings")

    @export_settings.setter
    def export_settings(self, value: Optional[pulumi.Input['AzureDatabricksDeltaLakeExportCommandArgs']]):
        pulumi.set(self, "export_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Azure Databricks Delta Lake Sql query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureDatabricksLinkedServiceArgs:
    def __init__(__self__, *,
                 domain: Any,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 existing_cluster_id: Optional[Any] = None,
                 instance_pool_id: Optional[Any] = None,
                 new_cluster_custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 new_cluster_driver_node_type: Optional[Any] = None,
                 new_cluster_enable_elastic_disk: Optional[Any] = None,
                 new_cluster_init_scripts: Optional[Any] = None,
                 new_cluster_log_destination: Optional[Any] = None,
                 new_cluster_node_type: Optional[Any] = None,
                 new_cluster_num_of_worker: Optional[Any] = None,
                 new_cluster_spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 new_cluster_spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 new_cluster_version: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 policy_id: Optional[Any] = None,
                 workspace_resource_id: Optional[Any] = None):
        """
        Azure Databricks linked service.
        :param Any domain: <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureDatabricks'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication: Required to specify MSI, if using Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any existing_cluster_id: The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        :param Any instance_pool_id: The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, Any]] new_cluster_custom_tags: Additional tags for cluster resources. This property is ignored in instance pool configurations.
        :param Any new_cluster_driver_node_type: The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or Expression with resultType string).
        :param Any new_cluster_enable_elastic_disk: Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType boolean).
        :param Any new_cluster_init_scripts: User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of strings).
        :param Any new_cluster_log_destination: Specify a location to deliver Spark driver, worker, and event logs. Type: string (or Expression with resultType string).
        :param Any new_cluster_node_type: The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is not specified. If instancePoolId is specified, this property is ignored. Type: string (or Expression with resultType string).
        :param Any new_cluster_num_of_worker: If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster or instance pool. For new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify a fixed number of worker nodes, such as '2'. Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, Any]] new_cluster_spark_conf: A set of optional, user-specified Spark configuration key-value pairs.
        :param pulumi.Input[Mapping[str, Any]] new_cluster_spark_env_vars: A set of optional, user-specified Spark environment variables key-value pairs.
        :param Any new_cluster_version: If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes created for each run of this activity. Required if instancePoolId is specified. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any policy_id: The policy id for limiting the ability to configure clusters based on a user defined set of rules. Type: string (or Expression with resultType string).
        :param Any workspace_resource_id: Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "type", 'AzureDatabricks')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if new_cluster_custom_tags is not None:
            pulumi.set(__self__, "new_cluster_custom_tags", new_cluster_custom_tags)
        if new_cluster_driver_node_type is not None:
            pulumi.set(__self__, "new_cluster_driver_node_type", new_cluster_driver_node_type)
        if new_cluster_enable_elastic_disk is not None:
            pulumi.set(__self__, "new_cluster_enable_elastic_disk", new_cluster_enable_elastic_disk)
        if new_cluster_init_scripts is not None:
            pulumi.set(__self__, "new_cluster_init_scripts", new_cluster_init_scripts)
        if new_cluster_log_destination is not None:
            pulumi.set(__self__, "new_cluster_log_destination", new_cluster_log_destination)
        if new_cluster_node_type is not None:
            pulumi.set(__self__, "new_cluster_node_type", new_cluster_node_type)
        if new_cluster_num_of_worker is not None:
            pulumi.set(__self__, "new_cluster_num_of_worker", new_cluster_num_of_worker)
        if new_cluster_spark_conf is not None:
            pulumi.set(__self__, "new_cluster_spark_conf", new_cluster_spark_conf)
        if new_cluster_spark_env_vars is not None:
            pulumi.set(__self__, "new_cluster_spark_env_vars", new_cluster_spark_env_vars)
        if new_cluster_version is not None:
            pulumi.set(__self__, "new_cluster_version", new_cluster_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if workspace_resource_id is not None:
            pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Any):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureDatabricks'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[Any]:
        """
        Required to specify MSI, if using Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[Any]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[Any]:
        """
        The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[Any]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[Any]:
        """
        The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[Any]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="newClusterCustomTags")
    def new_cluster_custom_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional tags for cluster resources. This property is ignored in instance pool configurations.
        """
        return pulumi.get(self, "new_cluster_custom_tags")

    @new_cluster_custom_tags.setter
    def new_cluster_custom_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "new_cluster_custom_tags", value)

    @property
    @pulumi.getter(name="newClusterDriverNodeType")
    def new_cluster_driver_node_type(self) -> Optional[Any]:
        """
        The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_driver_node_type")

    @new_cluster_driver_node_type.setter
    def new_cluster_driver_node_type(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_driver_node_type", value)

    @property
    @pulumi.getter(name="newClusterEnableElasticDisk")
    def new_cluster_enable_elastic_disk(self) -> Optional[Any]:
        """
        Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "new_cluster_enable_elastic_disk")

    @new_cluster_enable_elastic_disk.setter
    def new_cluster_enable_elastic_disk(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_enable_elastic_disk", value)

    @property
    @pulumi.getter(name="newClusterInitScripts")
    def new_cluster_init_scripts(self) -> Optional[Any]:
        """
        User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "new_cluster_init_scripts")

    @new_cluster_init_scripts.setter
    def new_cluster_init_scripts(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_init_scripts", value)

    @property
    @pulumi.getter(name="newClusterLogDestination")
    def new_cluster_log_destination(self) -> Optional[Any]:
        """
        Specify a location to deliver Spark driver, worker, and event logs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_log_destination")

    @new_cluster_log_destination.setter
    def new_cluster_log_destination(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_log_destination", value)

    @property
    @pulumi.getter(name="newClusterNodeType")
    def new_cluster_node_type(self) -> Optional[Any]:
        """
        The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is not specified. If instancePoolId is specified, this property is ignored. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_node_type")

    @new_cluster_node_type.setter
    def new_cluster_node_type(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_node_type", value)

    @property
    @pulumi.getter(name="newClusterNumOfWorker")
    def new_cluster_num_of_worker(self) -> Optional[Any]:
        """
        If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster or instance pool. For new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify a fixed number of worker nodes, such as '2'. Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_num_of_worker")

    @new_cluster_num_of_worker.setter
    def new_cluster_num_of_worker(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_num_of_worker", value)

    @property
    @pulumi.getter(name="newClusterSparkConf")
    def new_cluster_spark_conf(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A set of optional, user-specified Spark configuration key-value pairs.
        """
        return pulumi.get(self, "new_cluster_spark_conf")

    @new_cluster_spark_conf.setter
    def new_cluster_spark_conf(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "new_cluster_spark_conf", value)

    @property
    @pulumi.getter(name="newClusterSparkEnvVars")
    def new_cluster_spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A set of optional, user-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "new_cluster_spark_env_vars")

    @new_cluster_spark_env_vars.setter
    def new_cluster_spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "new_cluster_spark_env_vars", value)

    @property
    @pulumi.getter(name="newClusterVersion")
    def new_cluster_version(self) -> Optional[Any]:
        """
        If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes created for each run of this activity. Required if instancePoolId is specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_version")

    @new_cluster_version.setter
    def new_cluster_version(self, value: Optional[Any]):
        pulumi.set(self, "new_cluster_version", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[Any]:
        """
        The policy id for limiting the ability to configure clusters based on a user defined set of rules. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[Any]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> Optional[Any]:
        """
        Workspace resource id for databricks REST API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "workspace_resource_id")

    @workspace_resource_id.setter
    def workspace_resource_id(self, value: Optional[Any]):
        pulumi.set(self, "workspace_resource_id", value)


@pulumi.input_type
class AzureFileStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 account_key: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 file_share: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 sas_token: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 sas_uri: Optional[Any] = None,
                 snapshot: Optional[Any] = None,
                 user_id: Optional[Any] = None):
        """
        Azure File Storage linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureFileStorage'.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] account_key: The Azure key vault secret reference of accountKey in connection string.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any file_share: The azure file share name. It is required when auth with accountKey/sasToken. Type: string (or Expression with resultType string).
        :param Any host: Host name of the server. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to logon the server.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure File resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any snapshot: The azure file share snapshot version. Type: string (or Expression with resultType string).
        :param Any user_id: User ID to logon the server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureFileStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if file_share is not None:
            pulumi.set(__self__, "file_share", file_share)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureFileStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> Optional[Any]:
        """
        The azure file share name. It is required when auth with accountKey/sasToken. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_share")

    @file_share.setter
    def file_share(self, value: Optional[Any]):
        pulumi.set(self, "file_share", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        Host name of the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[Any]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to logon the server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure File resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @sas_uri.setter
    def sas_uri(self, value: Optional[Any]):
        pulumi.set(self, "sas_uri", value)

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[Any]:
        """
        The azure file share snapshot version. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snapshot")

    @snapshot.setter
    def snapshot(self, value: Optional[Any]):
        pulumi.set(self, "snapshot", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[Any]:
        """
        User ID to logon the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[Any]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class AzureFileStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of file server dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'AzureFileStorageLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureFileStorageLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'AzureFileStorageLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class AzureFileStorageReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Azure File Storage read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'AzureFileStorageReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the Azure File name starting from root path. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Azure File Storage wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Azure File Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureFileStorageReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'AzureFileStorageReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the Azure File name starting from root path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Azure File Storage wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Azure File Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class AzureFileStorageWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None):
        """
        Azure File Storage write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'AzureFileStorageWriteSettings'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'AzureFileStorageWriteSettings')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'AzureFileStorageWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)


@pulumi.input_type
class AzureFunctionActivityArgs:
    def __init__(__self__, *,
                 function_name: Any,
                 method: pulumi.Input[Union[str, 'AzureFunctionActivityMethod']],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 body: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Azure Function activity.
        :param Any function_name: Name of the Function that the Azure Function Activity will call. Type: string (or Expression with resultType string)
        :param pulumi.Input[Union[str, 'AzureFunctionActivityMethod']] method: Rest API method for target endpoint.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AzureFunctionActivity'.
        :param Any body: Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any headers: Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'AzureFunctionActivity')
        if body is not None:
            pulumi.set(__self__, "body", body)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Any:
        """
        Name of the Function that the Azure Function Activity will call. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: Any):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'AzureFunctionActivityMethod']]:
        """
        Rest API method for target endpoint.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'AzureFunctionActivityMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AzureFunctionActivity'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[Any]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Any]:
        """
        Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Any]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class AzureFunctionLinkedServiceArgs:
    def __init__(__self__, *,
                 function_app_url: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 function_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 resource_id: Optional[Any] = None):
        """
        Azure Function linked service.
        :param Any function_app_url: The endpoint of the Azure Function App. URL will be in the format https://<accountName>.azurewebsites.net.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureFunction'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication: Type of authentication (Required to specify MSI) used to connect to AzureFunction. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] function_key: Function or Host key for Azure Function App.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any resource_id: Allowed token audiences for azure function.
        """
        pulumi.set(__self__, "function_app_url", function_app_url)
        pulumi.set(__self__, "type", 'AzureFunction')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if function_key is not None:
            pulumi.set(__self__, "function_key", function_key)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="functionAppUrl")
    def function_app_url(self) -> Any:
        """
        The endpoint of the Azure Function App. URL will be in the format https://<accountName>.azurewebsites.net.
        """
        return pulumi.get(self, "function_app_url")

    @function_app_url.setter
    def function_app_url(self, value: Any):
        pulumi.set(self, "function_app_url", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureFunction'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[Any]:
        """
        Type of authentication (Required to specify MSI) used to connect to AzureFunction. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[Any]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="functionKey")
    def function_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Function or Host key for Azure Function App.
        """
        return pulumi.get(self, "function_key")

    @function_key.setter
    def function_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "function_key", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[Any]:
        """
        Allowed token audiences for azure function.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[Any]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class AzureKeyVaultLinkedServiceArgs:
    def __init__(__self__, *,
                 base_url: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Azure Key Vault linked service.
        :param Any base_url: The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureKeyVault'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "type", 'AzureKeyVault')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Any:
        """
        The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Any):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureKeyVault'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AzureKeyVaultSecretReferenceArgs:
    def __init__(__self__, *,
                 secret_name: Any,
                 store: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 secret_version: Optional[Any] = None):
        """
        Azure Key Vault secret reference.
        :param Any secret_name: The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] store: The Azure Key Vault linked service reference.
        :param pulumi.Input[str] type: Type of the secret.
               Expected value is 'AzureKeyVaultSecret'.
        :param Any secret_version: The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "type", 'AzureKeyVaultSecret')
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Any:
        """
        The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Any):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def store(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        The Azure Key Vault linked service reference.
        """
        return pulumi.get(self, "store")

    @store.setter
    def store(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "store", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the secret.
        Expected value is 'AzureKeyVaultSecret'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[Any]:
        """
        The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[Any]):
        pulumi.set(self, "secret_version", value)


@pulumi.input_type
class AzureMLBatchExecutionActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 web_service_inputs: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]] = None,
                 web_service_outputs: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]] = None):
        """
        Azure ML Batch Execution activity.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AzureMLBatchExecution'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Mapping[str, Any]] global_parameters: Key,Value pairs to be passed to the Azure ML Batch Execution Service endpoint. Keys must match the names of web service parameters defined in the published Azure ML web service. Values will be passed in the GlobalParameters property of the Azure ML batch execution request.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]] web_service_inputs: Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Inputs to AzureMLWebServiceFile objects specifying the input Blob locations.. This information will be passed in the WebServiceInputs property of the Azure ML batch execution request.
        :param pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]] web_service_outputs: Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Outputs to AzureMLWebServiceFile objects specifying the output Blob locations. This information will be passed in the WebServiceOutputs property of the Azure ML batch execution request.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'AzureMLBatchExecution')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_parameters is not None:
            pulumi.set(__self__, "global_parameters", global_parameters)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if web_service_inputs is not None:
            pulumi.set(__self__, "web_service_inputs", web_service_inputs)
        if web_service_outputs is not None:
            pulumi.set(__self__, "web_service_outputs", web_service_outputs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AzureMLBatchExecution'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalParameters")
    def global_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Key,Value pairs to be passed to the Azure ML Batch Execution Service endpoint. Keys must match the names of web service parameters defined in the published Azure ML web service. Values will be passed in the GlobalParameters property of the Azure ML batch execution request.
        """
        return pulumi.get(self, "global_parameters")

    @global_parameters.setter
    def global_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "global_parameters", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter(name="webServiceInputs")
    def web_service_inputs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]]:
        """
        Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Inputs to AzureMLWebServiceFile objects specifying the input Blob locations.. This information will be passed in the WebServiceInputs property of the Azure ML batch execution request.
        """
        return pulumi.get(self, "web_service_inputs")

    @web_service_inputs.setter
    def web_service_inputs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]]):
        pulumi.set(self, "web_service_inputs", value)

    @property
    @pulumi.getter(name="webServiceOutputs")
    def web_service_outputs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]]:
        """
        Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Outputs to AzureMLWebServiceFile objects specifying the output Blob locations. This information will be passed in the WebServiceOutputs property of the Azure ML batch execution request.
        """
        return pulumi.get(self, "web_service_outputs")

    @web_service_outputs.setter
    def web_service_outputs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureMLWebServiceFileArgs']]]]):
        pulumi.set(self, "web_service_outputs", value)


@pulumi.input_type
class AzureMLExecutePipelineActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 continue_on_step_failure: Optional[Any] = None,
                 data_path_assignments: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 experiment_name: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 ml_parent_run_id: Optional[Any] = None,
                 ml_pipeline_endpoint_id: Optional[Any] = None,
                 ml_pipeline_id: Optional[Any] = None,
                 ml_pipeline_parameters: Optional[Any] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 version: Optional[Any] = None):
        """
        Azure ML Execute Pipeline activity.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AzureMLExecutePipeline'.
        :param Any continue_on_step_failure: Whether to continue execution of other steps in the PipelineRun if a step fails. This information will be passed in the continueOnStepFailure property of the published pipeline execution request. Type: boolean (or Expression with resultType boolean).
        :param Any data_path_assignments: Dictionary used for changing data path assignments without retraining. Values will be passed in the dataPathAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression with resultType object).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any experiment_name: Run history experiment name of the pipeline run. This information will be passed in the ExperimentName property of the published pipeline execution request. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any ml_parent_run_id: The parent Azure ML Service pipeline run id. This information will be passed in the ParentRunId property of the published pipeline execution request. Type: string (or Expression with resultType string).
        :param Any ml_pipeline_endpoint_id: ID of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
        :param Any ml_pipeline_id: ID of the published Azure ML pipeline. Type: string (or Expression with resultType string).
        :param Any ml_pipeline_parameters: Key,Value pairs to be passed to the published Azure ML pipeline endpoint. Keys must match the names of pipeline parameters defined in the published pipeline. Values will be passed in the ParameterAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression with resultType object).
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param Any version: Version of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'AzureMLExecutePipeline')
        if continue_on_step_failure is not None:
            pulumi.set(__self__, "continue_on_step_failure", continue_on_step_failure)
        if data_path_assignments is not None:
            pulumi.set(__self__, "data_path_assignments", data_path_assignments)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if ml_parent_run_id is not None:
            pulumi.set(__self__, "ml_parent_run_id", ml_parent_run_id)
        if ml_pipeline_endpoint_id is not None:
            pulumi.set(__self__, "ml_pipeline_endpoint_id", ml_pipeline_endpoint_id)
        if ml_pipeline_id is not None:
            pulumi.set(__self__, "ml_pipeline_id", ml_pipeline_id)
        if ml_pipeline_parameters is not None:
            pulumi.set(__self__, "ml_pipeline_parameters", ml_pipeline_parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AzureMLExecutePipeline'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="continueOnStepFailure")
    def continue_on_step_failure(self) -> Optional[Any]:
        """
        Whether to continue execution of other steps in the PipelineRun if a step fails. This information will be passed in the continueOnStepFailure property of the published pipeline execution request. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "continue_on_step_failure")

    @continue_on_step_failure.setter
    def continue_on_step_failure(self, value: Optional[Any]):
        pulumi.set(self, "continue_on_step_failure", value)

    @property
    @pulumi.getter(name="dataPathAssignments")
    def data_path_assignments(self) -> Optional[Any]:
        """
        Dictionary used for changing data path assignments without retraining. Values will be passed in the dataPathAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression with resultType object).
        """
        return pulumi.get(self, "data_path_assignments")

    @data_path_assignments.setter
    def data_path_assignments(self, value: Optional[Any]):
        pulumi.set(self, "data_path_assignments", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[Any]:
        """
        Run history experiment name of the pipeline run. This information will be passed in the ExperimentName property of the published pipeline execution request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "experiment_name")

    @experiment_name.setter
    def experiment_name(self, value: Optional[Any]):
        pulumi.set(self, "experiment_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="mlParentRunId")
    def ml_parent_run_id(self) -> Optional[Any]:
        """
        The parent Azure ML Service pipeline run id. This information will be passed in the ParentRunId property of the published pipeline execution request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_parent_run_id")

    @ml_parent_run_id.setter
    def ml_parent_run_id(self, value: Optional[Any]):
        pulumi.set(self, "ml_parent_run_id", value)

    @property
    @pulumi.getter(name="mlPipelineEndpointId")
    def ml_pipeline_endpoint_id(self) -> Optional[Any]:
        """
        ID of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_pipeline_endpoint_id")

    @ml_pipeline_endpoint_id.setter
    def ml_pipeline_endpoint_id(self, value: Optional[Any]):
        pulumi.set(self, "ml_pipeline_endpoint_id", value)

    @property
    @pulumi.getter(name="mlPipelineId")
    def ml_pipeline_id(self) -> Optional[Any]:
        """
        ID of the published Azure ML pipeline. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_pipeline_id")

    @ml_pipeline_id.setter
    def ml_pipeline_id(self, value: Optional[Any]):
        pulumi.set(self, "ml_pipeline_id", value)

    @property
    @pulumi.getter(name="mlPipelineParameters")
    def ml_pipeline_parameters(self) -> Optional[Any]:
        """
        Key,Value pairs to be passed to the published Azure ML pipeline endpoint. Keys must match the names of pipeline parameters defined in the published pipeline. Values will be passed in the ParameterAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression with resultType object).
        """
        return pulumi.get(self, "ml_pipeline_parameters")

    @ml_pipeline_parameters.setter
    def ml_pipeline_parameters(self, value: Optional[Any]):
        pulumi.set(self, "ml_pipeline_parameters", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Version of the published Azure ML pipeline endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class AzureMLLinkedServiceArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 ml_endpoint: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None,
                 update_resource_endpoint: Optional[Any] = None):
        """
        Azure ML Studio Web Service linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] api_key: The API key for accessing the Azure ML model endpoint.
        :param Any ml_endpoint: The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureML'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication: Type of authentication (Required to specify MSI) used to connect to AzureML. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        :param Any update_resource_endpoint: The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "ml_endpoint", ml_endpoint)
        pulumi.set(__self__, "type", 'AzureML')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if update_resource_endpoint is not None:
            pulumi.set(__self__, "update_resource_endpoint", update_resource_endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The API key for accessing the Azure ML model endpoint.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="mlEndpoint")
    def ml_endpoint(self) -> Any:
        """
        The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_endpoint")

    @ml_endpoint.setter
    def ml_endpoint(self, value: Any):
        pulumi.set(self, "ml_endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureML'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[Any]:
        """
        Type of authentication (Required to specify MSI) used to connect to AzureML. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[Any]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="updateResourceEndpoint")
    def update_resource_endpoint(self) -> Optional[Any]:
        """
        The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "update_resource_endpoint")

    @update_resource_endpoint.setter
    def update_resource_endpoint(self, value: Optional[Any]):
        pulumi.set(self, "update_resource_endpoint", value)


@pulumi.input_type
class AzureMLServiceLinkedServiceArgs:
    def __init__(__self__, *,
                 ml_workspace_name: Any,
                 resource_group_name: Any,
                 subscription_id: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Azure ML Service linked service.
        :param Any ml_workspace_name: Azure ML Service workspace name. Type: string (or Expression with resultType string).
        :param Any resource_group_name: Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
        :param Any subscription_id: Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureMLService'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "ml_workspace_name", ml_workspace_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "type", 'AzureMLService')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="mlWorkspaceName")
    def ml_workspace_name(self) -> Any:
        """
        Azure ML Service workspace name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_workspace_name")

    @ml_workspace_name.setter
    def ml_workspace_name(self, value: Any):
        pulumi.set(self, "ml_workspace_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Any:
        """
        Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Any):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Any:
        """
        Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Any):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureMLService'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureMLUpdateResourceActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 trained_model_file_path: Any,
                 trained_model_linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 trained_model_name: Any,
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Azure ML Update Resource management activity.
        :param pulumi.Input[str] name: Activity name.
        :param Any trained_model_file_path: The relative file path in trainedModelLinkedService to represent the .ilearner file that will be uploaded by the update operation.  Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] trained_model_linked_service_name: Name of Azure Storage linked service holding the .ilearner file that will be uploaded by the update operation.
        :param Any trained_model_name: Name of the Trained Model module in the Web Service experiment to be updated. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'AzureMLUpdateResource'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trained_model_file_path", trained_model_file_path)
        pulumi.set(__self__, "trained_model_linked_service_name", trained_model_linked_service_name)
        pulumi.set(__self__, "trained_model_name", trained_model_name)
        pulumi.set(__self__, "type", 'AzureMLUpdateResource')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="trainedModelFilePath")
    def trained_model_file_path(self) -> Any:
        """
        The relative file path in trainedModelLinkedService to represent the .ilearner file that will be uploaded by the update operation.  Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "trained_model_file_path")

    @trained_model_file_path.setter
    def trained_model_file_path(self, value: Any):
        pulumi.set(self, "trained_model_file_path", value)

    @property
    @pulumi.getter(name="trainedModelLinkedServiceName")
    def trained_model_linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Name of Azure Storage linked service holding the .ilearner file that will be uploaded by the update operation.
        """
        return pulumi.get(self, "trained_model_linked_service_name")

    @trained_model_linked_service_name.setter
    def trained_model_linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "trained_model_linked_service_name", value)

    @property
    @pulumi.getter(name="trainedModelName")
    def trained_model_name(self) -> Any:
        """
        Name of the Trained Model module in the Web Service experiment to be updated. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "trained_model_name")

    @trained_model_name.setter
    def trained_model_name(self, value: Any):
        pulumi.set(self, "trained_model_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'AzureMLUpdateResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class AzureMLWebServiceFileArgs:
    def __init__(__self__, *,
                 file_path: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs']):
        """
        Azure ML WebService Input/Output file
        :param Any file_path: The relative file path, including container name, in the Azure Blob Storage specified by the LinkedService. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Reference to an Azure Storage LinkedService, where Azure ML WebService Input/Output file located.
        """
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "linked_service_name", linked_service_name)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Any:
        """
        The relative file path, including container name, in the Azure Blob Storage specified by the LinkedService. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Any):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Reference to an Azure Storage LinkedService, where Azure ML WebService Input/Output file located.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)


@pulumi.input_type
class AzureMariaDBLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Azure Database for MariaDB linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureMariaDB'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'AzureMariaDB')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureMariaDB'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class AzureMariaDBSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure MariaDB source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureMariaDBSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureMariaDBSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureMariaDBSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureMariaDBTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Azure Database for MariaDB dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureMariaDBTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureMariaDBTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureMariaDBTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzureMySqlLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Azure MySQL database linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureMySql'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureMySql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureMySql'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class AzureMySqlSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure MySql sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureMySqlSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: A query to execute before starting the copy. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureMySqlSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureMySqlSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        A query to execute before starting the copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureMySqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure MySQL source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureMySqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureMySqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureMySqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureMySqlTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure MySQL database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureMySqlTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The name of Azure MySQL database table. Type: string (or Expression with resultType string).
        :param Any table_name: The Azure MySQL database table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureMySqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureMySqlTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The name of Azure MySQL database table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Azure MySQL database table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzurePostgreSqlLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Azure PostgreSQL linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzurePostgreSql'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'AzurePostgreSql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzurePostgreSql'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class AzurePostgreSqlSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure PostgreSQL sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzurePostgreSqlSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: A query to execute before starting the copy. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzurePostgreSqlSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzurePostgreSqlSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        A query to execute before starting the copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzurePostgreSqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure PostgreSQL source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzurePostgreSqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzurePostgreSqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzurePostgreSqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzurePostgreSqlTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Azure PostgreSQL dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzurePostgreSqlTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
        :param Any table_name: The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzurePostgreSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzurePostgreSqlTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzureQueueSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Queue sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureQueueSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureQueueSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureQueueSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureSearchIndexDatasetArgs:
    def __init__(__self__, *,
                 index_name: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Search Index.
        :param Any index_name: The name of the Azure Search Index. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureSearchIndex'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSearchIndex')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Any:
        """
        The name of the Azure Search Index. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Any):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureSearchIndex'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class AzureSearchIndexSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[pulumi.Input[Union[str, 'AzureSearchIndexWriteBehaviorType']]] = None):
        """
        A copy activity Azure Search Index sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureSearchIndexSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union[str, 'AzureSearchIndexWriteBehaviorType']] write_behavior: Specify the write behavior when upserting documents into Azure Search Index.
        """
        pulumi.set(__self__, "type", 'AzureSearchIndexSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureSearchIndexSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[pulumi.Input[Union[str, 'AzureSearchIndexWriteBehaviorType']]]:
        """
        Specify the write behavior when upserting documents into Azure Search Index.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[pulumi.Input[Union[str, 'AzureSearchIndexWriteBehaviorType']]]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class AzureSearchLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Linked service for Windows Azure Search Service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureSearch'.
        :param Any url: URL for Azure Search service. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] key: Admin Key for Azure Search service
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'AzureSearch')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureSearch'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        URL for Azure Search service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Admin Key for Azure Search service
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AzureSqlDWLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Azure SQL Data Warehouse linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureSqlDW'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlDW')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureSqlDW'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureSqlDWTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Data Warehouse dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureSqlDWTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlDWTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureSqlDWTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzureSqlDatabaseLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 always_encrypted_settings: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Microsoft Azure SQL Database linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureSqlDatabase'.
        :param pulumi.Input['SqlAlwaysEncryptedPropertiesArgs'] always_encrypted_settings: Sql always encrypted properties.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Azure SQL Database.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlDatabase')
        if always_encrypted_settings is not None:
            pulumi.set(__self__, "always_encrypted_settings", always_encrypted_settings)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureSqlDatabase'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="alwaysEncryptedSettings")
    def always_encrypted_settings(self) -> Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]:
        """
        Sql always encrypted properties.
        """
        return pulumi.get(self, "always_encrypted_settings")

    @always_encrypted_settings.setter
    def always_encrypted_settings(self, value: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]):
        pulumi.set(self, "always_encrypted_settings", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Azure SQL Database.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureSqlMILinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 always_encrypted_settings: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None):
        """
        Azure SQL Managed Instance linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureSqlMI'.
        :param pulumi.Input['SqlAlwaysEncryptedPropertiesArgs'] always_encrypted_settings: Sql always encrypted properties.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Azure SQL Managed Instance.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlMI')
        if always_encrypted_settings is not None:
            pulumi.set(__self__, "always_encrypted_settings", always_encrypted_settings)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureSqlMI'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="alwaysEncryptedSettings")
    def always_encrypted_settings(self) -> Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]:
        """
        Sql always encrypted properties.
        """
        return pulumi.get(self, "always_encrypted_settings")

    @always_encrypted_settings.setter
    def always_encrypted_settings(self, value: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]):
        pulumi.set(self, "always_encrypted_settings", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Azure SQL Managed Instance.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class AzureSqlMITableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Managed Instance dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureSqlMITable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlMITable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureSqlMITable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzureSqlSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 sql_writer_stored_procedure_name: Optional[Any] = None,
                 sql_writer_table_type: Optional[Any] = None,
                 sql_writer_use_table_lock: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None,
                 stored_procedure_table_type_parameter_name: Optional[Any] = None,
                 table_option: Optional[Any] = None,
                 upsert_settings: Optional[pulumi.Input['SqlUpsertSettingsArgs']] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity Azure SQL sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureSqlSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_writer_stored_procedure_name: SQL writer stored procedure name. Type: string (or Expression with resultType string).
        :param Any sql_writer_table_type: SQL writer table type. Type: string (or Expression with resultType string).
        :param Any sql_writer_use_table_lock: Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: SQL stored procedure parameters.
        :param Any stored_procedure_table_type_parameter_name: The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        :param Any table_option: The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        :param pulumi.Input['SqlUpsertSettingsArgs'] upsert_settings: SQL upsert settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Write behavior when copying data into Azure SQL. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        pulumi.set(__self__, "type", 'AzureSqlSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if sql_writer_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_writer_stored_procedure_name", sql_writer_stored_procedure_name)
        if sql_writer_table_type is not None:
            pulumi.set(__self__, "sql_writer_table_type", sql_writer_table_type)
        if sql_writer_use_table_lock is not None:
            pulumi.set(__self__, "sql_writer_use_table_lock", sql_writer_use_table_lock)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)
        if stored_procedure_table_type_parameter_name is not None:
            pulumi.set(__self__, "stored_procedure_table_type_parameter_name", stored_procedure_table_type_parameter_name)
        if table_option is not None:
            pulumi.set(__self__, "table_option", table_option)
        if upsert_settings is not None:
            pulumi.set(__self__, "upsert_settings", upsert_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureSqlSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="sqlWriterStoredProcedureName")
    def sql_writer_stored_procedure_name(self) -> Optional[Any]:
        """
        SQL writer stored procedure name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_stored_procedure_name")

    @sql_writer_stored_procedure_name.setter
    def sql_writer_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_stored_procedure_name", value)

    @property
    @pulumi.getter(name="sqlWriterTableType")
    def sql_writer_table_type(self) -> Optional[Any]:
        """
        SQL writer table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_table_type")

    @sql_writer_table_type.setter
    def sql_writer_table_type(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_table_type", value)

    @property
    @pulumi.getter(name="sqlWriterUseTableLock")
    def sql_writer_use_table_lock(self) -> Optional[Any]:
        """
        Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "sql_writer_use_table_lock")

    @sql_writer_use_table_lock.setter
    def sql_writer_use_table_lock(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_use_table_lock", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        SQL stored procedure parameters.
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)

    @property
    @pulumi.getter(name="storedProcedureTableTypeParameterName")
    def stored_procedure_table_type_parameter_name(self) -> Optional[Any]:
        """
        The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "stored_procedure_table_type_parameter_name")

    @stored_procedure_table_type_parameter_name.setter
    def stored_procedure_table_type_parameter_name(self, value: Optional[Any]):
        pulumi.set(self, "stored_procedure_table_type_parameter_name", value)

    @property
    @pulumi.getter(name="tableOption")
    def table_option(self) -> Optional[Any]:
        """
        The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_option")

    @table_option.setter
    def table_option(self, value: Optional[Any]):
        pulumi.set(self, "table_option", value)

    @property
    @pulumi.getter(name="upsertSettings")
    def upsert_settings(self) -> Optional[pulumi.Input['SqlUpsertSettingsArgs']]:
        """
        SQL upsert settings.
        """
        return pulumi.get(self, "upsert_settings")

    @upsert_settings.setter
    def upsert_settings(self, value: Optional[pulumi.Input['SqlUpsertSettingsArgs']]):
        pulumi.set(self, "upsert_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Write behavior when copying data into Azure SQL. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class AzureSqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 produce_additional_types: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None):
        """
        A copy activity Azure SQL source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureSqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any produce_additional_types: Which additional types to produce.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        pulumi.set(__self__, "type", 'AzureSqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if produce_additional_types is not None:
            pulumi.set(__self__, "produce_additional_types", produce_additional_types)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureSqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="produceAdditionalTypes")
    def produce_additional_types(self) -> Optional[Any]:
        """
        Which additional types to produce.
        """
        return pulumi.get(self, "produce_additional_types")

    @produce_additional_types.setter
    def produce_additional_types(self, value: Optional[Any]):
        pulumi.set(self, "produce_additional_types", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class AzureSqlTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Server database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureSqlTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL database. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureSqlTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class AzureStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 account_key: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 sas_token: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 sas_uri: Optional[Any] = None):
        """
        The storage account linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureStorage'.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] account_key: The Azure key vault secret reference of accountKey in connection string.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[str] encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        pulumi.set(__self__, "type", 'AzureStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[pulumi.Input[str]]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @sas_uri.setter
    def sas_uri(self, value: Optional[Any]):
        pulumi.set(self, "sas_uri", value)


@pulumi.input_type
class AzureTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 table_name: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Table storage dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any table_name: The table name of the Azure Table storage. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'AzureTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'AzureTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        The table name of the Azure Table storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Any):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'AzureTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class AzureTableSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 azure_table_default_partition_key_value: Optional[Any] = None,
                 azure_table_insert_type: Optional[Any] = None,
                 azure_table_partition_key_name: Optional[Any] = None,
                 azure_table_row_key_name: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Table sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'AzureTableSink'.
        :param Any azure_table_default_partition_key_value: Azure Table default partition key value. Type: string (or Expression with resultType string).
        :param Any azure_table_insert_type: Azure Table insert type. Type: string (or Expression with resultType string).
        :param Any azure_table_partition_key_name: Azure Table partition key name. Type: string (or Expression with resultType string).
        :param Any azure_table_row_key_name: Azure Table row key name. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureTableSink')
        if azure_table_default_partition_key_value is not None:
            pulumi.set(__self__, "azure_table_default_partition_key_value", azure_table_default_partition_key_value)
        if azure_table_insert_type is not None:
            pulumi.set(__self__, "azure_table_insert_type", azure_table_insert_type)
        if azure_table_partition_key_name is not None:
            pulumi.set(__self__, "azure_table_partition_key_name", azure_table_partition_key_name)
        if azure_table_row_key_name is not None:
            pulumi.set(__self__, "azure_table_row_key_name", azure_table_row_key_name)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'AzureTableSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="azureTableDefaultPartitionKeyValue")
    def azure_table_default_partition_key_value(self) -> Optional[Any]:
        """
        Azure Table default partition key value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_table_default_partition_key_value")

    @azure_table_default_partition_key_value.setter
    def azure_table_default_partition_key_value(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_default_partition_key_value", value)

    @property
    @pulumi.getter(name="azureTableInsertType")
    def azure_table_insert_type(self) -> Optional[Any]:
        """
        Azure Table insert type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_table_insert_type")

    @azure_table_insert_type.setter
    def azure_table_insert_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_insert_type", value)

    @property
    @pulumi.getter(name="azureTablePartitionKeyName")
    def azure_table_partition_key_name(self) -> Optional[Any]:
        """
        Azure Table partition key name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_table_partition_key_name")

    @azure_table_partition_key_name.setter
    def azure_table_partition_key_name(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_partition_key_name", value)

    @property
    @pulumi.getter(name="azureTableRowKeyName")
    def azure_table_row_key_name(self) -> Optional[Any]:
        """
        Azure Table row key name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_table_row_key_name")

    @azure_table_row_key_name.setter
    def azure_table_row_key_name(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_row_key_name", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class AzureTableSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 azure_table_source_ignore_table_not_found: Optional[Any] = None,
                 azure_table_source_query: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure Table source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'AzureTableSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any azure_table_source_ignore_table_not_found: Azure Table source ignore table not found. Type: boolean (or Expression with resultType boolean).
        :param Any azure_table_source_query: Azure Table source query. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'AzureTableSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if azure_table_source_ignore_table_not_found is not None:
            pulumi.set(__self__, "azure_table_source_ignore_table_not_found", azure_table_source_ignore_table_not_found)
        if azure_table_source_query is not None:
            pulumi.set(__self__, "azure_table_source_query", azure_table_source_query)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'AzureTableSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="azureTableSourceIgnoreTableNotFound")
    def azure_table_source_ignore_table_not_found(self) -> Optional[Any]:
        """
        Azure Table source ignore table not found. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "azure_table_source_ignore_table_not_found")

    @azure_table_source_ignore_table_not_found.setter
    def azure_table_source_ignore_table_not_found(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_source_ignore_table_not_found", value)

    @property
    @pulumi.getter(name="azureTableSourceQuery")
    def azure_table_source_query(self) -> Optional[Any]:
        """
        Azure Table source query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_table_source_query")

    @azure_table_source_query.setter
    def azure_table_source_query(self, value: Optional[Any]):
        pulumi.set(self, "azure_table_source_query", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class AzureTableStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 account_key: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 sas_token: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 sas_uri: Optional[Any] = None):
        """
        The azure table storage linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'AzureTableStorage'.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] account_key: The Azure key vault secret reference of accountKey in connection string.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[str] encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        pulumi.set(__self__, "type", 'AzureTableStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'AzureTableStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[pulumi.Input[str]]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @sas_uri.setter
    def sas_uri(self, value: Optional[Any]):
        pulumi.set(self, "sas_uri", value)


@pulumi.input_type
class BinaryDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Binary dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the Binary storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Binary'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the binary dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Binary')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the Binary storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Binary'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the binary dataset.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class BinaryReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compression_properties: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]] = None):
        """
        Binary read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'BinaryReadSettings'.
        :param pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']] compression_properties: Compression settings.
        """
        pulumi.set(__self__, "type", 'BinaryReadSettings')
        if compression_properties is not None:
            pulumi.set(__self__, "compression_properties", compression_properties)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'BinaryReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compressionProperties")
    def compression_properties(self) -> Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]:
        """
        Compression settings.
        """
        return pulumi.get(self, "compression_properties")

    @compression_properties.setter
    def compression_properties(self, value: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]):
        pulumi.set(self, "compression_properties", value)


@pulumi.input_type
class BinarySinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Binary sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'BinarySink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: Binary store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'BinarySink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'BinarySink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        Binary store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class BinarySourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['BinaryReadSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity Binary source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'BinarySource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['BinaryReadSettingsArgs'] format_settings: Binary format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Binary store settings.
        """
        pulumi.set(__self__, "type", 'BinarySource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'BinarySource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['BinaryReadSettingsArgs']]:
        """
        Binary format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['BinaryReadSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Binary store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class BlobEventsTriggerArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[Union[str, 'BlobEventTypes']]]],
                 scope: pulumi.Input[str],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 blob_path_begins_with: Optional[pulumi.Input[str]] = None,
                 blob_path_ends_with: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ignore_empty_blobs: Optional[pulumi.Input[bool]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]] = None):
        """
        Trigger that runs every time a Blob event occurs.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'BlobEventTypes']]]] events: The type of events that cause this trigger to fire.
        :param pulumi.Input[str] scope: The ARM resource ID of the Storage Account.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'BlobEventsTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] blob_path_begins_with: The blob path must begin with the pattern provided for trigger to fire. For example, '/records/blobs/december/' will only fire the trigger for blobs in the december folder under the records container. At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
        :param pulumi.Input[str] blob_path_ends_with: The blob path must end with the pattern provided for trigger to fire. For example, 'december/boxes.csv' will only fire the trigger for blobs named boxes in a december folder. At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[bool] ignore_empty_blobs: If set to true, blobs with zero bytes will be ignored.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]] pipelines: Pipelines that need to be started.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "type", 'BlobEventsTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if blob_path_begins_with is not None:
            pulumi.set(__self__, "blob_path_begins_with", blob_path_begins_with)
        if blob_path_ends_with is not None:
            pulumi.set(__self__, "blob_path_ends_with", blob_path_ends_with)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_empty_blobs is not None:
            pulumi.set(__self__, "ignore_empty_blobs", ignore_empty_blobs)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)

    @property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'BlobEventTypes']]]]:
        """
        The type of events that cause this trigger to fire.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'BlobEventTypes']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The ARM resource ID of the Storage Account.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'BlobEventsTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="blobPathBeginsWith")
    def blob_path_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        The blob path must begin with the pattern provided for trigger to fire. For example, '/records/blobs/december/' will only fire the trigger for blobs in the december folder under the records container. At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
        """
        return pulumi.get(self, "blob_path_begins_with")

    @blob_path_begins_with.setter
    def blob_path_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_path_begins_with", value)

    @property
    @pulumi.getter(name="blobPathEndsWith")
    def blob_path_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        The blob path must end with the pattern provided for trigger to fire. For example, 'december/boxes.csv' will only fire the trigger for blobs named boxes in a december folder. At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
        """
        return pulumi.get(self, "blob_path_ends_with")

    @blob_path_ends_with.setter
    def blob_path_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_path_ends_with", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ignoreEmptyBlobs")
    def ignore_empty_blobs(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, blobs with zero bytes will be ignored.
        """
        return pulumi.get(self, "ignore_empty_blobs")

    @ignore_empty_blobs.setter
    def ignore_empty_blobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_empty_blobs", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]):
        pulumi.set(self, "pipelines", value)


@pulumi.input_type
class BlobSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 blob_writer_add_header: Optional[Any] = None,
                 blob_writer_date_time_format: Optional[Any] = None,
                 blob_writer_overwrite_files: Optional[Any] = None,
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 metadata: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Azure Blob sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'BlobSink'.
        :param Any blob_writer_add_header: Blob writer add header. Type: boolean (or Expression with resultType boolean).
        :param Any blob_writer_date_time_format: Blob writer date time format. Type: string (or Expression with resultType string).
        :param Any blob_writer_overwrite_files: Blob writer overwrite files. Type: boolean (or Expression with resultType boolean).
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]] metadata: Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'BlobSink')
        if blob_writer_add_header is not None:
            pulumi.set(__self__, "blob_writer_add_header", blob_writer_add_header)
        if blob_writer_date_time_format is not None:
            pulumi.set(__self__, "blob_writer_date_time_format", blob_writer_date_time_format)
        if blob_writer_overwrite_files is not None:
            pulumi.set(__self__, "blob_writer_overwrite_files", blob_writer_overwrite_files)
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'BlobSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="blobWriterAddHeader")
    def blob_writer_add_header(self) -> Optional[Any]:
        """
        Blob writer add header. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "blob_writer_add_header")

    @blob_writer_add_header.setter
    def blob_writer_add_header(self, value: Optional[Any]):
        pulumi.set(self, "blob_writer_add_header", value)

    @property
    @pulumi.getter(name="blobWriterDateTimeFormat")
    def blob_writer_date_time_format(self) -> Optional[Any]:
        """
        Blob writer date time format. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "blob_writer_date_time_format")

    @blob_writer_date_time_format.setter
    def blob_writer_date_time_format(self, value: Optional[Any]):
        pulumi.set(self, "blob_writer_date_time_format", value)

    @property
    @pulumi.getter(name="blobWriterOverwriteFiles")
    def blob_writer_overwrite_files(self) -> Optional[Any]:
        """
        Blob writer overwrite files. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "blob_writer_overwrite_files")

    @blob_writer_overwrite_files.setter
    def blob_writer_overwrite_files(self, value: Optional[Any]):
        pulumi.set(self, "blob_writer_overwrite_files", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]]:
        """
        Specify the custom metadata to be added to sink data. Type: array of objects (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataItemArgs']]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class BlobSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 skip_header_line_count: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 treat_empty_as_null: Optional[Any] = None):
        """
        A copy activity Azure Blob source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'BlobSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any skip_header_line_count: Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any treat_empty_as_null: Treat empty as null. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'BlobSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if skip_header_line_count is not None:
            pulumi.set(__self__, "skip_header_line_count", skip_header_line_count)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if treat_empty_as_null is not None:
            pulumi.set(__self__, "treat_empty_as_null", treat_empty_as_null)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'BlobSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="skipHeaderLineCount")
    def skip_header_line_count(self) -> Optional[Any]:
        """
        Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip_header_line_count")

    @skip_header_line_count.setter
    def skip_header_line_count(self, value: Optional[Any]):
        pulumi.set(self, "skip_header_line_count", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="treatEmptyAsNull")
    def treat_empty_as_null(self) -> Optional[Any]:
        """
        Treat empty as null. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "treat_empty_as_null")

    @treat_empty_as_null.setter
    def treat_empty_as_null(self, value: Optional[Any]):
        pulumi.set(self, "treat_empty_as_null", value)


@pulumi.input_type
class BlobTriggerArgs:
    def __init__(__self__, *,
                 folder_path: pulumi.Input[str],
                 linked_service: pulumi.Input['LinkedServiceReferenceArgs'],
                 max_concurrency: pulumi.Input[int],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]] = None):
        """
        Trigger that runs every time the selected Blob container changes.
        :param pulumi.Input[str] folder_path: The path of the container/folder that will trigger the pipeline.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: The Azure Storage linked service reference.
        :param pulumi.Input[int] max_concurrency: The max number of parallel files to handle when it is triggered.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'BlobTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]] pipelines: Pipelines that need to be started.
        """
        pulumi.set(__self__, "folder_path", folder_path)
        pulumi.set(__self__, "linked_service", linked_service)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "type", 'BlobTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> pulumi.Input[str]:
        """
        The path of the container/folder that will trigger the pipeline.
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        The Azure Storage linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> pulumi.Input[int]:
        """
        The max number of parallel files to handle when it is triggered.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_concurrency", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'BlobTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]):
        pulumi.set(self, "pipelines", value)


@pulumi.input_type
class CMKIdentityDefinitionArgs:
    def __init__(__self__, *,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        Managed Identity used for CMK.
        :param pulumi.Input[str] user_assigned_identity: The resource id of the user assigned identity to authenticate to customer's key vault.
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of the user assigned identity to authenticate to customer's key vault.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


@pulumi.input_type
class CassandraLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Cassandra data source.
        :param Any host: Host name for connection. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Cassandra'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for authentication.
        :param Any port: The port for the connection. Type: integer (or Expression with resultType integer).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Cassandra')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Cassandra'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port for the connection. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class CassandraSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 consistency_level: Optional[pulumi.Input[Union[str, 'CassandraSourceReadConsistencyLevels']]] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for a Cassandra database.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'CassandraSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param pulumi.Input[Union[str, 'CassandraSourceReadConsistencyLevels']] consistency_level: The consistency level specifies how many Cassandra servers must respond to a read request before returning data to the client application. Cassandra checks the specified number of Cassandra servers for data to satisfy the read request. Must be one of cassandraSourceReadConsistencyLevels. The default value is 'ONE'. It is case-insensitive.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Should be a SQL-92 query expression or Cassandra Query Language (CQL) command. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CassandraSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if consistency_level is not None:
            pulumi.set(__self__, "consistency_level", consistency_level)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'CassandraSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="consistencyLevel")
    def consistency_level(self) -> Optional[pulumi.Input[Union[str, 'CassandraSourceReadConsistencyLevels']]]:
        """
        The consistency level specifies how many Cassandra servers must respond to a read request before returning data to the client application. Cassandra checks the specified number of Cassandra servers for data to satisfy the read request. Must be one of cassandraSourceReadConsistencyLevels. The default value is 'ONE'. It is case-insensitive.
        """
        return pulumi.get(self, "consistency_level")

    @consistency_level.setter
    def consistency_level(self, value: Optional[pulumi.Input[Union[str, 'CassandraSourceReadConsistencyLevels']]]):
        pulumi.set(self, "consistency_level", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Should be a SQL-92 query expression or Cassandra Query Language (CQL) command. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class CassandraTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 keyspace: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Cassandra database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CassandraTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any keyspace: The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name of the Cassandra database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CassandraTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if keyspace is not None:
            pulumi.set(__self__, "keyspace", keyspace)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CassandraTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def keyspace(self) -> Optional[Any]:
        """
        The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "keyspace")

    @keyspace.setter
    def keyspace(self, value: Optional[Any]):
        pulumi.set(self, "keyspace", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name of the Cassandra database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ChainingTriggerArgs:
    def __init__(__self__, *,
                 depends_on: pulumi.Input[Sequence[pulumi.Input['PipelineReferenceArgs']]],
                 pipeline: pulumi.Input['TriggerPipelineReferenceArgs'],
                 run_dimension: pulumi.Input[str],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value pairs. Upstream pipelines should declare the same runDimension Name and their runs should have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension match for all upstream pipeline runs.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineReferenceArgs']]] depends_on: Upstream Pipelines.
        :param pulumi.Input['TriggerPipelineReferenceArgs'] pipeline: Pipeline for which runs are created when all upstream pipelines complete successfully.
        :param pulumi.Input[str] run_dimension: Run Dimension property that needs to be emitted by upstream pipelines.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'ChainingTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        """
        pulumi.set(__self__, "depends_on", depends_on)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "run_dimension", run_dimension)
        pulumi.set(__self__, "type", 'ChainingTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineReferenceArgs']]]:
        """
        Upstream Pipelines.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineReferenceArgs']]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def pipeline(self) -> pulumi.Input['TriggerPipelineReferenceArgs']:
        """
        Pipeline for which runs are created when all upstream pipelines complete successfully.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: pulumi.Input['TriggerPipelineReferenceArgs']):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter(name="runDimension")
    def run_dimension(self) -> pulumi.Input[str]:
        """
        Run Dimension property that needs to be emitted by upstream pipelines.
        """
        return pulumi.get(self, "run_dimension")

    @run_dimension.setter
    def run_dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "run_dimension", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'ChainingTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class CmdkeySetupArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 target_name: Any,
                 type: pulumi.Input[str],
                 user_name: Any):
        """
        The custom setup of running cmdkey commands.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password of data source access.
        :param Any target_name: The server name of data source access.
        :param pulumi.Input[str] type: The type of custom setup.
               Expected value is 'CmdkeySetup'.
        :param Any user_name: The user name of data source access.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "type", 'CmdkeySetup')
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The password of data source access.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> Any:
        """
        The server name of data source access.
        """
        return pulumi.get(self, "target_name")

    @target_name.setter
    def target_name(self, value: Any):
        pulumi.set(self, "target_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of custom setup.
        Expected value is 'CmdkeySetup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Any:
        """
        The user name of data source access.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Any):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class CommonDataServiceForAppsEntityDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Common Data Service for Apps entity dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CommonDataServiceForAppsEntity'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CommonDataServiceForAppsEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CommonDataServiceForAppsEntity'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @entity_name.setter
    def entity_name(self, value: Optional[Any]):
        pulumi.set(self, "entity_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class CommonDataServiceForAppsLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: Any,
                 deployment_type: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_credential_type: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Common Data Service for Apps linked service.
        :param Any authentication_type: The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param Any deployment_type: The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'CommonDataServiceForApps'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for online when there are more than one Common Data Service for Apps instances associated with the user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the Common Data Service for Apps instance.
        :param Any port: The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param Any service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'CommonDataServiceForApps')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Any:
        """
        The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Any):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Any:
        """
        The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: Any):
        pulumi.set(self, "deployment_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'CommonDataServiceForApps'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[Any]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for online when there are more than one Common Data Service for Apps instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[Any]):
        pulumi.set(self, "organization_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the Common Data Service for Apps instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @service_principal_credential.setter
    def service_principal_credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_credential", value)

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[Any]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @service_principal_credential_type.setter
    def service_principal_credential_type(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_credential_type", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[Any]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class CommonDataServiceForAppsSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 write_behavior: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']],
                 alternate_key_name: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 ignore_null_values: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Common Data Service for Apps sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'CommonDataServiceForAppsSink'.
        :param pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']] write_behavior: The write behavior for the operation.
        :param Any alternate_key_name: The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any ignore_null_values: The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CommonDataServiceForAppsSink')
        pulumi.set(__self__, "write_behavior", write_behavior)
        if alternate_key_name is not None:
            pulumi.set(__self__, "alternate_key_name", alternate_key_name)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if ignore_null_values is not None:
            pulumi.set(__self__, "ignore_null_values", ignore_null_values)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'CommonDataServiceForAppsSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]:
        """
        The write behavior for the operation.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]):
        pulumi.set(self, "write_behavior", value)

    @property
    @pulumi.getter(name="alternateKeyName")
    def alternate_key_name(self) -> Optional[Any]:
        """
        The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "alternate_key_name")

    @alternate_key_name.setter
    def alternate_key_name(self, value: Optional[Any]):
        pulumi.set(self, "alternate_key_name", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="ignoreNullValues")
    def ignore_null_values(self) -> Optional[Any]:
        """
        The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "ignore_null_values")

    @ignore_null_values.setter
    def ignore_null_values(self, value: Optional[Any]):
        pulumi.set(self, "ignore_null_values", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class CommonDataServiceForAppsSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Common Data Service for Apps source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'CommonDataServiceForAppsSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: FetchXML is a proprietary query language that is used in Microsoft Common Data Service for Apps (online & on-premises). Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CommonDataServiceForAppsSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'CommonDataServiceForAppsSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        FetchXML is a proprietary query language that is used in Microsoft Common Data Service for Apps (online & on-premises). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class ComponentSetupArgs:
    def __init__(__self__, *,
                 component_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 license_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None):
        """
        The custom setup of installing 3rd party components.
        :param pulumi.Input[str] component_name: The name of the 3rd party component.
        :param pulumi.Input[str] type: The type of custom setup.
               Expected value is 'ComponentSetup'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] license_key: The license key to activate the component.
        """
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "type", 'ComponentSetup')
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)

    @property
    @pulumi.getter(name="componentName")
    def component_name(self) -> pulumi.Input[str]:
        """
        The name of the 3rd party component.
        """
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "component_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of custom setup.
        Expected value is 'ComponentSetup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The license key to activate the component.
        """
        return pulumi.get(self, "license_key")

    @license_key.setter
    def license_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "license_key", value)


@pulumi.input_type
class ConcurLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 type: pulumi.Input[str],
                 username: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Concur Service linked service.
        :param Any client_id: Application client_id supplied by Concur App Management.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Concur'.
        :param Any username: The user name that you use to access Concur Service.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Concur. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name that you provided in the username field.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "type", 'Concur')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        Application client_id supplied by Concur App Management.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Concur'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Concur Service.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Any):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Concur. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name that you provided in the username field.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class ConcurObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Concur Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ConcurObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ConcurObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ConcurObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ConcurSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Concur Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ConcurSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ConcurSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ConcurSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class ControlActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Base class for all control activities like IfCondition, ForEach , Until.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Container'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Container')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Container'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class CopyActivityLogSettingsArgs:
    def __init__(__self__, *,
                 enable_reliable_logging: Optional[Any] = None,
                 log_level: Optional[Any] = None):
        """
        Settings for copy activity log.
        :param Any enable_reliable_logging: Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
        :param Any log_level: Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
        """
        if enable_reliable_logging is not None:
            pulumi.set(__self__, "enable_reliable_logging", enable_reliable_logging)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="enableReliableLogging")
    def enable_reliable_logging(self) -> Optional[Any]:
        """
        Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_reliable_logging")

    @enable_reliable_logging.setter
    def enable_reliable_logging(self, value: Optional[Any]):
        pulumi.set(self, "enable_reliable_logging", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[Any]:
        """
        Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[Any]):
        pulumi.set(self, "log_level", value)


@pulumi.input_type
class CopyActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sink: pulumi.Input[Union['AvroSinkArgs', 'AzureBlobFSSinkArgs', 'AzureDataExplorerSinkArgs', 'AzureDataLakeStoreSinkArgs', 'AzureDatabricksDeltaLakeSinkArgs', 'AzureMySqlSinkArgs', 'AzurePostgreSqlSinkArgs', 'AzureQueueSinkArgs', 'AzureSearchIndexSinkArgs', 'AzureSqlSinkArgs', 'AzureTableSinkArgs', 'BinarySinkArgs', 'BlobSinkArgs', 'CommonDataServiceForAppsSinkArgs', 'CosmosDbMongoDbApiSinkArgs', 'CosmosDbSqlApiSinkArgs', 'DelimitedTextSinkArgs', 'DocumentDbCollectionSinkArgs', 'DynamicsCrmSinkArgs', 'DynamicsSinkArgs', 'FileSystemSinkArgs', 'InformixSinkArgs', 'JsonSinkArgs', 'MicrosoftAccessSinkArgs', 'MongoDbAtlasSinkArgs', 'MongoDbV2SinkArgs', 'OdbcSinkArgs', 'OracleSinkArgs', 'OrcSinkArgs', 'ParquetSinkArgs', 'RestSinkArgs', 'SalesforceServiceCloudSinkArgs', 'SalesforceSinkArgs', 'SapCloudForCustomerSinkArgs', 'SnowflakeSinkArgs', 'SqlDWSinkArgs', 'SqlMISinkArgs', 'SqlServerSinkArgs', 'SqlSinkArgs']],
                 source: pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']],
                 type: pulumi.Input[str],
                 data_integration_units: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_skip_incompatible_row: Optional[Any] = None,
                 enable_staging: Optional[Any] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 log_settings: Optional[pulumi.Input['LogSettingsArgs']] = None,
                 log_storage_settings: Optional[pulumi.Input['LogStorageSettingsArgs']] = None,
                 outputs: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]] = None,
                 parallel_copies: Optional[Any] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 preserve: Optional[pulumi.Input[Sequence[Any]]] = None,
                 preserve_rules: Optional[pulumi.Input[Sequence[Any]]] = None,
                 redirect_incompatible_row_settings: Optional[pulumi.Input['RedirectIncompatibleRowSettingsArgs']] = None,
                 skip_error_file: Optional[pulumi.Input['SkipErrorFileArgs']] = None,
                 staging_settings: Optional[pulumi.Input['StagingSettingsArgs']] = None,
                 translator: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 validate_data_consistency: Optional[Any] = None):
        """
        Copy activity.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[Union['AvroSinkArgs', 'AzureBlobFSSinkArgs', 'AzureDataExplorerSinkArgs', 'AzureDataLakeStoreSinkArgs', 'AzureDatabricksDeltaLakeSinkArgs', 'AzureMySqlSinkArgs', 'AzurePostgreSqlSinkArgs', 'AzureQueueSinkArgs', 'AzureSearchIndexSinkArgs', 'AzureSqlSinkArgs', 'AzureTableSinkArgs', 'BinarySinkArgs', 'BlobSinkArgs', 'CommonDataServiceForAppsSinkArgs', 'CosmosDbMongoDbApiSinkArgs', 'CosmosDbSqlApiSinkArgs', 'DelimitedTextSinkArgs', 'DocumentDbCollectionSinkArgs', 'DynamicsCrmSinkArgs', 'DynamicsSinkArgs', 'FileSystemSinkArgs', 'InformixSinkArgs', 'JsonSinkArgs', 'MicrosoftAccessSinkArgs', 'MongoDbAtlasSinkArgs', 'MongoDbV2SinkArgs', 'OdbcSinkArgs', 'OracleSinkArgs', 'OrcSinkArgs', 'ParquetSinkArgs', 'RestSinkArgs', 'SalesforceServiceCloudSinkArgs', 'SalesforceSinkArgs', 'SapCloudForCustomerSinkArgs', 'SnowflakeSinkArgs', 'SqlDWSinkArgs', 'SqlMISinkArgs', 'SqlServerSinkArgs', 'SqlSinkArgs']] sink: Copy activity sink.
        :param pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']] source: Copy activity source.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Copy'.
        :param Any data_integration_units: Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any enable_skip_incompatible_row: Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any enable_staging: Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]] inputs: List of inputs for the activity.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['LogSettingsArgs'] log_settings: Log settings customer needs provide when enabling log.
        :param pulumi.Input['LogStorageSettingsArgs'] log_storage_settings: (Deprecated. Please use LogSettings) Log storage settings customer need to provide when enabling session log.
        :param pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]] outputs: List of outputs for the activity.
        :param Any parallel_copies: Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[Any]] preserve: Preserve rules.
        :param pulumi.Input[Sequence[Any]] preserve_rules: Preserve Rules.
        :param pulumi.Input['RedirectIncompatibleRowSettingsArgs'] redirect_incompatible_row_settings: Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
        :param pulumi.Input['SkipErrorFileArgs'] skip_error_file: Specify the fault tolerance for data consistency.
        :param pulumi.Input['StagingSettingsArgs'] staging_settings: Specifies interim staging settings when EnableStaging is true.
        :param Any translator: Copy activity translator. If not specified, tabular translator is used.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param Any validate_data_consistency: Whether to enable Data Consistency validation. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sink", sink)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", 'Copy')
        if data_integration_units is not None:
            pulumi.set(__self__, "data_integration_units", data_integration_units)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_skip_incompatible_row is not None:
            pulumi.set(__self__, "enable_skip_incompatible_row", enable_skip_incompatible_row)
        if enable_staging is not None:
            pulumi.set(__self__, "enable_staging", enable_staging)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if log_settings is not None:
            pulumi.set(__self__, "log_settings", log_settings)
        if log_storage_settings is not None:
            pulumi.set(__self__, "log_storage_settings", log_storage_settings)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if parallel_copies is not None:
            pulumi.set(__self__, "parallel_copies", parallel_copies)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if preserve is not None:
            pulumi.set(__self__, "preserve", preserve)
        if preserve_rules is not None:
            pulumi.set(__self__, "preserve_rules", preserve_rules)
        if redirect_incompatible_row_settings is not None:
            pulumi.set(__self__, "redirect_incompatible_row_settings", redirect_incompatible_row_settings)
        if skip_error_file is not None:
            pulumi.set(__self__, "skip_error_file", skip_error_file)
        if staging_settings is not None:
            pulumi.set(__self__, "staging_settings", staging_settings)
        if translator is not None:
            pulumi.set(__self__, "translator", translator)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if validate_data_consistency is not None:
            pulumi.set(__self__, "validate_data_consistency", validate_data_consistency)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def sink(self) -> pulumi.Input[Union['AvroSinkArgs', 'AzureBlobFSSinkArgs', 'AzureDataExplorerSinkArgs', 'AzureDataLakeStoreSinkArgs', 'AzureDatabricksDeltaLakeSinkArgs', 'AzureMySqlSinkArgs', 'AzurePostgreSqlSinkArgs', 'AzureQueueSinkArgs', 'AzureSearchIndexSinkArgs', 'AzureSqlSinkArgs', 'AzureTableSinkArgs', 'BinarySinkArgs', 'BlobSinkArgs', 'CommonDataServiceForAppsSinkArgs', 'CosmosDbMongoDbApiSinkArgs', 'CosmosDbSqlApiSinkArgs', 'DelimitedTextSinkArgs', 'DocumentDbCollectionSinkArgs', 'DynamicsCrmSinkArgs', 'DynamicsSinkArgs', 'FileSystemSinkArgs', 'InformixSinkArgs', 'JsonSinkArgs', 'MicrosoftAccessSinkArgs', 'MongoDbAtlasSinkArgs', 'MongoDbV2SinkArgs', 'OdbcSinkArgs', 'OracleSinkArgs', 'OrcSinkArgs', 'ParquetSinkArgs', 'RestSinkArgs', 'SalesforceServiceCloudSinkArgs', 'SalesforceSinkArgs', 'SapCloudForCustomerSinkArgs', 'SnowflakeSinkArgs', 'SqlDWSinkArgs', 'SqlMISinkArgs', 'SqlServerSinkArgs', 'SqlSinkArgs']]:
        """
        Copy activity sink.
        """
        return pulumi.get(self, "sink")

    @sink.setter
    def sink(self, value: pulumi.Input[Union['AvroSinkArgs', 'AzureBlobFSSinkArgs', 'AzureDataExplorerSinkArgs', 'AzureDataLakeStoreSinkArgs', 'AzureDatabricksDeltaLakeSinkArgs', 'AzureMySqlSinkArgs', 'AzurePostgreSqlSinkArgs', 'AzureQueueSinkArgs', 'AzureSearchIndexSinkArgs', 'AzureSqlSinkArgs', 'AzureTableSinkArgs', 'BinarySinkArgs', 'BlobSinkArgs', 'CommonDataServiceForAppsSinkArgs', 'CosmosDbMongoDbApiSinkArgs', 'CosmosDbSqlApiSinkArgs', 'DelimitedTextSinkArgs', 'DocumentDbCollectionSinkArgs', 'DynamicsCrmSinkArgs', 'DynamicsSinkArgs', 'FileSystemSinkArgs', 'InformixSinkArgs', 'JsonSinkArgs', 'MicrosoftAccessSinkArgs', 'MongoDbAtlasSinkArgs', 'MongoDbV2SinkArgs', 'OdbcSinkArgs', 'OracleSinkArgs', 'OrcSinkArgs', 'ParquetSinkArgs', 'RestSinkArgs', 'SalesforceServiceCloudSinkArgs', 'SalesforceSinkArgs', 'SapCloudForCustomerSinkArgs', 'SnowflakeSinkArgs', 'SqlDWSinkArgs', 'SqlMISinkArgs', 'SqlServerSinkArgs', 'SqlSinkArgs']]):
        pulumi.set(self, "sink", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']]:
        """
        Copy activity source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Copy'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dataIntegrationUnits")
    def data_integration_units(self) -> Optional[Any]:
        """
        Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "data_integration_units")

    @data_integration_units.setter
    def data_integration_units(self, value: Optional[Any]):
        pulumi.set(self, "data_integration_units", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSkipIncompatibleRow")
    def enable_skip_incompatible_row(self) -> Optional[Any]:
        """
        Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_skip_incompatible_row")

    @enable_skip_incompatible_row.setter
    def enable_skip_incompatible_row(self, value: Optional[Any]):
        pulumi.set(self, "enable_skip_incompatible_row", value)

    @property
    @pulumi.getter(name="enableStaging")
    def enable_staging(self) -> Optional[Any]:
        """
        Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_staging")

    @enable_staging.setter
    def enable_staging(self, value: Optional[Any]):
        pulumi.set(self, "enable_staging", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]:
        """
        List of inputs for the activity.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="logSettings")
    def log_settings(self) -> Optional[pulumi.Input['LogSettingsArgs']]:
        """
        Log settings customer needs provide when enabling log.
        """
        return pulumi.get(self, "log_settings")

    @log_settings.setter
    def log_settings(self, value: Optional[pulumi.Input['LogSettingsArgs']]):
        pulumi.set(self, "log_settings", value)

    @property
    @pulumi.getter(name="logStorageSettings")
    def log_storage_settings(self) -> Optional[pulumi.Input['LogStorageSettingsArgs']]:
        """
        (Deprecated. Please use LogSettings) Log storage settings customer need to provide when enabling session log.
        """
        return pulumi.get(self, "log_storage_settings")

    @log_storage_settings.setter
    def log_storage_settings(self, value: Optional[pulumi.Input['LogStorageSettingsArgs']]):
        pulumi.set(self, "log_storage_settings", value)

    @property
    @pulumi.getter
    def outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]:
        """
        List of outputs for the activity.
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]):
        pulumi.set(self, "outputs", value)

    @property
    @pulumi.getter(name="parallelCopies")
    def parallel_copies(self) -> Optional[Any]:
        """
        Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "parallel_copies")

    @parallel_copies.setter
    def parallel_copies(self, value: Optional[Any]):
        pulumi.set(self, "parallel_copies", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def preserve(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Preserve rules.
        """
        return pulumi.get(self, "preserve")

    @preserve.setter
    def preserve(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "preserve", value)

    @property
    @pulumi.getter(name="preserveRules")
    def preserve_rules(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Preserve Rules.
        """
        return pulumi.get(self, "preserve_rules")

    @preserve_rules.setter
    def preserve_rules(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "preserve_rules", value)

    @property
    @pulumi.getter(name="redirectIncompatibleRowSettings")
    def redirect_incompatible_row_settings(self) -> Optional[pulumi.Input['RedirectIncompatibleRowSettingsArgs']]:
        """
        Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
        """
        return pulumi.get(self, "redirect_incompatible_row_settings")

    @redirect_incompatible_row_settings.setter
    def redirect_incompatible_row_settings(self, value: Optional[pulumi.Input['RedirectIncompatibleRowSettingsArgs']]):
        pulumi.set(self, "redirect_incompatible_row_settings", value)

    @property
    @pulumi.getter(name="skipErrorFile")
    def skip_error_file(self) -> Optional[pulumi.Input['SkipErrorFileArgs']]:
        """
        Specify the fault tolerance for data consistency.
        """
        return pulumi.get(self, "skip_error_file")

    @skip_error_file.setter
    def skip_error_file(self, value: Optional[pulumi.Input['SkipErrorFileArgs']]):
        pulumi.set(self, "skip_error_file", value)

    @property
    @pulumi.getter(name="stagingSettings")
    def staging_settings(self) -> Optional[pulumi.Input['StagingSettingsArgs']]:
        """
        Specifies interim staging settings when EnableStaging is true.
        """
        return pulumi.get(self, "staging_settings")

    @staging_settings.setter
    def staging_settings(self, value: Optional[pulumi.Input['StagingSettingsArgs']]):
        pulumi.set(self, "staging_settings", value)

    @property
    @pulumi.getter
    def translator(self) -> Optional[Any]:
        """
        Copy activity translator. If not specified, tabular translator is used.
        """
        return pulumi.get(self, "translator")

    @translator.setter
    def translator(self, value: Optional[Any]):
        pulumi.set(self, "translator", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter(name="validateDataConsistency")
    def validate_data_consistency(self) -> Optional[Any]:
        """
        Whether to enable Data Consistency validation. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "validate_data_consistency")

    @validate_data_consistency.setter
    def validate_data_consistency(self, value: Optional[Any]):
        pulumi.set(self, "validate_data_consistency", value)


@pulumi.input_type
class CosmosDbLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 account_endpoint: Optional[Any] = None,
                 account_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_mode: Optional[pulumi.Input[Union[str, 'CosmosDbConnectionMode']]] = None,
                 connection_string: Optional[Any] = None,
                 database: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 service_principal_credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_credential_type: Optional[pulumi.Input[Union[str, 'CosmosDbServicePrincipalCredentialType']]] = None,
                 service_principal_id: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Microsoft Azure Cosmos Database (CosmosDB) linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'CosmosDb'.
        :param Any account_endpoint: The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] account_key: The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[Union[str, 'CosmosDbConnectionMode']] connection_mode: The connection mode used to access CosmosDB account. Type: string (or Expression with resultType string).
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the database. Type: string (or Expression with resultType string)
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param pulumi.Input[Union[str, 'CosmosDbServicePrincipalCredentialType']] service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'CosmosDb')
        if account_endpoint is not None:
            pulumi.set(__self__, "account_endpoint", account_endpoint)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_mode is not None:
            pulumi.set(__self__, "connection_mode", connection_mode)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'CosmosDb'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accountEndpoint")
    def account_endpoint(self) -> Optional[Any]:
        """
        The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "account_endpoint")

    @account_endpoint.setter
    def account_endpoint(self, value: Optional[Any]):
        pulumi.set(self, "account_endpoint", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionMode")
    def connection_mode(self) -> Optional[pulumi.Input[Union[str, 'CosmosDbConnectionMode']]]:
        """
        The connection mode used to access CosmosDB account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "connection_mode")

    @connection_mode.setter
    def connection_mode(self, value: Optional[pulumi.Input[Union[str, 'CosmosDbConnectionMode']]]):
        pulumi.set(self, "connection_mode", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The name of the database. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[Any]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @service_principal_credential.setter
    def service_principal_credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_credential", value)

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[pulumi.Input[Union[str, 'CosmosDbServicePrincipalCredentialType']]]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @service_principal_credential_type.setter
    def service_principal_credential_type(self, value: Optional[pulumi.Input[Union[str, 'CosmosDbServicePrincipalCredentialType']]]):
        pulumi.set(self, "service_principal_credential_type", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)


@pulumi.input_type
class CosmosDbMongoDbApiCollectionDatasetArgs:
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The CosmosDB (MongoDB API) database dataset.
        :param Any collection: The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CosmosDbMongoDbApiCollection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApiCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Any):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CosmosDbMongoDbApiCollection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class CosmosDbMongoDbApiLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 is_server_version_above32: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Linked service for CosmosDB (MongoDB API) data source.
        :param Any connection_string: The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'CosmosDbMongoDbApi'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any is_server_version_above32: Whether the CosmosDB (MongoDB API) server version is higher than 3.2. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApi')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_server_version_above32 is not None:
            pulumi.set(__self__, "is_server_version_above32", is_server_version_above32)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'CosmosDbMongoDbApi'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isServerVersionAbove32")
    def is_server_version_above32(self) -> Optional[Any]:
        """
        Whether the CosmosDB (MongoDB API) server version is higher than 3.2. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "is_server_version_above32")

    @is_server_version_above32.setter
    def is_server_version_above32(self, value: Optional[Any]):
        pulumi.set(self, "is_server_version_above32", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class CosmosDbMongoDbApiSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity sink for a CosmosDB (MongoDB API) database.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'CosmosDbMongoDbApiSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApiSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'CosmosDbMongoDbApiSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class CosmosDbMongoDbApiSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 batch_size: Optional[Any] = None,
                 cursor_methods: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 filter: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for a CosmosDB (MongoDB API) database.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'CosmosDbMongoDbApiSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any batch_size: Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        :param pulumi.Input['MongoDbCursorMethodsPropertiesArgs'] cursor_methods: Cursor methods for Mongodb query.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any filter: Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApiSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if cursor_methods is not None:
            pulumi.set(__self__, "cursor_methods", cursor_methods)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'CosmosDbMongoDbApiSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[Any]:
        """
        Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[Any]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="cursorMethods")
    def cursor_methods(self) -> Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]:
        """
        Cursor methods for Mongodb query.
        """
        return pulumi.get(self, "cursor_methods")

    @cursor_methods.setter
    def cursor_methods(self, value: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]):
        pulumi.set(self, "cursor_methods", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[Any]:
        """
        Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[Any]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class CosmosDbSqlApiCollectionDatasetArgs:
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Microsoft Azure CosmosDB (SQL API) Collection dataset.
        :param Any collection_name: CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CosmosDbSqlApiCollection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CosmosDbSqlApiCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Any):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CosmosDbSqlApiCollection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class CosmosDbSqlApiSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity Azure CosmosDB (SQL API) Collection sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'CosmosDbSqlApiSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
        """
        pulumi.set(__self__, "type", 'CosmosDbSqlApiSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'CosmosDbSqlApiSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class CosmosDbSqlApiSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 detect_datetime: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 page_size: Optional[Any] = None,
                 preferred_regions: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Azure CosmosDB (SQL API) Collection source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'CosmosDbSqlApiSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any detect_datetime: Whether detect primitive values as datetime values. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any page_size: Page size of the result. Type: integer (or Expression with resultType integer).
        :param Any preferred_regions: Preferred regions. Type: array of strings (or Expression with resultType array of strings).
        :param Any query: SQL API query. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CosmosDbSqlApiSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if detect_datetime is not None:
            pulumi.set(__self__, "detect_datetime", detect_datetime)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if preferred_regions is not None:
            pulumi.set(__self__, "preferred_regions", preferred_regions)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'CosmosDbSqlApiSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="detectDatetime")
    def detect_datetime(self) -> Optional[Any]:
        """
        Whether detect primitive values as datetime values. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "detect_datetime")

    @detect_datetime.setter
    def detect_datetime(self, value: Optional[Any]):
        pulumi.set(self, "detect_datetime", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[Any]:
        """
        Page size of the result. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[Any]):
        pulumi.set(self, "page_size", value)

    @property
    @pulumi.getter(name="preferredRegions")
    def preferred_regions(self) -> Optional[Any]:
        """
        Preferred regions. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "preferred_regions")

    @preferred_regions.setter
    def preferred_regions(self, value: Optional[Any]):
        pulumi.set(self, "preferred_regions", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        SQL API query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class CouchbaseLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 cred_string: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Couchbase server linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Couchbase'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] cred_string: The Azure key vault secret reference of credString in connection string.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'Couchbase')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if cred_string is not None:
            pulumi.set(__self__, "cred_string", cred_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Couchbase'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="credString")
    def cred_string(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of credString in connection string.
        """
        return pulumi.get(self, "cred_string")

    @cred_string.setter
    def cred_string(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "cred_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class CouchbaseSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Couchbase server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'CouchbaseSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'CouchbaseSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'CouchbaseSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class CouchbaseTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Couchbase server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CouchbaseTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CouchbaseTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CouchbaseTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class CredentialReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Credential reference type.
        :param pulumi.Input[str] reference_name: Reference credential name.
        :param pulumi.Input[str] type: Credential reference type.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference credential name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Credential reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CustomActivityReferenceObjectArgs:
    def __init__(__self__, *,
                 datasets: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]] = None,
                 linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None):
        """
        Reference objects for custom activity
        :param pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]] datasets: Dataset references.
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] linked_services: Linked service references.
        """
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if linked_services is not None:
            pulumi.set(__self__, "linked_services", linked_services)

    @property
    @pulumi.getter
    def datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]:
        """
        Dataset references.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]):
        pulumi.set(self, "datasets", value)

    @property
    @pulumi.getter(name="linkedServices")
    def linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Linked service references.
        """
        return pulumi.get(self, "linked_services")

    @linked_services.setter
    def linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "linked_services", value)


@pulumi.input_type
class CustomActivityArgs:
    def __init__(__self__, *,
                 command: Any,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 auto_user_specification: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 extended_properties: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 folder_path: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 reference_objects: Optional[pulumi.Input['CustomActivityReferenceObjectArgs']] = None,
                 resource_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 retention_time_in_days: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Custom activity type.
        :param Any command: Command for custom activity Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Custom'.
        :param Any auto_user_specification: Elevation level and scope for the user, default is nonadmin task. Type: string (or Expression with resultType double).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Mapping[str, Any]] extended_properties: User defined property bag. There is no restriction on the keys or values that can be used. The user specified custom activity has the full responsibility to consume and interpret the content defined.
        :param Any folder_path: Folder path for resource files Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input['CustomActivityReferenceObjectArgs'] reference_objects: Reference objects
        :param pulumi.Input['LinkedServiceReferenceArgs'] resource_linked_service: Resource linked service reference.
        :param Any retention_time_in_days: The retention time for the files submitted for custom activity. Type: double (or Expression with resultType double).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Custom')
        if auto_user_specification is not None:
            pulumi.set(__self__, "auto_user_specification", auto_user_specification)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if extended_properties is not None:
            pulumi.set(__self__, "extended_properties", extended_properties)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if reference_objects is not None:
            pulumi.set(__self__, "reference_objects", reference_objects)
        if resource_linked_service is not None:
            pulumi.set(__self__, "resource_linked_service", resource_linked_service)
        if retention_time_in_days is not None:
            pulumi.set(__self__, "retention_time_in_days", retention_time_in_days)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def command(self) -> Any:
        """
        Command for custom activity Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Any):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="autoUserSpecification")
    def auto_user_specification(self) -> Optional[Any]:
        """
        Elevation level and scope for the user, default is nonadmin task. Type: string (or Expression with resultType double).
        """
        return pulumi.get(self, "auto_user_specification")

    @auto_user_specification.setter
    def auto_user_specification(self, value: Optional[Any]):
        pulumi.set(self, "auto_user_specification", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extendedProperties")
    def extended_properties(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        User defined property bag. There is no restriction on the keys or values that can be used. The user specified custom activity has the full responsibility to consume and interpret the content defined.
        """
        return pulumi.get(self, "extended_properties")

    @extended_properties.setter
    def extended_properties(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "extended_properties", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Folder path for resource files Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="referenceObjects")
    def reference_objects(self) -> Optional[pulumi.Input['CustomActivityReferenceObjectArgs']]:
        """
        Reference objects
        """
        return pulumi.get(self, "reference_objects")

    @reference_objects.setter
    def reference_objects(self, value: Optional[pulumi.Input['CustomActivityReferenceObjectArgs']]):
        pulumi.set(self, "reference_objects", value)

    @property
    @pulumi.getter(name="resourceLinkedService")
    def resource_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Resource linked service reference.
        """
        return pulumi.get(self, "resource_linked_service")

    @resource_linked_service.setter
    def resource_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "resource_linked_service", value)

    @property
    @pulumi.getter(name="retentionTimeInDays")
    def retention_time_in_days(self) -> Optional[Any]:
        """
        The retention time for the files submitted for custom activity. Type: double (or Expression with resultType double).
        """
        return pulumi.get(self, "retention_time_in_days")

    @retention_time_in_days.setter
    def retention_time_in_days(self, value: Optional[Any]):
        pulumi.set(self, "retention_time_in_days", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class CustomDataSourceLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Custom linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'CustomDataSource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'CustomDataSource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'CustomDataSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class CustomDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The custom dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'CustomDataset'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CustomDataset')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'CustomDataset'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class CustomEventsTriggerArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[Any]],
                 scope: pulumi.Input[str],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]] = None,
                 subject_begins_with: Optional[pulumi.Input[str]] = None,
                 subject_ends_with: Optional[pulumi.Input[str]] = None):
        """
        Trigger that runs every time a custom event is received.
        :param pulumi.Input[Sequence[Any]] events: The list of event types that cause this trigger to fire.
        :param pulumi.Input[str] scope: The ARM resource ID of the Azure Event Grid Topic.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'CustomEventsTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]] pipelines: Pipelines that need to be started.
        :param pulumi.Input[str] subject_begins_with: The event subject must begin with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith, subjectEndsWith.
        :param pulumi.Input[str] subject_ends_with: The event subject must end with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith, subjectEndsWith.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "type", 'CustomEventsTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)
        if subject_begins_with is not None:
            pulumi.set(__self__, "subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            pulumi.set(__self__, "subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[Any]]:
        """
        The list of event types that cause this trigger to fire.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[Any]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The ARM resource ID of the Azure Event Grid Topic.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'CustomEventsTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]):
        pulumi.set(self, "pipelines", value)

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        The event subject must begin with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith, subjectEndsWith.
        """
        return pulumi.get(self, "subject_begins_with")

    @subject_begins_with.setter
    def subject_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_begins_with", value)

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        The event subject must end with the pattern provided for trigger to fire. At least one of these must be provided: subjectBeginsWith, subjectEndsWith.
        """
        return pulumi.get(self, "subject_ends_with")

    @subject_ends_with.setter
    def subject_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_ends_with", value)


@pulumi.input_type
class DWCopyCommandDefaultValueArgs:
    def __init__(__self__, *,
                 column_name: Optional[Any] = None,
                 default_value: Optional[Any] = None):
        """
        Default value.
        :param Any column_name: Column name. Type: object (or Expression with resultType string).
        :param Any default_value: The default value of the column. Type: object (or Expression with resultType string).
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[Any]:
        """
        Column name. Type: object (or Expression with resultType string).
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[Any]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        The default value of the column. Type: object (or Expression with resultType string).
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[Any]):
        pulumi.set(self, "default_value", value)


@pulumi.input_type
class DWCopyCommandSettingsArgs:
    def __init__(__self__, *,
                 additional_options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 default_values: Optional[pulumi.Input[Sequence[pulumi.Input['DWCopyCommandDefaultValueArgs']]]] = None):
        """
        DW Copy Command settings.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_options: Additional options directly passed to SQL DW in Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalOptions": { "MAXERRORS": "1000", "DATEFORMAT": "'ymd'" }
        :param pulumi.Input[Sequence[pulumi.Input['DWCopyCommandDefaultValueArgs']]] default_values: Specifies the default values for each target column in SQL DW. The default values in the property overwrite the DEFAULT constraint set in the DB, and identity column cannot have a default value. Type: array of objects (or Expression with resultType array of objects).
        """
        if additional_options is not None:
            pulumi.set(__self__, "additional_options", additional_options)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)

    @property
    @pulumi.getter(name="additionalOptions")
    def additional_options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional options directly passed to SQL DW in Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalOptions": { "MAXERRORS": "1000", "DATEFORMAT": "'ymd'" }
        """
        return pulumi.get(self, "additional_options")

    @additional_options.setter
    def additional_options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_options", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DWCopyCommandDefaultValueArgs']]]]:
        """
        Specifies the default values for each target column in SQL DW. The default values in the property overwrite the DEFAULT constraint set in the DB, and identity column cannot have a default value. Type: array of objects (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DWCopyCommandDefaultValueArgs']]]]):
        pulumi.set(self, "default_values", value)


@pulumi.input_type
class DataFlowFolderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param pulumi.Input[str] name: The name of the folder that this data flow is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the folder that this data flow is in.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DataFlowReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 dataset_parameters: Optional[Any] = None):
        """
        Data flow reference type.
        :param pulumi.Input[str] reference_name: Reference data flow name.
        :param pulumi.Input[str] type: Data flow reference type.
        :param Any dataset_parameters: Reference data flow parameters from dataset.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference data flow name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Data flow reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[Any]:
        """
        Reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[Any]):
        pulumi.set(self, "dataset_parameters", value)


@pulumi.input_type
class DataFlowSinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DatasetReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowReferenceArgs']] = None,
                 linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None):
        """
        Transformation for data flow sink.
        :param pulumi.Input[str] name: Transformation name.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Dataset reference.
        :param pulumi.Input[str] description: Transformation description.
        :param pulumi.Input['DataFlowReferenceArgs'] flowlet: Flowlet Reference
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: Linked service reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] schema_linked_service: Schema linked service reference.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DatasetReferenceArgs']]:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DatasetReferenceArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowReferenceArgs']]:
        """
        Flowlet Reference
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowReferenceArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


@pulumi.input_type
class DataFlowSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DatasetReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowReferenceArgs']] = None,
                 linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None):
        """
        Transformation for data flow source.
        :param pulumi.Input[str] name: Transformation name.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Dataset reference.
        :param pulumi.Input[str] description: Transformation description.
        :param pulumi.Input['DataFlowReferenceArgs'] flowlet: Flowlet Reference
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: Linked service reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] schema_linked_service: Schema linked service reference.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DatasetReferenceArgs']]:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DatasetReferenceArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowReferenceArgs']]:
        """
        Flowlet Reference
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowReferenceArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


@pulumi.input_type
class DataFlowStagingInfoArgs:
    def __init__(__self__, *,
                 folder_path: Optional[Any] = None,
                 linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None):
        """
        Staging info for execute data flow activity.
        :param Any folder_path: Folder path for staging blob. Type: string (or Expression with resultType string)
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: Staging linked service reference.
        """
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Folder path for staging blob. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Staging linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service", value)


@pulumi.input_type
class DataLakeAnalyticsUSQLActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 script_linked_service: pulumi.Input['LinkedServiceReferenceArgs'],
                 script_path: Any,
                 type: pulumi.Input[str],
                 compilation_mode: Optional[Any] = None,
                 degree_of_parallelism: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 priority: Optional[Any] = None,
                 runtime_version: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Data Lake Analytics U-SQL activity.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input['LinkedServiceReferenceArgs'] script_linked_service: Script linked service reference.
        :param Any script_path: Case-sensitive path to folder that contains the U-SQL script. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'DataLakeAnalyticsU-SQL'.
        :param Any compilation_mode: Compilation mode of U-SQL. Must be one of these values : Semantic, Full and SingleBox. Type: string (or Expression with resultType string).
        :param Any degree_of_parallelism: The maximum number of nodes simultaneously used to run the job. Default value is 1. Type: integer (or Expression with resultType integer), minimum: 1.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Mapping[str, Any]] parameters: Parameters for U-SQL job request.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param Any priority: Determines which jobs out of all that are queued should be selected to run first. The lower the number, the higher the priority. Default value is 1000. Type: integer (or Expression with resultType integer), minimum: 1.
        :param Any runtime_version: Runtime version of the U-SQL engine to use. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "script_linked_service", script_linked_service)
        pulumi.set(__self__, "script_path", script_path)
        pulumi.set(__self__, "type", 'DataLakeAnalyticsU-SQL')
        if compilation_mode is not None:
            pulumi.set(__self__, "compilation_mode", compilation_mode)
        if degree_of_parallelism is not None:
            pulumi.set(__self__, "degree_of_parallelism", degree_of_parallelism)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scriptLinkedService")
    def script_linked_service(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Script linked service reference.
        """
        return pulumi.get(self, "script_linked_service")

    @script_linked_service.setter
    def script_linked_service(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "script_linked_service", value)

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> Any:
        """
        Case-sensitive path to folder that contains the U-SQL script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "script_path")

    @script_path.setter
    def script_path(self, value: Any):
        pulumi.set(self, "script_path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'DataLakeAnalyticsU-SQL'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compilationMode")
    def compilation_mode(self) -> Optional[Any]:
        """
        Compilation mode of U-SQL. Must be one of these values : Semantic, Full and SingleBox. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "compilation_mode")

    @compilation_mode.setter
    def compilation_mode(self, value: Optional[Any]):
        pulumi.set(self, "compilation_mode", value)

    @property
    @pulumi.getter(name="degreeOfParallelism")
    def degree_of_parallelism(self) -> Optional[Any]:
        """
        The maximum number of nodes simultaneously used to run the job. Default value is 1. Type: integer (or Expression with resultType integer), minimum: 1.
        """
        return pulumi.get(self, "degree_of_parallelism")

    @degree_of_parallelism.setter
    def degree_of_parallelism(self, value: Optional[Any]):
        pulumi.set(self, "degree_of_parallelism", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Parameters for U-SQL job request.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[Any]:
        """
        Determines which jobs out of all that are queued should be selected to run first. The lower the number, the higher the priority. Default value is 1000. Type: integer (or Expression with resultType integer), minimum: 1.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[Any]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[Any]:
        """
        Runtime version of the U-SQL engine to use. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[Any]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class DatabricksNotebookActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 notebook_path: Any,
                 type: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        DatabricksNotebook activity.
        :param pulumi.Input[str] name: Activity name.
        :param Any notebook_path: The absolute path of the notebook to be run in the Databricks Workspace. This path must begin with a slash. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'DatabricksNotebook'.
        :param pulumi.Input[Mapping[str, Any]] base_parameters: Base parameters to be used for each run of this job.If the notebook takes a parameter that is not specified, the default value from the notebook will be used.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] libraries: A list of libraries to be installed on the cluster that will execute the job.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notebook_path", notebook_path)
        pulumi.set(__self__, "type", 'DatabricksNotebook')
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> Any:
        """
        The absolute path of the notebook to be run in the Databricks Workspace. This path must begin with a slash. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: Any):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'DatabricksNotebook'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Base parameters to be used for each run of this job.If the notebook takes a parameter that is not specified, the default value from the notebook will be used.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        A list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class DatabricksSparkJarActivityArgs:
    def __init__(__self__, *,
                 main_class_name: Any,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 parameters: Optional[pulumi.Input[Sequence[Any]]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        DatabricksSparkJar activity.
        :param Any main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'DatabricksSparkJar'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] libraries: A list of libraries to be installed on the cluster that will execute the job.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Sequence[Any]] parameters: Parameters that will be passed to the main method.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "main_class_name", main_class_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'DatabricksSparkJar')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Any:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Any):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'DatabricksSparkJar'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        A list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Parameters that will be passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class DatabricksSparkPythonActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 python_file: Any,
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 parameters: Optional[pulumi.Input[Sequence[Any]]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        DatabricksSparkPython activity.
        :param pulumi.Input[str] name: Activity name.
        :param Any python_file: The URI of the Python file to be executed. DBFS paths are supported. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'DatabricksSparkPython'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] libraries: A list of libraries to be installed on the cluster that will execute the job.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Sequence[Any]] parameters: Command line parameters that will be passed to the Python file.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "python_file", python_file)
        pulumi.set(__self__, "type", 'DatabricksSparkPython')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> Any:
        """
        The URI of the Python file to be executed. DBFS paths are supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: Any):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'DatabricksSparkPython'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        A list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Command line parameters that will be passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class DatasetBZip2CompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The BZip2 compression method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'BZip2'.
        """
        pulumi.set(__self__, "type", 'BZip2')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'BZip2'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatasetDeflateCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 level: Optional[Any] = None):
        """
        The Deflate compression method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'Deflate'.
        :param Any level: The Deflate compression level.
        """
        pulumi.set(__self__, "type", 'Deflate')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'Deflate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[Any]:
        """
        The Deflate compression level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[Any]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class DatasetFolderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[str] name: The name of the folder that this Dataset is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the folder that this Dataset is in.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatasetGZipCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 level: Optional[Any] = None):
        """
        The GZip compression method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'GZip'.
        :param Any level: The GZip compression level.
        """
        pulumi.set(__self__, "type", 'GZip')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'GZip'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[Any]:
        """
        The GZip compression level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[Any]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class DatasetReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Dataset reference type.
        :param pulumi.Input[str] reference_name: Reference dataset name.
        :param pulumi.Input[str] type: Dataset reference type.
        :param pulumi.Input[Mapping[str, Any]] parameters: Arguments for dataset.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference dataset name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Dataset reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Arguments for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DatasetTarCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The Tar archive method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'Tar'.
        """
        pulumi.set(__self__, "type", 'Tar')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'Tar'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatasetTarGZipCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 level: Optional[Any] = None):
        """
        The TarGZip compression method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'TarGZip'.
        :param Any level: The TarGZip compression level.
        """
        pulumi.set(__self__, "type", 'TarGZip')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'TarGZip'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[Any]:
        """
        The TarGZip compression level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[Any]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class DatasetZipDeflateCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 level: Optional[Any] = None):
        """
        The ZipDeflate compression method used on a dataset.
        :param pulumi.Input[str] type: Type of dataset compression. Type: string (or Expression with resultType string).
               Expected value is 'ZipDeflate'.
        :param Any level: The ZipDeflate compression level.
        """
        pulumi.set(__self__, "type", 'ZipDeflate')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset compression. Type: string (or Expression with resultType string).
        Expected value is 'ZipDeflate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[Any]:
        """
        The ZipDeflate compression level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[Any]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class Db2LinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'Db2AuthenticationType']]] = None,
                 certificate_common_name: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 database: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 package_collection: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for DB2 data source.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Db2'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'Db2AuthenticationType']] authentication_type: AuthenticationType to be used for connection. It is mutually exclusive with connectionString property.
        :param Any certificate_common_name: Certificate Common Name when TLS is enabled. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with server, database, authenticationType, userName, packageCollection and certificateCommonName property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: Database name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param Any package_collection: Under where packages are created when querying database. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for authentication.
        :param Any server: Server name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Db2')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if certificate_common_name is not None:
            pulumi.set(__self__, "certificate_common_name", certificate_common_name)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if package_collection is not None:
            pulumi.set(__self__, "package_collection", package_collection)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Db2'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'Db2AuthenticationType']]]:
        """
        AuthenticationType to be used for connection. It is mutually exclusive with connectionString property.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'Db2AuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="certificateCommonName")
    def certificate_common_name(self) -> Optional[Any]:
        """
        Certificate Common Name when TLS is enabled. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "certificate_common_name")

    @certificate_common_name.setter
    def certificate_common_name(self, value: Optional[Any]):
        pulumi.set(self, "certificate_common_name", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with server, database, authenticationType, userName, packageCollection and certificateCommonName property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        Database name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[Any]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="packageCollection")
    def package_collection(self) -> Optional[Any]:
        """
        Under where packages are created when querying database. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_collection")

    @package_collection.setter
    def package_collection(self, value: Optional[Any]):
        pulumi.set(self, "package_collection", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Server name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[Any]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class Db2SourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for Db2 databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'Db2Source'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'Db2Source')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'Db2Source'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class Db2TableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Db2 table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Db2Table'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The Db2 table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'Db2Table')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Db2Table'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The Db2 table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class DeleteActivityArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetReferenceArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_logging: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 log_storage_settings: Optional[pulumi.Input['LogStorageSettingsArgs']] = None,
                 max_concurrent_connections: Optional[pulumi.Input[int]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 recursive: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Delete activity.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Delete activity dataset reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Delete'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any enable_logging: Whether to record detailed logs of delete-activity execution. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['LogStorageSettingsArgs'] log_storage_settings: Log storage settings customer need to provide when enableLogging is true.
        :param pulumi.Input[int] max_concurrent_connections: The max concurrent connections to connect data source at the same time.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param Any recursive: If true, files or sub-folders under current folder path will be deleted recursively. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Delete activity store settings.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Delete')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if log_storage_settings is not None:
            pulumi.set(__self__, "log_storage_settings", log_storage_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetReferenceArgs']:
        """
        Delete activity dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetReferenceArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Delete'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[Any]:
        """
        Whether to record detailed logs of delete-activity execution. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[Any]):
        pulumi.set(self, "enable_logging", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="logStorageSettings")
    def log_storage_settings(self) -> Optional[pulumi.Input['LogStorageSettingsArgs']]:
        """
        Log storage settings customer need to provide when enableLogging is true.
        """
        return pulumi.get(self, "log_storage_settings")

    @log_storage_settings.setter
    def log_storage_settings(self, value: Optional[pulumi.Input['LogStorageSettingsArgs']]):
        pulumi.set(self, "log_storage_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[pulumi.Input[int]]:
        """
        The max concurrent connections to connect data source at the same time.
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files or sub-folders under current folder path will be deleted recursively. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Delete activity store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class DelimitedTextDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 column_delimiter: Optional[Any] = None,
                 compression_codec: Optional[Any] = None,
                 compression_level: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encoding_name: Optional[Any] = None,
                 escape_char: Optional[Any] = None,
                 first_row_as_header: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 quote_char: Optional[Any] = None,
                 row_delimiter: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Delimited text dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the delimited text storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DelimitedText'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any column_delimiter: The column delimiter. Type: string (or Expression with resultType string).
        :param Any compression_codec: The data compressionCodec. Type: string (or Expression with resultType string).
        :param Any compression_level: The data compression method used for DelimitedText.
        :param pulumi.Input[str] description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param Any escape_char: The escape character. Type: string (or Expression with resultType string).
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any quote_char: The quote character. Type: string (or Expression with resultType string).
        :param Any row_delimiter: The row delimiter. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'DelimitedText')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if column_delimiter is not None:
            pulumi.set(__self__, "column_delimiter", column_delimiter)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if row_delimiter is not None:
            pulumi.set(__self__, "row_delimiter", row_delimiter)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the delimited text storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DelimitedText'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="columnDelimiter")
    def column_delimiter(self) -> Optional[Any]:
        """
        The column delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "column_delimiter")

    @column_delimiter.setter
    def column_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "column_delimiter", value)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[Any]:
        """
        The data compressionCodec. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[Any]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[Any]:
        """
        The data compression method used for DelimitedText.
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[Any]):
        pulumi.set(self, "compression_level", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: Optional[Any]):
        pulumi.set(self, "encoding_name", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[Any]:
        """
        The escape character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[Any]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @first_row_as_header.setter
    def first_row_as_header(self, value: Optional[Any]):
        pulumi.set(self, "first_row_as_header", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @null_value.setter
    def null_value(self, value: Optional[Any]):
        pulumi.set(self, "null_value", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[Any]:
        """
        The quote character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[Any]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="rowDelimiter")
    def row_delimiter(self) -> Optional[Any]:
        """
        The row delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "row_delimiter")

    @row_delimiter.setter
    def row_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "row_delimiter", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class DelimitedTextReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compression_properties: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]] = None,
                 skip_line_count: Optional[Any] = None):
        """
        Delimited text read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'DelimitedTextReadSettings'.
        :param pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']] compression_properties: Compression settings.
        :param Any skip_line_count: Indicates the number of non-empty rows to skip when reading data from input files. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'DelimitedTextReadSettings')
        if compression_properties is not None:
            pulumi.set(__self__, "compression_properties", compression_properties)
        if skip_line_count is not None:
            pulumi.set(__self__, "skip_line_count", skip_line_count)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'DelimitedTextReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compressionProperties")
    def compression_properties(self) -> Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]:
        """
        Compression settings.
        """
        return pulumi.get(self, "compression_properties")

    @compression_properties.setter
    def compression_properties(self, value: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]):
        pulumi.set(self, "compression_properties", value)

    @property
    @pulumi.getter(name="skipLineCount")
    def skip_line_count(self) -> Optional[Any]:
        """
        Indicates the number of non-empty rows to skip when reading data from input files. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip_line_count")

    @skip_line_count.setter
    def skip_line_count(self, value: Optional[Any]):
        pulumi.set(self, "skip_line_count", value)


@pulumi.input_type
class DelimitedTextSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['DelimitedTextWriteSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity DelimitedText sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'DelimitedTextSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DelimitedTextWriteSettingsArgs'] format_settings: DelimitedText format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: DelimitedText store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DelimitedTextSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'DelimitedTextSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['DelimitedTextWriteSettingsArgs']]:
        """
        DelimitedText format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['DelimitedTextWriteSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        DelimitedText store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class DelimitedTextSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['DelimitedTextReadSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity DelimitedText source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DelimitedTextSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DelimitedTextReadSettingsArgs'] format_settings: DelimitedText format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: DelimitedText store settings.
        """
        pulumi.set(__self__, "type", 'DelimitedTextSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DelimitedTextSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['DelimitedTextReadSettingsArgs']]:
        """
        DelimitedText format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['DelimitedTextReadSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        DelimitedText store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class DelimitedTextWriteSettingsArgs:
    def __init__(__self__, *,
                 file_extension: Any,
                 type: pulumi.Input[str],
                 file_name_prefix: Optional[Any] = None,
                 max_rows_per_file: Optional[Any] = None,
                 quote_all_text: Optional[Any] = None):
        """
        Delimited text write settings.
        :param Any file_extension: The file extension used to create the files. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'DelimitedTextWriteSettings'.
        :param Any file_name_prefix: Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        :param Any max_rows_per_file: Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        :param Any quote_all_text: Indicates whether string values should always be enclosed with quotes. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "file_extension", file_extension)
        pulumi.set(__self__, "type", 'DelimitedTextWriteSettings')
        if file_name_prefix is not None:
            pulumi.set(__self__, "file_name_prefix", file_name_prefix)
        if max_rows_per_file is not None:
            pulumi.set(__self__, "max_rows_per_file", max_rows_per_file)
        if quote_all_text is not None:
            pulumi.set(__self__, "quote_all_text", quote_all_text)

    @property
    @pulumi.getter(name="fileExtension")
    def file_extension(self) -> Any:
        """
        The file extension used to create the files. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_extension")

    @file_extension.setter
    def file_extension(self, value: Any):
        pulumi.set(self, "file_extension", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'DelimitedTextWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileNamePrefix")
    def file_name_prefix(self) -> Optional[Any]:
        """
        Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name_prefix")

    @file_name_prefix.setter
    def file_name_prefix(self, value: Optional[Any]):
        pulumi.set(self, "file_name_prefix", value)

    @property
    @pulumi.getter(name="maxRowsPerFile")
    def max_rows_per_file(self) -> Optional[Any]:
        """
        Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_rows_per_file")

    @max_rows_per_file.setter
    def max_rows_per_file(self, value: Optional[Any]):
        pulumi.set(self, "max_rows_per_file", value)

    @property
    @pulumi.getter(name="quoteAllText")
    def quote_all_text(self) -> Optional[Any]:
        """
        Indicates whether string values should always be enclosed with quotes. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "quote_all_text")

    @quote_all_text.setter
    def quote_all_text(self, value: Optional[Any]):
        pulumi.set(self, "quote_all_text", value)


@pulumi.input_type
class DistcpSettingsArgs:
    def __init__(__self__, *,
                 resource_manager_endpoint: Any,
                 temp_script_path: Any,
                 distcp_options: Optional[Any] = None):
        """
        Distcp settings.
        :param Any resource_manager_endpoint: Specifies the Yarn ResourceManager endpoint. Type: string (or Expression with resultType string).
        :param Any temp_script_path: Specifies an existing folder path which will be used to store temp Distcp command script. The script file is generated by ADF and will be removed after Copy job finished. Type: string (or Expression with resultType string).
        :param Any distcp_options: Specifies the Distcp options. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "resource_manager_endpoint", resource_manager_endpoint)
        pulumi.set(__self__, "temp_script_path", temp_script_path)
        if distcp_options is not None:
            pulumi.set(__self__, "distcp_options", distcp_options)

    @property
    @pulumi.getter(name="resourceManagerEndpoint")
    def resource_manager_endpoint(self) -> Any:
        """
        Specifies the Yarn ResourceManager endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_manager_endpoint")

    @resource_manager_endpoint.setter
    def resource_manager_endpoint(self, value: Any):
        pulumi.set(self, "resource_manager_endpoint", value)

    @property
    @pulumi.getter(name="tempScriptPath")
    def temp_script_path(self) -> Any:
        """
        Specifies an existing folder path which will be used to store temp Distcp command script. The script file is generated by ADF and will be removed after Copy job finished. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "temp_script_path")

    @temp_script_path.setter
    def temp_script_path(self, value: Any):
        pulumi.set(self, "temp_script_path", value)

    @property
    @pulumi.getter(name="distcpOptions")
    def distcp_options(self) -> Optional[Any]:
        """
        Specifies the Distcp options. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "distcp_options")

    @distcp_options.setter
    def distcp_options(self, value: Optional[Any]):
        pulumi.set(self, "distcp_options", value)


@pulumi.input_type
class DocumentDbCollectionDatasetArgs:
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Microsoft Azure Document Database Collection dataset.
        :param Any collection_name: Document Database collection name. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DocumentDbCollection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DocumentDbCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        Document Database collection name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Any):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DocumentDbCollection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class DocumentDbCollectionSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 nesting_separator: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity Document Database Collection sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'DocumentDbCollectionSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any nesting_separator: Nested properties separator. Default is . (dot). Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
        """
        pulumi.set(__self__, "type", 'DocumentDbCollectionSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if nesting_separator is not None:
            pulumi.set(__self__, "nesting_separator", nesting_separator)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'DocumentDbCollectionSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="nestingSeparator")
    def nesting_separator(self) -> Optional[Any]:
        """
        Nested properties separator. Default is . (dot). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "nesting_separator")

    @nesting_separator.setter
    def nesting_separator(self, value: Optional[Any]):
        pulumi.set(self, "nesting_separator", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class DocumentDbCollectionSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 nesting_separator: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Document Database Collection source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DocumentDbCollectionSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any nesting_separator: Nested properties separator. Type: string (or Expression with resultType string).
        :param Any query: Documents query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DocumentDbCollectionSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if nesting_separator is not None:
            pulumi.set(__self__, "nesting_separator", nesting_separator)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DocumentDbCollectionSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="nestingSeparator")
    def nesting_separator(self) -> Optional[Any]:
        """
        Nested properties separator. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "nesting_separator")

    @nesting_separator.setter
    def nesting_separator(self, value: Optional[Any]):
        pulumi.set(self, "nesting_separator", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Documents query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class DrillLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Drill server linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Drill'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Drill')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Drill'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class DrillSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Drill server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DrillSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DrillSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DrillSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class DrillTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Drill server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DrillTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Drill. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DrillTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DrillTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Drill. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class DynamicsAXLinkedServiceArgs:
    def __init__(__self__, *,
                 aad_resource_id: Any,
                 service_principal_id: Any,
                 service_principal_key: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 tenant: Any,
                 type: pulumi.Input[str],
                 url: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Dynamics AX linked service.
        :param Any aad_resource_id: Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application's client ID. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key Vault. Type: string (or Expression with resultType string).
        :param Any tenant: Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering the mouse in the top-right corner of the Azure portal. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'DynamicsAX'.
        :param Any url: The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "type", 'DynamicsAX')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Any:
        """
        Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "aad_resource_id")

    @aad_resource_id.setter
    def aad_resource_id(self, value: Any):
        pulumi.set(self, "aad_resource_id", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        Specify the application's client ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Any):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key Vault. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering the mouse in the top-right corner of the Azure portal. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Any):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'DynamicsAX'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DynamicsAXResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 path: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the Dynamics AX OData entity.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any path: The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DynamicsAXResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'DynamicsAXResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Any):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DynamicsAXResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class DynamicsAXSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Dynamics AX source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DynamicsAXSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DynamicsAXSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DynamicsAXSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class DynamicsCrmEntityDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Dynamics CRM entity dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DynamicsCrmEntity'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DynamicsCrmEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DynamicsCrmEntity'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @entity_name.setter
    def entity_name(self, value: Optional[Any]):
        pulumi.set(self, "entity_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class DynamicsCrmLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: Any,
                 deployment_type: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_credential_type: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Dynamics CRM linked service.
        :param Any authentication_type: The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param Any deployment_type: The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'DynamicsCrm'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there are more than one Dynamics CRM instances associated with the user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the Dynamics CRM instance.
        :param Any port: The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param Any service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'DynamicsCrm')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Any:
        """
        The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Any):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Any:
        """
        The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: Any):
        pulumi.set(self, "deployment_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'DynamicsCrm'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[Any]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there are more than one Dynamics CRM instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[Any]):
        pulumi.set(self, "organization_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the Dynamics CRM instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @service_principal_credential.setter
    def service_principal_credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_credential", value)

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[Any]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @service_principal_credential_type.setter
    def service_principal_credential_type(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_credential_type", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[Any]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DynamicsCrmSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 write_behavior: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']],
                 alternate_key_name: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 ignore_null_values: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Dynamics CRM sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'DynamicsCrmSink'.
        :param pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']] write_behavior: The write behavior for the operation.
        :param Any alternate_key_name: The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any ignore_null_values: The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DynamicsCrmSink')
        pulumi.set(__self__, "write_behavior", write_behavior)
        if alternate_key_name is not None:
            pulumi.set(__self__, "alternate_key_name", alternate_key_name)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if ignore_null_values is not None:
            pulumi.set(__self__, "ignore_null_values", ignore_null_values)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'DynamicsCrmSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]:
        """
        The write behavior for the operation.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]):
        pulumi.set(self, "write_behavior", value)

    @property
    @pulumi.getter(name="alternateKeyName")
    def alternate_key_name(self) -> Optional[Any]:
        """
        The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "alternate_key_name")

    @alternate_key_name.setter
    def alternate_key_name(self, value: Optional[Any]):
        pulumi.set(self, "alternate_key_name", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="ignoreNullValues")
    def ignore_null_values(self) -> Optional[Any]:
        """
        The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "ignore_null_values")

    @ignore_null_values.setter
    def ignore_null_values(self, value: Optional[Any]):
        pulumi.set(self, "ignore_null_values", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class DynamicsCrmSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Dynamics CRM source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DynamicsCrmSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: FetchXML is a proprietary query language that is used in Microsoft Dynamics CRM (online & on-premises). Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DynamicsCrmSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DynamicsCrmSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        FetchXML is a proprietary query language that is used in Microsoft Dynamics CRM (online & on-premises). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class DynamicsEntityDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Dynamics entity dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'DynamicsEntity'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DynamicsEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'DynamicsEntity'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @entity_name.setter
    def entity_name(self, value: Optional[Any]):
        pulumi.set(self, "entity_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class DynamicsLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: Any,
                 deployment_type: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_credential_type: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Dynamics linked service.
        :param Any authentication_type: The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param Any deployment_type: The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Dynamics'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Dynamics instance. The property is required for on-prem and required for online when there are more than one Dynamics instances associated with the user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the Dynamics instance.
        :param Any port: The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param Any service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Dynamics instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'Dynamics')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Any:
        """
        The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Any):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Any:
        """
        The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: Any):
        pulumi.set(self, "deployment_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Dynamics'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[Any]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Dynamics instance. The property is required for on-prem and required for online when there are more than one Dynamics instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[Any]):
        pulumi.set(self, "organization_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the Dynamics instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @service_principal_credential.setter
    def service_principal_credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_credential", value)

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[Any]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @service_principal_credential_type.setter
    def service_principal_credential_type(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_credential_type", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[Any]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Dynamics instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DynamicsSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 write_behavior: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']],
                 alternate_key_name: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 ignore_null_values: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Dynamics sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'DynamicsSink'.
        :param pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']] write_behavior: The write behavior for the operation.
        :param Any alternate_key_name: The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any ignore_null_values: The flag indicating whether ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DynamicsSink')
        pulumi.set(__self__, "write_behavior", write_behavior)
        if alternate_key_name is not None:
            pulumi.set(__self__, "alternate_key_name", alternate_key_name)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if ignore_null_values is not None:
            pulumi.set(__self__, "ignore_null_values", ignore_null_values)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'DynamicsSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]:
        """
        The write behavior for the operation.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: pulumi.Input[Union[str, 'DynamicsSinkWriteBehavior']]):
        pulumi.set(self, "write_behavior", value)

    @property
    @pulumi.getter(name="alternateKeyName")
    def alternate_key_name(self) -> Optional[Any]:
        """
        The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "alternate_key_name")

    @alternate_key_name.setter
    def alternate_key_name(self, value: Optional[Any]):
        pulumi.set(self, "alternate_key_name", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="ignoreNullValues")
    def ignore_null_values(self) -> Optional[Any]:
        """
        The flag indicating whether ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "ignore_null_values")

    @ignore_null_values.setter
    def ignore_null_values(self, value: Optional[Any]):
        pulumi.set(self, "ignore_null_values", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class DynamicsSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Dynamics source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'DynamicsSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: FetchXML is a proprietary query language that is used in Microsoft Dynamics (online & on-premises). Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'DynamicsSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'DynamicsSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        FetchXML is a proprietary query language that is used in Microsoft Dynamics (online & on-premises). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class EloquaLinkedServiceArgs:
    def __init__(__self__, *,
                 endpoint: Any,
                 type: pulumi.Input[str],
                 username: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Eloqua server linked service.
        :param Any endpoint: The endpoint of the Eloqua server. (i.e. eloqua.example.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Eloqua'.
        :param Any username: The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Eloqua')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Eloqua server. (i.e. eloqua.example.com)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Eloqua'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Any):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class EloquaObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Eloqua server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'EloquaObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'EloquaObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'EloquaObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class EloquaSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Eloqua server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'EloquaSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'EloquaSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'EloquaSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class EncryptionConfigurationArgs:
    def __init__(__self__, *,
                 key_name: pulumi.Input[str],
                 vault_base_url: pulumi.Input[str],
                 identity: Optional[pulumi.Input['CMKIdentityDefinitionArgs']] = None,
                 key_version: Optional[pulumi.Input[str]] = None):
        """
        Definition of CMK for the factory.
        :param pulumi.Input[str] key_name: The name of the key in Azure Key Vault to use as Customer Managed Key.
        :param pulumi.Input[str] vault_base_url: The url of the Azure Key Vault used for CMK.
        :param pulumi.Input['CMKIdentityDefinitionArgs'] identity: User assigned identity to use to authenticate to customer's key vault. If not provided Managed Service Identity will be used.
        :param pulumi.Input[str] key_version: The version of the key used for CMK. If not provided, latest version will be used.
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "vault_base_url", vault_base_url)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[str]:
        """
        The name of the key in Azure Key Vault to use as Customer Managed Key.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="vaultBaseUrl")
    def vault_base_url(self) -> pulumi.Input[str]:
        """
        The url of the Azure Key Vault used for CMK.
        """
        return pulumi.get(self, "vault_base_url")

    @vault_base_url.setter
    def vault_base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_base_url", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['CMKIdentityDefinitionArgs']]:
        """
        User assigned identity to use to authenticate to customer's key vault. If not provided Managed Service Identity will be used.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['CMKIdentityDefinitionArgs']]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the key used for CMK. If not provided, latest version will be used.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version", value)


@pulumi.input_type
class EntityReferenceArgs:
    def __init__(__self__, *,
                 reference_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEntityReferenceType']]] = None):
        """
        The entity reference.
        :param pulumi.Input[str] reference_name: The name of this referenced entity.
        :param pulumi.Input[Union[str, 'IntegrationRuntimeEntityReferenceType']] type: The type of this referenced entity.
        """
        if reference_name is not None:
            pulumi.set(__self__, "reference_name", reference_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of this referenced entity.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEntityReferenceType']]]:
        """
        The type of this referenced entity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEntityReferenceType']]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EnvironmentVariableSetupArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 variable_name: pulumi.Input[str],
                 variable_value: pulumi.Input[str]):
        """
        The custom setup of setting environment variable.
        :param pulumi.Input[str] type: The type of custom setup.
               Expected value is 'EnvironmentVariableSetup'.
        :param pulumi.Input[str] variable_name: The name of the environment variable.
        :param pulumi.Input[str] variable_value: The value of the environment variable.
        """
        pulumi.set(__self__, "type", 'EnvironmentVariableSetup')
        pulumi.set(__self__, "variable_name", variable_name)
        pulumi.set(__self__, "variable_value", variable_value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of custom setup.
        Expected value is 'EnvironmentVariableSetup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="variableName")
    def variable_name(self) -> pulumi.Input[str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "variable_name")

    @variable_name.setter
    def variable_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "variable_name", value)

    @property
    @pulumi.getter(name="variableValue")
    def variable_value(self) -> pulumi.Input[str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "variable_value")

    @variable_value.setter
    def variable_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "variable_value", value)


@pulumi.input_type
class ExcelDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 first_row_as_header: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 range: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 sheet_index: Optional[Any] = None,
                 sheet_name: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Excel dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the excel storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Excel'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the json dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any range: The partial data of one sheet. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any sheet_index: The sheet index of excel file and default value is 0. Type: integer (or Expression with resultType integer)
        :param Any sheet_name: The sheet name of excel file. Type: string (or Expression with resultType string).
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Excel')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if sheet_index is not None:
            pulumi.set(__self__, "sheet_index", sheet_index)
        if sheet_name is not None:
            pulumi.set(__self__, "sheet_name", sheet_name)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the excel storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Excel'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @first_row_as_header.setter
    def first_row_as_header(self, value: Optional[Any]):
        pulumi.set(self, "first_row_as_header", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @null_value.setter
    def null_value(self, value: Optional[Any]):
        pulumi.set(self, "null_value", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[Any]:
        """
        The partial data of one sheet. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[Any]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="sheetIndex")
    def sheet_index(self) -> Optional[Any]:
        """
        The sheet index of excel file and default value is 0. Type: integer (or Expression with resultType integer)
        """
        return pulumi.get(self, "sheet_index")

    @sheet_index.setter
    def sheet_index(self, value: Optional[Any]):
        pulumi.set(self, "sheet_index", value)

    @property
    @pulumi.getter(name="sheetName")
    def sheet_name(self) -> Optional[Any]:
        """
        The sheet name of excel file. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sheet_name")

    @sheet_name.setter
    def sheet_name(self, value: Optional[Any]):
        pulumi.set(self, "sheet_name", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class ExcelSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity excel source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ExcelSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Excel store settings.
        """
        pulumi.set(__self__, "type", 'ExcelSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ExcelSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Excel store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class ExecuteDataFlowActivityTypePropertiesComputeArgs:
    def __init__(__self__, *,
                 compute_type: Optional[Any] = None,
                 core_count: Optional[Any] = None):
        """
        Compute properties for data flow activity.
        :param Any compute_type: Compute type of the cluster which will execute data flow job. Possible values include: 'General', 'MemoryOptimized', 'ComputeOptimized'. Type: string (or Expression with resultType string)
        :param Any core_count: Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272. Type: integer (or Expression with resultType integer)
        """
        if compute_type is not None:
            pulumi.set(__self__, "compute_type", compute_type)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> Optional[Any]:
        """
        Compute type of the cluster which will execute data flow job. Possible values include: 'General', 'MemoryOptimized', 'ComputeOptimized'. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: Optional[Any]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[Any]:
        """
        Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272. Type: integer (or Expression with resultType integer)
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[Any]):
        pulumi.set(self, "core_count", value)


@pulumi.input_type
class ExecuteDataFlowActivityArgs:
    def __init__(__self__, *,
                 data_flow: pulumi.Input['DataFlowReferenceArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 compute: Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']] = None,
                 continue_on_error: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 integration_runtime: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 run_concurrently: Optional[Any] = None,
                 staging: Optional[pulumi.Input['DataFlowStagingInfoArgs']] = None,
                 trace_level: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Execute data flow activity.
        :param pulumi.Input['DataFlowReferenceArgs'] data_flow: Data flow reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'ExecuteDataFlow'.
        :param pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs'] compute: Compute properties for data flow activity.
        :param Any continue_on_error: Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or Expression with resultType boolean)
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] integration_runtime: The integration runtime reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param Any run_concurrently: Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently. Type: boolean (or Expression with resultType boolean)
        :param pulumi.Input['DataFlowStagingInfoArgs'] staging: Staging info for execute data flow activity.
        :param Any trace_level: Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string (or Expression with resultType string)
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "data_flow", data_flow)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'ExecuteDataFlow')
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if continue_on_error is not None:
            pulumi.set(__self__, "continue_on_error", continue_on_error)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if integration_runtime is not None:
            pulumi.set(__self__, "integration_runtime", integration_runtime)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if run_concurrently is not None:
            pulumi.set(__self__, "run_concurrently", run_concurrently)
        if staging is not None:
            pulumi.set(__self__, "staging", staging)
        if trace_level is not None:
            pulumi.set(__self__, "trace_level", trace_level)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="dataFlow")
    def data_flow(self) -> pulumi.Input['DataFlowReferenceArgs']:
        """
        Data flow reference.
        """
        return pulumi.get(self, "data_flow")

    @data_flow.setter
    def data_flow(self, value: pulumi.Input['DataFlowReferenceArgs']):
        pulumi.set(self, "data_flow", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'ExecuteDataFlow'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']]:
        """
        Compute properties for data flow activity.
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="continueOnError")
    def continue_on_error(self) -> Optional[Any]:
        """
        Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or Expression with resultType boolean)
        """
        return pulumi.get(self, "continue_on_error")

    @continue_on_error.setter
    def continue_on_error(self, value: Optional[Any]):
        pulumi.set(self, "continue_on_error", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="integrationRuntime")
    def integration_runtime(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "integration_runtime")

    @integration_runtime.setter
    def integration_runtime(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "integration_runtime", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="runConcurrently")
    def run_concurrently(self) -> Optional[Any]:
        """
        Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently. Type: boolean (or Expression with resultType boolean)
        """
        return pulumi.get(self, "run_concurrently")

    @run_concurrently.setter
    def run_concurrently(self, value: Optional[Any]):
        pulumi.set(self, "run_concurrently", value)

    @property
    @pulumi.getter
    def staging(self) -> Optional[pulumi.Input['DataFlowStagingInfoArgs']]:
        """
        Staging info for execute data flow activity.
        """
        return pulumi.get(self, "staging")

    @staging.setter
    def staging(self, value: Optional[pulumi.Input['DataFlowStagingInfoArgs']]):
        pulumi.set(self, "staging", value)

    @property
    @pulumi.getter(name="traceLevel")
    def trace_level(self) -> Optional[Any]:
        """
        Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "trace_level")

    @trace_level.setter
    def trace_level(self, value: Optional[Any]):
        pulumi.set(self, "trace_level", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class ExecutePipelineActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 pipeline: pulumi.Input['PipelineReferenceArgs'],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 wait_on_completion: Optional[pulumi.Input[bool]] = None):
        """
        Execute pipeline activity.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input['PipelineReferenceArgs'] pipeline: Pipeline reference.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'ExecutePipeline'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Mapping[str, Any]] parameters: Pipeline parameters.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param pulumi.Input[bool] wait_on_completion: Defines whether activity execution will wait for the dependent pipeline execution to finish. Default is false.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "type", 'ExecutePipeline')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if wait_on_completion is not None:
            pulumi.set(__self__, "wait_on_completion", wait_on_completion)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pipeline(self) -> pulumi.Input['PipelineReferenceArgs']:
        """
        Pipeline reference.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: pulumi.Input['PipelineReferenceArgs']):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'ExecutePipeline'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Pipeline parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter(name="waitOnCompletion")
    def wait_on_completion(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether activity execution will wait for the dependent pipeline execution to finish. Default is false.
        """
        return pulumi.get(self, "wait_on_completion")

    @wait_on_completion.setter
    def wait_on_completion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_completion", value)


@pulumi.input_type
class ExecuteSSISPackageActivityArgs:
    def __init__(__self__, *,
                 connect_via: pulumi.Input['IntegrationRuntimeReferenceArgs'],
                 name: pulumi.Input[str],
                 package_location: pulumi.Input['SSISPackageLocationArgs'],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 environment_path: Optional[Any] = None,
                 execution_credential: Optional[pulumi.Input['SSISExecutionCredentialArgs']] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 log_location: Optional[pulumi.Input['SSISLogLocationArgs']] = None,
                 logging_level: Optional[Any] = None,
                 package_connection_managers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]] = None,
                 package_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 project_connection_managers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]] = None,
                 project_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]] = None,
                 property_overrides: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISPropertyOverrideArgs']]]] = None,
                 runtime: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Execute SSIS package activity.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input['SSISPackageLocationArgs'] package_location: SSIS package location.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'ExecuteSSISPackage'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any environment_path: The environment path to execute the SSIS package. Type: string (or Expression with resultType string).
        :param pulumi.Input['SSISExecutionCredentialArgs'] execution_credential: The package execution credential.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['SSISLogLocationArgs'] log_location: SSIS package execution log location.
        :param Any logging_level: The logging level of SSIS package execution. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]] package_connection_managers: The package level connection managers to execute the SSIS package.
        :param pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]] package_parameters: The package level parameters to execute the SSIS package.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]] project_connection_managers: The project level connection managers to execute the SSIS package.
        :param pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]] project_parameters: The project level parameters to execute the SSIS package.
        :param pulumi.Input[Mapping[str, pulumi.Input['SSISPropertyOverrideArgs']]] property_overrides: The property overrides to execute the SSIS package.
        :param Any runtime: Specifies the runtime to execute SSIS package. The value should be "x86" or "x64". Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "connect_via", connect_via)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "package_location", package_location)
        pulumi.set(__self__, "type", 'ExecuteSSISPackage')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_path is not None:
            pulumi.set(__self__, "environment_path", environment_path)
        if execution_credential is not None:
            pulumi.set(__self__, "execution_credential", execution_credential)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if log_location is not None:
            pulumi.set(__self__, "log_location", log_location)
        if logging_level is not None:
            pulumi.set(__self__, "logging_level", logging_level)
        if package_connection_managers is not None:
            pulumi.set(__self__, "package_connection_managers", package_connection_managers)
        if package_parameters is not None:
            pulumi.set(__self__, "package_parameters", package_parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if project_connection_managers is not None:
            pulumi.set(__self__, "project_connection_managers", project_connection_managers)
        if project_parameters is not None:
            pulumi.set(__self__, "project_parameters", project_parameters)
        if property_overrides is not None:
            pulumi.set(__self__, "property_overrides", property_overrides)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> pulumi.Input['IntegrationRuntimeReferenceArgs']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: pulumi.Input['IntegrationRuntimeReferenceArgs']):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="packageLocation")
    def package_location(self) -> pulumi.Input['SSISPackageLocationArgs']:
        """
        SSIS package location.
        """
        return pulumi.get(self, "package_location")

    @package_location.setter
    def package_location(self, value: pulumi.Input['SSISPackageLocationArgs']):
        pulumi.set(self, "package_location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'ExecuteSSISPackage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="environmentPath")
    def environment_path(self) -> Optional[Any]:
        """
        The environment path to execute the SSIS package. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "environment_path")

    @environment_path.setter
    def environment_path(self, value: Optional[Any]):
        pulumi.set(self, "environment_path", value)

    @property
    @pulumi.getter(name="executionCredential")
    def execution_credential(self) -> Optional[pulumi.Input['SSISExecutionCredentialArgs']]:
        """
        The package execution credential.
        """
        return pulumi.get(self, "execution_credential")

    @execution_credential.setter
    def execution_credential(self, value: Optional[pulumi.Input['SSISExecutionCredentialArgs']]):
        pulumi.set(self, "execution_credential", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="logLocation")
    def log_location(self) -> Optional[pulumi.Input['SSISLogLocationArgs']]:
        """
        SSIS package execution log location.
        """
        return pulumi.get(self, "log_location")

    @log_location.setter
    def log_location(self, value: Optional[pulumi.Input['SSISLogLocationArgs']]):
        pulumi.set(self, "log_location", value)

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[Any]:
        """
        The logging level of SSIS package execution. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "logging_level")

    @logging_level.setter
    def logging_level(self, value: Optional[Any]):
        pulumi.set(self, "logging_level", value)

    @property
    @pulumi.getter(name="packageConnectionManagers")
    def package_connection_managers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]]:
        """
        The package level connection managers to execute the SSIS package.
        """
        return pulumi.get(self, "package_connection_managers")

    @package_connection_managers.setter
    def package_connection_managers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]]):
        pulumi.set(self, "package_connection_managers", value)

    @property
    @pulumi.getter(name="packageParameters")
    def package_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]:
        """
        The package level parameters to execute the SSIS package.
        """
        return pulumi.get(self, "package_parameters")

    @package_parameters.setter
    def package_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]):
        pulumi.set(self, "package_parameters", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="projectConnectionManagers")
    def project_connection_managers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]]:
        """
        The project level connection managers to execute the SSIS package.
        """
        return pulumi.get(self, "project_connection_managers")

    @project_connection_managers.setter
    def project_connection_managers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]]]):
        pulumi.set(self, "project_connection_managers", value)

    @property
    @pulumi.getter(name="projectParameters")
    def project_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]:
        """
        The project level parameters to execute the SSIS package.
        """
        return pulumi.get(self, "project_parameters")

    @project_parameters.setter
    def project_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISExecutionParameterArgs']]]]):
        pulumi.set(self, "project_parameters", value)

    @property
    @pulumi.getter(name="propertyOverrides")
    def property_overrides(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISPropertyOverrideArgs']]]]:
        """
        The property overrides to execute the SSIS package.
        """
        return pulumi.get(self, "property_overrides")

    @property_overrides.setter
    def property_overrides(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SSISPropertyOverrideArgs']]]]):
        pulumi.set(self, "property_overrides", value)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[Any]:
        """
        Specifies the runtime to execute SSIS package. The value should be "x86" or "x64". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[Any]):
        pulumi.set(self, "runtime", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class ExecuteWranglingDataflowActivityArgs:
    def __init__(__self__, *,
                 data_flow: pulumi.Input['DataFlowReferenceArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 compute: Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']] = None,
                 continue_on_error: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 integration_runtime: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkMappingArgs']]]] = None,
                 run_concurrently: Optional[Any] = None,
                 sinks: Optional[pulumi.Input[Mapping[str, pulumi.Input['PowerQuerySinkArgs']]]] = None,
                 staging: Optional[pulumi.Input['DataFlowStagingInfoArgs']] = None,
                 trace_level: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Execute power query activity.
        :param pulumi.Input['DataFlowReferenceArgs'] data_flow: Data flow reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'ExecuteWranglingDataflow'.
        :param pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs'] compute: Compute properties for data flow activity.
        :param Any continue_on_error: Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or Expression with resultType boolean)
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] integration_runtime: The integration runtime reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkMappingArgs']]] queries: List of mapping for Power Query mashup query to sink dataset(s).
        :param Any run_concurrently: Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently. Type: boolean (or Expression with resultType boolean)
        :param pulumi.Input[Mapping[str, pulumi.Input['PowerQuerySinkArgs']]] sinks: (Deprecated. Please use Queries). List of Power Query activity sinks mapped to a queryName.
        :param pulumi.Input['DataFlowStagingInfoArgs'] staging: Staging info for execute data flow activity.
        :param Any trace_level: Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string (or Expression with resultType string)
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "data_flow", data_flow)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'ExecuteWranglingDataflow')
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if continue_on_error is not None:
            pulumi.set(__self__, "continue_on_error", continue_on_error)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if integration_runtime is not None:
            pulumi.set(__self__, "integration_runtime", integration_runtime)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if run_concurrently is not None:
            pulumi.set(__self__, "run_concurrently", run_concurrently)
        if sinks is not None:
            pulumi.set(__self__, "sinks", sinks)
        if staging is not None:
            pulumi.set(__self__, "staging", staging)
        if trace_level is not None:
            pulumi.set(__self__, "trace_level", trace_level)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="dataFlow")
    def data_flow(self) -> pulumi.Input['DataFlowReferenceArgs']:
        """
        Data flow reference.
        """
        return pulumi.get(self, "data_flow")

    @data_flow.setter
    def data_flow(self, value: pulumi.Input['DataFlowReferenceArgs']):
        pulumi.set(self, "data_flow", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'ExecuteWranglingDataflow'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']]:
        """
        Compute properties for data flow activity.
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input['ExecuteDataFlowActivityTypePropertiesComputeArgs']]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="continueOnError")
    def continue_on_error(self) -> Optional[Any]:
        """
        Continue on error setting used for data flow execution. Enables processing to continue if a sink fails. Type: boolean (or Expression with resultType boolean)
        """
        return pulumi.get(self, "continue_on_error")

    @continue_on_error.setter
    def continue_on_error(self, value: Optional[Any]):
        pulumi.set(self, "continue_on_error", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="integrationRuntime")
    def integration_runtime(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "integration_runtime")

    @integration_runtime.setter
    def integration_runtime(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "integration_runtime", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkMappingArgs']]]]:
        """
        List of mapping for Power Query mashup query to sink dataset(s).
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkMappingArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="runConcurrently")
    def run_concurrently(self) -> Optional[Any]:
        """
        Concurrent run setting used for data flow execution. Allows sinks with the same save order to be processed concurrently. Type: boolean (or Expression with resultType boolean)
        """
        return pulumi.get(self, "run_concurrently")

    @run_concurrently.setter
    def run_concurrently(self, value: Optional[Any]):
        pulumi.set(self, "run_concurrently", value)

    @property
    @pulumi.getter
    def sinks(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PowerQuerySinkArgs']]]]:
        """
        (Deprecated. Please use Queries). List of Power Query activity sinks mapped to a queryName.
        """
        return pulumi.get(self, "sinks")

    @sinks.setter
    def sinks(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PowerQuerySinkArgs']]]]):
        pulumi.set(self, "sinks", value)

    @property
    @pulumi.getter
    def staging(self) -> Optional[pulumi.Input['DataFlowStagingInfoArgs']]:
        """
        Staging info for execute data flow activity.
        """
        return pulumi.get(self, "staging")

    @staging.setter
    def staging(self, value: Optional[pulumi.Input['DataFlowStagingInfoArgs']]):
        pulumi.set(self, "staging", value)

    @property
    @pulumi.getter(name="traceLevel")
    def trace_level(self) -> Optional[Any]:
        """
        Trace level setting used for data flow monitoring output. Supported values are: 'coarse', 'fine', and 'none'. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "trace_level")

    @trace_level.setter
    def trace_level(self, value: Optional[Any]):
        pulumi.set(self, "trace_level", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class ExecutionActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Base class for all execution activities.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Execution'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Execution')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Execution'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class ExpressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Azure Data Factory expression definition.
        :param pulumi.Input[str] type: Expression type.
        :param pulumi.Input[str] value: Expression value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Expression type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Expression value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FactoryGitHubConfigurationArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[str],
                 collaboration_branch: pulumi.Input[str],
                 repository_name: pulumi.Input[str],
                 root_folder: pulumi.Input[str],
                 type: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['GitHubClientSecretArgs']] = None,
                 host_name: Optional[pulumi.Input[str]] = None,
                 last_commit_id: Optional[pulumi.Input[str]] = None):
        """
        Factory's GitHub repo information.
        :param pulumi.Input[str] account_name: Account name.
        :param pulumi.Input[str] collaboration_branch: Collaboration branch.
        :param pulumi.Input[str] repository_name: Repository name.
        :param pulumi.Input[str] root_folder: Root folder.
        :param pulumi.Input[str] type: Type of repo configuration.
               Expected value is 'FactoryGitHubConfiguration'.
        :param pulumi.Input[str] client_id: GitHub bring your own app client id.
        :param pulumi.Input['GitHubClientSecretArgs'] client_secret: GitHub bring your own app client secret information.
        :param pulumi.Input[str] host_name: GitHub Enterprise host name. For example: https://github.mydomain.com
        :param pulumi.Input[str] last_commit_id: Last commit id.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "type", 'FactoryGitHubConfiguration')
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        Account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> pulumi.Input[str]:
        """
        Collaboration branch.
        """
        return pulumi.get(self, "collaboration_branch")

    @collaboration_branch.setter
    def collaboration_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "collaboration_branch", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        Repository name.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> pulumi.Input[str]:
        """
        Root folder.
        """
        return pulumi.get(self, "root_folder")

    @root_folder.setter
    def root_folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of repo configuration.
        Expected value is 'FactoryGitHubConfiguration'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        GitHub bring your own app client id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['GitHubClientSecretArgs']]:
        """
        GitHub bring your own app client secret information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['GitHubClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        GitHub Enterprise host name. For example: https://github.mydomain.com
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[str]]:
        """
        Last commit id.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_commit_id", value)


@pulumi.input_type
class FactoryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'FactoryIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Identity properties of the factory resource.
        :param pulumi.Input[Union[str, 'FactoryIdentityType']] type: The identity type.
        :param pulumi.Input[Mapping[str, Any]] user_assigned_identities: List of user assigned identities for the factory.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'FactoryIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'FactoryIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        List of user assigned identities for the factory.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class FactoryVSTSConfigurationArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[str],
                 collaboration_branch: pulumi.Input[str],
                 project_name: pulumi.Input[str],
                 repository_name: pulumi.Input[str],
                 root_folder: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_commit_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        Factory's VSTS repo information.
        :param pulumi.Input[str] account_name: Account name.
        :param pulumi.Input[str] collaboration_branch: Collaboration branch.
        :param pulumi.Input[str] project_name: VSTS project name.
        :param pulumi.Input[str] repository_name: Repository name.
        :param pulumi.Input[str] root_folder: Root folder.
        :param pulumi.Input[str] type: Type of repo configuration.
               Expected value is 'FactoryVSTSConfiguration'.
        :param pulumi.Input[str] last_commit_id: Last commit id.
        :param pulumi.Input[str] tenant_id: VSTS tenant id.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "type", 'FactoryVSTSConfiguration')
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        Account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> pulumi.Input[str]:
        """
        Collaboration branch.
        """
        return pulumi.get(self, "collaboration_branch")

    @collaboration_branch.setter
    def collaboration_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "collaboration_branch", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> pulumi.Input[str]:
        """
        VSTS project name.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        Repository name.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> pulumi.Input[str]:
        """
        Root folder.
        """
        return pulumi.get(self, "root_folder")

    @root_folder.setter
    def root_folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of repo configuration.
        Expected value is 'FactoryVSTSConfiguration'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[str]]:
        """
        Last commit id.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        VSTS tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class FileServerLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_id: Optional[Any] = None):
        """
        File system linked service.
        :param Any host: Host name of the server. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'FileServer'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to logon the server.
        :param Any user_id: User ID to logon the server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'FileServer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name of the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'FileServer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to logon the server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[Any]:
        """
        User ID to logon the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[Any]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class FileServerLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of file server dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'FileServerLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'FileServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'FileServerLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class FileServerReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_filter: Optional[Any] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        File server read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'FileServerReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_filter: Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: FileServer wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: FileServer wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'FileServerReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_filter is not None:
            pulumi.set(__self__, "file_filter", file_filter)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'FileServerReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileFilter")
    def file_filter(self) -> Optional[Any]:
        """
        Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_filter")

    @file_filter.setter
    def file_filter(self, value: Optional[Any]):
        pulumi.set(self, "file_filter", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        FileServer wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        FileServer wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class FileServerWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None):
        """
        File server write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'FileServerWriteSettings'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'FileServerWriteSettings')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'FileServerWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)


@pulumi.input_type
class FileShareDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 file_filter: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        An on-premises file system dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'FileShare'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the file system.
        :param pulumi.Input[str] description: Dataset description.
        :param Any file_filter: Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        :param Any file_name: The name of the on-premises file system. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the on-premises file system. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of the files.
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'FileShare')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_filter is not None:
            pulumi.set(__self__, "file_filter", file_filter)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'FileShare'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the file system.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileFilter")
    def file_filter(self) -> Optional[Any]:
        """
        Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_filter")

    @file_filter.setter
    def file_filter(self, value: Optional[Any]):
        pulumi.set(self, "file_filter", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the on-premises file system. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the on-premises file system. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of the files.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class FileSystemSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity file system sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'FileSystemSink'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'FileSystemSink')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'FileSystemSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class FileSystemSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity file system source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'FileSystemSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'FileSystemSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'FileSystemSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class FilterActivityArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['ExpressionArgs'],
                 items: pulumi.Input['ExpressionArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Filter and return results from input array based on the conditions.
        :param pulumi.Input['ExpressionArgs'] condition: Condition to be used for filtering the input.
        :param pulumi.Input['ExpressionArgs'] items: Input array on which filter should be applied.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Filter'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Filter')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['ExpressionArgs']:
        """
        Condition to be used for filtering the input.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input['ExpressionArgs']:
        """
        Input array on which filter should be applied.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Filter'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class FlowletArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DataFlowFolderArgs']] = None,
                 script: Optional[pulumi.Input[str]] = None,
                 script_lines: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sinks: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]] = None,
                 transformations: Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Data flow flowlet
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the data flow.
        :param pulumi.Input[str] description: The description of the data flow.
        :param pulumi.Input['DataFlowFolderArgs'] folder: The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param pulumi.Input[str] script: Flowlet script.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] script_lines: Flowlet script lines.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]] sinks: List of sinks in Flowlet.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]] sources: List of sources in Flowlet.
        :param pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]] transformations: List of transformations in Flowlet.
        :param pulumi.Input[str] type: Type of data flow.
               Expected value is 'Flowlet'.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_lines is not None:
            pulumi.set(__self__, "script_lines", script_lines)
        if sinks is not None:
            pulumi.set(__self__, "sinks", sinks)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if type is not None:
            pulumi.set(__self__, "type", 'Flowlet')

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[Any]:
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[Any]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the data flow.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the data flow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DataFlowFolderArgs']]:
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DataFlowFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        Flowlet script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter(name="scriptLines")
    def script_lines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Flowlet script lines.
        """
        return pulumi.get(self, "script_lines")

    @script_lines.setter
    def script_lines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "script_lines", value)

    @property
    @pulumi.getter
    def sinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]]:
        """
        List of sinks in Flowlet.
        """
        return pulumi.get(self, "sinks")

    @sinks.setter
    def sinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]]):
        pulumi.set(self, "sinks", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]]:
        """
        List of sources in Flowlet.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def transformations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]]:
        """
        List of transformations in Flowlet.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]]):
        pulumi.set(self, "transformations", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of data flow.
        Expected value is 'Flowlet'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ForEachActivityArgs:
    def __init__(__self__, *,
                 activities: pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]],
                 items: pulumi.Input['ExpressionArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 is_sequential: Optional[pulumi.Input[bool]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity is used for iterating over a collection and execute given activities.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] activities: List of activities to execute .
        :param pulumi.Input['ExpressionArgs'] items: Collection to iterate.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'ForEach'.
        :param pulumi.Input[int] batch_count: Batch count to be used for controlling the number of parallel execution (when isSequential is set to false).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[bool] is_sequential: Should the loop be executed in sequence or in parallel (max 50)
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "activities", activities)
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'ForEach')
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_sequential is not None:
            pulumi.set(__self__, "is_sequential", is_sequential)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def activities(self) -> pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]:
        """
        List of activities to execute .
        """
        return pulumi.get(self, "activities")

    @activities.setter
    def activities(self, value: pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]):
        pulumi.set(self, "activities", value)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input['ExpressionArgs']:
        """
        Collection to iterate.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'ForEach'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        Batch count to be used for controlling the number of parallel execution (when isSequential is set to false).
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isSequential")
    def is_sequential(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the loop be executed in sequence or in parallel (max 50)
        """
        return pulumi.get(self, "is_sequential")

    @is_sequential.setter
    def is_sequential(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sequential", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class FtpReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 use_binary_transfer: Optional[pulumi.Input[bool]] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Ftp read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'FtpReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] use_binary_transfer: Specify whether to use binary transfer mode for FTP stores.
        :param Any wildcard_file_name: Ftp wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Ftp wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'FtpReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if use_binary_transfer is not None:
            pulumi.set(__self__, "use_binary_transfer", use_binary_transfer)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'FtpReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="useBinaryTransfer")
    def use_binary_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether to use binary transfer mode for FTP stores.
        """
        return pulumi.get(self, "use_binary_transfer")

    @use_binary_transfer.setter
    def use_binary_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_binary_transfer", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Ftp wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Ftp wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class FtpServerLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'FtpAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        A FTP server Linked Service.
        :param Any host: Host name of the FTP server. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'FtpServer'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'FtpAuthenticationType']] authentication_type: The authentication type to be used to connect to the FTP server.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_server_certificate_validation: If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any enable_ssl: If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to logon the FTP server.
        :param Any port: The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any user_name: Username to logon the FTP server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'FtpServer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name of the FTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'FtpServer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'FtpAuthenticationType']]]:
        """
        The authentication type to be used to connect to the FTP server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'FtpAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @enable_server_certificate_validation.setter
    def enable_server_certificate_validation(self, value: Optional[Any]):
        pulumi.set(self, "enable_server_certificate_validation", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to logon the FTP server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to logon the FTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class FtpServerLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of ftp server dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'FtpServerLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'FtpServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'FtpServerLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class GetMetadataActivityArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetReferenceArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 field_list: Optional[pulumi.Input[Sequence[Any]]] = None,
                 format_settings: Optional[pulumi.Input[Union['BinaryReadSettingsArgs', 'DelimitedTextReadSettingsArgs', 'JsonReadSettingsArgs', 'XmlReadSettingsArgs']]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Activity to get metadata of dataset
        :param pulumi.Input['DatasetReferenceArgs'] dataset: GetMetadata activity dataset reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'GetMetadata'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[Any]] field_list: Fields of metadata to get from dataset.
        :param pulumi.Input[Union['BinaryReadSettingsArgs', 'DelimitedTextReadSettingsArgs', 'JsonReadSettingsArgs', 'XmlReadSettingsArgs']] format_settings: GetMetadata activity format settings.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: GetMetadata activity store settings.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'GetMetadata')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if field_list is not None:
            pulumi.set(__self__, "field_list", field_list)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetReferenceArgs']:
        """
        GetMetadata activity dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetReferenceArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'GetMetadata'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fieldList")
    def field_list(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Fields of metadata to get from dataset.
        """
        return pulumi.get(self, "field_list")

    @field_list.setter
    def field_list(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "field_list", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input[Union['BinaryReadSettingsArgs', 'DelimitedTextReadSettingsArgs', 'JsonReadSettingsArgs', 'XmlReadSettingsArgs']]]:
        """
        GetMetadata activity format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input[Union['BinaryReadSettingsArgs', 'DelimitedTextReadSettingsArgs', 'JsonReadSettingsArgs', 'XmlReadSettingsArgs']]]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        GetMetadata activity store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class GitHubClientSecret:
    def __init__(__self__, *,
                 byoa_secret_akv_url: Optional[str] = None,
                 byoa_secret_name: Optional[str] = None):
        """
        Client secret information for factory's bring your own app repository configuration.
        :param str byoa_secret_akv_url: Bring your own app client secret AKV URL.
        :param str byoa_secret_name: Bring your own app client secret name in AKV.
        """
        if byoa_secret_akv_url is not None:
            pulumi.set(__self__, "byoa_secret_akv_url", byoa_secret_akv_url)
        if byoa_secret_name is not None:
            pulumi.set(__self__, "byoa_secret_name", byoa_secret_name)

    @property
    @pulumi.getter(name="byoaSecretAkvUrl")
    def byoa_secret_akv_url(self) -> Optional[str]:
        """
        Bring your own app client secret AKV URL.
        """
        return pulumi.get(self, "byoa_secret_akv_url")

    @byoa_secret_akv_url.setter
    def byoa_secret_akv_url(self, value: Optional[str]):
        pulumi.set(self, "byoa_secret_akv_url", value)

    @property
    @pulumi.getter(name="byoaSecretName")
    def byoa_secret_name(self) -> Optional[str]:
        """
        Bring your own app client secret name in AKV.
        """
        return pulumi.get(self, "byoa_secret_name")

    @byoa_secret_name.setter
    def byoa_secret_name(self, value: Optional[str]):
        pulumi.set(self, "byoa_secret_name", value)


@pulumi.input_type
class GitHubClientSecretArgs:
    def __init__(__self__, *,
                 byoa_secret_akv_url: Optional[pulumi.Input[str]] = None,
                 byoa_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Client secret information for factory's bring your own app repository configuration.
        :param pulumi.Input[str] byoa_secret_akv_url: Bring your own app client secret AKV URL.
        :param pulumi.Input[str] byoa_secret_name: Bring your own app client secret name in AKV.
        """
        if byoa_secret_akv_url is not None:
            pulumi.set(__self__, "byoa_secret_akv_url", byoa_secret_akv_url)
        if byoa_secret_name is not None:
            pulumi.set(__self__, "byoa_secret_name", byoa_secret_name)

    @property
    @pulumi.getter(name="byoaSecretAkvUrl")
    def byoa_secret_akv_url(self) -> Optional[pulumi.Input[str]]:
        """
        Bring your own app client secret AKV URL.
        """
        return pulumi.get(self, "byoa_secret_akv_url")

    @byoa_secret_akv_url.setter
    def byoa_secret_akv_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byoa_secret_akv_url", value)

    @property
    @pulumi.getter(name="byoaSecretName")
    def byoa_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Bring your own app client secret name in AKV.
        """
        return pulumi.get(self, "byoa_secret_name")

    @byoa_secret_name.setter
    def byoa_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byoa_secret_name", value)


@pulumi.input_type
class GlobalParameterSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'GlobalParameterType']],
                 value: Any):
        """
        Definition of a single parameter for an entity.
        :param pulumi.Input[Union[str, 'GlobalParameterType']] type: Global Parameter type.
        :param Any value: Value of parameter.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'GlobalParameterType']]:
        """
        Global Parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'GlobalParameterType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        Value of parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Any):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GoogleAdWordsLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'GoogleAdWordsAuthenticationType']],
                 client_customer_id: Any,
                 developer_token: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 email: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 key_file_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 refresh_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None):
        """
        Google AdWords service linked service.
        :param pulumi.Input[Union[str, 'GoogleAdWordsAuthenticationType']] authentication_type: The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        :param Any client_customer_id: The Client customer ID of the AdWords account that you want to fetch report data for.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] developer_token: The developer token associated with the manager account that you use to grant access to the AdWords API.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'GoogleAdWords'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret of the google application used to acquire the refresh token.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any email: The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any key_file_path: The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] refresh_token: The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "client_customer_id", client_customer_id)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "type", 'GoogleAdWords')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'GoogleAdWordsAuthenticationType']]:
        """
        The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'GoogleAdWordsAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="clientCustomerID")
    def client_customer_id(self) -> Any:
        """
        The Client customer ID of the AdWords account that you want to fetch report data for.
        """
        return pulumi.get(self, "client_customer_id")

    @client_customer_id.setter
    def client_customer_id(self, value: Any):
        pulumi.set(self, "client_customer_id", value)

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The developer token associated with the manager account that you use to grant access to the AdWords API.
        """
        return pulumi.get(self, "developer_token")

    @developer_token.setter
    def developer_token(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "developer_token", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'GoogleAdWords'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret of the google application used to acquire the refresh token.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[Any]:
        """
        The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[Any]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[Any]:
        """
        The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "key_file_path")

    @key_file_path.setter
    def key_file_path(self, value: Optional[Any]):
        pulumi.set(self, "key_file_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)


@pulumi.input_type
class GoogleAdWordsObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Google AdWords service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'GoogleAdWordsObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GoogleAdWordsObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'GoogleAdWordsObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class GoogleAdWordsSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Google AdWords service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'GoogleAdWordsSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'GoogleAdWordsSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'GoogleAdWordsSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class GoogleBigQueryLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'GoogleBigQueryAuthenticationType']],
                 project: Any,
                 type: pulumi.Input[str],
                 additional_projects: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 email: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 key_file_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 refresh_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 request_google_drive_scope: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None):
        """
        Google BigQuery service linked service.
        :param pulumi.Input[Union[str, 'GoogleBigQueryAuthenticationType']] authentication_type: The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        :param Any project: The default BigQuery project to query against.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'GoogleBigQuery'.
        :param Any additional_projects: A comma-separated list of public BigQuery projects to access.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret of the google application used to acquire the refresh token.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any email: The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any key_file_path: The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] refresh_token: The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
        :param Any request_google_drive_scope: Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine BigQuery data with data from Google Drive. The default value is false.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "type", 'GoogleBigQuery')
        if additional_projects is not None:
            pulumi.set(__self__, "additional_projects", additional_projects)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if request_google_drive_scope is not None:
            pulumi.set(__self__, "request_google_drive_scope", request_google_drive_scope)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'GoogleBigQueryAuthenticationType']]:
        """
        The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'GoogleBigQueryAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def project(self) -> Any:
        """
        The default BigQuery project to query against.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Any):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'GoogleBigQuery'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalProjects")
    def additional_projects(self) -> Optional[Any]:
        """
        A comma-separated list of public BigQuery projects to access.
        """
        return pulumi.get(self, "additional_projects")

    @additional_projects.setter
    def additional_projects(self, value: Optional[Any]):
        pulumi.set(self, "additional_projects", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret of the google application used to acquire the refresh token.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[Any]:
        """
        The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[Any]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[Any]:
        """
        The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "key_file_path")

    @key_file_path.setter
    def key_file_path(self, value: Optional[Any]):
        pulumi.set(self, "key_file_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="requestGoogleDriveScope")
    def request_google_drive_scope(self) -> Optional[Any]:
        """
        Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine BigQuery data with data from Google Drive. The default value is false.
        """
        return pulumi.get(self, "request_google_drive_scope")

    @request_google_drive_scope.setter
    def request_google_drive_scope(self, value: Optional[Any]):
        pulumi.set(self, "request_google_drive_scope", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)


@pulumi.input_type
class GoogleBigQueryObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 dataset: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Google BigQuery service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'GoogleBigQueryObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any dataset: The database name of the Google BigQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Google BigQuery. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using database + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GoogleBigQueryObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'GoogleBigQueryObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[Any]:
        """
        The database name of the Google BigQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[Any]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Google BigQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using database + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class GoogleBigQuerySourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Google BigQuery service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'GoogleBigQuerySource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'GoogleBigQuerySource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'GoogleBigQuerySource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class GoogleCloudStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 secret_access_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_url: Optional[Any] = None):
        """
        Linked service for Google Cloud Storage.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'GoogleCloudStorage'.
        :param Any access_key_id: The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] secret_access_key: The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'GoogleCloudStorage')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'GoogleCloudStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[Any]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[Any]):
        pulumi.set(self, "service_url", value)


@pulumi.input_type
class GoogleCloudStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of Google Cloud Storage dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'GoogleCloudStorageLocation'.
        :param Any bucket_name: Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'GoogleCloudStorageLocation')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'GoogleCloudStorageLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[Any]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class GoogleCloudStorageReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Google Cloud Storage read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'GoogleCloudStorageReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the Google Cloud Storage object name. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Google Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Google Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'GoogleCloudStorageReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'GoogleCloudStorageReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the Google Cloud Storage object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Google Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Google Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class GreenplumLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Greenplum Database linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Greenplum'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Greenplum')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Greenplum'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class GreenplumSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Greenplum Database source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'GreenplumSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'GreenplumSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'GreenplumSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class GreenplumTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Greenplum Database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'GreenplumTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of Greenplum. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GreenplumTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'GreenplumTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of Greenplum. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class HBaseLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'HBaseAuthenticationType']],
                 host: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        HBase server linked service.
        :param pulumi.Input[Union[str, 'HBaseAuthenticationType']] authentication_type: The authentication mechanism to use to connect to the HBase server.
        :param Any host: The IP address or host name of the HBase server. (i.e. 192.168.222.160)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'HBase'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name.
        :param Any port: The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any username: The user name used to connect to the HBase instance.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'HBase')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'HBaseAuthenticationType']]:
        """
        The authentication mechanism to use to connect to the HBase server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'HBaseAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the HBase server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'HBase'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[Any]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the HBase instance.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class HBaseObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        HBase server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'HBaseObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HBaseObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'HBaseObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class HBaseSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity HBase server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'HBaseSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'HBaseSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'HBaseSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class HDInsightHiveActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[Any]]] = None,
                 defines: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 get_debug_info: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 query_timeout: Optional[pulumi.Input[int]] = None,
                 script_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 script_path: Optional[Any] = None,
                 storage_linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 variables: Optional[pulumi.Input[Sequence[Any]]] = None):
        """
        HDInsight Hive activity type.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'HDInsightHive'.
        :param pulumi.Input[Sequence[Any]] arguments: User specified arguments to HDInsightActivity.
        :param pulumi.Input[Mapping[str, Any]] defines: Allows user to specify defines for Hive job request.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']] get_debug_info: Debug info option.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[int] query_timeout: Query timeout value (in minutes).  Effective when the HDInsight cluster is with ESP (Enterprise Security Package)
        :param pulumi.Input['LinkedServiceReferenceArgs'] script_linked_service: Script linked service reference.
        :param Any script_path: Script path. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] storage_linked_services: Storage linked service references.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param pulumi.Input[Sequence[Any]] variables: User specified arguments under hivevar namespace.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'HDInsightHive')
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if defines is not None:
            pulumi.set(__self__, "defines", defines)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if get_debug_info is not None:
            pulumi.set(__self__, "get_debug_info", get_debug_info)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if script_linked_service is not None:
            pulumi.set(__self__, "script_linked_service", script_linked_service)
        if script_path is not None:
            pulumi.set(__self__, "script_path", script_path)
        if storage_linked_services is not None:
            pulumi.set(__self__, "storage_linked_services", storage_linked_services)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'HDInsightHive'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        User specified arguments to HDInsightActivity.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def defines(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Allows user to specify defines for Hive job request.
        """
        return pulumi.get(self, "defines")

    @defines.setter
    def defines(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defines", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="getDebugInfo")
    def get_debug_info(self) -> Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]:
        """
        Debug info option.
        """
        return pulumi.get(self, "get_debug_info")

    @get_debug_info.setter
    def get_debug_info(self, value: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]):
        pulumi.set(self, "get_debug_info", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Query timeout value (in minutes).  Effective when the HDInsight cluster is with ESP (Enterprise Security Package)
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="scriptLinkedService")
    def script_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Script linked service reference.
        """
        return pulumi.get(self, "script_linked_service")

    @script_linked_service.setter
    def script_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "script_linked_service", value)

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> Optional[Any]:
        """
        Script path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "script_path")

    @script_path.setter
    def script_path(self, value: Optional[Any]):
        pulumi.set(self, "script_path", value)

    @property
    @pulumi.getter(name="storageLinkedServices")
    def storage_linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Storage linked service references.
        """
        return pulumi.get(self, "storage_linked_services")

    @storage_linked_services.setter
    def storage_linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "storage_linked_services", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        User specified arguments under hivevar namespace.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class HDInsightLinkedServiceArgs:
    def __init__(__self__, *,
                 cluster_uri: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 file_system: Optional[Any] = None,
                 hcatalog_linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 is_esp_enabled: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        HDInsight linked service.
        :param Any cluster_uri: HDInsight cluster URI. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'HDInsight'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any file_system: Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] hcatalog_linked_service_name: A reference to the Azure SQL linked service that points to the HCatalog database.
        :param Any is_esp_enabled: Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: The Azure Storage linked service reference.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: HDInsight cluster password.
        :param Any user_name: HDInsight cluster user name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "cluster_uri", cluster_uri)
        pulumi.set(__self__, "type", 'HDInsight')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if hcatalog_linked_service_name is not None:
            pulumi.set(__self__, "hcatalog_linked_service_name", hcatalog_linked_service_name)
        if is_esp_enabled is not None:
            pulumi.set(__self__, "is_esp_enabled", is_esp_enabled)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="clusterUri")
    def cluster_uri(self) -> Any:
        """
        HDInsight cluster URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_uri")

    @cluster_uri.setter
    def cluster_uri(self, value: Any):
        pulumi.set(self, "cluster_uri", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'HDInsight'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[Any]:
        """
        Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[Any]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter(name="hcatalogLinkedServiceName")
    def hcatalog_linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        A reference to the Azure SQL linked service that points to the HCatalog database.
        """
        return pulumi.get(self, "hcatalog_linked_service_name")

    @hcatalog_linked_service_name.setter
    def hcatalog_linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "hcatalog_linked_service_name", value)

    @property
    @pulumi.getter(name="isEspEnabled")
    def is_esp_enabled(self) -> Optional[Any]:
        """
        Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
        """
        return pulumi.get(self, "is_esp_enabled")

    @is_esp_enabled.setter
    def is_esp_enabled(self, value: Optional[Any]):
        pulumi.set(self, "is_esp_enabled", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        The Azure Storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        HDInsight cluster password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        HDInsight cluster user name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class HDInsightMapReduceActivityArgs:
    def __init__(__self__, *,
                 class_name: Any,
                 jar_file_path: Any,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[Any]]] = None,
                 defines: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 get_debug_info: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]] = None,
                 jar_libs: Optional[pulumi.Input[Sequence[Any]]] = None,
                 jar_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 storage_linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        HDInsight MapReduce activity type.
        :param Any class_name: Class name. Type: string (or Expression with resultType string).
        :param Any jar_file_path: Jar path. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'HDInsightMapReduce'.
        :param pulumi.Input[Sequence[Any]] arguments: User specified arguments to HDInsightActivity.
        :param pulumi.Input[Mapping[str, Any]] defines: Allows user to specify defines for the MapReduce job request.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']] get_debug_info: Debug info option.
        :param pulumi.Input[Sequence[Any]] jar_libs: Jar libs.
        :param pulumi.Input['LinkedServiceReferenceArgs'] jar_linked_service: Jar linked service reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] storage_linked_services: Storage linked service references.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "class_name", class_name)
        pulumi.set(__self__, "jar_file_path", jar_file_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'HDInsightMapReduce')
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if defines is not None:
            pulumi.set(__self__, "defines", defines)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if get_debug_info is not None:
            pulumi.set(__self__, "get_debug_info", get_debug_info)
        if jar_libs is not None:
            pulumi.set(__self__, "jar_libs", jar_libs)
        if jar_linked_service is not None:
            pulumi.set(__self__, "jar_linked_service", jar_linked_service)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if storage_linked_services is not None:
            pulumi.set(__self__, "storage_linked_services", storage_linked_services)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Any:
        """
        Class name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Any):
        pulumi.set(self, "class_name", value)

    @property
    @pulumi.getter(name="jarFilePath")
    def jar_file_path(self) -> Any:
        """
        Jar path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "jar_file_path")

    @jar_file_path.setter
    def jar_file_path(self, value: Any):
        pulumi.set(self, "jar_file_path", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'HDInsightMapReduce'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        User specified arguments to HDInsightActivity.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def defines(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Allows user to specify defines for the MapReduce job request.
        """
        return pulumi.get(self, "defines")

    @defines.setter
    def defines(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defines", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="getDebugInfo")
    def get_debug_info(self) -> Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]:
        """
        Debug info option.
        """
        return pulumi.get(self, "get_debug_info")

    @get_debug_info.setter
    def get_debug_info(self, value: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]):
        pulumi.set(self, "get_debug_info", value)

    @property
    @pulumi.getter(name="jarLibs")
    def jar_libs(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Jar libs.
        """
        return pulumi.get(self, "jar_libs")

    @jar_libs.setter
    def jar_libs(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "jar_libs", value)

    @property
    @pulumi.getter(name="jarLinkedService")
    def jar_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Jar linked service reference.
        """
        return pulumi.get(self, "jar_linked_service")

    @jar_linked_service.setter
    def jar_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "jar_linked_service", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="storageLinkedServices")
    def storage_linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Storage linked service references.
        """
        return pulumi.get(self, "storage_linked_services")

    @storage_linked_services.setter
    def storage_linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "storage_linked_services", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class HDInsightOnDemandLinkedServiceArgs:
    def __init__(__self__, *,
                 cluster_resource_group: Any,
                 cluster_size: Any,
                 host_subscription_id: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 tenant: Any,
                 time_to_live: Any,
                 type: pulumi.Input[str],
                 version: Any,
                 additional_linked_service_names: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 cluster_name_prefix: Optional[Any] = None,
                 cluster_password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 cluster_ssh_password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 cluster_ssh_user_name: Optional[Any] = None,
                 cluster_type: Optional[Any] = None,
                 cluster_user_name: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 core_configuration: Optional[Any] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 data_node_size: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 h_base_configuration: Optional[Any] = None,
                 hcatalog_linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 hdfs_configuration: Optional[Any] = None,
                 head_node_size: Optional[Any] = None,
                 hive_configuration: Optional[Any] = None,
                 map_reduce_configuration: Optional[Any] = None,
                 oozie_configuration: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 script_actions: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 spark_version: Optional[Any] = None,
                 storm_configuration: Optional[Any] = None,
                 subnet_name: Optional[Any] = None,
                 virtual_network_id: Optional[Any] = None,
                 yarn_configuration: Optional[Any] = None,
                 zookeeper_node_size: Optional[Any] = None):
        """
        HDInsight ondemand linked service.
        :param Any cluster_resource_group: The resource group where the cluster belongs. Type: string (or Expression with resultType string).
        :param Any cluster_size: Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
        :param Any host_subscription_id: The customers subscription to host the cluster. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
        :param Any tenant: The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
        :param Any time_to_live: The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an activity run if there are no other active jobs in the cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'HDInsightOnDemand'.
        :param Any version: Version of the HDInsight cluster. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] additional_linked_service_names: Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them on your behalf.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any cluster_name_prefix: The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] cluster_password: The password to access the cluster.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] cluster_ssh_password: The password to SSH remotely connect clusters node (for Linux).
        :param Any cluster_ssh_user_name: The username to SSH remotely connect to clusters node (for Linux). Type: string (or Expression with resultType string).
        :param Any cluster_type: The cluster type. Type: string (or Expression with resultType string).
        :param Any cluster_user_name: The username to access the cluster. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any core_configuration: Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param Any data_node_size: Specifies the size of the data node for the HDInsight cluster.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any h_base_configuration: Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
        :param pulumi.Input['LinkedServiceReferenceArgs'] hcatalog_linked_service_name: The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by using the Azure SQL database as the metastore.
        :param Any hdfs_configuration: Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
        :param Any head_node_size: Specifies the size of the head node for the HDInsight cluster.
        :param Any hive_configuration: Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
        :param Any map_reduce_configuration: Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
        :param Any oozie_configuration: Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]] script_actions: Custom script actions to run on HDI ondemand cluster once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
        :param Any service_principal_id: The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key for the service principal id.
        :param Any spark_version: The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
        :param Any storm_configuration: Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
        :param Any subnet_name: The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type: string (or Expression with resultType string).
        :param Any virtual_network_id: The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with resultType string).
        :param Any yarn_configuration: Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
        :param Any zookeeper_node_size: Specifies the size of the Zoo Keeper node for the HDInsight cluster.
        """
        pulumi.set(__self__, "cluster_resource_group", cluster_resource_group)
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "host_subscription_id", host_subscription_id)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "time_to_live", time_to_live)
        pulumi.set(__self__, "type", 'HDInsightOnDemand')
        pulumi.set(__self__, "version", version)
        if additional_linked_service_names is not None:
            pulumi.set(__self__, "additional_linked_service_names", additional_linked_service_names)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name_prefix is not None:
            pulumi.set(__self__, "cluster_name_prefix", cluster_name_prefix)
        if cluster_password is not None:
            pulumi.set(__self__, "cluster_password", cluster_password)
        if cluster_ssh_password is not None:
            pulumi.set(__self__, "cluster_ssh_password", cluster_ssh_password)
        if cluster_ssh_user_name is not None:
            pulumi.set(__self__, "cluster_ssh_user_name", cluster_ssh_user_name)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if cluster_user_name is not None:
            pulumi.set(__self__, "cluster_user_name", cluster_user_name)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if core_configuration is not None:
            pulumi.set(__self__, "core_configuration", core_configuration)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if data_node_size is not None:
            pulumi.set(__self__, "data_node_size", data_node_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if h_base_configuration is not None:
            pulumi.set(__self__, "h_base_configuration", h_base_configuration)
        if hcatalog_linked_service_name is not None:
            pulumi.set(__self__, "hcatalog_linked_service_name", hcatalog_linked_service_name)
        if hdfs_configuration is not None:
            pulumi.set(__self__, "hdfs_configuration", hdfs_configuration)
        if head_node_size is not None:
            pulumi.set(__self__, "head_node_size", head_node_size)
        if hive_configuration is not None:
            pulumi.set(__self__, "hive_configuration", hive_configuration)
        if map_reduce_configuration is not None:
            pulumi.set(__self__, "map_reduce_configuration", map_reduce_configuration)
        if oozie_configuration is not None:
            pulumi.set(__self__, "oozie_configuration", oozie_configuration)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if script_actions is not None:
            pulumi.set(__self__, "script_actions", script_actions)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if storm_configuration is not None:
            pulumi.set(__self__, "storm_configuration", storm_configuration)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if yarn_configuration is not None:
            pulumi.set(__self__, "yarn_configuration", yarn_configuration)
        if zookeeper_node_size is not None:
            pulumi.set(__self__, "zookeeper_node_size", zookeeper_node_size)

    @property
    @pulumi.getter(name="clusterResourceGroup")
    def cluster_resource_group(self) -> Any:
        """
        The resource group where the cluster belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_resource_group")

    @cluster_resource_group.setter
    def cluster_resource_group(self, value: Any):
        pulumi.set(self, "cluster_resource_group", value)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Any:
        """
        Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_size")

    @cluster_size.setter
    def cluster_size(self, value: Any):
        pulumi.set(self, "cluster_size", value)

    @property
    @pulumi.getter(name="hostSubscriptionId")
    def host_subscription_id(self) -> Any:
        """
        The customers subscription to host the cluster. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_subscription_id")

    @host_subscription_id.setter
    def host_subscription_id(self, value: Any):
        pulumi.set(self, "host_subscription_id", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Any):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Any:
        """
        The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an activity run if there are no other active jobs in the cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "time_to_live")

    @time_to_live.setter
    def time_to_live(self, value: Any):
        pulumi.set(self, "time_to_live", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'HDInsightOnDemand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Any:
        """
        Version of the HDInsight cluster. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Any):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="additionalLinkedServiceNames")
    def additional_linked_service_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them on your behalf.
        """
        return pulumi.get(self, "additional_linked_service_names")

    @additional_linked_service_names.setter
    def additional_linked_service_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "additional_linked_service_names", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterNamePrefix")
    def cluster_name_prefix(self) -> Optional[Any]:
        """
        The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_name_prefix")

    @cluster_name_prefix.setter
    def cluster_name_prefix(self, value: Optional[Any]):
        pulumi.set(self, "cluster_name_prefix", value)

    @property
    @pulumi.getter(name="clusterPassword")
    def cluster_password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password to access the cluster.
        """
        return pulumi.get(self, "cluster_password")

    @cluster_password.setter
    def cluster_password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "cluster_password", value)

    @property
    @pulumi.getter(name="clusterSshPassword")
    def cluster_ssh_password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password to SSH remotely connect clusters node (for Linux).
        """
        return pulumi.get(self, "cluster_ssh_password")

    @cluster_ssh_password.setter
    def cluster_ssh_password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "cluster_ssh_password", value)

    @property
    @pulumi.getter(name="clusterSshUserName")
    def cluster_ssh_user_name(self) -> Optional[Any]:
        """
        The username to SSH remotely connect to clusters node (for Linux). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_ssh_user_name")

    @cluster_ssh_user_name.setter
    def cluster_ssh_user_name(self, value: Optional[Any]):
        pulumi.set(self, "cluster_ssh_user_name", value)

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[Any]:
        """
        The cluster type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: Optional[Any]):
        pulumi.set(self, "cluster_type", value)

    @property
    @pulumi.getter(name="clusterUserName")
    def cluster_user_name(self) -> Optional[Any]:
        """
        The username to access the cluster. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_user_name")

    @cluster_user_name.setter
    def cluster_user_name(self, value: Optional[Any]):
        pulumi.set(self, "cluster_user_name", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="coreConfiguration")
    def core_configuration(self) -> Optional[Any]:
        """
        Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
        """
        return pulumi.get(self, "core_configuration")

    @core_configuration.setter
    def core_configuration(self, value: Optional[Any]):
        pulumi.set(self, "core_configuration", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter(name="dataNodeSize")
    def data_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the data node for the HDInsight cluster.
        """
        return pulumi.get(self, "data_node_size")

    @data_node_size.setter
    def data_node_size(self, value: Optional[Any]):
        pulumi.set(self, "data_node_size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="hBaseConfiguration")
    def h_base_configuration(self) -> Optional[Any]:
        """
        Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "h_base_configuration")

    @h_base_configuration.setter
    def h_base_configuration(self, value: Optional[Any]):
        pulumi.set(self, "h_base_configuration", value)

    @property
    @pulumi.getter(name="hcatalogLinkedServiceName")
    def hcatalog_linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by using the Azure SQL database as the metastore.
        """
        return pulumi.get(self, "hcatalog_linked_service_name")

    @hcatalog_linked_service_name.setter
    def hcatalog_linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "hcatalog_linked_service_name", value)

    @property
    @pulumi.getter(name="hdfsConfiguration")
    def hdfs_configuration(self) -> Optional[Any]:
        """
        Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "hdfs_configuration")

    @hdfs_configuration.setter
    def hdfs_configuration(self, value: Optional[Any]):
        pulumi.set(self, "hdfs_configuration", value)

    @property
    @pulumi.getter(name="headNodeSize")
    def head_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the head node for the HDInsight cluster.
        """
        return pulumi.get(self, "head_node_size")

    @head_node_size.setter
    def head_node_size(self, value: Optional[Any]):
        pulumi.set(self, "head_node_size", value)

    @property
    @pulumi.getter(name="hiveConfiguration")
    def hive_configuration(self) -> Optional[Any]:
        """
        Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "hive_configuration")

    @hive_configuration.setter
    def hive_configuration(self, value: Optional[Any]):
        pulumi.set(self, "hive_configuration", value)

    @property
    @pulumi.getter(name="mapReduceConfiguration")
    def map_reduce_configuration(self) -> Optional[Any]:
        """
        Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "map_reduce_configuration")

    @map_reduce_configuration.setter
    def map_reduce_configuration(self, value: Optional[Any]):
        pulumi.set(self, "map_reduce_configuration", value)

    @property
    @pulumi.getter(name="oozieConfiguration")
    def oozie_configuration(self) -> Optional[Any]:
        """
        Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "oozie_configuration")

    @oozie_configuration.setter
    def oozie_configuration(self, value: Optional[Any]):
        pulumi.set(self, "oozie_configuration", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]]:
        """
        Custom script actions to run on HDI ondemand cluster once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
        """
        return pulumi.get(self, "script_actions")

    @script_actions.setter
    def script_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]]):
        pulumi.set(self, "script_actions", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key for the service principal id.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[Any]:
        """
        The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: Optional[Any]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="stormConfiguration")
    def storm_configuration(self) -> Optional[Any]:
        """
        Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "storm_configuration")

    @storm_configuration.setter
    def storm_configuration(self, value: Optional[Any]):
        pulumi.set(self, "storm_configuration", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[Any]:
        """
        The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[Any]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[Any]:
        """
        The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[Any]):
        pulumi.set(self, "virtual_network_id", value)

    @property
    @pulumi.getter(name="yarnConfiguration")
    def yarn_configuration(self) -> Optional[Any]:
        """
        Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "yarn_configuration")

    @yarn_configuration.setter
    def yarn_configuration(self, value: Optional[Any]):
        pulumi.set(self, "yarn_configuration", value)

    @property
    @pulumi.getter(name="zookeeperNodeSize")
    def zookeeper_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the Zoo Keeper node for the HDInsight cluster.
        """
        return pulumi.get(self, "zookeeper_node_size")

    @zookeeper_node_size.setter
    def zookeeper_node_size(self, value: Optional[Any]):
        pulumi.set(self, "zookeeper_node_size", value)


@pulumi.input_type
class HDInsightPigActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 arguments: Optional[Any] = None,
                 defines: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 get_debug_info: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 script_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 script_path: Optional[Any] = None,
                 storage_linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        HDInsight Pig activity type.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'HDInsightPig'.
        :param Any arguments: User specified arguments to HDInsightActivity. Type: array (or Expression with resultType array).
        :param pulumi.Input[Mapping[str, Any]] defines: Allows user to specify defines for Pig job request.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']] get_debug_info: Debug info option.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input['LinkedServiceReferenceArgs'] script_linked_service: Script linked service reference.
        :param Any script_path: Script path. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] storage_linked_services: Storage linked service references.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'HDInsightPig')
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if defines is not None:
            pulumi.set(__self__, "defines", defines)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if get_debug_info is not None:
            pulumi.set(__self__, "get_debug_info", get_debug_info)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if script_linked_service is not None:
            pulumi.set(__self__, "script_linked_service", script_linked_service)
        if script_path is not None:
            pulumi.set(__self__, "script_path", script_path)
        if storage_linked_services is not None:
            pulumi.set(__self__, "storage_linked_services", storage_linked_services)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'HDInsightPig'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Any]:
        """
        User specified arguments to HDInsightActivity. Type: array (or Expression with resultType array).
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[Any]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def defines(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Allows user to specify defines for Pig job request.
        """
        return pulumi.get(self, "defines")

    @defines.setter
    def defines(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defines", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="getDebugInfo")
    def get_debug_info(self) -> Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]:
        """
        Debug info option.
        """
        return pulumi.get(self, "get_debug_info")

    @get_debug_info.setter
    def get_debug_info(self, value: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]):
        pulumi.set(self, "get_debug_info", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="scriptLinkedService")
    def script_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Script linked service reference.
        """
        return pulumi.get(self, "script_linked_service")

    @script_linked_service.setter
    def script_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "script_linked_service", value)

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> Optional[Any]:
        """
        Script path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "script_path")

    @script_path.setter
    def script_path(self, value: Optional[Any]):
        pulumi.set(self, "script_path", value)

    @property
    @pulumi.getter(name="storageLinkedServices")
    def storage_linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Storage linked service references.
        """
        return pulumi.get(self, "storage_linked_services")

    @storage_linked_services.setter
    def storage_linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "storage_linked_services", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class HDInsightSparkActivityArgs:
    def __init__(__self__, *,
                 entry_file_path: Any,
                 name: pulumi.Input[str],
                 root_path: Any,
                 type: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[Any]]] = None,
                 class_name: Optional[pulumi.Input[str]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 get_debug_info: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 proxy_user: Optional[Any] = None,
                 spark_config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spark_job_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        HDInsight Spark activity.
        :param Any entry_file_path: The relative path to the root folder of the code/package to be executed. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param Any root_path: The root path in 'sparkJobLinkedService' for all the jobs files. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'HDInsightSpark'.
        :param pulumi.Input[Sequence[Any]] arguments: The user-specified arguments to HDInsightSparkActivity.
        :param pulumi.Input[str] class_name: The application's Java/Spark main class.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']] get_debug_info: Debug info option.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param Any proxy_user: The user to impersonate that will execute the job. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, Any]] spark_config: Spark configuration property.
        :param pulumi.Input['LinkedServiceReferenceArgs'] spark_job_linked_service: The storage linked service for uploading the entry file and dependencies, and for receiving logs.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "entry_file_path", entry_file_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "root_path", root_path)
        pulumi.set(__self__, "type", 'HDInsightSpark')
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if get_debug_info is not None:
            pulumi.set(__self__, "get_debug_info", get_debug_info)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if proxy_user is not None:
            pulumi.set(__self__, "proxy_user", proxy_user)
        if spark_config is not None:
            pulumi.set(__self__, "spark_config", spark_config)
        if spark_job_linked_service is not None:
            pulumi.set(__self__, "spark_job_linked_service", spark_job_linked_service)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="entryFilePath")
    def entry_file_path(self) -> Any:
        """
        The relative path to the root folder of the code/package to be executed. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entry_file_path")

    @entry_file_path.setter
    def entry_file_path(self, value: Any):
        pulumi.set(self, "entry_file_path", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="rootPath")
    def root_path(self) -> Any:
        """
        The root path in 'sparkJobLinkedService' for all the jobs files. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "root_path")

    @root_path.setter
    def root_path(self, value: Any):
        pulumi.set(self, "root_path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'HDInsightSpark'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        The user-specified arguments to HDInsightSparkActivity.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The application's Java/Spark main class.
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_name", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="getDebugInfo")
    def get_debug_info(self) -> Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]:
        """
        Debug info option.
        """
        return pulumi.get(self, "get_debug_info")

    @get_debug_info.setter
    def get_debug_info(self, value: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]):
        pulumi.set(self, "get_debug_info", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="proxyUser")
    def proxy_user(self) -> Optional[Any]:
        """
        The user to impersonate that will execute the job. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "proxy_user")

    @proxy_user.setter
    def proxy_user(self, value: Optional[Any]):
        pulumi.set(self, "proxy_user", value)

    @property
    @pulumi.getter(name="sparkConfig")
    def spark_config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Spark configuration property.
        """
        return pulumi.get(self, "spark_config")

    @spark_config.setter
    def spark_config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_config", value)

    @property
    @pulumi.getter(name="sparkJobLinkedService")
    def spark_job_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        The storage linked service for uploading the entry file and dependencies, and for receiving logs.
        """
        return pulumi.get(self, "spark_job_linked_service")

    @spark_job_linked_service.setter
    def spark_job_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "spark_job_linked_service", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class HDInsightStreamingActivityArgs:
    def __init__(__self__, *,
                 file_paths: pulumi.Input[Sequence[Any]],
                 input: Any,
                 mapper: Any,
                 name: pulumi.Input[str],
                 output: Any,
                 reducer: Any,
                 type: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[Any]]] = None,
                 combiner: Optional[Any] = None,
                 command_environment: Optional[pulumi.Input[Sequence[Any]]] = None,
                 defines: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 file_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 get_debug_info: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 storage_linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        HDInsight streaming activity type.
        :param pulumi.Input[Sequence[Any]] file_paths: Paths to streaming job files. Can be directories.
        :param Any input: Input blob path. Type: string (or Expression with resultType string).
        :param Any mapper: Mapper executable name. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] name: Activity name.
        :param Any output: Output blob path. Type: string (or Expression with resultType string).
        :param Any reducer: Reducer executable name. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'HDInsightStreaming'.
        :param pulumi.Input[Sequence[Any]] arguments: User specified arguments to HDInsightActivity.
        :param Any combiner: Combiner executable name. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] command_environment: Command line environment values.
        :param pulumi.Input[Mapping[str, Any]] defines: Allows user to specify defines for streaming job request.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['LinkedServiceReferenceArgs'] file_linked_service: Linked service reference where the files are located.
        :param pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']] get_debug_info: Debug info option.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] storage_linked_services: Storage linked service references.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "file_paths", file_paths)
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "mapper", mapper)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output", output)
        pulumi.set(__self__, "reducer", reducer)
        pulumi.set(__self__, "type", 'HDInsightStreaming')
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if combiner is not None:
            pulumi.set(__self__, "combiner", combiner)
        if command_environment is not None:
            pulumi.set(__self__, "command_environment", command_environment)
        if defines is not None:
            pulumi.set(__self__, "defines", defines)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_linked_service is not None:
            pulumi.set(__self__, "file_linked_service", file_linked_service)
        if get_debug_info is not None:
            pulumi.set(__self__, "get_debug_info", get_debug_info)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if storage_linked_services is not None:
            pulumi.set(__self__, "storage_linked_services", storage_linked_services)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> pulumi.Input[Sequence[Any]]:
        """
        Paths to streaming job files. Can be directories.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: pulumi.Input[Sequence[Any]]):
        pulumi.set(self, "file_paths", value)

    @property
    @pulumi.getter
    def input(self) -> Any:
        """
        Input blob path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Any):
        pulumi.set(self, "input", value)

    @property
    @pulumi.getter
    def mapper(self) -> Any:
        """
        Mapper executable name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "mapper")

    @mapper.setter
    def mapper(self, value: Any):
        pulumi.set(self, "mapper", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def output(self) -> Any:
        """
        Output blob path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Any):
        pulumi.set(self, "output", value)

    @property
    @pulumi.getter
    def reducer(self) -> Any:
        """
        Reducer executable name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "reducer")

    @reducer.setter
    def reducer(self, value: Any):
        pulumi.set(self, "reducer", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'HDInsightStreaming'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        User specified arguments to HDInsightActivity.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def combiner(self) -> Optional[Any]:
        """
        Combiner executable name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "combiner")

    @combiner.setter
    def combiner(self, value: Optional[Any]):
        pulumi.set(self, "combiner", value)

    @property
    @pulumi.getter(name="commandEnvironment")
    def command_environment(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Command line environment values.
        """
        return pulumi.get(self, "command_environment")

    @command_environment.setter
    def command_environment(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "command_environment", value)

    @property
    @pulumi.getter
    def defines(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Allows user to specify defines for streaming job request.
        """
        return pulumi.get(self, "defines")

    @defines.setter
    def defines(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defines", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileLinkedService")
    def file_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference where the files are located.
        """
        return pulumi.get(self, "file_linked_service")

    @file_linked_service.setter
    def file_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "file_linked_service", value)

    @property
    @pulumi.getter(name="getDebugInfo")
    def get_debug_info(self) -> Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]:
        """
        Debug info option.
        """
        return pulumi.get(self, "get_debug_info")

    @get_debug_info.setter
    def get_debug_info(self, value: Optional[pulumi.Input[Union[str, 'HDInsightActivityDebugInfoOption']]]):
        pulumi.set(self, "get_debug_info", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="storageLinkedServices")
    def storage_linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        Storage linked service references.
        """
        return pulumi.get(self, "storage_linked_services")

    @storage_linked_services.setter
    def storage_linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "storage_linked_services", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class HdfsLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Hadoop Distributed File System (HDFS) linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Hdfs'.
        :param Any url: The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for Windows authentication.
        :param Any user_name: User name for Windows authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Hdfs')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Hdfs'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for Windows authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Windows authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class HdfsLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of HDFS.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'HdfsLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'HdfsLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'HdfsLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class HdfsReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 distcp_settings: Optional[pulumi.Input['DistcpSettingsArgs']] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        HDFS read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'HdfsReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DistcpSettingsArgs'] distcp_settings: Specifies Distcp-related settings.
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: HDFS wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: HDFS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'HdfsReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if distcp_settings is not None:
            pulumi.set(__self__, "distcp_settings", distcp_settings)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'HdfsReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="distcpSettings")
    def distcp_settings(self) -> Optional[pulumi.Input['DistcpSettingsArgs']]:
        """
        Specifies Distcp-related settings.
        """
        return pulumi.get(self, "distcp_settings")

    @distcp_settings.setter
    def distcp_settings(self, value: Optional[pulumi.Input['DistcpSettingsArgs']]):
        pulumi.set(self, "distcp_settings", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        HDFS wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        HDFS wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class HdfsSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 distcp_settings: Optional[pulumi.Input['DistcpSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity HDFS source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'HdfsSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DistcpSettingsArgs'] distcp_settings: Specifies Distcp-related settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'HdfsSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if distcp_settings is not None:
            pulumi.set(__self__, "distcp_settings", distcp_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'HdfsSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="distcpSettings")
    def distcp_settings(self) -> Optional[pulumi.Input['DistcpSettingsArgs']]:
        """
        Specifies Distcp-related settings.
        """
        return pulumi.get(self, "distcp_settings")

    @distcp_settings.setter
    def distcp_settings(self, value: Optional[pulumi.Input['DistcpSettingsArgs']]):
        pulumi.set(self, "distcp_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class HiveLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'HiveAuthenticationType']],
                 host: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 server_type: Optional[pulumi.Input[Union[str, 'HiveServerType']]] = None,
                 service_discovery_mode: Optional[Any] = None,
                 thrift_transport_protocol: Optional[pulumi.Input[Union[str, 'HiveThriftTransportProtocol']]] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_native_query: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None,
                 zoo_keeper_name_space: Optional[Any] = None):
        """
        Hive Server linked service.
        :param pulumi.Input[Union[str, 'HiveAuthenticationType']] authentication_type: The authentication method used to access the Hive server.
        :param Any host: IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Hive'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Hive server.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name that you provided in the Username field
        :param Any port: The TCP port that the Hive server uses to listen for client connections.
        :param pulumi.Input[Union[str, 'HiveServerType']] server_type: The type of Hive server.
        :param Any service_discovery_mode: true to indicate using the ZooKeeper service, false not.
        :param pulumi.Input[Union[str, 'HiveThriftTransportProtocol']] thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_native_query: Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name that you use to access Hive Server.
        :param Any zoo_keeper_name_space: The namespace on ZooKeeper under which Hive Server 2 nodes are added.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Hive')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if service_discovery_mode is not None:
            pulumi.set(__self__, "service_discovery_mode", service_discovery_mode)
        if thrift_transport_protocol is not None:
            pulumi.set(__self__, "thrift_transport_protocol", thrift_transport_protocol)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_native_query is not None:
            pulumi.set(__self__, "use_native_query", use_native_query)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if zoo_keeper_name_space is not None:
            pulumi.set(__self__, "zoo_keeper_name_space", zoo_keeper_name_space)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'HiveAuthenticationType']]:
        """
        The authentication method used to access the Hive server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'HiveAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Hive'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Hive server.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[Any]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name that you provided in the Username field
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Hive server uses to listen for client connections.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[Union[str, 'HiveServerType']]]:
        """
        The type of Hive server.
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[Union[str, 'HiveServerType']]]):
        pulumi.set(self, "server_type", value)

    @property
    @pulumi.getter(name="serviceDiscoveryMode")
    def service_discovery_mode(self) -> Optional[Any]:
        """
        true to indicate using the ZooKeeper service, false not.
        """
        return pulumi.get(self, "service_discovery_mode")

    @service_discovery_mode.setter
    def service_discovery_mode(self, value: Optional[Any]):
        pulumi.set(self, "service_discovery_mode", value)

    @property
    @pulumi.getter(name="thriftTransportProtocol")
    def thrift_transport_protocol(self) -> Optional[pulumi.Input[Union[str, 'HiveThriftTransportProtocol']]]:
        """
        The transport protocol to use in the Thrift layer.
        """
        return pulumi.get(self, "thrift_transport_protocol")

    @thrift_transport_protocol.setter
    def thrift_transport_protocol(self, value: Optional[pulumi.Input[Union[str, 'HiveThriftTransportProtocol']]]):
        pulumi.set(self, "thrift_transport_protocol", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useNativeQuery")
    def use_native_query(self) -> Optional[Any]:
        """
        Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
        """
        return pulumi.get(self, "use_native_query")

    @use_native_query.setter
    def use_native_query(self, value: Optional[Any]):
        pulumi.set(self, "use_native_query", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name that you use to access Hive Server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="zooKeeperNameSpace")
    def zoo_keeper_name_space(self) -> Optional[Any]:
        """
        The namespace on ZooKeeper under which Hive Server 2 nodes are added.
        """
        return pulumi.get(self, "zoo_keeper_name_space")

    @zoo_keeper_name_space.setter
    def zoo_keeper_name_space(self, value: Optional[Any]):
        pulumi.set(self, "zoo_keeper_name_space", value)


@pulumi.input_type
class HiveObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Hive Server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'HiveObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Hive. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HiveObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'HiveObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Hive. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class HiveSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Hive Server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'HiveSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'HiveSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'HiveSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class HttpDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 additional_headers: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 format: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 relative_url: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        A file in an HTTP web server.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'HttpFile'.
        :param Any additional_headers: The headers for the HTTP Request. e.g. request-header-name-1:request-header-value-1
               ...
               request-header-name-n:request-header-value-n Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used on files.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']] format: The format of files.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any relative_url: The relative URL based on the URL in the HttpLinkedService refers to an HTTP file Type: string (or Expression with resultType string).
        :param Any request_body: The body for the HTTP request. Type: string (or Expression with resultType string).
        :param Any request_method: The HTTP method for the HTTP request. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HttpFile')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'HttpFile'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The headers for the HTTP Request. e.g. request-header-name-1:request-header-value-1
        ...
        request-header-name-n:request-header-value-n Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[Any]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used on files.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]:
        """
        The format of files.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[Union['AvroFormatArgs', 'JsonFormatArgs', 'OrcFormatArgs', 'ParquetFormatArgs', 'TextFormatArgs']]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        The relative URL based on the URL in the HttpLinkedService refers to an HTTP file Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: Optional[Any]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The body for the HTTP request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[Any]):
        pulumi.set(self, "request_body", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method for the HTTP request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[Any]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class HttpLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 auth_headers: Optional[Any] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'HttpAuthenticationType']]] = None,
                 cert_thumbprint: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 embedded_cert_data: Optional[Any] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Linked service for an HTTP source.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'HttpServer'.
        :param Any url: The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any auth_headers: The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        :param pulumi.Input[Union[str, 'HttpAuthenticationType']] authentication_type: The authentication type to be used to connect to the HTTP server.
        :param Any cert_thumbprint: Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any embedded_cert_data: Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        :param Any enable_server_certificate_validation: If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
        :param Any user_name: User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'HttpServer')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auth_headers is not None:
            pulumi.set(__self__, "auth_headers", auth_headers)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if cert_thumbprint is not None:
            pulumi.set(__self__, "cert_thumbprint", cert_thumbprint)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if embedded_cert_data is not None:
            pulumi.set(__self__, "embedded_cert_data", embedded_cert_data)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'HttpServer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authHeaders")
    def auth_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "auth_headers")

    @auth_headers.setter
    def auth_headers(self, value: Optional[Any]):
        pulumi.set(self, "auth_headers", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'HttpAuthenticationType']]]:
        """
        The authentication type to be used to connect to the HTTP server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'HttpAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="certThumbprint")
    def cert_thumbprint(self) -> Optional[Any]:
        """
        Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cert_thumbprint")

    @cert_thumbprint.setter
    def cert_thumbprint(self, value: Optional[Any]):
        pulumi.set(self, "cert_thumbprint", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="embeddedCertData")
    def embedded_cert_data(self) -> Optional[Any]:
        """
        Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "embedded_cert_data")

    @embedded_cert_data.setter
    def embedded_cert_data(self, value: Optional[Any]):
        pulumi.set(self, "embedded_cert_data", value)

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @enable_server_certificate_validation.setter
    def enable_server_certificate_validation(self, value: Optional[Any]):
        pulumi.set(self, "enable_server_certificate_validation", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class HttpReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_headers: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 request_timeout: Optional[Any] = None):
        """
        Sftp read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'HttpReadSettings'.
        :param Any additional_headers: The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any request_body: The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        :param Any request_method: The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        :param Any request_timeout: Specifies the timeout for a HTTP client to get HTTP response from HTTP server.
        """
        pulumi.set(__self__, "type", 'HttpReadSettings')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'HttpReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[Any]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[Any]):
        pulumi.set(self, "request_body", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[Any]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for a HTTP client to get HTTP response from HTTP server.
        """
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "request_timeout", value)


@pulumi.input_type
class HttpServerLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 relative_url: Optional[Any] = None):
        """
        The location of http server.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'HttpServerLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any relative_url: Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'HttpServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'HttpServerLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: Optional[Any]):
        pulumi.set(self, "relative_url", value)


@pulumi.input_type
class HttpSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for an HTTP file.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'HttpSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: Specifies the timeout for a HTTP client to get HTTP response from HTTP server. The default value is equivalent to System.Net.HttpWebRequest.Timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'HttpSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'HttpSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for a HTTP client to get HTTP response from HTTP server. The default value is equivalent to System.Net.HttpWebRequest.Timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class HubspotLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 refresh_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Hubspot Service linked service.
        :param Any client_id: The client ID associated with your Hubspot application.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Hubspot'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: The access token obtained when initiallyauthenticatingyourOAuth integration.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret associated with your Hubspot application.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] refresh_token: The refresh token obtained when initiallyauthenticatingyourOAuth integration.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "type", 'Hubspot')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with your Hubspot application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Hubspot'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access token obtained when initiallyauthenticatingyourOAuth integration.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret associated with your Hubspot application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The refresh token obtained when initiallyauthenticatingyourOAuth integration.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class HubspotObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Hubspot Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'HubspotObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HubspotObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'HubspotObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class HubspotSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Hubspot Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'HubspotSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'HubspotSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'HubspotSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class IfConditionActivityArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input['ExpressionArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 if_false_activities: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]] = None,
                 if_true_activities: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity evaluates a boolean expression and executes either the activities under the ifTrueActivities property or the ifFalseActivities property depending on the result of the expression.
        :param pulumi.Input['ExpressionArgs'] expression: An expression that would evaluate to Boolean. This is used to determine the block of activities (ifTrueActivities or ifFalseActivities) that will be executed.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'IfCondition'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] if_false_activities: List of activities to execute if expression is evaluated to false. This is an optional property and if not provided, the activity will exit without any action.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] if_true_activities: List of activities to execute if expression is evaluated to true. This is an optional property and if not provided, the activity will exit without any action.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'IfCondition')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if if_false_activities is not None:
            pulumi.set(__self__, "if_false_activities", if_false_activities)
        if if_true_activities is not None:
            pulumi.set(__self__, "if_true_activities", if_true_activities)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input['ExpressionArgs']:
        """
        An expression that would evaluate to Boolean. This is used to determine the block of activities (ifTrueActivities or ifFalseActivities) that will be executed.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'IfCondition'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ifFalseActivities")
    def if_false_activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]:
        """
        List of activities to execute if expression is evaluated to false. This is an optional property and if not provided, the activity will exit without any action.
        """
        return pulumi.get(self, "if_false_activities")

    @if_false_activities.setter
    def if_false_activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]):
        pulumi.set(self, "if_false_activities", value)

    @property
    @pulumi.getter(name="ifTrueActivities")
    def if_true_activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]:
        """
        List of activities to execute if expression is evaluated to true. This is an optional property and if not provided, the activity will exit without any action.
        """
        return pulumi.get(self, "if_true_activities")

    @if_true_activities.setter
    def if_true_activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]):
        pulumi.set(self, "if_true_activities", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class ImpalaLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'ImpalaAuthenticationType']],
                 host: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Impala server linked service.
        :param pulumi.Input[Union[str, 'ImpalaAuthenticationType']] authentication_type: The authentication type to use.
        :param Any host: The IP address or host name of the Impala server. (i.e. 192.168.222.160)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Impala'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name when using UsernameAndPassword.
        :param Any port: The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Impala')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'ImpalaAuthenticationType']]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'ImpalaAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Impala server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Impala'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name when using UsernameAndPassword.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ImpalaObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Impala server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ImpalaObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Impala. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ImpalaObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ImpalaObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Impala. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ImpalaSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Impala server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ImpalaSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ImpalaSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ImpalaSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class InformixLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Informix linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Informix'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Informix')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Informix'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class InformixSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Informix sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'InformixSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: A query to execute before starting the copy. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'InformixSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'InformixSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        A query to execute before starting the copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class InformixSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for Informix.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'InformixSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'InformixSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'InformixSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class InformixTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Informix table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'InformixTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Informix table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'InformixTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'InformixTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Informix table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class IntegrationRuntimeComputePropertiesArgs:
    def __init__(__self__, *,
                 data_flow_properties: Optional[pulumi.Input['IntegrationRuntimeDataFlowPropertiesArgs']] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 max_parallel_executions_per_node: Optional[pulumi.Input[int]] = None,
                 node_size: Optional[pulumi.Input[str]] = None,
                 number_of_nodes: Optional[pulumi.Input[int]] = None,
                 v_net_properties: Optional[pulumi.Input['IntegrationRuntimeVNetPropertiesArgs']] = None):
        """
        The compute resource properties for managed integration runtime.
        :param pulumi.Input['IntegrationRuntimeDataFlowPropertiesArgs'] data_flow_properties: Data flow properties for managed integration runtime.
        :param pulumi.Input[str] location: The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        :param pulumi.Input[int] max_parallel_executions_per_node: Maximum parallel executions count per node for managed integration runtime.
        :param pulumi.Input[str] node_size: The node size requirement to managed integration runtime.
        :param pulumi.Input[int] number_of_nodes: The required number of nodes for managed integration runtime.
        :param pulumi.Input['IntegrationRuntimeVNetPropertiesArgs'] v_net_properties: VNet properties for managed integration runtime.
        """
        if data_flow_properties is not None:
            pulumi.set(__self__, "data_flow_properties", data_flow_properties)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if max_parallel_executions_per_node is not None:
            pulumi.set(__self__, "max_parallel_executions_per_node", max_parallel_executions_per_node)
        if node_size is not None:
            pulumi.set(__self__, "node_size", node_size)
        if number_of_nodes is not None:
            pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        if v_net_properties is not None:
            pulumi.set(__self__, "v_net_properties", v_net_properties)

    @property
    @pulumi.getter(name="dataFlowProperties")
    def data_flow_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeDataFlowPropertiesArgs']]:
        """
        Data flow properties for managed integration runtime.
        """
        return pulumi.get(self, "data_flow_properties")

    @data_flow_properties.setter
    def data_flow_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeDataFlowPropertiesArgs']]):
        pulumi.set(self, "data_flow_properties", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maxParallelExecutionsPerNode")
    def max_parallel_executions_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum parallel executions count per node for managed integration runtime.
        """
        return pulumi.get(self, "max_parallel_executions_per_node")

    @max_parallel_executions_per_node.setter
    def max_parallel_executions_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallel_executions_per_node", value)

    @property
    @pulumi.getter(name="nodeSize")
    def node_size(self) -> Optional[pulumi.Input[str]]:
        """
        The node size requirement to managed integration runtime.
        """
        return pulumi.get(self, "node_size")

    @node_size.setter
    def node_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_size", value)

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The required number of nodes for managed integration runtime.
        """
        return pulumi.get(self, "number_of_nodes")

    @number_of_nodes.setter
    def number_of_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_nodes", value)

    @property
    @pulumi.getter(name="vNetProperties")
    def v_net_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeVNetPropertiesArgs']]:
        """
        VNet properties for managed integration runtime.
        """
        return pulumi.get(self, "v_net_properties")

    @v_net_properties.setter
    def v_net_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeVNetPropertiesArgs']]):
        pulumi.set(self, "v_net_properties", value)


@pulumi.input_type
class IntegrationRuntimeCustomSetupScriptPropertiesArgs:
    def __init__(__self__, *,
                 blob_container_uri: Optional[pulumi.Input[str]] = None,
                 sas_token: Optional[pulumi.Input['SecureStringArgs']] = None):
        """
        Custom setup script properties for a managed dedicated integration runtime.
        :param pulumi.Input[str] blob_container_uri: The URI of the Azure blob container that contains the custom setup script.
        :param pulumi.Input['SecureStringArgs'] sas_token: The SAS token of the Azure blob container.
        """
        if blob_container_uri is not None:
            pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the Azure blob container that contains the custom setup script.
        """
        return pulumi.get(self, "blob_container_uri")

    @blob_container_uri.setter
    def blob_container_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_container_uri", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input['SecureStringArgs']]:
        """
        The SAS token of the Azure blob container.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input['SecureStringArgs']]):
        pulumi.set(self, "sas_token", value)


@pulumi.input_type
class IntegrationRuntimeCustomerVirtualNetworkArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        The definition and properties of virtual network to which Azure-SSIS integration runtime will join.
        :param pulumi.Input[str] subnet_id: The ID of subnet to which Azure-SSIS integration runtime will join.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of subnet to which Azure-SSIS integration runtime will join.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class IntegrationRuntimeDataFlowPropertiesArgs:
    def __init__(__self__, *,
                 cleanup: Optional[pulumi.Input[bool]] = None,
                 compute_type: Optional[pulumi.Input[Union[str, 'DataFlowComputeType']]] = None,
                 core_count: Optional[pulumi.Input[int]] = None,
                 time_to_live: Optional[pulumi.Input[int]] = None):
        """
        Data flow properties for managed integration runtime.
        :param pulumi.Input[bool] cleanup: Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default is true.
        :param pulumi.Input[Union[str, 'DataFlowComputeType']] compute_type: Compute type of the cluster which will execute data flow job.
        :param pulumi.Input[int] core_count: Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        :param pulumi.Input[int] time_to_live: Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        if cleanup is not None:
            pulumi.set(__self__, "cleanup", cleanup)
        if compute_type is not None:
            pulumi.set(__self__, "compute_type", compute_type)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter
    def cleanup(self) -> Optional[pulumi.Input[bool]]:
        """
        Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default is true.
        """
        return pulumi.get(self, "cleanup")

    @cleanup.setter
    def cleanup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cleanup", value)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> Optional[pulumi.Input[Union[str, 'DataFlowComputeType']]]:
        """
        Compute type of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: Optional[pulumi.Input[Union[str, 'DataFlowComputeType']]]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[int]]:
        """
        Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_count", value)

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[pulumi.Input[int]]:
        """
        Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "time_to_live")

    @time_to_live.setter
    def time_to_live(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_to_live", value)


@pulumi.input_type
class IntegrationRuntimeDataProxyPropertiesArgs:
    def __init__(__self__, *,
                 connect_via: Optional[pulumi.Input['EntityReferenceArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 staging_linked_service: Optional[pulumi.Input['EntityReferenceArgs']] = None):
        """
        Data proxy properties for a managed dedicated integration runtime.
        :param pulumi.Input['EntityReferenceArgs'] connect_via: The self-hosted integration runtime reference.
        :param pulumi.Input[str] path: The path to contain the staged data in the Blob storage.
        :param pulumi.Input['EntityReferenceArgs'] staging_linked_service: The staging linked service reference.
        """
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if staging_linked_service is not None:
            pulumi.set(__self__, "staging_linked_service", staging_linked_service)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['EntityReferenceArgs']]:
        """
        The self-hosted integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['EntityReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to contain the staged data in the Blob storage.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="stagingLinkedService")
    def staging_linked_service(self) -> Optional[pulumi.Input['EntityReferenceArgs']]:
        """
        The staging linked service reference.
        """
        return pulumi.get(self, "staging_linked_service")

    @staging_linked_service.setter
    def staging_linked_service(self, value: Optional[pulumi.Input['EntityReferenceArgs']]):
        pulumi.set(self, "staging_linked_service", value)


@pulumi.input_type
class IntegrationRuntimeReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Integration runtime reference type.
        :param pulumi.Input[str] reference_name: Reference integration runtime name.
        :param pulumi.Input[str] type: Type of integration runtime.
        :param pulumi.Input[Mapping[str, Any]] parameters: Arguments for integration runtime.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference integration runtime name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Arguments for integration runtime.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class IntegrationRuntimeSsisCatalogInfoArgs:
    def __init__(__self__, *,
                 catalog_admin_password: Optional[pulumi.Input['SecureStringArgs']] = None,
                 catalog_admin_user_name: Optional[pulumi.Input[str]] = None,
                 catalog_pricing_tier: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeSsisCatalogPricingTier']]] = None,
                 catalog_server_endpoint: Optional[pulumi.Input[str]] = None,
                 dual_standby_pair_name: Optional[pulumi.Input[str]] = None):
        """
        Catalog information for managed dedicated integration runtime.
        :param pulumi.Input['SecureStringArgs'] catalog_admin_password: The password of the administrator user account of the catalog database.
        :param pulumi.Input[str] catalog_admin_user_name: The administrator user name of catalog database.
        :param pulumi.Input[Union[str, 'IntegrationRuntimeSsisCatalogPricingTier']] catalog_pricing_tier: The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        :param pulumi.Input[str] catalog_server_endpoint: The catalog database server URL.
        :param pulumi.Input[str] dual_standby_pair_name: The dual standby pair name of Azure-SSIS Integration Runtimes to support SSISDB failover.
        """
        if catalog_admin_password is not None:
            pulumi.set(__self__, "catalog_admin_password", catalog_admin_password)
        if catalog_admin_user_name is not None:
            pulumi.set(__self__, "catalog_admin_user_name", catalog_admin_user_name)
        if catalog_pricing_tier is not None:
            pulumi.set(__self__, "catalog_pricing_tier", catalog_pricing_tier)
        if catalog_server_endpoint is not None:
            pulumi.set(__self__, "catalog_server_endpoint", catalog_server_endpoint)
        if dual_standby_pair_name is not None:
            pulumi.set(__self__, "dual_standby_pair_name", dual_standby_pair_name)

    @property
    @pulumi.getter(name="catalogAdminPassword")
    def catalog_admin_password(self) -> Optional[pulumi.Input['SecureStringArgs']]:
        """
        The password of the administrator user account of the catalog database.
        """
        return pulumi.get(self, "catalog_admin_password")

    @catalog_admin_password.setter
    def catalog_admin_password(self, value: Optional[pulumi.Input['SecureStringArgs']]):
        pulumi.set(self, "catalog_admin_password", value)

    @property
    @pulumi.getter(name="catalogAdminUserName")
    def catalog_admin_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The administrator user name of catalog database.
        """
        return pulumi.get(self, "catalog_admin_user_name")

    @catalog_admin_user_name.setter
    def catalog_admin_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_admin_user_name", value)

    @property
    @pulumi.getter(name="catalogPricingTier")
    def catalog_pricing_tier(self) -> Optional[pulumi.Input[Union[str, 'IntegrationRuntimeSsisCatalogPricingTier']]]:
        """
        The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        """
        return pulumi.get(self, "catalog_pricing_tier")

    @catalog_pricing_tier.setter
    def catalog_pricing_tier(self, value: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeSsisCatalogPricingTier']]]):
        pulumi.set(self, "catalog_pricing_tier", value)

    @property
    @pulumi.getter(name="catalogServerEndpoint")
    def catalog_server_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The catalog database server URL.
        """
        return pulumi.get(self, "catalog_server_endpoint")

    @catalog_server_endpoint.setter
    def catalog_server_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_server_endpoint", value)

    @property
    @pulumi.getter(name="dualStandbyPairName")
    def dual_standby_pair_name(self) -> Optional[pulumi.Input[str]]:
        """
        The dual standby pair name of Azure-SSIS Integration Runtimes to support SSISDB failover.
        """
        return pulumi.get(self, "dual_standby_pair_name")

    @dual_standby_pair_name.setter
    def dual_standby_pair_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dual_standby_pair_name", value)


@pulumi.input_type
class IntegrationRuntimeSsisPropertiesArgs:
    def __init__(__self__, *,
                 catalog_info: Optional[pulumi.Input['IntegrationRuntimeSsisCatalogInfoArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 custom_setup_script_properties: Optional[pulumi.Input['IntegrationRuntimeCustomSetupScriptPropertiesArgs']] = None,
                 data_proxy_properties: Optional[pulumi.Input['IntegrationRuntimeDataProxyPropertiesArgs']] = None,
                 edition: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEdition']]] = None,
                 express_custom_setup_properties: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AzPowerShellSetupArgs', 'CmdkeySetupArgs', 'ComponentSetupArgs', 'EnvironmentVariableSetupArgs']]]]] = None,
                 license_type: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeLicenseType']]] = None,
                 package_stores: Optional[pulumi.Input[Sequence[pulumi.Input['PackageStoreArgs']]]] = None):
        """
        SSIS properties for managed integration runtime.
        :param pulumi.Input['IntegrationRuntimeSsisCatalogInfoArgs'] catalog_info: Catalog information for managed dedicated integration runtime.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input['IntegrationRuntimeCustomSetupScriptPropertiesArgs'] custom_setup_script_properties: Custom setup script properties for a managed dedicated integration runtime.
        :param pulumi.Input['IntegrationRuntimeDataProxyPropertiesArgs'] data_proxy_properties: Data proxy properties for a managed dedicated integration runtime.
        :param pulumi.Input[Union[str, 'IntegrationRuntimeEdition']] edition: The edition for the SSIS Integration Runtime
        :param pulumi.Input[Sequence[pulumi.Input[Union['AzPowerShellSetupArgs', 'CmdkeySetupArgs', 'ComponentSetupArgs', 'EnvironmentVariableSetupArgs']]]] express_custom_setup_properties: Custom setup without script properties for a SSIS integration runtime.
        :param pulumi.Input[Union[str, 'IntegrationRuntimeLicenseType']] license_type: License type for bringing your own license scenario.
        :param pulumi.Input[Sequence[pulumi.Input['PackageStoreArgs']]] package_stores: Package stores for the SSIS Integration Runtime.
        """
        if catalog_info is not None:
            pulumi.set(__self__, "catalog_info", catalog_info)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if custom_setup_script_properties is not None:
            pulumi.set(__self__, "custom_setup_script_properties", custom_setup_script_properties)
        if data_proxy_properties is not None:
            pulumi.set(__self__, "data_proxy_properties", data_proxy_properties)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if express_custom_setup_properties is not None:
            pulumi.set(__self__, "express_custom_setup_properties", express_custom_setup_properties)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if package_stores is not None:
            pulumi.set(__self__, "package_stores", package_stores)

    @property
    @pulumi.getter(name="catalogInfo")
    def catalog_info(self) -> Optional[pulumi.Input['IntegrationRuntimeSsisCatalogInfoArgs']]:
        """
        Catalog information for managed dedicated integration runtime.
        """
        return pulumi.get(self, "catalog_info")

    @catalog_info.setter
    def catalog_info(self, value: Optional[pulumi.Input['IntegrationRuntimeSsisCatalogInfoArgs']]):
        pulumi.set(self, "catalog_info", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter(name="customSetupScriptProperties")
    def custom_setup_script_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeCustomSetupScriptPropertiesArgs']]:
        """
        Custom setup script properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "custom_setup_script_properties")

    @custom_setup_script_properties.setter
    def custom_setup_script_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeCustomSetupScriptPropertiesArgs']]):
        pulumi.set(self, "custom_setup_script_properties", value)

    @property
    @pulumi.getter(name="dataProxyProperties")
    def data_proxy_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeDataProxyPropertiesArgs']]:
        """
        Data proxy properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "data_proxy_properties")

    @data_proxy_properties.setter
    def data_proxy_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeDataProxyPropertiesArgs']]):
        pulumi.set(self, "data_proxy_properties", value)

    @property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEdition']]]:
        """
        The edition for the SSIS Integration Runtime
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeEdition']]]):
        pulumi.set(self, "edition", value)

    @property
    @pulumi.getter(name="expressCustomSetupProperties")
    def express_custom_setup_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['AzPowerShellSetupArgs', 'CmdkeySetupArgs', 'ComponentSetupArgs', 'EnvironmentVariableSetupArgs']]]]]:
        """
        Custom setup without script properties for a SSIS integration runtime.
        """
        return pulumi.get(self, "express_custom_setup_properties")

    @express_custom_setup_properties.setter
    def express_custom_setup_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AzPowerShellSetupArgs', 'CmdkeySetupArgs', 'ComponentSetupArgs', 'EnvironmentVariableSetupArgs']]]]]):
        pulumi.set(self, "express_custom_setup_properties", value)

    @property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[Union[str, 'IntegrationRuntimeLicenseType']]]:
        """
        License type for bringing your own license scenario.
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[Union[str, 'IntegrationRuntimeLicenseType']]]):
        pulumi.set(self, "license_type", value)

    @property
    @pulumi.getter(name="packageStores")
    def package_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PackageStoreArgs']]]]:
        """
        Package stores for the SSIS Integration Runtime.
        """
        return pulumi.get(self, "package_stores")

    @package_stores.setter
    def package_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PackageStoreArgs']]]]):
        pulumi.set(self, "package_stores", value)


@pulumi.input_type
class IntegrationRuntimeVNetPropertiesArgs:
    def __init__(__self__, *,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 v_net_id: Optional[pulumi.Input[str]] = None):
        """
        VNet properties for managed integration runtime.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: Resource IDs of the public IP addresses that this integration runtime will use.
        :param pulumi.Input[str] subnet: The name of the subnet this integration runtime will join.
        :param pulumi.Input[str] subnet_id: The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
        :param pulumi.Input[str] v_net_id: The ID of the VNet that this integration runtime will join.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if v_net_id is not None:
            pulumi.set(__self__, "v_net_id", v_net_id)

    @property
    @pulumi.getter(name="publicIPs")
    def public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Resource IDs of the public IP addresses that this integration runtime will use.
        """
        return pulumi.get(self, "public_ips")

    @public_ips.setter
    def public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "public_ips", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the subnet this integration runtime will join.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vNetId")
    def v_net_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the VNet that this integration runtime will join.
        """
        return pulumi.get(self, "v_net_id")

    @v_net_id.setter
    def v_net_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "v_net_id", value)


@pulumi.input_type
class JiraLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 username: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Jira Service linked service.
        :param Any host: The IP address or host name of the Jira service. (e.g. jira.example.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Jira'.
        :param Any username: The user name that you use to access Jira Service.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name that you provided in the username field.
        :param Any port: The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through HTTPS, or 8080 if connecting through HTTP.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Jira')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Jira service. (e.g. jira.example.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Jira'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Jira Service.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Any):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name that you provided in the username field.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through HTTPS, or 8080 if connecting through HTTP.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class JiraObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Jira Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'JiraObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'JiraObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'JiraObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class JiraSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Jira Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'JiraSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'JiraSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'JiraSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class JsonDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encoding_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Json dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the json data storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Json'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the json dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Json')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the json data storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Json'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: Optional[Any]):
        pulumi.set(self, "encoding_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class JsonFormatArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 deserializer: Optional[Any] = None,
                 encoding_name: Optional[Any] = None,
                 file_pattern: Optional[Any] = None,
                 json_node_reference: Optional[Any] = None,
                 json_path_definition: Optional[Any] = None,
                 nesting_separator: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in JSON format.
        :param pulumi.Input[str] type: Type of dataset storage format.
               Expected value is 'JsonFormat'.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any encoding_name: The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
        :param Any file_pattern: File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
        :param Any json_node_reference: The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
        :param Any json_path_definition: The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
        :param Any nesting_separator: The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'JsonFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if file_pattern is not None:
            pulumi.set(__self__, "file_pattern", file_pattern)
        if json_node_reference is not None:
            pulumi.set(__self__, "json_node_reference", json_node_reference)
        if json_path_definition is not None:
            pulumi.set(__self__, "json_path_definition", json_path_definition)
        if nesting_separator is not None:
            pulumi.set(__self__, "nesting_separator", nesting_separator)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage format.
        Expected value is 'JsonFormat'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @deserializer.setter
    def deserializer(self, value: Optional[Any]):
        pulumi.set(self, "deserializer", value)

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: Optional[Any]):
        pulumi.set(self, "encoding_name", value)

    @property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> Optional[Any]:
        """
        File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
        """
        return pulumi.get(self, "file_pattern")

    @file_pattern.setter
    def file_pattern(self, value: Optional[Any]):
        pulumi.set(self, "file_pattern", value)

    @property
    @pulumi.getter(name="jsonNodeReference")
    def json_node_reference(self) -> Optional[Any]:
        """
        The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "json_node_reference")

    @json_node_reference.setter
    def json_node_reference(self, value: Optional[Any]):
        pulumi.set(self, "json_node_reference", value)

    @property
    @pulumi.getter(name="jsonPathDefinition")
    def json_path_definition(self) -> Optional[Any]:
        """
        The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "json_path_definition")

    @json_path_definition.setter
    def json_path_definition(self, value: Optional[Any]):
        pulumi.set(self, "json_path_definition", value)

    @property
    @pulumi.getter(name="nestingSeparator")
    def nesting_separator(self) -> Optional[Any]:
        """
        The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "nesting_separator")

    @nesting_separator.setter
    def nesting_separator(self, value: Optional[Any]):
        pulumi.set(self, "nesting_separator", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[Any]):
        pulumi.set(self, "serializer", value)


@pulumi.input_type
class JsonReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compression_properties: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]] = None):
        """
        Json read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'JsonReadSettings'.
        :param pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']] compression_properties: Compression settings.
        """
        pulumi.set(__self__, "type", 'JsonReadSettings')
        if compression_properties is not None:
            pulumi.set(__self__, "compression_properties", compression_properties)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'JsonReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compressionProperties")
    def compression_properties(self) -> Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]:
        """
        Compression settings.
        """
        return pulumi.get(self, "compression_properties")

    @compression_properties.setter
    def compression_properties(self, value: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]):
        pulumi.set(self, "compression_properties", value)


@pulumi.input_type
class JsonSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['JsonWriteSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Json sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'JsonSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['JsonWriteSettingsArgs'] format_settings: Json format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: Json store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'JsonSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'JsonSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['JsonWriteSettingsArgs']]:
        """
        Json format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['JsonWriteSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        Json store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class JsonSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['JsonReadSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity Json source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'JsonSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['JsonReadSettingsArgs'] format_settings: Json format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Json store settings.
        """
        pulumi.set(__self__, "type", 'JsonSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'JsonSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['JsonReadSettingsArgs']]:
        """
        Json format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['JsonReadSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Json store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class JsonWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_pattern: Optional[Any] = None):
        """
        Json write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'JsonWriteSettings'.
        :param Any file_pattern: File pattern of JSON. This setting controls the way a collection of JSON objects will be treated. The default value is 'setOfObjects'. It is case-sensitive.
        """
        pulumi.set(__self__, "type", 'JsonWriteSettings')
        if file_pattern is not None:
            pulumi.set(__self__, "file_pattern", file_pattern)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'JsonWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> Optional[Any]:
        """
        File pattern of JSON. This setting controls the way a collection of JSON objects will be treated. The default value is 'setOfObjects'. It is case-sensitive.
        """
        return pulumi.get(self, "file_pattern")

    @file_pattern.setter
    def file_pattern(self, value: Optional[Any]):
        pulumi.set(self, "file_pattern", value)


@pulumi.input_type
class LinkedIntegrationRuntimeKeyAuthorizationArgs:
    def __init__(__self__, *,
                 authorization_type: pulumi.Input[str],
                 key: pulumi.Input['SecureStringArgs']):
        """
        The key authorization type integration runtime.
        :param pulumi.Input[str] authorization_type: The authorization type for integration runtime sharing.
               Expected value is 'Key'.
        :param pulumi.Input['SecureStringArgs'] key: The key used for authorization.
        """
        pulumi.set(__self__, "authorization_type", 'Key')
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> pulumi.Input[str]:
        """
        The authorization type for integration runtime sharing.
        Expected value is 'Key'.
        """
        return pulumi.get(self, "authorization_type")

    @authorization_type.setter
    def authorization_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authorization_type", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input['SecureStringArgs']:
        """
        The key used for authorization.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['SecureStringArgs']):
        pulumi.set(self, "key", value)


@pulumi.input_type
class LinkedIntegrationRuntimeRbacAuthorizationArgs:
    def __init__(__self__, *,
                 authorization_type: pulumi.Input[str],
                 resource_id: pulumi.Input[str]):
        """
        The role based access control (RBAC) authorization type integration runtime.
        :param pulumi.Input[str] authorization_type: The authorization type for integration runtime sharing.
               Expected value is 'RBAC'.
        :param pulumi.Input[str] resource_id: The resource identifier of the integration runtime to be shared.
        """
        pulumi.set(__self__, "authorization_type", 'RBAC')
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> pulumi.Input[str]:
        """
        The authorization type for integration runtime sharing.
        Expected value is 'RBAC'.
        """
        return pulumi.get(self, "authorization_type")

    @authorization_type.setter
    def authorization_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authorization_type", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        The resource identifier of the integration runtime to be shared.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class LinkedServiceReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Linked service reference type.
        :param pulumi.Input[str] reference_name: Reference LinkedService name.
        :param pulumi.Input[str] type: Linked service reference type.
        :param pulumi.Input[Mapping[str, Any]] parameters: Arguments for LinkedService.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference LinkedService name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Linked service reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Arguments for LinkedService.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class LogLocationSettingsArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 path: Optional[Any] = None):
        """
        Log location settings.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Log storage linked service reference.
        :param Any path: The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Log storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LogSettingsArgs:
    def __init__(__self__, *,
                 log_location_settings: pulumi.Input['LogLocationSettingsArgs'],
                 copy_activity_log_settings: Optional[pulumi.Input['CopyActivityLogSettingsArgs']] = None,
                 enable_copy_activity_log: Optional[Any] = None):
        """
        Log settings.
        :param pulumi.Input['LogLocationSettingsArgs'] log_location_settings: Log location settings customer needs to provide when enabling log.
        :param pulumi.Input['CopyActivityLogSettingsArgs'] copy_activity_log_settings: Specifies settings for copy activity log.
        :param Any enable_copy_activity_log: Specifies whether to enable copy activity log. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "log_location_settings", log_location_settings)
        if copy_activity_log_settings is not None:
            pulumi.set(__self__, "copy_activity_log_settings", copy_activity_log_settings)
        if enable_copy_activity_log is not None:
            pulumi.set(__self__, "enable_copy_activity_log", enable_copy_activity_log)

    @property
    @pulumi.getter(name="logLocationSettings")
    def log_location_settings(self) -> pulumi.Input['LogLocationSettingsArgs']:
        """
        Log location settings customer needs to provide when enabling log.
        """
        return pulumi.get(self, "log_location_settings")

    @log_location_settings.setter
    def log_location_settings(self, value: pulumi.Input['LogLocationSettingsArgs']):
        pulumi.set(self, "log_location_settings", value)

    @property
    @pulumi.getter(name="copyActivityLogSettings")
    def copy_activity_log_settings(self) -> Optional[pulumi.Input['CopyActivityLogSettingsArgs']]:
        """
        Specifies settings for copy activity log.
        """
        return pulumi.get(self, "copy_activity_log_settings")

    @copy_activity_log_settings.setter
    def copy_activity_log_settings(self, value: Optional[pulumi.Input['CopyActivityLogSettingsArgs']]):
        pulumi.set(self, "copy_activity_log_settings", value)

    @property
    @pulumi.getter(name="enableCopyActivityLog")
    def enable_copy_activity_log(self) -> Optional[Any]:
        """
        Specifies whether to enable copy activity log. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_copy_activity_log")

    @enable_copy_activity_log.setter
    def enable_copy_activity_log(self, value: Optional[Any]):
        pulumi.set(self, "enable_copy_activity_log", value)


@pulumi.input_type
class LogStorageSettingsArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 enable_reliable_logging: Optional[Any] = None,
                 log_level: Optional[Any] = None,
                 path: Optional[Any] = None):
        """
        (Deprecated. Please use LogSettings) Log storage settings.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Log storage linked service reference.
        :param Any enable_reliable_logging: Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
        :param Any log_level: Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
        :param Any path: The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        if enable_reliable_logging is not None:
            pulumi.set(__self__, "enable_reliable_logging", enable_reliable_logging)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Log storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="enableReliableLogging")
    def enable_reliable_logging(self) -> Optional[Any]:
        """
        Specifies whether to enable reliable logging. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_reliable_logging")

    @enable_reliable_logging.setter
    def enable_reliable_logging(self, value: Optional[Any]):
        pulumi.set(self, "enable_reliable_logging", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[Any]:
        """
        Gets or sets the log level, support: Info, Warning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[Any]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LookupActivityArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetReferenceArgs'],
                 name: pulumi.Input[str],
                 source: pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 first_row_only: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Lookup activity.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Lookup activity dataset reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']] source: Dataset-specific source properties, same as copy activity source.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Lookup'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any first_row_only: Whether to return first row or all rows. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", 'Lookup')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if first_row_only is not None:
            pulumi.set(__self__, "first_row_only", first_row_only)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetReferenceArgs']:
        """
        Lookup activity dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetReferenceArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']]:
        """
        Dataset-specific source properties, same as copy activity source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[Union['AmazonMWSSourceArgs', 'AmazonRdsForOracleSourceArgs', 'AmazonRdsForSqlServerSourceArgs', 'AmazonRedshiftSourceArgs', 'AvroSourceArgs', 'AzureBlobFSSourceArgs', 'AzureDataExplorerSourceArgs', 'AzureDataLakeStoreSourceArgs', 'AzureDatabricksDeltaLakeSourceArgs', 'AzureMariaDBSourceArgs', 'AzureMySqlSourceArgs', 'AzurePostgreSqlSourceArgs', 'AzureSqlSourceArgs', 'AzureTableSourceArgs', 'BinarySourceArgs', 'BlobSourceArgs', 'CassandraSourceArgs', 'CommonDataServiceForAppsSourceArgs', 'ConcurSourceArgs', 'CosmosDbMongoDbApiSourceArgs', 'CosmosDbSqlApiSourceArgs', 'CouchbaseSourceArgs', 'Db2SourceArgs', 'DelimitedTextSourceArgs', 'DocumentDbCollectionSourceArgs', 'DrillSourceArgs', 'DynamicsAXSourceArgs', 'DynamicsCrmSourceArgs', 'DynamicsSourceArgs', 'EloquaSourceArgs', 'ExcelSourceArgs', 'FileSystemSourceArgs', 'GoogleAdWordsSourceArgs', 'GoogleBigQuerySourceArgs', 'GreenplumSourceArgs', 'HBaseSourceArgs', 'HdfsSourceArgs', 'HiveSourceArgs', 'HttpSourceArgs', 'HubspotSourceArgs', 'ImpalaSourceArgs', 'InformixSourceArgs', 'JiraSourceArgs', 'JsonSourceArgs', 'MagentoSourceArgs', 'MariaDBSourceArgs', 'MarketoSourceArgs', 'MicrosoftAccessSourceArgs', 'MongoDbAtlasSourceArgs', 'MongoDbSourceArgs', 'MongoDbV2SourceArgs', 'MySqlSourceArgs', 'NetezzaSourceArgs', 'ODataSourceArgs', 'OdbcSourceArgs', 'Office365SourceArgs', 'OracleServiceCloudSourceArgs', 'OracleSourceArgs', 'OrcSourceArgs', 'ParquetSourceArgs', 'PaypalSourceArgs', 'PhoenixSourceArgs', 'PostgreSqlSourceArgs', 'PrestoSourceArgs', 'QuickBooksSourceArgs', 'RelationalSourceArgs', 'ResponsysSourceArgs', 'RestSourceArgs', 'SalesforceMarketingCloudSourceArgs', 'SalesforceServiceCloudSourceArgs', 'SalesforceSourceArgs', 'SapBwSourceArgs', 'SapCloudForCustomerSourceArgs', 'SapEccSourceArgs', 'SapHanaSourceArgs', 'SapOpenHubSourceArgs', 'SapTableSourceArgs', 'ServiceNowSourceArgs', 'SharePointOnlineListSourceArgs', 'ShopifySourceArgs', 'SnowflakeSourceArgs', 'SparkSourceArgs', 'SqlDWSourceArgs', 'SqlMISourceArgs', 'SqlServerSourceArgs', 'SqlSourceArgs', 'SquareSourceArgs', 'SybaseSourceArgs', 'TabularSourceArgs', 'TeradataSourceArgs', 'VerticaSourceArgs', 'WebSourceArgs', 'XeroSourceArgs', 'XmlSourceArgs', 'ZohoSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Lookup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="firstRowOnly")
    def first_row_only(self) -> Optional[Any]:
        """
        Whether to return first row or all rows. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_only")

    @first_row_only.setter
    def first_row_only(self, value: Optional[Any]):
        pulumi.set(self, "first_row_only", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class MagentoLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Magento server linked service.
        :param Any host: The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Magento'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: The access token from Magento.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Magento')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Magento'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access token from Magento.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class MagentoObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Magento server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MagentoObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MagentoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MagentoObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class MagentoSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Magento server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MagentoSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MagentoSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MagentoSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class ManagedIntegrationRuntimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compute_properties: Optional[pulumi.Input['IntegrationRuntimeComputePropertiesArgs']] = None,
                 customer_virtual_network: Optional[pulumi.Input['IntegrationRuntimeCustomerVirtualNetworkArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 managed_virtual_network: Optional[pulumi.Input['ManagedVirtualNetworkReferenceArgs']] = None,
                 ssis_properties: Optional[pulumi.Input['IntegrationRuntimeSsisPropertiesArgs']] = None):
        """
        Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
        :param pulumi.Input[str] type: The type of integration runtime.
               Expected value is 'Managed'.
        :param pulumi.Input['IntegrationRuntimeComputePropertiesArgs'] compute_properties: The compute resource for managed integration runtime.
        :param pulumi.Input['IntegrationRuntimeCustomerVirtualNetworkArgs'] customer_virtual_network: The name of virtual network to which Azure-SSIS integration runtime will join
        :param pulumi.Input[str] description: Integration runtime description.
        :param pulumi.Input['ManagedVirtualNetworkReferenceArgs'] managed_virtual_network: Managed Virtual Network reference.
        :param pulumi.Input['IntegrationRuntimeSsisPropertiesArgs'] ssis_properties: SSIS properties for managed integration runtime.
        """
        pulumi.set(__self__, "type", 'Managed')
        if compute_properties is not None:
            pulumi.set(__self__, "compute_properties", compute_properties)
        if customer_virtual_network is not None:
            pulumi.set(__self__, "customer_virtual_network", customer_virtual_network)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if managed_virtual_network is not None:
            pulumi.set(__self__, "managed_virtual_network", managed_virtual_network)
        if ssis_properties is not None:
            pulumi.set(__self__, "ssis_properties", ssis_properties)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of integration runtime.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="computeProperties")
    def compute_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeComputePropertiesArgs']]:
        """
        The compute resource for managed integration runtime.
        """
        return pulumi.get(self, "compute_properties")

    @compute_properties.setter
    def compute_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeComputePropertiesArgs']]):
        pulumi.set(self, "compute_properties", value)

    @property
    @pulumi.getter(name="customerVirtualNetwork")
    def customer_virtual_network(self) -> Optional[pulumi.Input['IntegrationRuntimeCustomerVirtualNetworkArgs']]:
        """
        The name of virtual network to which Azure-SSIS integration runtime will join
        """
        return pulumi.get(self, "customer_virtual_network")

    @customer_virtual_network.setter
    def customer_virtual_network(self, value: Optional[pulumi.Input['IntegrationRuntimeCustomerVirtualNetworkArgs']]):
        pulumi.set(self, "customer_virtual_network", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="managedVirtualNetwork")
    def managed_virtual_network(self) -> Optional[pulumi.Input['ManagedVirtualNetworkReferenceArgs']]:
        """
        Managed Virtual Network reference.
        """
        return pulumi.get(self, "managed_virtual_network")

    @managed_virtual_network.setter
    def managed_virtual_network(self, value: Optional[pulumi.Input['ManagedVirtualNetworkReferenceArgs']]):
        pulumi.set(self, "managed_virtual_network", value)

    @property
    @pulumi.getter(name="ssisProperties")
    def ssis_properties(self) -> Optional[pulumi.Input['IntegrationRuntimeSsisPropertiesArgs']]:
        """
        SSIS properties for managed integration runtime.
        """
        return pulumi.get(self, "ssis_properties")

    @ssis_properties.setter
    def ssis_properties(self, value: Optional[pulumi.Input['IntegrationRuntimeSsisPropertiesArgs']]):
        pulumi.set(self, "ssis_properties", value)


@pulumi.input_type
class ManagedPrivateEndpointArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_id: Optional[pulumi.Input[str]] = None,
                 private_link_resource_id: Optional[pulumi.Input[str]] = None):
        """
        Properties of a managed private endpoint
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fqdns: Fully qualified domain names
        :param pulumi.Input[str] group_id: The groupId to which the managed private endpoint is created
        :param pulumi.Input[str] private_link_resource_id: The ARM resource ID of the resource to which the managed private endpoint is created
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fully qualified domain names
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The groupId to which the managed private endpoint is created
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM resource ID of the resource to which the managed private endpoint is created
        """
        return pulumi.get(self, "private_link_resource_id")

    @private_link_resource_id.setter
    def private_link_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_resource_id", value)


@pulumi.input_type
class ManagedVirtualNetworkReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Managed Virtual Network reference type.
        :param pulumi.Input[str] reference_name: Reference ManagedVirtualNetwork name.
        :param pulumi.Input[str] type: Managed Virtual Network reference type.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference ManagedVirtualNetwork name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Managed Virtual Network reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MappingDataFlowArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DataFlowFolderArgs']] = None,
                 script: Optional[pulumi.Input[str]] = None,
                 script_lines: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sinks: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]] = None,
                 transformations: Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Mapping data flow.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the data flow.
        :param pulumi.Input[str] description: The description of the data flow.
        :param pulumi.Input['DataFlowFolderArgs'] folder: The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param pulumi.Input[str] script: DataFlow script.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] script_lines: Data flow script lines.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]] sinks: List of sinks in data flow.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]] sources: List of sources in data flow.
        :param pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]] transformations: List of transformations in data flow.
        :param pulumi.Input[str] type: Type of data flow.
               Expected value is 'MappingDataFlow'.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_lines is not None:
            pulumi.set(__self__, "script_lines", script_lines)
        if sinks is not None:
            pulumi.set(__self__, "sinks", sinks)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if type is not None:
            pulumi.set(__self__, "type", 'MappingDataFlow')

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the data flow.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the data flow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DataFlowFolderArgs']]:
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DataFlowFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        DataFlow script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter(name="scriptLines")
    def script_lines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Data flow script lines.
        """
        return pulumi.get(self, "script_lines")

    @script_lines.setter
    def script_lines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "script_lines", value)

    @property
    @pulumi.getter
    def sinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]]:
        """
        List of sinks in data flow.
        """
        return pulumi.get(self, "sinks")

    @sinks.setter
    def sinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSinkArgs']]]]):
        pulumi.set(self, "sinks", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]]:
        """
        List of sources in data flow.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def transformations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]]:
        """
        List of transformations in data flow.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TransformationArgs']]]]):
        pulumi.set(self, "transformations", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of data flow.
        Expected value is 'MappingDataFlow'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MariaDBLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        MariaDB server linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MariaDB'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'MariaDB')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MariaDB'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class MariaDBSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity MariaDB server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MariaDBSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MariaDBSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MariaDBSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MariaDBTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        MariaDB server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MariaDBTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MariaDBTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MariaDBTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class MarketoLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 endpoint: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Marketo server linked service.
        :param Any client_id: The client Id of your Marketo service.
        :param Any endpoint: The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Marketo'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret of your Marketo service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Marketo')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client Id of your Marketo service.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Marketo'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret of your Marketo service.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class MarketoObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Marketo server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MarketoObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MarketoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MarketoObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class MarketoSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Marketo server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MarketoSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MarketoSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MarketoSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MetadataItemArgs:
    def __init__(__self__, *,
                 name: Optional[Any] = None,
                 value: Optional[Any] = None):
        """
        Specify the name and value of custom metadata item.
        :param Any name: Metadata item key name. Type: string (or Expression with resultType string).
        :param Any value: Metadata item value. Type: string (or Expression with resultType string).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[Any]:
        """
        Metadata item key name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[Any]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Metadata item value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MicrosoftAccessLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Microsoft Access linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MicrosoftAccess'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'MicrosoftAccess')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MicrosoftAccess'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class MicrosoftAccessSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Microsoft Access sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'MicrosoftAccessSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: A query to execute before starting the copy. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MicrosoftAccessSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'MicrosoftAccessSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        A query to execute before starting the copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class MicrosoftAccessSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for Microsoft Access.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MicrosoftAccessSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MicrosoftAccessSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MicrosoftAccessSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MicrosoftAccessTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Microsoft Access table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MicrosoftAccessTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Microsoft Access table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MicrosoftAccessTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MicrosoftAccessTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Microsoft Access table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class MongoDbAtlasCollectionDatasetArgs:
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB Atlas database dataset.
        :param Any collection: The collection name of the MongoDB Atlas database. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MongoDbAtlasCollection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbAtlasCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the MongoDB Atlas database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Any):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MongoDbAtlasCollection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class MongoDbAtlasLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Linked service for MongoDB Atlas data source.
        :param Any connection_string: The MongoDB Atlas connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the MongoDB Atlas database that you want to access. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MongoDbAtlas'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'MongoDbAtlas')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The MongoDB Atlas connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the MongoDB Atlas database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MongoDbAtlas'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class MongoDbAtlasSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity MongoDB Atlas sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'MongoDbAtlasSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'MongoDbAtlasSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'MongoDbAtlasSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class MongoDbAtlasSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 batch_size: Optional[Any] = None,
                 cursor_methods: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 filter: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for a MongoDB Atlas database.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MongoDbAtlasSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any batch_size: Specifies the number of documents to return in each batch of the response from MongoDB Atlas instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        :param pulumi.Input['MongoDbCursorMethodsPropertiesArgs'] cursor_methods: Cursor methods for Mongodb query
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any filter: Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MongoDbAtlasSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if cursor_methods is not None:
            pulumi.set(__self__, "cursor_methods", cursor_methods)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MongoDbAtlasSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[Any]:
        """
        Specifies the number of documents to return in each batch of the response from MongoDB Atlas instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[Any]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="cursorMethods")
    def cursor_methods(self) -> Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]:
        """
        Cursor methods for Mongodb query
        """
        return pulumi.get(self, "cursor_methods")

    @cursor_methods.setter
    def cursor_methods(self, value: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]):
        pulumi.set(self, "cursor_methods", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[Any]:
        """
        Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[Any]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MongoDbCollectionDatasetArgs:
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB database dataset.
        :param Any collection_name: The table name of the MongoDB database. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MongoDbCollection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        The table name of the MongoDB database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Any):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MongoDbCollection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class MongoDbCursorMethodsPropertiesArgs:
    def __init__(__self__, *,
                 limit: Optional[Any] = None,
                 project: Optional[Any] = None,
                 skip: Optional[Any] = None,
                 sort: Optional[Any] = None):
        """
        Cursor methods for Mongodb query
        :param Any limit: Specifies the maximum number of documents the server returns. limit() is analogous to the LIMIT statement in a SQL database. Type: integer (or Expression with resultType integer).
        :param Any project: Specifies the fields to return in the documents that match the query filter. To return all fields in the matching documents, omit this parameter. Type: string (or Expression with resultType string).
        :param Any skip: Specifies the how many documents skipped and where MongoDB begins returning results. This approach may be useful in implementing paginated results. Type: integer (or Expression with resultType integer).
        :param Any sort: Specifies the order in which the query returns matching documents. Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def limit(self) -> Optional[Any]:
        """
        Specifies the maximum number of documents the server returns. limit() is analogous to the LIMIT statement in a SQL database. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[Any]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[Any]:
        """
        Specifies the fields to return in the documents that match the query filter. To return all fields in the matching documents, omit this parameter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[Any]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def skip(self) -> Optional[Any]:
        """
        Specifies the how many documents skipped and where MongoDB begins returning results. This approach may be useful in implementing paginated results. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: Optional[Any]):
        pulumi.set(self, "skip", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[Any]:
        """
        Specifies the order in which the query returns matching documents. Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[Any]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class MongoDbLinkedServiceArgs:
    def __init__(__self__, *,
                 database_name: Any,
                 server: Any,
                 type: pulumi.Input[str],
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 auth_source: Optional[Any] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'MongoDbAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for MongoDb data source.
        :param Any database_name: The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        :param Any server: The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MongoDb'.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any auth_source: Database to verify the username and password. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union[str, 'MongoDbAuthenticationType']] authentication_type: The authentication type to be used to connect to the MongoDB database.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for authentication.
        :param Any port: The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'MongoDb')
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Any:
        """
        The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Any):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Any):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MongoDb'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[Any]:
        """
        Database to verify the username and password. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[Any]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'MongoDbAuthenticationType']]]:
        """
        The authentication type to be used to connect to the MongoDB database.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'MongoDbAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class MongoDbSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for a MongoDB database.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MongoDbSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Should be a SQL-92 query expression. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MongoDbSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MongoDbSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Should be a SQL-92 query expression. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MongoDbV2CollectionDatasetArgs:
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB database dataset.
        :param Any collection: The collection name of the MongoDB database. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MongoDbV2Collection'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbV2Collection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the MongoDB database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Any):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MongoDbV2Collection'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class MongoDbV2LinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Linked service for MongoDB data source.
        :param Any connection_string: The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MongoDbV2'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'MongoDbV2')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MongoDbV2'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class MongoDbV2SinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity MongoDB sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'MongoDbV2Sink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'MongoDbV2Sink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'MongoDbV2Sink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string (or Expression with resultType string). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class MongoDbV2SourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 batch_size: Optional[Any] = None,
                 cursor_methods: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 filter: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for a MongoDB database.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MongoDbV2Source'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any batch_size: Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        :param pulumi.Input['MongoDbCursorMethodsPropertiesArgs'] cursor_methods: Cursor methods for Mongodb query
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any filter: Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MongoDbV2Source')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if cursor_methods is not None:
            pulumi.set(__self__, "cursor_methods", cursor_methods)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MongoDbV2Source'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[Any]:
        """
        Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect the user or the application. This property's main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[Any]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="cursorMethods")
    def cursor_methods(self) -> Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]:
        """
        Cursor methods for Mongodb query
        """
        return pulumi.get(self, "cursor_methods")

    @cursor_methods.setter
    def cursor_methods(self, value: Optional[pulumi.Input['MongoDbCursorMethodsPropertiesArgs']]):
        pulumi.set(self, "cursor_methods", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[Any]:
        """
        Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[Any]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MultiplePipelineTriggerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]] = None):
        """
        Base class for all triggers that support one to many model for trigger to pipeline.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'MultiplePipelineTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]] pipelines: Pipelines that need to be started.
        """
        pulumi.set(__self__, "type", 'MultiplePipelineTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'MultiplePipelineTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]):
        pulumi.set(self, "pipelines", value)


@pulumi.input_type
class MySqlLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Linked service for MySQL data source.
        :param Any connection_string: The connection string.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'MySql'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'MySql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'MySql'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class MySqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for MySQL databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'MySqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'MySqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'MySqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class MySqlTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The MySQL table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'MySqlTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The MySQL table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MySqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'MySqlTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The MySQL table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class NetezzaLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Netezza linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Netezza'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Netezza')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Netezza'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class NetezzaPartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for Netezza source partitioning.
        :param Any partition_column_name: The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_upper_bound: The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class NetezzaSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['NetezzaPartitionSettingsArgs']] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Netezza source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'NetezzaSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Netezza read in parallel. Possible values include: "None", "DataSlice", "DynamicRange".
        :param pulumi.Input['NetezzaPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Netezza source partitioning.
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'NetezzaSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'NetezzaSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Netezza read in parallel. Possible values include: "None", "DataSlice", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['NetezzaPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Netezza source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['NetezzaPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class NetezzaTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Netezza dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'NetezzaTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Netezza. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'NetezzaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'NetezzaTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Netezza. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ODataLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 aad_resource_id: Optional[Any] = None,
                 aad_service_principal_credential_type: Optional[pulumi.Input[Union[str, 'ODataAadServicePrincipalCredentialType']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 auth_headers: Optional[Any] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'ODataAuthenticationType']]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_embedded_cert: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_embedded_cert_password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Open Data Protocol (OData) linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'OData'.
        :param Any url: The URL of the OData service endpoint. Type: string (or Expression with resultType string).
        :param Any aad_resource_id: Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union[str, 'ODataAadServicePrincipalCredentialType']] aad_service_principal_credential_type: Specify the credential type (key or cert) is used for service principal.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any auth_headers: The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        :param pulumi.Input[Union[str, 'ODataAuthenticationType']] authentication_type: Type of authentication used to connect to the OData service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password of the OData service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_embedded_cert: Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_embedded_cert_password: Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Any tenant: Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression with resultType string).
        :param Any user_name: User name of the OData service. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OData')
        pulumi.set(__self__, "url", url)
        if aad_resource_id is not None:
            pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        if aad_service_principal_credential_type is not None:
            pulumi.set(__self__, "aad_service_principal_credential_type", aad_service_principal_credential_type)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auth_headers is not None:
            pulumi.set(__self__, "auth_headers", auth_headers)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_embedded_cert is not None:
            pulumi.set(__self__, "service_principal_embedded_cert", service_principal_embedded_cert)
        if service_principal_embedded_cert_password is not None:
            pulumi.set(__self__, "service_principal_embedded_cert_password", service_principal_embedded_cert_password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'OData'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the OData service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Optional[Any]:
        """
        Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "aad_resource_id")

    @aad_resource_id.setter
    def aad_resource_id(self, value: Optional[Any]):
        pulumi.set(self, "aad_resource_id", value)

    @property
    @pulumi.getter(name="aadServicePrincipalCredentialType")
    def aad_service_principal_credential_type(self) -> Optional[pulumi.Input[Union[str, 'ODataAadServicePrincipalCredentialType']]]:
        """
        Specify the credential type (key or cert) is used for service principal.
        """
        return pulumi.get(self, "aad_service_principal_credential_type")

    @aad_service_principal_credential_type.setter
    def aad_service_principal_credential_type(self, value: Optional[pulumi.Input[Union[str, 'ODataAadServicePrincipalCredentialType']]]):
        pulumi.set(self, "aad_service_principal_credential_type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authHeaders")
    def auth_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "auth_headers")

    @auth_headers.setter
    def auth_headers(self, value: Optional[Any]):
        pulumi.set(self, "auth_headers", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'ODataAuthenticationType']]]:
        """
        Type of authentication used to connect to the OData service.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'ODataAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password of the OData service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="servicePrincipalEmbeddedCert")
    def service_principal_embedded_cert(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_embedded_cert")

    @service_principal_embedded_cert.setter
    def service_principal_embedded_cert(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_embedded_cert", value)

    @property
    @pulumi.getter(name="servicePrincipalEmbeddedCertPassword")
    def service_principal_embedded_cert_password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_embedded_cert_password")

    @service_principal_embedded_cert_password.setter
    def service_principal_embedded_cert_password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_embedded_cert_password", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name of the OData service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class ODataResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 path: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Open Data Protocol (OData) resource dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ODataResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any path: The OData resource path. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ODataResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ODataResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The OData resource path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class ODataSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for OData source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ODataSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ODataSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ODataSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class OdbcLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        Open Database Connectivity (ODBC) linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Odbc'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Odbc')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Odbc'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[Any]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class OdbcSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity ODBC sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'OdbcSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: A query to execute before starting the copy. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OdbcSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'OdbcSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        A query to execute before starting the copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class OdbcSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for ODBC databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'OdbcSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OdbcSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'OdbcSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class OdbcTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The ODBC table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'OdbcTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The ODBC table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OdbcTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'OdbcTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The ODBC table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class Office365DatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 table_name: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 predicate: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Office365 account.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any table_name: Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Office365Table'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any predicate: A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'Office365Table')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if predicate is not None:
            pulumi.set(__self__, "predicate", predicate)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Any):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Office365Table'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def predicate(self) -> Optional[Any]:
        """
        A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "predicate")

    @predicate.setter
    def predicate(self, value: Optional[Any]):
        pulumi.set(self, "predicate", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class Office365LinkedServiceArgs:
    def __init__(__self__, *,
                 office365_tenant_id: Any,
                 service_principal_id: Any,
                 service_principal_key: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 service_principal_tenant_id: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Office365 linked service.
        :param Any office365_tenant_id: Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application's client ID. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: Specify the application's key.
        :param Any service_principal_tenant_id: Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Office365'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "office365_tenant_id", office365_tenant_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "service_principal_tenant_id", service_principal_tenant_id)
        pulumi.set(__self__, "type", 'Office365')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="office365TenantId")
    def office365_tenant_id(self) -> Any:
        """
        Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "office365_tenant_id")

    @office365_tenant_id.setter
    def office365_tenant_id(self, value: Any):
        pulumi.set(self, "office365_tenant_id", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        Specify the application's client ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Any):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        Specify the application's key.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter(name="servicePrincipalTenantId")
    def service_principal_tenant_id(self) -> Any:
        """
        Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_tenant_id")

    @service_principal_tenant_id.setter
    def service_principal_tenant_id(self, value: Any):
        pulumi.set(self, "service_principal_tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Office365'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class Office365SourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 allowed_groups: Optional[Any] = None,
                 date_filter_column: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 end_time: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 output_columns: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 start_time: Optional[Any] = None,
                 user_scope_filter_uri: Optional[Any] = None):
        """
        A copy activity source for an Office 365 service.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'Office365Source'.
        :param Any allowed_groups: The groups containing all the users. Type: array of strings (or Expression with resultType array of strings).
        :param Any date_filter_column: The Column to apply the <paramref name="StartTime"/> and <paramref name="EndTime"/>. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any end_time: End time of the requested range for this dataset. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any output_columns: The columns to be read out from the Office 365 table. Type: array of objects (or Expression with resultType array of objects). Example: [ { "name": "Id" }, { "name": "CreatedDateTime" } ]
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any start_time: Start time of the requested range for this dataset. Type: string (or Expression with resultType string).
        :param Any user_scope_filter_uri: The user scope uri. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Office365Source')
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if date_filter_column is not None:
            pulumi.set(__self__, "date_filter_column", date_filter_column)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if output_columns is not None:
            pulumi.set(__self__, "output_columns", output_columns)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if user_scope_filter_uri is not None:
            pulumi.set(__self__, "user_scope_filter_uri", user_scope_filter_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'Office365Source'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Any]:
        """
        The groups containing all the users. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[Any]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="dateFilterColumn")
    def date_filter_column(self) -> Optional[Any]:
        """
        The Column to apply the <paramref name="StartTime"/> and <paramref name="EndTime"/>. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "date_filter_column")

    @date_filter_column.setter
    def date_filter_column(self, value: Optional[Any]):
        pulumi.set(self, "date_filter_column", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[Any]:
        """
        End time of the requested range for this dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[Any]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="outputColumns")
    def output_columns(self) -> Optional[Any]:
        """
        The columns to be read out from the Office 365 table. Type: array of objects (or Expression with resultType array of objects). Example: [ { "name": "Id" }, { "name": "CreatedDateTime" } ]
        """
        return pulumi.get(self, "output_columns")

    @output_columns.setter
    def output_columns(self, value: Optional[Any]):
        pulumi.set(self, "output_columns", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[Any]:
        """
        Start time of the requested range for this dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[Any]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="userScopeFilterUri")
    def user_scope_filter_uri(self) -> Optional[Any]:
        """
        The user scope uri. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_scope_filter_uri")

    @user_scope_filter_uri.setter
    def user_scope_filter_uri(self, value: Optional[Any]):
        pulumi.set(self, "user_scope_filter_uri", value)


@pulumi.input_type
class OracleCloudStorageLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 secret_access_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_url: Optional[Any] = None):
        """
        Linked service for Oracle Cloud Storage.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'OracleCloudStorage'.
        :param Any access_key_id: The access key identifier of the Oracle Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] secret_access_key: The secret access key of the Oracle Cloud Storage Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the Oracle Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OracleCloudStorage')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'OracleCloudStorage'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Oracle Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[Any]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The secret access key of the Oracle Cloud Storage Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the Oracle Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[Any]):
        pulumi.set(self, "service_url", value)


@pulumi.input_type
class OracleCloudStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of Oracle Cloud Storage dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'OracleCloudStorageLocation'.
        :param Any bucket_name: Specify the bucketName of Oracle Cloud Storage. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of Oracle Cloud Storage. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OracleCloudStorageLocation')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'OracleCloudStorageLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of Oracle Cloud Storage. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[Any]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of Oracle Cloud Storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[Any]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class OracleCloudStorageReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 prefix: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Oracle Cloud Storage read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'OracleCloudStorageReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any prefix: The prefix filter for the Oracle Cloud Storage object name. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Oracle Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Oracle Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OracleCloudStorageReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'OracleCloudStorageReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the Oracle Cloud Storage object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[Any]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Oracle Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Oracle Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class OracleLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Oracle database.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Oracle'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Oracle')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Oracle'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class OraclePartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_names: Optional[pulumi.Input[Sequence[Any]]] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for Oracle source partitioning.
        :param Any partition_column_name: The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] partition_names: Names of the physical partitions of Oracle table. 
        :param Any partition_upper_bound: The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_names is not None:
            pulumi.set(__self__, "partition_names", partition_names)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionNames")
    def partition_names(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        Names of the physical partitions of Oracle table. 
        """
        return pulumi.get(self, "partition_names")

    @partition_names.setter
    def partition_names(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "partition_names", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class OracleServiceCloudLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 password: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 type: pulumi.Input[str],
                 username: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Oracle Service Cloud linked service.
        :param Any host: The URL of the Oracle Service Cloud instance.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name that you provided in the username key.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'OracleServiceCloud'.
        :param Any username: The user name that you use to access Oracle Service Cloud server.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'OracleServiceCloud')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URL of the Oracle Service Cloud instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The password corresponding to the user name that you provided in the username key.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'OracleServiceCloud'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Oracle Service Cloud server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Any):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class OracleServiceCloudObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Oracle Service Cloud dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'OracleServiceCloudObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OracleServiceCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'OracleServiceCloudObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class OracleServiceCloudSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Oracle Service Cloud source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'OracleServiceCloudSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OracleServiceCloudSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'OracleServiceCloudSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class OracleSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Oracle sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'OracleSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OracleSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'OracleSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class OracleSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 oracle_reader_query: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['OraclePartitionSettingsArgs']] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Oracle source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'OracleSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any oracle_reader_query: Oracle reader query. Type: string (or Expression with resultType string).
        :param Any partition_option: The partition mechanism that will be used for Oracle read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['OraclePartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Oracle source partitioning.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OracleSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if oracle_reader_query is not None:
            pulumi.set(__self__, "oracle_reader_query", oracle_reader_query)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'OracleSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="oracleReaderQuery")
    def oracle_reader_query(self) -> Optional[Any]:
        """
        Oracle reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "oracle_reader_query")

    @oracle_reader_query.setter
    def oracle_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "oracle_reader_query", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Oracle read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['OraclePartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Oracle source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['OraclePartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class OracleTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The on-premises Oracle database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'OracleTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OracleTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'OracleTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class OrcDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 orc_compression_codec: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        ORC dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the ORC data storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Orc'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any orc_compression_codec: The data orcCompressionCodec. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Orc')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if orc_compression_codec is not None:
            pulumi.set(__self__, "orc_compression_codec", orc_compression_codec)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the ORC data storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Orc'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="orcCompressionCodec")
    def orc_compression_codec(self) -> Optional[Any]:
        """
        The data orcCompressionCodec. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "orc_compression_codec")

    @orc_compression_codec.setter
    def orc_compression_codec(self, value: Optional[Any]):
        pulumi.set(self, "orc_compression_codec", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class OrcFormatArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Optimized Row Columnar (ORC) format.
        :param pulumi.Input[str] type: Type of dataset storage format.
               Expected value is 'OrcFormat'.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OrcFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage format.
        Expected value is 'OrcFormat'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @deserializer.setter
    def deserializer(self, value: Optional[Any]):
        pulumi.set(self, "deserializer", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[Any]):
        pulumi.set(self, "serializer", value)


@pulumi.input_type
class OrcSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['OrcWriteSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity ORC sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'OrcSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['OrcWriteSettingsArgs'] format_settings: ORC format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: ORC store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'OrcSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'OrcSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['OrcWriteSettingsArgs']]:
        """
        ORC format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['OrcWriteSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        ORC store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class OrcSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity ORC source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'OrcSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: ORC store settings.
        """
        pulumi.set(__self__, "type", 'OrcSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'OrcSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        ORC store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class OrcWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name_prefix: Optional[Any] = None,
                 max_rows_per_file: Optional[Any] = None):
        """
        Orc write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'OrcWriteSettings'.
        :param Any file_name_prefix: Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        :param Any max_rows_per_file: Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'OrcWriteSettings')
        if file_name_prefix is not None:
            pulumi.set(__self__, "file_name_prefix", file_name_prefix)
        if max_rows_per_file is not None:
            pulumi.set(__self__, "max_rows_per_file", max_rows_per_file)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'OrcWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileNamePrefix")
    def file_name_prefix(self) -> Optional[Any]:
        """
        Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name_prefix")

    @file_name_prefix.setter
    def file_name_prefix(self, value: Optional[Any]):
        pulumi.set(self, "file_name_prefix", value)

    @property
    @pulumi.getter(name="maxRowsPerFile")
    def max_rows_per_file(self) -> Optional[Any]:
        """
        Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_rows_per_file")

    @max_rows_per_file.setter
    def max_rows_per_file(self, value: Optional[Any]):
        pulumi.set(self, "max_rows_per_file", value)


@pulumi.input_type
class PackageStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 package_store_linked_service: pulumi.Input['EntityReferenceArgs']):
        """
        Package store for the SSIS integration runtime.
        :param pulumi.Input[str] name: The name of the package store
        :param pulumi.Input['EntityReferenceArgs'] package_store_linked_service: The package store linked service reference.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "package_store_linked_service", package_store_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the package store
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="packageStoreLinkedService")
    def package_store_linked_service(self) -> pulumi.Input['EntityReferenceArgs']:
        """
        The package store linked service reference.
        """
        return pulumi.get(self, "package_store_linked_service")

    @package_store_linked_service.setter
    def package_store_linked_service(self, value: pulumi.Input['EntityReferenceArgs']):
        pulumi.set(self, "package_store_linked_service", value)


@pulumi.input_type
class ParameterSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ParameterType']],
                 default_value: Optional[Any] = None):
        """
        Definition of a single parameter for an entity.
        :param pulumi.Input[Union[str, 'ParameterType']] type: Parameter type.
        :param Any default_value: Default value of parameter.
        """
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ParameterType']]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ParameterType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        Default value of parameter.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[Any]):
        pulumi.set(self, "default_value", value)


@pulumi.input_type
class ParquetDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression_codec: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Parquet dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the parquet storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Parquet'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any compression_codec: The data compressionCodec. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Parquet')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the parquet storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Parquet'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[Any]:
        """
        The data compressionCodec. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[Any]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class ParquetFormatArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Parquet format.
        :param pulumi.Input[str] type: Type of dataset storage format.
               Expected value is 'ParquetFormat'.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'ParquetFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage format.
        Expected value is 'ParquetFormat'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @deserializer.setter
    def deserializer(self, value: Optional[Any]):
        pulumi.set(self, "deserializer", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[Any]):
        pulumi.set(self, "serializer", value)


@pulumi.input_type
class ParquetSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['ParquetWriteSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Parquet sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'ParquetSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['ParquetWriteSettingsArgs'] format_settings: Parquet format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']] store_settings: Parquet store settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ParquetSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'ParquetSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['ParquetWriteSettingsArgs']]:
        """
        Parquet format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['ParquetWriteSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]:
        """
        Parquet store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AzureBlobFSWriteSettingsArgs', 'AzureBlobStorageWriteSettingsArgs', 'AzureDataLakeStoreWriteSettingsArgs', 'AzureFileStorageWriteSettingsArgs', 'FileServerWriteSettingsArgs', 'SftpWriteSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class ParquetSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity Parquet source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ParquetSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Parquet store settings.
        """
        pulumi.set(__self__, "type", 'ParquetSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ParquetSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Parquet store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class ParquetWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name_prefix: Optional[Any] = None,
                 max_rows_per_file: Optional[Any] = None):
        """
        Parquet write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'ParquetWriteSettings'.
        :param Any file_name_prefix: Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        :param Any max_rows_per_file: Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        pulumi.set(__self__, "type", 'ParquetWriteSettings')
        if file_name_prefix is not None:
            pulumi.set(__self__, "file_name_prefix", file_name_prefix)
        if max_rows_per_file is not None:
            pulumi.set(__self__, "max_rows_per_file", max_rows_per_file)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'ParquetWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileNamePrefix")
    def file_name_prefix(self) -> Optional[Any]:
        """
        Specifies the file name pattern <fileNamePrefix>_<fileIndex>.<fileExtension> when copy from non-file based store without partitionOptions. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name_prefix")

    @file_name_prefix.setter
    def file_name_prefix(self, value: Optional[Any]):
        pulumi.set(self, "file_name_prefix", value)

    @property
    @pulumi.getter(name="maxRowsPerFile")
    def max_rows_per_file(self) -> Optional[Any]:
        """
        Limit the written file's row count to be smaller than or equal to the specified count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_rows_per_file")

    @max_rows_per_file.setter
    def max_rows_per_file(self, value: Optional[Any]):
        pulumi.set(self, "max_rows_per_file", value)


@pulumi.input_type
class PaypalLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 host: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Paypal Service linked service.
        :param Any client_id: The client ID associated with your PayPal application.
        :param Any host: The URLof the PayPal instance. (i.e. api.sandbox.paypal.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Paypal'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret associated with your PayPal application.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Paypal')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with your PayPal application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URLof the PayPal instance. (i.e. api.sandbox.paypal.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Paypal'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret associated with your PayPal application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class PaypalObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Paypal Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'PaypalObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PaypalObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'PaypalObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class PaypalSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Paypal Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'PaypalSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'PaypalSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'PaypalSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class PhoenixLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'PhoenixAuthenticationType']],
                 host: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Phoenix server linked service.
        :param pulumi.Input[Union[str, 'PhoenixAuthenticationType']] authentication_type: The authentication mechanism used to connect to the Phoenix server.
        :param Any host: The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Phoenix'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using WindowsAzureHDInsightService.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name.
        :param Any port: The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to connect to the Phoenix server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Phoenix')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'PhoenixAuthenticationType']]:
        """
        The authentication mechanism used to connect to the Phoenix server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'PhoenixAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Phoenix'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using WindowsAzureHDInsightService.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[Any]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the Phoenix server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class PhoenixObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Phoenix server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'PhoenixObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Phoenix. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PhoenixObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'PhoenixObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Phoenix. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class PhoenixSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Phoenix server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'PhoenixSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'PhoenixSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'PhoenixSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class PipelineElapsedTimeMetricPolicyArgs:
    def __init__(__self__, *,
                 duration: Optional[Any] = None):
        """
        Pipeline ElapsedTime Metric Policy.
        :param Any duration: TimeSpan value, after which an Azure Monitoring Metric is fired.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[Any]:
        """
        TimeSpan value, after which an Azure Monitoring Metric is fired.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[Any]):
        pulumi.set(self, "duration", value)


@pulumi.input_type
class PipelineFolderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
        :param pulumi.Input[str] name: The name of the folder that this Pipeline is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the folder that this Pipeline is in.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PipelinePolicyArgs:
    def __init__(__self__, *,
                 elapsed_time_metric: Optional[pulumi.Input['PipelineElapsedTimeMetricPolicyArgs']] = None):
        """
        Pipeline Policy.
        :param pulumi.Input['PipelineElapsedTimeMetricPolicyArgs'] elapsed_time_metric: Pipeline ElapsedTime Metric Policy.
        """
        if elapsed_time_metric is not None:
            pulumi.set(__self__, "elapsed_time_metric", elapsed_time_metric)

    @property
    @pulumi.getter(name="elapsedTimeMetric")
    def elapsed_time_metric(self) -> Optional[pulumi.Input['PipelineElapsedTimeMetricPolicyArgs']]:
        """
        Pipeline ElapsedTime Metric Policy.
        """
        return pulumi.get(self, "elapsed_time_metric")

    @elapsed_time_metric.setter
    def elapsed_time_metric(self, value: Optional[pulumi.Input['PipelineElapsedTimeMetricPolicyArgs']]):
        pulumi.set(self, "elapsed_time_metric", value)


@pulumi.input_type
class PipelineReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        Pipeline reference type.
        :param pulumi.Input[str] reference_name: Reference pipeline name.
        :param pulumi.Input[str] type: Pipeline reference type.
        :param pulumi.Input[str] name: Reference name.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference pipeline name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Pipeline reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Reference name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PolybaseSettingsArgs:
    def __init__(__self__, *,
                 reject_sample_value: Optional[Any] = None,
                 reject_type: Optional[pulumi.Input[Union[str, 'PolybaseSettingsRejectType']]] = None,
                 reject_value: Optional[Any] = None,
                 use_type_default: Optional[Any] = None):
        """
        PolyBase settings.
        :param Any reject_sample_value: Determines the number of rows to attempt to retrieve before the PolyBase recalculates the percentage of rejected rows. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Union[str, 'PolybaseSettingsRejectType']] reject_type: Reject type.
        :param Any reject_value: Specifies the value or the percentage of rows that can be rejected before the query fails. Type: number (or Expression with resultType number), minimum: 0.
        :param Any use_type_default: Specifies how to handle missing values in delimited text files when PolyBase retrieves data from the text file. Type: boolean (or Expression with resultType boolean).
        """
        if reject_sample_value is not None:
            pulumi.set(__self__, "reject_sample_value", reject_sample_value)
        if reject_type is not None:
            pulumi.set(__self__, "reject_type", reject_type)
        if reject_value is not None:
            pulumi.set(__self__, "reject_value", reject_value)
        if use_type_default is not None:
            pulumi.set(__self__, "use_type_default", use_type_default)

    @property
    @pulumi.getter(name="rejectSampleValue")
    def reject_sample_value(self) -> Optional[Any]:
        """
        Determines the number of rows to attempt to retrieve before the PolyBase recalculates the percentage of rejected rows. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "reject_sample_value")

    @reject_sample_value.setter
    def reject_sample_value(self, value: Optional[Any]):
        pulumi.set(self, "reject_sample_value", value)

    @property
    @pulumi.getter(name="rejectType")
    def reject_type(self) -> Optional[pulumi.Input[Union[str, 'PolybaseSettingsRejectType']]]:
        """
        Reject type.
        """
        return pulumi.get(self, "reject_type")

    @reject_type.setter
    def reject_type(self, value: Optional[pulumi.Input[Union[str, 'PolybaseSettingsRejectType']]]):
        pulumi.set(self, "reject_type", value)

    @property
    @pulumi.getter(name="rejectValue")
    def reject_value(self) -> Optional[Any]:
        """
        Specifies the value or the percentage of rows that can be rejected before the query fails. Type: number (or Expression with resultType number), minimum: 0.
        """
        return pulumi.get(self, "reject_value")

    @reject_value.setter
    def reject_value(self, value: Optional[Any]):
        pulumi.set(self, "reject_value", value)

    @property
    @pulumi.getter(name="useTypeDefault")
    def use_type_default(self) -> Optional[Any]:
        """
        Specifies how to handle missing values in delimited text files when PolyBase retrieves data from the text file. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_type_default")

    @use_type_default.setter
    def use_type_default(self, value: Optional[Any]):
        pulumi.set(self, "use_type_default", value)


@pulumi.input_type
class PostgreSqlLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Linked service for PostgreSQL data source.
        :param Any connection_string: The connection string.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'PostgreSql'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'PostgreSql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'PostgreSql'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class PostgreSqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for PostgreSQL databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'PostgreSqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'PostgreSqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'PostgreSqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class PostgreSqlTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The PostgreSQL table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'PostgreSqlTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The PostgreSQL table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PostgreSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'PostgreSqlTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The PostgreSQL table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class PowerQuerySinkMappingArgs:
    def __init__(__self__, *,
                 dataflow_sinks: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkArgs']]]] = None,
                 query_name: Optional[pulumi.Input[str]] = None):
        """
        Map Power Query mashup query to sink dataset(s).
        :param pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkArgs']]] dataflow_sinks: List of sinks mapped to Power Query mashup query.
        :param pulumi.Input[str] query_name: Name of the query in Power Query mashup document.
        """
        if dataflow_sinks is not None:
            pulumi.set(__self__, "dataflow_sinks", dataflow_sinks)
        if query_name is not None:
            pulumi.set(__self__, "query_name", query_name)

    @property
    @pulumi.getter(name="dataflowSinks")
    def dataflow_sinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkArgs']]]]:
        """
        List of sinks mapped to Power Query mashup query.
        """
        return pulumi.get(self, "dataflow_sinks")

    @dataflow_sinks.setter
    def dataflow_sinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySinkArgs']]]]):
        pulumi.set(self, "dataflow_sinks", value)

    @property
    @pulumi.getter(name="queryName")
    def query_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the query in Power Query mashup document.
        """
        return pulumi.get(self, "query_name")

    @query_name.setter
    def query_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_name", value)


@pulumi.input_type
class PowerQuerySinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DatasetReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowReferenceArgs']] = None,
                 linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 script: Optional[pulumi.Input[str]] = None):
        """
        Power query sink.
        :param pulumi.Input[str] name: Transformation name.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Dataset reference.
        :param pulumi.Input[str] description: Transformation description.
        :param pulumi.Input['DataFlowReferenceArgs'] flowlet: Flowlet Reference
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: Linked service reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] schema_linked_service: Schema linked service reference.
        :param pulumi.Input[str] script: sink script.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DatasetReferenceArgs']]:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DatasetReferenceArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowReferenceArgs']]:
        """
        Flowlet Reference
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowReferenceArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "schema_linked_service", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        sink script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


@pulumi.input_type
class PowerQuerySourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DatasetReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowReferenceArgs']] = None,
                 linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 script: Optional[pulumi.Input[str]] = None):
        """
        Power query source.
        :param pulumi.Input[str] name: Transformation name.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Dataset reference.
        :param pulumi.Input[str] description: Transformation description.
        :param pulumi.Input['DataFlowReferenceArgs'] flowlet: Flowlet Reference
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service: Linked service reference.
        :param pulumi.Input['LinkedServiceReferenceArgs'] schema_linked_service: Schema linked service reference.
        :param pulumi.Input[str] script: source script.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DatasetReferenceArgs']]:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DatasetReferenceArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowReferenceArgs']]:
        """
        Flowlet Reference
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowReferenceArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "schema_linked_service", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        source script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


@pulumi.input_type
class PrestoLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'PrestoAuthenticationType']],
                 catalog: Any,
                 host: Any,
                 server_version: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 time_zone_id: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Presto server linked service.
        :param pulumi.Input[Union[str, 'PrestoAuthenticationType']] authentication_type: The authentication mechanism used to connect to the Presto server.
        :param Any catalog: The catalog context for all request against the server.
        :param Any host: The IP address or host name of the Presto server. (i.e. 192.168.222.160)
        :param Any server_version: The version of the Presto server. (i.e. 0.148-t)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Presto'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name.
        :param Any port: The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
        :param Any time_zone_id: The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database. The default value is the system time zone.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to connect to the Presto server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "server_version", server_version)
        pulumi.set(__self__, "type", 'Presto')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if time_zone_id is not None:
            pulumi.set(__self__, "time_zone_id", time_zone_id)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'PrestoAuthenticationType']]:
        """
        The authentication mechanism used to connect to the Presto server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'PrestoAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def catalog(self) -> Any:
        """
        The catalog context for all request against the server.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Any):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Presto server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Any:
        """
        The version of the Presto server. (i.e. 0.148-t)
        """
        return pulumi.get(self, "server_version")

    @server_version.setter
    def server_version(self, value: Any):
        pulumi.set(self, "server_version", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Presto'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="timeZoneID")
    def time_zone_id(self) -> Optional[Any]:
        """
        The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database. The default value is the system time zone.
        """
        return pulumi.get(self, "time_zone_id")

    @time_zone_id.setter
    def time_zone_id(self, value: Optional[Any]):
        pulumi.set(self, "time_zone_id", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the Presto server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class PrestoObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Presto server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'PrestoObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Presto. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PrestoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'PrestoObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Presto. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class PrestoSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Presto server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'PrestoSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'PrestoSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'PrestoSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class PrivateLinkConnectionApprovalRequestArgs:
    def __init__(__self__, *,
                 private_link_service_connection_state: Optional[pulumi.Input['PrivateLinkConnectionStateArgs']] = None):
        """
        A request to approve or reject a private endpoint connection
        :param pulumi.Input['PrivateLinkConnectionStateArgs'] private_link_service_connection_state: The state of a private link connection
        """
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional[pulumi.Input['PrivateLinkConnectionStateArgs']]:
        """
        The state of a private link connection
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @private_link_service_connection_state.setter
    def private_link_service_connection_state(self, value: Optional[pulumi.Input['PrivateLinkConnectionStateArgs']]):
        pulumi.set(self, "private_link_service_connection_state", value)


@pulumi.input_type
class PrivateLinkConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        The state of a private link connection
        :param pulumi.Input[str] actions_required: ActionsRequired for a private link connection
        :param pulumi.Input[str] description: Description of a private link connection
        :param pulumi.Input[str] status: Status of a private link connection
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[str]]:
        """
        ActionsRequired for a private link connection
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of a private link connection
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of a private link connection
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class QuickBooksLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 access_token_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 company_id: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 consumer_key: Optional[Any] = None,
                 consumer_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 endpoint: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None):
        """
        QuickBooks server linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'QuickBooks'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: The access token for OAuth 1.0 authentication.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token_secret: The access token secret for OAuth 1.0 authentication.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any company_id: The company ID of the QuickBooks company to authorize.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to QuickBooks. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param Any consumer_key: The consumer key for OAuth 1.0 authentication.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] consumer_secret: The consumer secret for OAuth 1.0 authentication.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        pulumi.set(__self__, "type", 'QuickBooks')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_secret is not None:
            pulumi.set(__self__, "access_token_secret", access_token_secret)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if company_id is not None:
            pulumi.set(__self__, "company_id", company_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'QuickBooks'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access token for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accessTokenSecret")
    def access_token_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access token secret for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "access_token_secret")

    @access_token_secret.setter
    def access_token_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token_secret", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="companyId")
    def company_id(self) -> Optional[Any]:
        """
        The company ID of the QuickBooks company to authorize.
        """
        return pulumi.get(self, "company_id")

    @company_id.setter
    def company_id(self, value: Optional[Any]):
        pulumi.set(self, "company_id", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to QuickBooks. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[Any]:
        """
        The consumer key for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[Any]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The consumer secret for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[Any]:
        """
        The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[Any]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)


@pulumi.input_type
class QuickBooksObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        QuickBooks server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'QuickBooksObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'QuickBooksObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'QuickBooksObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class QuickBooksSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity QuickBooks server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'QuickBooksSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'QuickBooksSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'QuickBooksSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class RecurrenceScheduleOccurrenceArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input['DayOfWeek']] = None,
                 occurrence: Optional[pulumi.Input[int]] = None):
        """
        The recurrence schedule occurrence.
        :param pulumi.Input['DayOfWeek'] day: The day of the week.
        :param pulumi.Input[int] occurrence: The occurrence.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if occurrence is not None:
            pulumi.set(__self__, "occurrence", occurrence)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input['DayOfWeek']]:
        """
        The day of the week.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input['DayOfWeek']]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def occurrence(self) -> Optional[pulumi.Input[int]]:
        """
        The occurrence.
        """
        return pulumi.get(self, "occurrence")

    @occurrence.setter
    def occurrence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "occurrence", value)


@pulumi.input_type
class RecurrenceScheduleArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 minutes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 month_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 monthly_occurrences: Optional[pulumi.Input[Sequence[pulumi.Input['RecurrenceScheduleOccurrenceArgs']]]] = None,
                 week_days: Optional[pulumi.Input[Sequence[pulumi.Input['DaysOfWeek']]]] = None):
        """
        The recurrence schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours: The hours.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] minutes: The minutes.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] month_days: The month days.
        :param pulumi.Input[Sequence[pulumi.Input['RecurrenceScheduleOccurrenceArgs']]] monthly_occurrences: The monthly occurrences.
        :param pulumi.Input[Sequence[pulumi.Input['DaysOfWeek']]] week_days: The days of the week.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if month_days is not None:
            pulumi.set(__self__, "month_days", month_days)
        if monthly_occurrences is not None:
            pulumi.set(__self__, "monthly_occurrences", monthly_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The hours.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The minutes.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter(name="monthDays")
    def month_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The month days.
        """
        return pulumi.get(self, "month_days")

    @month_days.setter
    def month_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "month_days", value)

    @property
    @pulumi.getter(name="monthlyOccurrences")
    def monthly_occurrences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecurrenceScheduleOccurrenceArgs']]]]:
        """
        The monthly occurrences.
        """
        return pulumi.get(self, "monthly_occurrences")

    @monthly_occurrences.setter
    def monthly_occurrences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecurrenceScheduleOccurrenceArgs']]]]):
        pulumi.set(self, "monthly_occurrences", value)

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DaysOfWeek']]]]:
        """
        The days of the week.
        """
        return pulumi.get(self, "week_days")

    @week_days.setter
    def week_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DaysOfWeek']]]]):
        pulumi.set(self, "week_days", value)


@pulumi.input_type
class RedirectIncompatibleRowSettingsArgs:
    def __init__(__self__, *,
                 linked_service_name: Any,
                 path: Optional[Any] = None):
        """
        Redirect incompatible row settings
        :param Any linked_service_name: Name of the Azure Storage, Storage SAS, or Azure Data Lake Store linked service used for redirecting incompatible row. Must be specified if redirectIncompatibleRowSettings is specified. Type: string (or Expression with resultType string).
        :param Any path: The path for storing the redirect incompatible row data. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Any:
        """
        Name of the Azure Storage, Storage SAS, or Azure Data Lake Store linked service used for redirecting incompatible row. Must be specified if redirectIncompatibleRowSettings is specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Any):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The path for storing the redirect incompatible row data. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class RedshiftUnloadSettingsArgs:
    def __init__(__self__, *,
                 bucket_name: Any,
                 s3_linked_service_name: pulumi.Input['LinkedServiceReferenceArgs']):
        """
        The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data from Amazon Redshift source will be unloaded into S3 first and then copied into the targeted sink from the interim S3.
        :param Any bucket_name: The bucket of the interim Amazon S3 which will be used to store the unloaded data from Amazon Redshift source. The bucket must be in the same region as the Amazon Redshift source. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] s3_linked_service_name: The name of the Amazon S3 linked service which will be used for the unload operation when copying from the Amazon Redshift source.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "s3_linked_service_name", s3_linked_service_name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Any:
        """
        The bucket of the interim Amazon S3 which will be used to store the unloaded data from Amazon Redshift source. The bucket must be in the same region as the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Any):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="s3LinkedServiceName")
    def s3_linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        The name of the Amazon S3 linked service which will be used for the unload operation when copying from the Amazon Redshift source.
        """
        return pulumi.get(self, "s3_linked_service_name")

    @s3_linked_service_name.setter
    def s3_linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "s3_linked_service_name", value)


@pulumi.input_type
class RelationalSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for various relational databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'RelationalSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'RelationalSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'RelationalSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class RelationalTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The relational table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'RelationalTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The relational table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'RelationalTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'RelationalTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The relational table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class RerunTumblingWindowTriggerArgs:
    def __init__(__self__, *,
                 parent_trigger: Any,
                 requested_end_time: pulumi.Input[str],
                 requested_start_time: pulumi.Input[str],
                 rerun_concurrency: pulumi.Input[int],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end time.
        :param Any parent_trigger: The parent trigger reference.
        :param pulumi.Input[str] requested_end_time: The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
        :param pulumi.Input[str] requested_start_time: The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
        :param pulumi.Input[int] rerun_concurrency: The max number of parallel time windows (ready for execution) for which a rerun is triggered.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'RerunTumblingWindowTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        """
        pulumi.set(__self__, "parent_trigger", parent_trigger)
        pulumi.set(__self__, "requested_end_time", requested_end_time)
        pulumi.set(__self__, "requested_start_time", requested_start_time)
        pulumi.set(__self__, "rerun_concurrency", rerun_concurrency)
        pulumi.set(__self__, "type", 'RerunTumblingWindowTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="parentTrigger")
    def parent_trigger(self) -> Any:
        """
        The parent trigger reference.
        """
        return pulumi.get(self, "parent_trigger")

    @parent_trigger.setter
    def parent_trigger(self, value: Any):
        pulumi.set(self, "parent_trigger", value)

    @property
    @pulumi.getter(name="requestedEndTime")
    def requested_end_time(self) -> pulumi.Input[str]:
        """
        The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
        """
        return pulumi.get(self, "requested_end_time")

    @requested_end_time.setter
    def requested_end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "requested_end_time", value)

    @property
    @pulumi.getter(name="requestedStartTime")
    def requested_start_time(self) -> pulumi.Input[str]:
        """
        The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
        """
        return pulumi.get(self, "requested_start_time")

    @requested_start_time.setter
    def requested_start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "requested_start_time", value)

    @property
    @pulumi.getter(name="rerunConcurrency")
    def rerun_concurrency(self) -> pulumi.Input[int]:
        """
        The max number of parallel time windows (ready for execution) for which a rerun is triggered.
        """
        return pulumi.get(self, "rerun_concurrency")

    @rerun_concurrency.setter
    def rerun_concurrency(self, value: pulumi.Input[int]):
        pulumi.set(self, "rerun_concurrency", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'RerunTumblingWindowTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ResponsysLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 endpoint: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Responsys linked service.
        :param Any client_id: The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the Responsys server.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Responsys'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Responsys')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Responsys server.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Responsys'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class ResponsysObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Responsys dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ResponsysObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ResponsysObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ResponsysObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ResponsysSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Responsys source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ResponsysSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ResponsysSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ResponsysSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class RestResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 additional_headers: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 pagination_rules: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 relative_url: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        A Rest service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'RestResource'.
        :param Any additional_headers: The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any pagination_rules: The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any relative_url: The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
        :param Any request_body: The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        :param Any request_method: The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'RestResource')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if pagination_rules is not None:
            pulumi.set(__self__, "pagination_rules", pagination_rules)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'RestResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[Any]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="paginationRules")
    def pagination_rules(self) -> Optional[Any]:
        """
        The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pagination_rules")

    @pagination_rules.setter
    def pagination_rules(self, value: Optional[Any]):
        pulumi.set(self, "pagination_rules", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: Optional[Any]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[Any]):
        pulumi.set(self, "request_body", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[Any]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class RestServiceLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'RestServiceAuthenticationType']],
                 type: pulumi.Input[str],
                 url: Any,
                 aad_resource_id: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 auth_headers: Optional[Any] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 tenant: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Rest Service linked service.
        :param pulumi.Input[Union[str, 'RestServiceAuthenticationType']] authentication_type: Type of authentication used to connect to the REST service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'RestService'.
        :param Any url: The base URL of the REST service.
        :param Any aad_resource_id: The resource you are requesting authorization to use.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any auth_headers: The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_server_certificate_validation: Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password used in Basic authentication type.
        :param Any service_principal_id: The application's client ID used in AadServicePrincipal authentication type.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The application's key used in AadServicePrincipal authentication type.
        :param Any tenant: The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application resides.
        :param Any user_name: The user name used in Basic authentication type.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "type", 'RestService')
        pulumi.set(__self__, "url", url)
        if aad_resource_id is not None:
            pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auth_headers is not None:
            pulumi.set(__self__, "auth_headers", auth_headers)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'RestServiceAuthenticationType']]:
        """
        Type of authentication used to connect to the REST service.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'RestServiceAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'RestService'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The base URL of the REST service.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Optional[Any]:
        """
        The resource you are requesting authorization to use.
        """
        return pulumi.get(self, "aad_resource_id")

    @aad_resource_id.setter
    def aad_resource_id(self, value: Optional[Any]):
        pulumi.set(self, "aad_resource_id", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authHeaders")
    def auth_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to RESTful API used for authorization. Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "auth_headers")

    @auth_headers.setter
    def auth_headers(self, value: Optional[Any]):
        pulumi.set(self, "auth_headers", value)

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @azure_cloud_type.setter
    def azure_cloud_type(self, value: Optional[Any]):
        pulumi.set(self, "azure_cloud_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @enable_server_certificate_validation.setter
    def enable_server_certificate_validation(self, value: Optional[Any]):
        pulumi.set(self, "enable_server_certificate_validation", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password used in Basic authentication type.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The application's client ID used in AadServicePrincipal authentication type.
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The application's key used in AadServicePrincipal authentication type.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application resides.
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[Any]):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The user name used in Basic authentication type.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class RestSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_headers: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_compression_type: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 request_interval: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity Rest service Sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'RestSink'.
        :param Any additional_headers: The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_compression_type: Http Compression Type to Send data in compressed format with Optimal Compression Level, Default is None. And The Only Supported option is Gzip. 
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:01:40. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any request_interval: The time to await before sending next request, in milliseconds 
        :param Any request_method: The HTTP method used to call the RESTful API. The default is POST. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'RestSink')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_compression_type is not None:
            pulumi.set(__self__, "http_compression_type", http_compression_type)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if request_interval is not None:
            pulumi.set(__self__, "request_interval", request_interval)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'RestSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[Any]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpCompressionType")
    def http_compression_type(self) -> Optional[Any]:
        """
        Http Compression Type to Send data in compressed format with Optimal Compression Level, Default is None. And The Only Supported option is Gzip. 
        """
        return pulumi.get(self, "http_compression_type")

    @http_compression_type.setter
    def http_compression_type(self, value: Optional[Any]):
        pulumi.set(self, "http_compression_type", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:01:40. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="requestInterval")
    def request_interval(self) -> Optional[Any]:
        """
        The time to await before sending next request, in milliseconds 
        """
        return pulumi.get(self, "request_interval")

    @request_interval.setter
    def request_interval(self, value: Optional[Any]):
        pulumi.set(self, "request_interval", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method used to call the RESTful API. The default is POST. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[Any]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class RestSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 additional_headers: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pagination_rules: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_interval: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Rest service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'RestSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any additional_headers: The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:01:40. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any pagination_rules: The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        :param Any request_body: The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        :param Any request_interval: The time to await before sending next page request. 
        :param Any request_method: The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'RestSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pagination_rules is not None:
            pulumi.set(__self__, "pagination_rules", pagination_rules)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_interval is not None:
            pulumi.set(__self__, "request_interval", request_interval)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'RestSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[Any]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:01:40. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="paginationRules")
    def pagination_rules(self) -> Optional[Any]:
        """
        The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pagination_rules")

    @pagination_rules.setter
    def pagination_rules(self, value: Optional[Any]):
        pulumi.set(self, "pagination_rules", value)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[Any]):
        pulumi.set(self, "request_body", value)

    @property
    @pulumi.getter(name="requestInterval")
    def request_interval(self) -> Optional[Any]:
        """
        The time to await before sending next page request. 
        """
        return pulumi.get(self, "request_interval")

    @request_interval.setter
    def request_interval(self, value: Optional[Any]):
        pulumi.set(self, "request_interval", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[Any]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class RetryPolicyArgs:
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 interval_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        Execution policy for an activity.
        :param Any count: Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[int] interval_in_seconds: Interval between retries in seconds. Default is 30.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[Any]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between retries in seconds. Default is 30.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)


@pulumi.input_type
class SSISAccessCredentialArgs:
    def __init__(__self__, *,
                 domain: Any,
                 password: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 user_name: Any):
        """
        SSIS access credential.
        :param Any domain: Domain for windows authentication.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for windows authentication.
        :param Any user_name: UseName for windows authentication.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        Domain for windows authentication.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Any):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        Password for windows authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Any:
        """
        UseName for windows authentication.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Any):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SSISChildPackageArgs:
    def __init__(__self__, *,
                 package_content: Any,
                 package_path: Any,
                 package_last_modified_date: Optional[pulumi.Input[str]] = None,
                 package_name: Optional[pulumi.Input[str]] = None):
        """
        SSIS embedded child package.
        :param Any package_content: Content for embedded child package. Type: string (or Expression with resultType string).
        :param Any package_path: Path for embedded child package. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] package_last_modified_date: Last modified date for embedded child package.
        :param pulumi.Input[str] package_name: Name for embedded child package.
        """
        pulumi.set(__self__, "package_content", package_content)
        pulumi.set(__self__, "package_path", package_path)
        if package_last_modified_date is not None:
            pulumi.set(__self__, "package_last_modified_date", package_last_modified_date)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)

    @property
    @pulumi.getter(name="packageContent")
    def package_content(self) -> Any:
        """
        Content for embedded child package. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_content")

    @package_content.setter
    def package_content(self, value: Any):
        pulumi.set(self, "package_content", value)

    @property
    @pulumi.getter(name="packagePath")
    def package_path(self) -> Any:
        """
        Path for embedded child package. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_path")

    @package_path.setter
    def package_path(self, value: Any):
        pulumi.set(self, "package_path", value)

    @property
    @pulumi.getter(name="packageLastModifiedDate")
    def package_last_modified_date(self) -> Optional[pulumi.Input[str]]:
        """
        Last modified date for embedded child package.
        """
        return pulumi.get(self, "package_last_modified_date")

    @package_last_modified_date.setter
    def package_last_modified_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_last_modified_date", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for embedded child package.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)


@pulumi.input_type
class SSISExecutionCredentialArgs:
    def __init__(__self__, *,
                 domain: Any,
                 password: pulumi.Input['SecureStringArgs'],
                 user_name: Any):
        """
        SSIS package execution credential.
        :param Any domain: Domain for windows authentication.
        :param pulumi.Input['SecureStringArgs'] password: Password for windows authentication.
        :param Any user_name: UseName for windows authentication.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        Domain for windows authentication.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Any):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input['SecureStringArgs']:
        """
        Password for windows authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input['SecureStringArgs']):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Any:
        """
        UseName for windows authentication.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Any):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SSISExecutionParameterArgs:
    def __init__(__self__, *,
                 value: Any):
        """
        SSIS execution parameter.
        :param Any value: SSIS package execution parameter value. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        SSIS package execution parameter value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Any):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SSISLogLocationArgs:
    def __init__(__self__, *,
                 log_path: Any,
                 type: pulumi.Input[Union[str, 'SsisLogLocationType']],
                 access_credential: Optional[pulumi.Input['SSISAccessCredentialArgs']] = None,
                 log_refresh_interval: Optional[Any] = None):
        """
        SSIS package execution log location
        :param Any log_path: The SSIS package execution log path. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union[str, 'SsisLogLocationType']] type: The type of SSIS log location.
        :param pulumi.Input['SSISAccessCredentialArgs'] access_credential: The package execution log access credential.
        :param Any log_refresh_interval: Specifies the interval to refresh log. The default interval is 5 minutes. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "log_path", log_path)
        pulumi.set(__self__, "type", type)
        if access_credential is not None:
            pulumi.set(__self__, "access_credential", access_credential)
        if log_refresh_interval is not None:
            pulumi.set(__self__, "log_refresh_interval", log_refresh_interval)

    @property
    @pulumi.getter(name="logPath")
    def log_path(self) -> Any:
        """
        The SSIS package execution log path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "log_path")

    @log_path.setter
    def log_path(self, value: Any):
        pulumi.set(self, "log_path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'SsisLogLocationType']]:
        """
        The type of SSIS log location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'SsisLogLocationType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessCredential")
    def access_credential(self) -> Optional[pulumi.Input['SSISAccessCredentialArgs']]:
        """
        The package execution log access credential.
        """
        return pulumi.get(self, "access_credential")

    @access_credential.setter
    def access_credential(self, value: Optional[pulumi.Input['SSISAccessCredentialArgs']]):
        pulumi.set(self, "access_credential", value)

    @property
    @pulumi.getter(name="logRefreshInterval")
    def log_refresh_interval(self) -> Optional[Any]:
        """
        Specifies the interval to refresh log. The default interval is 5 minutes. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "log_refresh_interval")

    @log_refresh_interval.setter
    def log_refresh_interval(self, value: Optional[Any]):
        pulumi.set(self, "log_refresh_interval", value)


@pulumi.input_type
class SSISPackageLocationArgs:
    def __init__(__self__, *,
                 access_credential: Optional[pulumi.Input['SSISAccessCredentialArgs']] = None,
                 child_packages: Optional[pulumi.Input[Sequence[pulumi.Input['SSISChildPackageArgs']]]] = None,
                 configuration_access_credential: Optional[pulumi.Input['SSISAccessCredentialArgs']] = None,
                 configuration_path: Optional[Any] = None,
                 package_content: Optional[Any] = None,
                 package_last_modified_date: Optional[pulumi.Input[str]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 package_password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 package_path: Optional[Any] = None,
                 type: Optional[pulumi.Input[Union[str, 'SsisPackageLocationType']]] = None):
        """
        SSIS package location.
        :param pulumi.Input['SSISAccessCredentialArgs'] access_credential: The package access credential.
        :param pulumi.Input[Sequence[pulumi.Input['SSISChildPackageArgs']]] child_packages: The embedded child package list.
        :param pulumi.Input['SSISAccessCredentialArgs'] configuration_access_credential: The configuration file access credential.
        :param Any configuration_path: The configuration file of the package execution. Type: string (or Expression with resultType string).
        :param Any package_content: The embedded package content. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] package_last_modified_date: The embedded package last modified date.
        :param pulumi.Input[str] package_name: The package name.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] package_password: Password of the package.
        :param Any package_path: The SSIS package path. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union[str, 'SsisPackageLocationType']] type: The type of SSIS package location.
        """
        if access_credential is not None:
            pulumi.set(__self__, "access_credential", access_credential)
        if child_packages is not None:
            pulumi.set(__self__, "child_packages", child_packages)
        if configuration_access_credential is not None:
            pulumi.set(__self__, "configuration_access_credential", configuration_access_credential)
        if configuration_path is not None:
            pulumi.set(__self__, "configuration_path", configuration_path)
        if package_content is not None:
            pulumi.set(__self__, "package_content", package_content)
        if package_last_modified_date is not None:
            pulumi.set(__self__, "package_last_modified_date", package_last_modified_date)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if package_password is not None:
            pulumi.set(__self__, "package_password", package_password)
        if package_path is not None:
            pulumi.set(__self__, "package_path", package_path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessCredential")
    def access_credential(self) -> Optional[pulumi.Input['SSISAccessCredentialArgs']]:
        """
        The package access credential.
        """
        return pulumi.get(self, "access_credential")

    @access_credential.setter
    def access_credential(self, value: Optional[pulumi.Input['SSISAccessCredentialArgs']]):
        pulumi.set(self, "access_credential", value)

    @property
    @pulumi.getter(name="childPackages")
    def child_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSISChildPackageArgs']]]]:
        """
        The embedded child package list.
        """
        return pulumi.get(self, "child_packages")

    @child_packages.setter
    def child_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSISChildPackageArgs']]]]):
        pulumi.set(self, "child_packages", value)

    @property
    @pulumi.getter(name="configurationAccessCredential")
    def configuration_access_credential(self) -> Optional[pulumi.Input['SSISAccessCredentialArgs']]:
        """
        The configuration file access credential.
        """
        return pulumi.get(self, "configuration_access_credential")

    @configuration_access_credential.setter
    def configuration_access_credential(self, value: Optional[pulumi.Input['SSISAccessCredentialArgs']]):
        pulumi.set(self, "configuration_access_credential", value)

    @property
    @pulumi.getter(name="configurationPath")
    def configuration_path(self) -> Optional[Any]:
        """
        The configuration file of the package execution. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "configuration_path")

    @configuration_path.setter
    def configuration_path(self, value: Optional[Any]):
        pulumi.set(self, "configuration_path", value)

    @property
    @pulumi.getter(name="packageContent")
    def package_content(self) -> Optional[Any]:
        """
        The embedded package content. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_content")

    @package_content.setter
    def package_content(self, value: Optional[Any]):
        pulumi.set(self, "package_content", value)

    @property
    @pulumi.getter(name="packageLastModifiedDate")
    def package_last_modified_date(self) -> Optional[pulumi.Input[str]]:
        """
        The embedded package last modified date.
        """
        return pulumi.get(self, "package_last_modified_date")

    @package_last_modified_date.setter
    def package_last_modified_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_last_modified_date", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        The package name.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter(name="packagePassword")
    def package_password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password of the package.
        """
        return pulumi.get(self, "package_password")

    @package_password.setter
    def package_password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "package_password", value)

    @property
    @pulumi.getter(name="packagePath")
    def package_path(self) -> Optional[Any]:
        """
        The SSIS package path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_path")

    @package_path.setter
    def package_path(self, value: Optional[Any]):
        pulumi.set(self, "package_path", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'SsisPackageLocationType']]]:
        """
        The type of SSIS package location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'SsisPackageLocationType']]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SSISPropertyOverrideArgs:
    def __init__(__self__, *,
                 value: Any,
                 is_sensitive: Optional[pulumi.Input[bool]] = None):
        """
        SSIS property override.
        :param Any value: SSIS package property override value. Type: string (or Expression with resultType string).
        :param pulumi.Input[bool] is_sensitive: Whether SSIS package property override value is sensitive data. Value will be encrypted in SSISDB if it is true
        """
        pulumi.set(__self__, "value", value)
        if is_sensitive is not None:
            pulumi.set(__self__, "is_sensitive", is_sensitive)

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        SSIS package property override value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Any):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSensitive")
    def is_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SSIS package property override value is sensitive data. Value will be encrypted in SSISDB if it is true
        """
        return pulumi.get(self, "is_sensitive")

    @is_sensitive.setter
    def is_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sensitive", value)


@pulumi.input_type
class SalesforceLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 api_version: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 environment_url: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 security_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Salesforce.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Salesforce'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any api_version: The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any environment_url: The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password for Basic authentication of the Salesforce instance.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] security_token: The security token is optional to remotely access Salesforce instance.
        :param Any username: The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Salesforce')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if environment_url is not None:
            pulumi.set(__self__, "environment_url", environment_url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Salesforce'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[Any]:
        """
        The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[Any]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="environmentUrl")
    def environment_url(self) -> Optional[Any]:
        """
        The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "environment_url")

    @environment_url.setter
    def environment_url(self, value: Optional[Any]):
        pulumi.set(self, "environment_url", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password for Basic authentication of the Salesforce instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The security token is optional to remotely access Salesforce instance.
        """
        return pulumi.get(self, "security_token")

    @security_token.setter
    def security_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "security_token", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SalesforceMarketingCloudLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Salesforce Marketing Cloud linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SalesforceMarketingCloud'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Salesforce Marketing Cloud. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'SalesforceMarketingCloud')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SalesforceMarketingCloud'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Salesforce Marketing Cloud. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class SalesforceMarketingCloudObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Salesforce Marketing Cloud dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SalesforceMarketingCloudObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceMarketingCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SalesforceMarketingCloudObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class SalesforceMarketingCloudSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Salesforce Marketing Cloud source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SalesforceMarketingCloudSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SalesforceMarketingCloudSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SalesforceMarketingCloudSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SalesforceObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 object_api_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Salesforce object dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SalesforceObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any object_api_name: The Salesforce object API name. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if object_api_name is not None:
            pulumi.set(__self__, "object_api_name", object_api_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SalesforceObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="objectApiName")
    def object_api_name(self) -> Optional[Any]:
        """
        The Salesforce object API name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "object_api_name")

    @object_api_name.setter
    def object_api_name(self, value: Optional[Any]):
        pulumi.set(self, "object_api_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SalesforceServiceCloudLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 api_version: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 environment_url: Optional[Any] = None,
                 extended_properties: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 security_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Salesforce Service Cloud.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SalesforceServiceCloud'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any api_version: The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any environment_url: The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :param Any extended_properties: Extended properties appended to the connection string. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password for Basic authentication of the Salesforce instance.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] security_token: The security token is optional to remotely access Salesforce instance.
        :param Any username: The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SalesforceServiceCloud')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if environment_url is not None:
            pulumi.set(__self__, "environment_url", environment_url)
        if extended_properties is not None:
            pulumi.set(__self__, "extended_properties", extended_properties)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SalesforceServiceCloud'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[Any]:
        """
        The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[Any]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="environmentUrl")
    def environment_url(self) -> Optional[Any]:
        """
        The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "environment_url")

    @environment_url.setter
    def environment_url(self, value: Optional[Any]):
        pulumi.set(self, "environment_url", value)

    @property
    @pulumi.getter(name="extendedProperties")
    def extended_properties(self) -> Optional[Any]:
        """
        Extended properties appended to the connection string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "extended_properties")

    @extended_properties.setter
    def extended_properties(self, value: Optional[Any]):
        pulumi.set(self, "extended_properties", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password for Basic authentication of the Salesforce instance.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The security token is optional to remotely access Salesforce instance.
        """
        return pulumi.get(self, "security_token")

    @security_token.setter
    def security_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "security_token", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SalesforceServiceCloudObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 object_api_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Salesforce Service Cloud object dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SalesforceServiceCloudObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any object_api_name: The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceServiceCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if object_api_name is not None:
            pulumi.set(__self__, "object_api_name", object_api_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SalesforceServiceCloudObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="objectApiName")
    def object_api_name(self) -> Optional[Any]:
        """
        The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "object_api_name")

    @object_api_name.setter
    def object_api_name(self, value: Optional[Any]):
        pulumi.set(self, "object_api_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SalesforceServiceCloudSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 external_id_field_name: Optional[Any] = None,
                 ignore_null_values: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]] = None):
        """
        A copy activity Salesforce Service Cloud sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SalesforceServiceCloudSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any external_id_field_name: The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
        :param Any ignore_null_values: The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set it to true, it means ADF will leave the data in the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update the data in the destination object to NULL when doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']] write_behavior: The write behavior for the operation. Default is Insert.
        """
        pulumi.set(__self__, "type", 'SalesforceServiceCloudSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if external_id_field_name is not None:
            pulumi.set(__self__, "external_id_field_name", external_id_field_name)
        if ignore_null_values is not None:
            pulumi.set(__self__, "ignore_null_values", ignore_null_values)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SalesforceServiceCloudSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="externalIdFieldName")
    def external_id_field_name(self) -> Optional[Any]:
        """
        The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "external_id_field_name")

    @external_id_field_name.setter
    def external_id_field_name(self, value: Optional[Any]):
        pulumi.set(self, "external_id_field_name", value)

    @property
    @pulumi.getter(name="ignoreNullValues")
    def ignore_null_values(self) -> Optional[Any]:
        """
        The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set it to true, it means ADF will leave the data in the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update the data in the destination object to NULL when doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "ignore_null_values")

    @ignore_null_values.setter
    def ignore_null_values(self, value: Optional[Any]):
        pulumi.set(self, "ignore_null_values", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]]:
        """
        The write behavior for the operation. Default is Insert.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SalesforceServiceCloudSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 read_behavior: Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Salesforce Service Cloud source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SalesforceServiceCloudSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']] read_behavior: The read behavior for the operation. Default is Query.
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SalesforceServiceCloudSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if read_behavior is not None:
            pulumi.set(__self__, "read_behavior", read_behavior)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SalesforceServiceCloudSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="readBehavior")
    def read_behavior(self) -> Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]]:
        """
        The read behavior for the operation. Default is Query.
        """
        return pulumi.get(self, "read_behavior")

    @read_behavior.setter
    def read_behavior(self, value: Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]]):
        pulumi.set(self, "read_behavior", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SalesforceSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 external_id_field_name: Optional[Any] = None,
                 ignore_null_values: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]] = None):
        """
        A copy activity Salesforce sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SalesforceSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any external_id_field_name: The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
        :param Any ignore_null_values: The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set it to true, it means ADF will leave the data in the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update the data in the destination object to NULL when doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']] write_behavior: The write behavior for the operation. Default is Insert.
        """
        pulumi.set(__self__, "type", 'SalesforceSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if external_id_field_name is not None:
            pulumi.set(__self__, "external_id_field_name", external_id_field_name)
        if ignore_null_values is not None:
            pulumi.set(__self__, "ignore_null_values", ignore_null_values)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SalesforceSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="externalIdFieldName")
    def external_id_field_name(self) -> Optional[Any]:
        """
        The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "external_id_field_name")

    @external_id_field_name.setter
    def external_id_field_name(self, value: Optional[Any]):
        pulumi.set(self, "external_id_field_name", value)

    @property
    @pulumi.getter(name="ignoreNullValues")
    def ignore_null_values(self) -> Optional[Any]:
        """
        The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set it to true, it means ADF will leave the data in the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update the data in the destination object to NULL when doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "ignore_null_values")

    @ignore_null_values.setter
    def ignore_null_values(self, value: Optional[Any]):
        pulumi.set(self, "ignore_null_values", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]]:
        """
        The write behavior for the operation. Default is Insert.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[pulumi.Input[Union[str, 'SalesforceSinkWriteBehavior']]]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SalesforceSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 read_behavior: Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Salesforce source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SalesforceSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']] read_behavior: The read behavior for the operation. Default is Query.
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SalesforceSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if read_behavior is not None:
            pulumi.set(__self__, "read_behavior", read_behavior)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SalesforceSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="readBehavior")
    def read_behavior(self) -> Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]]:
        """
        The read behavior for the operation. Default is Query.
        """
        return pulumi.get(self, "read_behavior")

    @read_behavior.setter
    def read_behavior(self, value: Optional[pulumi.Input[Union[str, 'SalesforceSourceReadBehavior']]]):
        pulumi.set(self, "read_behavior", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapBWLinkedServiceArgs:
    def __init__(__self__, *,
                 client_id: Any,
                 server: Any,
                 system_number: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Business Warehouse Linked Service.
        :param Any client_id: Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param Any server: Host name of the SAP BW instance. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapBW'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the SAP BW server.
        :param Any user_name: Username to access the SAP BW server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "system_number", system_number)
        pulumi.set(__self__, "type", 'SapBW')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Any):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        Host name of the SAP BW instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Any):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Any:
        """
        System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @system_number.setter
    def system_number(self, value: Any):
        pulumi.set(self, "system_number", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapBW'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the SAP BW server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP BW server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SapBwCubeDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The SAP BW cube dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapBwCube'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SapBwCube')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapBwCube'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SapBwSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SapBW server via MDX.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapBwSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: MDX query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapBwSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapBwSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        MDX query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapCloudForCustomerLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: Any,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 username: Optional[Any] = None):
        """
        Linked service for SAP Cloud for Customer.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapCloudForCustomer'.
        :param Any url: The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password for Basic authentication.
        :param Any username: The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapCloudForCustomer')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapCloudForCustomer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SapCloudForCustomerResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 path: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the SAP Cloud for Customer OData entity.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any path: The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapCloudForCustomerResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'SapCloudForCustomerResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Any):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapCloudForCustomerResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SapCloudForCustomerSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[pulumi.Input[Union[str, 'SapCloudForCustomerSinkWriteBehavior']]] = None):
        """
        A copy activity SAP Cloud for Customer sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SapCloudForCustomerSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union[str, 'SapCloudForCustomerSinkWriteBehavior']] write_behavior: The write behavior for the operation. Default is 'Insert'.
        """
        pulumi.set(__self__, "type", 'SapCloudForCustomerSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SapCloudForCustomerSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[pulumi.Input[Union[str, 'SapCloudForCustomerSinkWriteBehavior']]]:
        """
        The write behavior for the operation. Default is 'Insert'.
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[pulumi.Input[Union[str, 'SapCloudForCustomerSinkWriteBehavior']]]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SapCloudForCustomerSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SAP Cloud for Customer source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapCloudForCustomerSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: SAP Cloud for Customer OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapCloudForCustomerSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapCloudForCustomerSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        SAP Cloud for Customer OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapEccLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Linked service for SAP ERP Central Component(SAP ECC).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapEcc'.
        :param pulumi.Input[str] url: The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[str] encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password for Basic authentication.
        :param pulumi.Input[str] username: The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapEcc')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapEcc'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[pulumi.Input[str]]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SapEccResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 path: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the SAP ECC OData entity.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any path: The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapEccResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'SapEccResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Any):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapEccResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SapEccSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SAP ECC source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapEccSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: SAP ECC OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapEccSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapEccSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:05:00. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        SAP ECC OData query. For example, "$top=1". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapHanaLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'SapHanaAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP HANA Linked Service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapHana'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'SapHanaAuthenticationType']] authentication_type: The authentication type to be used to connect to the SAP HANA server.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the SAP HANA server.
        :param Any server: Host name of the SAP HANA server. Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP HANA server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapHana')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapHana'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'SapHanaAuthenticationType']]]:
        """
        The authentication type to be used to connect to the SAP HANA server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'SapHanaAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the SAP HANA server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP HANA server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[Any]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP HANA server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SapHanaPartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None):
        """
        The settings that will be leveraged for SAP HANA source partitioning.
        :param Any partition_column_name: The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)


@pulumi.input_type
class SapHanaSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 packet_size: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SapHanaPartitionSettingsArgs']] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SAP HANA source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapHanaSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any packet_size: The packet size of data read from SAP HANA. Type: integer(or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for SAP HANA read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "SapHanaDynamicRange". 
        :param pulumi.Input['SapHanaPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for SAP HANA source partitioning.
        :param Any query: SAP HANA Sql query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapHanaSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if packet_size is not None:
            pulumi.set(__self__, "packet_size", packet_size)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapHanaSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="packetSize")
    def packet_size(self) -> Optional[Any]:
        """
        The packet size of data read from SAP HANA. Type: integer(or Expression with resultType integer).
        """
        return pulumi.get(self, "packet_size")

    @packet_size.setter
    def packet_size(self, value: Optional[Any]):
        pulumi.set(self, "packet_size", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for SAP HANA read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "SapHanaDynamicRange". 
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SapHanaPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for SAP HANA source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SapHanaPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        SAP HANA Sql query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapHanaTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        SAP HANA Table properties.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapHanaTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of SAP HANA. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SapHanaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapHanaTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of SAP HANA. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class SapOpenHubLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 language: Optional[Any] = None,
                 logon_group: Optional[Any] = None,
                 message_server: Optional[Any] = None,
                 message_server_service: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server: Optional[Any] = None,
                 system_id: Optional[Any] = None,
                 system_number: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Business Warehouse Open Hub Destination Linked Service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapOpenHub'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any language: Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression with resultType string).
        :param Any logon_group: The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        :param Any message_server: The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        :param Any message_server_service: The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the SAP BW server where the open hub destination is located.
        :param Any server: Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType string).
        :param Any system_id: SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapOpenHub')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if logon_group is not None:
            pulumi.set(__self__, "logon_group", logon_group)
        if message_server is not None:
            pulumi.set(__self__, "message_server", message_server)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if system_id is not None:
            pulumi.set(__self__, "system_id", system_id)
        if system_number is not None:
            pulumi.set(__self__, "system_number", system_number)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapOpenHub'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def language(self) -> Optional[Any]:
        """
        Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[Any]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter(name="logonGroup")
    def logon_group(self) -> Optional[Any]:
        """
        The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "logon_group")

    @logon_group.setter
    def logon_group(self, value: Optional[Any]):
        pulumi.set(self, "logon_group", value)

    @property
    @pulumi.getter(name="messageServer")
    def message_server(self) -> Optional[Any]:
        """
        The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server")

    @message_server.setter
    def message_server(self, value: Optional[Any]):
        pulumi.set(self, "message_server", value)

    @property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[Any]:
        """
        The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server_service")

    @message_server_service.setter
    def message_server_service(self, value: Optional[Any]):
        pulumi.set(self, "message_server_service", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the SAP BW server where the open hub destination is located.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[Any]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> Optional[Any]:
        """
        SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_id")

    @system_id.setter
    def system_id(self, value: Optional[Any]):
        pulumi.set(self, "system_id", value)

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Optional[Any]:
        """
        System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @system_number.setter
    def system_number(self, value: Optional[Any]):
        pulumi.set(self, "system_number", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SapOpenHubSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 base_request_id: Optional[Any] = None,
                 custom_rfc_read_table_function_module: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 exclude_last_request: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 sap_data_column_delimiter: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SAP Business Warehouse Open Hub Destination source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapOpenHubSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any base_request_id: The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        :param Any custom_rfc_read_table_function_module: Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any exclude_last_request: Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sap_data_column_delimiter: The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapOpenHubSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if base_request_id is not None:
            pulumi.set(__self__, "base_request_id", base_request_id)
        if custom_rfc_read_table_function_module is not None:
            pulumi.set(__self__, "custom_rfc_read_table_function_module", custom_rfc_read_table_function_module)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if exclude_last_request is not None:
            pulumi.set(__self__, "exclude_last_request", exclude_last_request)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if sap_data_column_delimiter is not None:
            pulumi.set(__self__, "sap_data_column_delimiter", sap_data_column_delimiter)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapOpenHubSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="baseRequestId")
    def base_request_id(self) -> Optional[Any]:
        """
        The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        """
        return pulumi.get(self, "base_request_id")

    @base_request_id.setter
    def base_request_id(self, value: Optional[Any]):
        pulumi.set(self, "base_request_id", value)

    @property
    @pulumi.getter(name="customRfcReadTableFunctionModule")
    def custom_rfc_read_table_function_module(self) -> Optional[Any]:
        """
        Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "custom_rfc_read_table_function_module")

    @custom_rfc_read_table_function_module.setter
    def custom_rfc_read_table_function_module(self, value: Optional[Any]):
        pulumi.set(self, "custom_rfc_read_table_function_module", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="excludeLastRequest")
    def exclude_last_request(self) -> Optional[Any]:
        """
        Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "exclude_last_request")

    @exclude_last_request.setter
    def exclude_last_request(self, value: Optional[Any]):
        pulumi.set(self, "exclude_last_request", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sapDataColumnDelimiter")
    def sap_data_column_delimiter(self) -> Optional[Any]:
        """
        The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sap_data_column_delimiter")

    @sap_data_column_delimiter.setter
    def sap_data_column_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "sap_data_column_delimiter", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SapOpenHubTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 open_hub_destination_name: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 base_request_id: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 exclude_last_request: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Sap Business Warehouse Open Hub Destination Table properties.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any open_hub_destination_name: The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapOpenHubTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any base_request_id: The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        :param pulumi.Input[str] description: Dataset description.
        :param Any exclude_last_request: Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "open_hub_destination_name", open_hub_destination_name)
        pulumi.set(__self__, "type", 'SapOpenHubTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if base_request_id is not None:
            pulumi.set(__self__, "base_request_id", base_request_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_last_request is not None:
            pulumi.set(__self__, "exclude_last_request", exclude_last_request)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="openHubDestinationName")
    def open_hub_destination_name(self) -> Any:
        """
        The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "open_hub_destination_name")

    @open_hub_destination_name.setter
    def open_hub_destination_name(self, value: Any):
        pulumi.set(self, "open_hub_destination_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapOpenHubTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="baseRequestId")
    def base_request_id(self) -> Optional[Any]:
        """
        The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        """
        return pulumi.get(self, "base_request_id")

    @base_request_id.setter
    def base_request_id(self, value: Optional[Any]):
        pulumi.set(self, "base_request_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="excludeLastRequest")
    def exclude_last_request(self) -> Optional[Any]:
        """
        Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "exclude_last_request")

    @exclude_last_request.setter
    def exclude_last_request(self, value: Optional[Any]):
        pulumi.set(self, "exclude_last_request", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SapTableLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 language: Optional[Any] = None,
                 logon_group: Optional[Any] = None,
                 message_server: Optional[Any] = None,
                 message_server_service: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server: Optional[Any] = None,
                 snc_library_path: Optional[Any] = None,
                 snc_mode: Optional[Any] = None,
                 snc_my_name: Optional[Any] = None,
                 snc_partner_name: Optional[Any] = None,
                 snc_qop: Optional[Any] = None,
                 system_id: Optional[Any] = None,
                 system_number: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Table Linked Service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SapTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any language: Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType string).
        :param Any logon_group: The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        :param Any message_server: The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        :param Any message_server_service: The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to access the SAP server where the table is located.
        :param Any server: Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_library_path: External security product's library to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_mode: SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType string).
        :param Any snc_my_name: Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_partner_name: Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_qop: SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
        :param Any system_id: SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if logon_group is not None:
            pulumi.set(__self__, "logon_group", logon_group)
        if message_server is not None:
            pulumi.set(__self__, "message_server", message_server)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if snc_library_path is not None:
            pulumi.set(__self__, "snc_library_path", snc_library_path)
        if snc_mode is not None:
            pulumi.set(__self__, "snc_mode", snc_mode)
        if snc_my_name is not None:
            pulumi.set(__self__, "snc_my_name", snc_my_name)
        if snc_partner_name is not None:
            pulumi.set(__self__, "snc_partner_name", snc_partner_name)
        if snc_qop is not None:
            pulumi.set(__self__, "snc_qop", snc_qop)
        if system_id is not None:
            pulumi.set(__self__, "system_id", system_id)
        if system_number is not None:
            pulumi.set(__self__, "system_number", system_number)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SapTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def language(self) -> Optional[Any]:
        """
        Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[Any]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter(name="logonGroup")
    def logon_group(self) -> Optional[Any]:
        """
        The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "logon_group")

    @logon_group.setter
    def logon_group(self, value: Optional[Any]):
        pulumi.set(self, "logon_group", value)

    @property
    @pulumi.getter(name="messageServer")
    def message_server(self) -> Optional[Any]:
        """
        The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server")

    @message_server.setter
    def message_server(self, value: Optional[Any]):
        pulumi.set(self, "message_server", value)

    @property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[Any]:
        """
        The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server_service")

    @message_server_service.setter
    def message_server_service(self, value: Optional[Any]):
        pulumi.set(self, "message_server_service", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to access the SAP server where the table is located.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[Any]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="sncLibraryPath")
    def snc_library_path(self) -> Optional[Any]:
        """
        External security product's library to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_library_path")

    @snc_library_path.setter
    def snc_library_path(self, value: Optional[Any]):
        pulumi.set(self, "snc_library_path", value)

    @property
    @pulumi.getter(name="sncMode")
    def snc_mode(self) -> Optional[Any]:
        """
        SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_mode")

    @snc_mode.setter
    def snc_mode(self, value: Optional[Any]):
        pulumi.set(self, "snc_mode", value)

    @property
    @pulumi.getter(name="sncMyName")
    def snc_my_name(self) -> Optional[Any]:
        """
        Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_my_name")

    @snc_my_name.setter
    def snc_my_name(self, value: Optional[Any]):
        pulumi.set(self, "snc_my_name", value)

    @property
    @pulumi.getter(name="sncPartnerName")
    def snc_partner_name(self) -> Optional[Any]:
        """
        Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_partner_name")

    @snc_partner_name.setter
    def snc_partner_name(self, value: Optional[Any]):
        pulumi.set(self, "snc_partner_name", value)

    @property
    @pulumi.getter(name="sncQop")
    def snc_qop(self) -> Optional[Any]:
        """
        SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_qop")

    @snc_qop.setter
    def snc_qop(self, value: Optional[Any]):
        pulumi.set(self, "snc_qop", value)

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> Optional[Any]:
        """
        SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_id")

    @system_id.setter
    def system_id(self, value: Optional[Any]):
        pulumi.set(self, "system_id", value)

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Optional[Any]:
        """
        System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @system_number.setter
    def system_number(self, value: Optional[Any]):
        pulumi.set(self, "system_number", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SapTablePartitionSettingsArgs:
    def __init__(__self__, *,
                 max_partitions_number: Optional[Any] = None,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for SAP table source partitioning.
        :param Any max_partitions_number: The maximum value of partitions the table will be split into. Type: integer (or Expression with resultType string).
        :param Any partition_column_name: The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_upper_bound: The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if max_partitions_number is not None:
            pulumi.set(__self__, "max_partitions_number", max_partitions_number)
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="maxPartitionsNumber")
    def max_partitions_number(self) -> Optional[Any]:
        """
        The maximum value of partitions the table will be split into. Type: integer (or Expression with resultType string).
        """
        return pulumi.get(self, "max_partitions_number")

    @max_partitions_number.setter
    def max_partitions_number(self, value: Optional[Any]):
        pulumi.set(self, "max_partitions_number", value)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class SapTableResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 table_name: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        SAP Table Resource properties.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param Any table_name: The name of the SAP Table. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SapTableResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'SapTableResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        The name of the SAP Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Any):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SapTableResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SapTableSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 batch_size: Optional[Any] = None,
                 custom_rfc_read_table_function_module: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SapTablePartitionSettingsArgs']] = None,
                 query_timeout: Optional[Any] = None,
                 rfc_table_fields: Optional[Any] = None,
                 rfc_table_options: Optional[Any] = None,
                 row_count: Optional[Any] = None,
                 row_skips: Optional[Any] = None,
                 sap_data_column_delimiter: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for SAP Table source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SapTableSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any batch_size: Specifies the maximum number of rows that will be retrieved at a time when retrieving data from SAP Table. Type: integer (or Expression with resultType integer).
        :param Any custom_rfc_read_table_function_module: Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with resultType string).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for SAP table read in parallel. Possible values include: "None", "PartitionOnInt", "PartitionOnCalendarYear", "PartitionOnCalendarMonth", "PartitionOnCalendarDate", "PartitionOnTime".
        :param pulumi.Input['SapTablePartitionSettingsArgs'] partition_settings: The settings that will be leveraged for SAP table source partitioning.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any rfc_table_fields: The fields of the SAP table that will be retrieved. For example, column0, column1. Type: string (or Expression with resultType string).
        :param Any rfc_table_options: The options for the filtering of the SAP Table. For example, COLUMN0 EQ SOME VALUE. Type: string (or Expression with resultType string).
        :param Any row_count: The number of rows to be retrieved. Type: integer(or Expression with resultType integer).
        :param Any row_skips: The number of rows that will be skipped. Type: integer (or Expression with resultType integer).
        :param Any sap_data_column_delimiter: The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SapTableSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if custom_rfc_read_table_function_module is not None:
            pulumi.set(__self__, "custom_rfc_read_table_function_module", custom_rfc_read_table_function_module)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if rfc_table_fields is not None:
            pulumi.set(__self__, "rfc_table_fields", rfc_table_fields)
        if rfc_table_options is not None:
            pulumi.set(__self__, "rfc_table_options", rfc_table_options)
        if row_count is not None:
            pulumi.set(__self__, "row_count", row_count)
        if row_skips is not None:
            pulumi.set(__self__, "row_skips", row_skips)
        if sap_data_column_delimiter is not None:
            pulumi.set(__self__, "sap_data_column_delimiter", sap_data_column_delimiter)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SapTableSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[Any]:
        """
        Specifies the maximum number of rows that will be retrieved at a time when retrieving data from SAP Table. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[Any]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="customRfcReadTableFunctionModule")
    def custom_rfc_read_table_function_module(self) -> Optional[Any]:
        """
        Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "custom_rfc_read_table_function_module")

    @custom_rfc_read_table_function_module.setter
    def custom_rfc_read_table_function_module(self, value: Optional[Any]):
        pulumi.set(self, "custom_rfc_read_table_function_module", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for SAP table read in parallel. Possible values include: "None", "PartitionOnInt", "PartitionOnCalendarYear", "PartitionOnCalendarMonth", "PartitionOnCalendarDate", "PartitionOnTime".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SapTablePartitionSettingsArgs']]:
        """
        The settings that will be leveraged for SAP table source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SapTablePartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="rfcTableFields")
    def rfc_table_fields(self) -> Optional[Any]:
        """
        The fields of the SAP table that will be retrieved. For example, column0, column1. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "rfc_table_fields")

    @rfc_table_fields.setter
    def rfc_table_fields(self, value: Optional[Any]):
        pulumi.set(self, "rfc_table_fields", value)

    @property
    @pulumi.getter(name="rfcTableOptions")
    def rfc_table_options(self) -> Optional[Any]:
        """
        The options for the filtering of the SAP Table. For example, COLUMN0 EQ SOME VALUE. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "rfc_table_options")

    @rfc_table_options.setter
    def rfc_table_options(self, value: Optional[Any]):
        pulumi.set(self, "rfc_table_options", value)

    @property
    @pulumi.getter(name="rowCount")
    def row_count(self) -> Optional[Any]:
        """
        The number of rows to be retrieved. Type: integer(or Expression with resultType integer).
        """
        return pulumi.get(self, "row_count")

    @row_count.setter
    def row_count(self, value: Optional[Any]):
        pulumi.set(self, "row_count", value)

    @property
    @pulumi.getter(name="rowSkips")
    def row_skips(self) -> Optional[Any]:
        """
        The number of rows that will be skipped. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "row_skips")

    @row_skips.setter
    def row_skips(self, value: Optional[Any]):
        pulumi.set(self, "row_skips", value)

    @property
    @pulumi.getter(name="sapDataColumnDelimiter")
    def sap_data_column_delimiter(self) -> Optional[Any]:
        """
        The single character that will be used as delimiter passed to SAP RFC as well as splitting the output data retrieved. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sap_data_column_delimiter")

    @sap_data_column_delimiter.setter
    def sap_data_column_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "sap_data_column_delimiter", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class ScheduleTriggerRecurrenceArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[Union[str, 'RecurrenceFrequency']]] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 schedule: Optional[pulumi.Input['RecurrenceScheduleArgs']] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        The workflow trigger recurrence.
        :param pulumi.Input[str] end_time: The end time.
        :param pulumi.Input[Union[str, 'RecurrenceFrequency']] frequency: The frequency.
        :param pulumi.Input[int] interval: The interval.
        :param pulumi.Input['RecurrenceScheduleArgs'] schedule: The recurrence schedule.
        :param pulumi.Input[str] start_time: The start time.
        :param pulumi.Input[str] time_zone: The time zone.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[Union[str, 'RecurrenceFrequency']]]:
        """
        The frequency.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[Union[str, 'RecurrenceFrequency']]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['RecurrenceScheduleArgs']]:
        """
        The recurrence schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['RecurrenceScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class ScheduleTriggerArgs:
    def __init__(__self__, *,
                 recurrence: pulumi.Input['ScheduleTriggerRecurrenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]] = None):
        """
        Trigger that creates pipeline runs periodically, on schedule.
        :param pulumi.Input['ScheduleTriggerRecurrenceArgs'] recurrence: Recurrence schedule configuration.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'ScheduleTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]] pipelines: Pipelines that need to be started.
        """
        pulumi.set(__self__, "recurrence", recurrence)
        pulumi.set(__self__, "type", 'ScheduleTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)

    @property
    @pulumi.getter
    def recurrence(self) -> pulumi.Input['ScheduleTriggerRecurrenceArgs']:
        """
        Recurrence schedule configuration.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: pulumi.Input['ScheduleTriggerRecurrenceArgs']):
        pulumi.set(self, "recurrence", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'ScheduleTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerPipelineReferenceArgs']]]]):
        pulumi.set(self, "pipelines", value)


@pulumi.input_type
class ScriptActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 roles: Any,
                 uri: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        Custom script action to run on HDI ondemand cluster once it's up.
        :param pulumi.Input[str] name: The user provided name of the script action.
        :param Any roles: The node types on which the script action should be executed.
        :param pulumi.Input[str] uri: The URI for the script action.
        :param pulumi.Input[str] parameters: The parameters for the script action.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "uri", uri)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The user provided name of the script action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def roles(self) -> Any:
        """
        The node types on which the script action should be executed.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Any):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI for the script action.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        The parameters for the script action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class SecureStringArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Azure Data Factory secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
        :param pulumi.Input[str] type: Type of the secret.
               Expected value is 'SecureString'.
        :param pulumi.Input[str] value: Value of secure string.
        """
        pulumi.set(__self__, "type", 'SecureString')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the secret.
        Expected value is 'SecureString'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of secure string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SelfDependencyTumblingWindowTriggerReferenceArgs:
    def __init__(__self__, *,
                 offset: pulumi.Input[str],
                 type: pulumi.Input[str],
                 size: Optional[pulumi.Input[str]] = None):
        """
        Self referenced tumbling window trigger dependency.
        :param pulumi.Input[str] offset: Timespan applied to the start time of a tumbling window when evaluating dependency.
        :param pulumi.Input[str] type: The type of dependency reference.
               Expected value is 'SelfDependencyTumblingWindowTriggerReference'.
        :param pulumi.Input[str] size: The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "type", 'SelfDependencyTumblingWindowTriggerReference')
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def offset(self) -> pulumi.Input[str]:
        """
        Timespan applied to the start time of a tumbling window when evaluating dependency.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: pulumi.Input[str]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of dependency reference.
        Expected value is 'SelfDependencyTumblingWindowTriggerReference'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class SelfHostedIntegrationRuntimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 linked_info: Optional[pulumi.Input[Union['LinkedIntegrationRuntimeKeyAuthorizationArgs', 'LinkedIntegrationRuntimeRbacAuthorizationArgs']]] = None):
        """
        Self-hosted integration runtime.
        :param pulumi.Input[str] type: The type of integration runtime.
               Expected value is 'SelfHosted'.
        :param pulumi.Input[str] description: Integration runtime description.
        :param pulumi.Input[Union['LinkedIntegrationRuntimeKeyAuthorizationArgs', 'LinkedIntegrationRuntimeRbacAuthorizationArgs']] linked_info: The base definition of a linked integration runtime.
        """
        pulumi.set(__self__, "type", 'SelfHosted')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of integration runtime.
        Expected value is 'SelfHosted'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional[pulumi.Input[Union['LinkedIntegrationRuntimeKeyAuthorizationArgs', 'LinkedIntegrationRuntimeRbacAuthorizationArgs']]]:
        """
        The base definition of a linked integration runtime.
        """
        return pulumi.get(self, "linked_info")

    @linked_info.setter
    def linked_info(self, value: Optional[pulumi.Input[Union['LinkedIntegrationRuntimeKeyAuthorizationArgs', 'LinkedIntegrationRuntimeRbacAuthorizationArgs']]]):
        pulumi.set(self, "linked_info", value)


@pulumi.input_type
class ServiceNowLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'ServiceNowAuthenticationType']],
                 endpoint: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        ServiceNow server linked service.
        :param pulumi.Input[Union[str, 'ServiceNowAuthenticationType']] authentication_type: The authentication type to use.
        :param Any endpoint: The endpoint of the ServiceNow server. (i.e. <instance>.service-now.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'ServiceNow'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id for OAuth2 authentication.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret for OAuth2 authentication.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name for Basic and OAuth2 authentication.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        :param Any username: The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'ServiceNow')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'ServiceNowAuthenticationType']]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'ServiceNowAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the ServiceNow server. (i.e. <instance>.service-now.com)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Any):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'ServiceNow'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id for OAuth2 authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret for OAuth2 authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name for Basic and OAuth2 authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceNowObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        ServiceNow server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ServiceNowObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ServiceNowObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ServiceNowObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ServiceNowSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity ServiceNow server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ServiceNowSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ServiceNowSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ServiceNowSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SetVariableActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None,
                 value: Optional[Any] = None,
                 variable_name: Optional[pulumi.Input[str]] = None):
        """
        Set value for a Variable.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'SetVariable'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        :param Any value: Value to be set. Could be a static value or Expression
        :param pulumi.Input[str] variable_name: Name of the variable whose value needs to be set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'SetVariable')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable_name is not None:
            pulumi.set(__self__, "variable_name", variable_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'SetVariable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Value to be set. Could be a static value or Expression
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="variableName")
    def variable_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the variable whose value needs to be set.
        """
        return pulumi.get(self, "variable_name")

    @variable_name.setter
    def variable_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variable_name", value)


@pulumi.input_type
class SftpLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of SFTP dataset.
        :param pulumi.Input[str] type: Type of dataset storage location.
               Expected value is 'SftpLocation'.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'SftpLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage location.
        Expected value is 'SftpLocation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[Any]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[Any]):
        pulumi.set(self, "folder_path", value)


@pulumi.input_type
class SftpReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 delete_files_after_completion: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 enable_partition_discovery: Optional[pulumi.Input[bool]] = None,
                 file_list_path: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 partition_root_path: Optional[Any] = None,
                 recursive: Optional[Any] = None,
                 wildcard_file_name: Optional[Any] = None,
                 wildcard_folder_path: Optional[Any] = None):
        """
        Sftp read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'SftpReadSettings'.
        :param Any delete_files_after_completion: Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[bool] enable_partition_discovery: Indicates whether to enable partition discovery.
        :param Any file_list_path: Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any partition_root_path: Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        :param Any recursive: If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        :param Any wildcard_file_name: Sftp wildcardFileName. Type: string (or Expression with resultType string).
        :param Any wildcard_folder_path: Sftp wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SftpReadSettings')
        if delete_files_after_completion is not None:
            pulumi.set(__self__, "delete_files_after_completion", delete_files_after_completion)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if enable_partition_discovery is not None:
            pulumi.set(__self__, "enable_partition_discovery", enable_partition_discovery)
        if file_list_path is not None:
            pulumi.set(__self__, "file_list_path", file_list_path)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if partition_root_path is not None:
            pulumi.set(__self__, "partition_root_path", partition_root_path)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if wildcard_file_name is not None:
            pulumi.set(__self__, "wildcard_file_name", wildcard_file_name)
        if wildcard_folder_path is not None:
            pulumi.set(__self__, "wildcard_folder_path", wildcard_folder_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'SftpReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="deleteFilesAfterCompletion")
    def delete_files_after_completion(self) -> Optional[Any]:
        """
        Indicates whether the source files need to be deleted after copy completion. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "delete_files_after_completion")

    @delete_files_after_completion.setter
    def delete_files_after_completion(self, value: Optional[Any]):
        pulumi.set(self, "delete_files_after_completion", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="enablePartitionDiscovery")
    def enable_partition_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to enable partition discovery.
        """
        return pulumi.get(self, "enable_partition_discovery")

    @enable_partition_discovery.setter
    def enable_partition_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partition_discovery", value)

    @property
    @pulumi.getter(name="fileListPath")
    def file_list_path(self) -> Optional[Any]:
        """
        Point to a text file that lists each file (relative path to the path configured in the dataset) that you want to copy. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_list_path")

    @file_list_path.setter
    def file_list_path(self, value: Optional[Any]):
        pulumi.set(self, "file_list_path", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @modified_datetime_end.setter
    def modified_datetime_end(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_end", value)

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @modified_datetime_start.setter
    def modified_datetime_start(self, value: Optional[Any]):
        pulumi.set(self, "modified_datetime_start", value)

    @property
    @pulumi.getter(name="partitionRootPath")
    def partition_root_path(self) -> Optional[Any]:
        """
        Specify the root path where partition discovery starts from. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_root_path")

    @partition_root_path.setter
    def partition_root_path(self, value: Optional[Any]):
        pulumi.set(self, "partition_root_path", value)

    @property
    @pulumi.getter
    def recursive(self) -> Optional[Any]:
        """
        If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "recursive")

    @recursive.setter
    def recursive(self, value: Optional[Any]):
        pulumi.set(self, "recursive", value)

    @property
    @pulumi.getter(name="wildcardFileName")
    def wildcard_file_name(self) -> Optional[Any]:
        """
        Sftp wildcardFileName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_file_name")

    @wildcard_file_name.setter
    def wildcard_file_name(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_file_name", value)

    @property
    @pulumi.getter(name="wildcardFolderPath")
    def wildcard_folder_path(self) -> Optional[Any]:
        """
        Sftp wildcardFolderPath. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "wildcard_folder_path")

    @wildcard_folder_path.setter
    def wildcard_folder_path(self, value: Optional[Any]):
        pulumi.set(self, "wildcard_folder_path", value)


@pulumi.input_type
class SftpServerLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'SftpAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_key_fingerprint: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pass_phrase: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 port: Optional[Any] = None,
                 private_key_content: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 private_key_path: Optional[Any] = None,
                 skip_host_key_validation: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        A linked service for an SSH File Transfer Protocol (SFTP) server. 
        :param Any host: The SFTP server host name. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Sftp'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'SftpAuthenticationType']] authentication_type: The authentication type to be used to connect to the FTP server.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_key_fingerprint: The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] pass_phrase: The password to decrypt the SSH private key if the SSH private key is encrypted.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password to logon the SFTP server for Basic authentication.
        :param Any port: The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] private_key_content: Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
        :param Any private_key_path: The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
        :param Any skip_host_key_validation: If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any user_name: The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Sftp')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_key_fingerprint is not None:
            pulumi.set(__self__, "host_key_fingerprint", host_key_fingerprint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pass_phrase is not None:
            pulumi.set(__self__, "pass_phrase", pass_phrase)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_key_content is not None:
            pulumi.set(__self__, "private_key_content", private_key_content)
        if private_key_path is not None:
            pulumi.set(__self__, "private_key_path", private_key_path)
        if skip_host_key_validation is not None:
            pulumi.set(__self__, "skip_host_key_validation", skip_host_key_validation)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The SFTP server host name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Sftp'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'SftpAuthenticationType']]]:
        """
        The authentication type to be used to connect to the FTP server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'SftpAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="hostKeyFingerprint")
    def host_key_fingerprint(self) -> Optional[Any]:
        """
        The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_key_fingerprint")

    @host_key_fingerprint.setter
    def host_key_fingerprint(self, value: Optional[Any]):
        pulumi.set(self, "host_key_fingerprint", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="passPhrase")
    def pass_phrase(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password to decrypt the SSH private key if the SSH private key is encrypted.
        """
        return pulumi.get(self, "pass_phrase")

    @pass_phrase.setter
    def pass_phrase(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "pass_phrase", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password to logon the SFTP server for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[Any]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="privateKeyContent")
    def private_key_content(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
        """
        return pulumi.get(self, "private_key_content")

    @private_key_content.setter
    def private_key_content(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "private_key_content", value)

    @property
    @pulumi.getter(name="privateKeyPath")
    def private_key_path(self) -> Optional[Any]:
        """
        The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "private_key_path")

    @private_key_path.setter
    def private_key_path(self, value: Optional[Any]):
        pulumi.set(self, "private_key_path", value)

    @property
    @pulumi.getter(name="skipHostKeyValidation")
    def skip_host_key_validation(self) -> Optional[Any]:
        """
        If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "skip_host_key_validation")

    @skip_host_key_validation.setter
    def skip_host_key_validation(self, value: Optional[Any]):
        pulumi.set(self, "skip_host_key_validation", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SftpWriteSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 copy_behavior: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 operation_timeout: Optional[Any] = None,
                 use_temp_file_rename: Optional[Any] = None):
        """
        Sftp write settings.
        :param pulumi.Input[str] type: The write setting type.
               Expected value is 'SftpWriteSettings'.
        :param Any copy_behavior: The type of copy behavior for copy sink.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any operation_timeout: Specifies the timeout for writing each chunk to SFTP server. Default value: 01:00:00 (one hour). Type: string (or Expression with resultType string).
        :param Any use_temp_file_rename: Upload to temporary file(s) and rename. Disable this option if your SFTP server doesn't support rename operation. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'SftpWriteSettings')
        if copy_behavior is not None:
            pulumi.set(__self__, "copy_behavior", copy_behavior)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if operation_timeout is not None:
            pulumi.set(__self__, "operation_timeout", operation_timeout)
        if use_temp_file_rename is not None:
            pulumi.set(__self__, "use_temp_file_rename", use_temp_file_rename)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The write setting type.
        Expected value is 'SftpWriteSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="copyBehavior")
    def copy_behavior(self) -> Optional[Any]:
        """
        The type of copy behavior for copy sink.
        """
        return pulumi.get(self, "copy_behavior")

    @copy_behavior.setter
    def copy_behavior(self, value: Optional[Any]):
        pulumi.set(self, "copy_behavior", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="operationTimeout")
    def operation_timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for writing each chunk to SFTP server. Default value: 01:00:00 (one hour). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "operation_timeout")

    @operation_timeout.setter
    def operation_timeout(self, value: Optional[Any]):
        pulumi.set(self, "operation_timeout", value)

    @property
    @pulumi.getter(name="useTempFileRename")
    def use_temp_file_rename(self) -> Optional[Any]:
        """
        Upload to temporary file(s) and rename. Disable this option if your SFTP server doesn't support rename operation. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_temp_file_rename")

    @use_temp_file_rename.setter
    def use_temp_file_rename(self, value: Optional[Any]):
        pulumi.set(self, "use_temp_file_rename", value)


@pulumi.input_type
class SharePointOnlineListLinkedServiceArgs:
    def __init__(__self__, *,
                 service_principal_id: Any,
                 service_principal_key: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 site_url: Any,
                 tenant_id: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        SharePoint Online List linked service.
        :param Any service_principal_id: The application (client) ID of your application registered in Azure Active Directory. Make sure to grant SharePoint site permission to this application. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The client secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Any site_url: The URL of the SharePoint Online site. For example, https://contoso.sharepoint.com/sites/siteName. Type: string (or Expression with resultType string).
        :param Any tenant_id: The tenant ID under which your application resides. You can find it from Azure portal Active Directory overview page. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SharePointOnlineList'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "site_url", site_url)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", 'SharePointOnlineList')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        The application (client) ID of your application registered in Azure Active Directory. Make sure to grant SharePoint site permission to this application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Any):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The client secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "service_principal_key", value)

    @property
    @pulumi.getter(name="siteUrl")
    def site_url(self) -> Any:
        """
        The URL of the SharePoint Online site. For example, https://contoso.sharepoint.com/sites/siteName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "site_url")

    @site_url.setter
    def site_url(self, value: Any):
        pulumi.set(self, "site_url", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Any:
        """
        The tenant ID under which your application resides. You can find it from Azure portal Active Directory overview page. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Any):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SharePointOnlineList'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class SharePointOnlineListResourceDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 list_name: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The sharepoint online list resource dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SharePointOnlineListResource'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any list_name: The name of the SharePoint Online list. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SharePointOnlineListResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if list_name is not None:
            pulumi.set(__self__, "list_name", list_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SharePointOnlineListResource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="listName")
    def list_name(self) -> Optional[Any]:
        """
        The name of the SharePoint Online list. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "list_name")

    @list_name.setter
    def list_name(self, value: Optional[Any]):
        pulumi.set(self, "list_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class SharePointOnlineListSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 http_request_timeout: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for sharePoint online list source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SharePointOnlineListSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any http_request_timeout: The wait time to get a response from SharePoint Online. Default value is 5 minutes (00:05:00). Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: The OData query to filter the data in SharePoint Online list. For example, "$top=1". Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SharePointOnlineListSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if http_request_timeout is not None:
            pulumi.set(__self__, "http_request_timeout", http_request_timeout)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SharePointOnlineListSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="httpRequestTimeout")
    def http_request_timeout(self) -> Optional[Any]:
        """
        The wait time to get a response from SharePoint Online. Default value is 5 minutes (00:05:00). Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "http_request_timeout")

    @http_request_timeout.setter
    def http_request_timeout(self, value: Optional[Any]):
        pulumi.set(self, "http_request_timeout", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        The OData query to filter the data in SharePoint Online list. For example, "$top=1". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class ShopifyLinkedServiceArgs:
    def __init__(__self__, *,
                 host: Any,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Shopify Service linked service.
        :param Any host: The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Shopify'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: The API access token that can be used to access Shopifys data. The token won't expire if it is offline mode.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Shopify')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Shopify'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The API access token that can be used to access Shopifys data. The token won't expire if it is offline mode.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class ShopifyObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Shopify Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ShopifyObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ShopifyObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ShopifyObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ShopifySourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Shopify Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ShopifySource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ShopifySource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ShopifySource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SkipErrorFileArgs:
    def __init__(__self__, *,
                 data_inconsistency: Optional[Any] = None,
                 file_missing: Optional[Any] = None):
        """
        Skip error file.
        :param Any data_inconsistency: Skip if source/sink file changed by other concurrent write. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any file_missing: Skip if file is deleted by other client during copy. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        if data_inconsistency is not None:
            pulumi.set(__self__, "data_inconsistency", data_inconsistency)
        if file_missing is not None:
            pulumi.set(__self__, "file_missing", file_missing)

    @property
    @pulumi.getter(name="dataInconsistency")
    def data_inconsistency(self) -> Optional[Any]:
        """
        Skip if source/sink file changed by other concurrent write. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "data_inconsistency")

    @data_inconsistency.setter
    def data_inconsistency(self, value: Optional[Any]):
        pulumi.set(self, "data_inconsistency", value)

    @property
    @pulumi.getter(name="fileMissing")
    def file_missing(self) -> Optional[Any]:
        """
        Skip if file is deleted by other client during copy. Default is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "file_missing")

    @file_missing.setter
    def file_missing(self, value: Optional[Any]):
        pulumi.set(self, "file_missing", value)


@pulumi.input_type
class SnowflakeDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The snowflake dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SnowflakeTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Snowflake database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SnowflakeTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SnowflakeTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Snowflake database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class SnowflakeExportCopyCommandArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_copy_options: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 additional_format_options: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Snowflake export command settings.
        :param pulumi.Input[str] type: The export setting type.
               Expected value is 'SnowflakeExportCopyCommand'.
        :param pulumi.Input[Mapping[str, Any]] additional_copy_options: Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE_FORMAT": "MM/DD/YYYY", "TIME_FORMAT": "'HH24:MI:SS.FF'" }
        :param pulumi.Input[Mapping[str, Any]] additional_format_options: Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalFormatOptions": { "OVERWRITE": "TRUE", "MAX_FILE_SIZE": "'FALSE'" }
        """
        pulumi.set(__self__, "type", 'SnowflakeExportCopyCommand')
        if additional_copy_options is not None:
            pulumi.set(__self__, "additional_copy_options", additional_copy_options)
        if additional_format_options is not None:
            pulumi.set(__self__, "additional_format_options", additional_format_options)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The export setting type.
        Expected value is 'SnowflakeExportCopyCommand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalCopyOptions")
    def additional_copy_options(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE_FORMAT": "MM/DD/YYYY", "TIME_FORMAT": "'HH24:MI:SS.FF'" }
        """
        return pulumi.get(self, "additional_copy_options")

    @additional_copy_options.setter
    def additional_copy_options(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_copy_options", value)

    @property
    @pulumi.getter(name="additionalFormatOptions")
    def additional_format_options(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalFormatOptions": { "OVERWRITE": "TRUE", "MAX_FILE_SIZE": "'FALSE'" }
        """
        return pulumi.get(self, "additional_format_options")

    @additional_format_options.setter
    def additional_format_options(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_format_options", value)


@pulumi.input_type
class SnowflakeImportCopyCommandArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_copy_options: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 additional_format_options: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Snowflake import command settings.
        :param pulumi.Input[str] type: The import setting type.
               Expected value is 'SnowflakeImportCopyCommand'.
        :param pulumi.Input[Mapping[str, Any]] additional_copy_options: Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE_FORMAT": "MM/DD/YYYY", "TIME_FORMAT": "'HH24:MI:SS.FF'" }
        :param pulumi.Input[Mapping[str, Any]] additional_format_options: Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalFormatOptions": { "FORCE": "TRUE", "LOAD_UNCERTAIN_FILES": "'FALSE'" }
        """
        pulumi.set(__self__, "type", 'SnowflakeImportCopyCommand')
        if additional_copy_options is not None:
            pulumi.set(__self__, "additional_copy_options", additional_copy_options)
        if additional_format_options is not None:
            pulumi.set(__self__, "additional_format_options", additional_format_options)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The import setting type.
        Expected value is 'SnowflakeImportCopyCommand'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalCopyOptions")
    def additional_copy_options(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional copy options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalCopyOptions": { "DATE_FORMAT": "MM/DD/YYYY", "TIME_FORMAT": "'HH24:MI:SS.FF'" }
        """
        return pulumi.get(self, "additional_copy_options")

    @additional_copy_options.setter
    def additional_copy_options(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_copy_options", value)

    @property
    @pulumi.getter(name="additionalFormatOptions")
    def additional_format_options(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional format options directly passed to snowflake Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object). Example: "additionalFormatOptions": { "FORCE": "TRUE", "LOAD_UNCERTAIN_FILES": "'FALSE'" }
        """
        return pulumi.get(self, "additional_format_options")

    @additional_format_options.setter
    def additional_format_options(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_format_options", value)


@pulumi.input_type
class SnowflakeLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Snowflake linked service.
        :param Any connection_string: The connection string of snowflake. Type: string, SecureString.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Snowflake'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Snowflake')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string of snowflake. Type: string, SecureString.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Snowflake'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class SnowflakeSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 import_settings: Optional[pulumi.Input['SnowflakeImportCopyCommandArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None):
        """
        A copy activity snowflake sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SnowflakeSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['SnowflakeImportCopyCommandArgs'] import_settings: Snowflake import settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SnowflakeSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if import_settings is not None:
            pulumi.set(__self__, "import_settings", import_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SnowflakeSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="importSettings")
    def import_settings(self) -> Optional[pulumi.Input['SnowflakeImportCopyCommandArgs']]:
        """
        Snowflake import settings.
        """
        return pulumi.get(self, "import_settings")

    @import_settings.setter
    def import_settings(self, value: Optional[pulumi.Input['SnowflakeImportCopyCommandArgs']]):
        pulumi.set(self, "import_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)


@pulumi.input_type
class SnowflakeSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 export_settings: Optional[pulumi.Input['SnowflakeExportCopyCommandArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity snowflake source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SnowflakeSource'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['SnowflakeExportCopyCommandArgs'] export_settings: Snowflake export settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Snowflake Sql query. Type: string (or Expression with resultType string).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SnowflakeSource')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if export_settings is not None:
            pulumi.set(__self__, "export_settings", export_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SnowflakeSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="exportSettings")
    def export_settings(self) -> Optional[pulumi.Input['SnowflakeExportCopyCommandArgs']]:
        """
        Snowflake export settings.
        """
        return pulumi.get(self, "export_settings")

    @export_settings.setter
    def export_settings(self, value: Optional[pulumi.Input['SnowflakeExportCopyCommandArgs']]):
        pulumi.set(self, "export_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Snowflake Sql query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SparkLinkedServiceArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[Union[str, 'SparkAuthenticationType']],
                 host: Any,
                 port: Any,
                 type: pulumi.Input[str],
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server_type: Optional[pulumi.Input[Union[str, 'SparkServerType']]] = None,
                 thrift_transport_protocol: Optional[pulumi.Input[Union[str, 'SparkThriftTransportProtocol']]] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Spark Server linked service.
        :param pulumi.Input[Union[str, 'SparkAuthenticationType']] authentication_type: The authentication method used to access the Spark server.
        :param Any host: IP address or host name of the Spark server
        :param Any port: The TCP port that the Spark server uses to listen for client connections.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Spark'.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Spark server.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password corresponding to the user name that you provided in the Username field
        :param pulumi.Input[Union[str, 'SparkServerType']] server_type: The type of Spark server.
        :param pulumi.Input[Union[str, 'SparkThriftTransportProtocol']] thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name that you use to access Spark Server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", 'Spark')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if thrift_transport_protocol is not None:
            pulumi.set(__self__, "thrift_transport_protocol", thrift_transport_protocol)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[Union[str, 'SparkAuthenticationType']]:
        """
        The authentication method used to access the Spark server.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[Union[str, 'SparkAuthenticationType']]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        IP address or host name of the Spark server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Any):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Any:
        """
        The TCP port that the Spark server uses to listen for client connections.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Any):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Spark'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @allow_host_name_cn_mismatch.setter
    def allow_host_name_cn_mismatch(self, value: Optional[Any]):
        pulumi.set(self, "allow_host_name_cn_mismatch", value)

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @allow_self_signed_server_cert.setter
    def allow_self_signed_server_cert(self, value: Optional[Any]):
        pulumi.set(self, "allow_self_signed_server_cert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @enable_ssl.setter
    def enable_ssl(self, value: Optional[Any]):
        pulumi.set(self, "enable_ssl", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Spark server.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[Any]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The password corresponding to the user name that you provided in the Username field
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[Union[str, 'SparkServerType']]]:
        """
        The type of Spark server.
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[Union[str, 'SparkServerType']]]):
        pulumi.set(self, "server_type", value)

    @property
    @pulumi.getter(name="thriftTransportProtocol")
    def thrift_transport_protocol(self) -> Optional[pulumi.Input[Union[str, 'SparkThriftTransportProtocol']]]:
        """
        The transport protocol to use in the Thrift layer.
        """
        return pulumi.get(self, "thrift_transport_protocol")

    @thrift_transport_protocol.setter
    def thrift_transport_protocol(self, value: Optional[pulumi.Input[Union[str, 'SparkThriftTransportProtocol']]]):
        pulumi.set(self, "thrift_transport_protocol", value)

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @trusted_cert_path.setter
    def trusted_cert_path(self, value: Optional[Any]):
        pulumi.set(self, "trusted_cert_path", value)

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @use_system_trust_store.setter
    def use_system_trust_store(self, value: Optional[Any]):
        pulumi.set(self, "use_system_trust_store", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name that you use to access Spark Server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SparkObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Spark Server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SparkObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Spark. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SparkObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SparkObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Spark. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class SparkSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Spark Server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SparkSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SparkSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SparkSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SqlAlwaysEncryptedPropertiesArgs:
    def __init__(__self__, *,
                 always_encrypted_akv_auth_type: pulumi.Input[Union[str, 'SqlAlwaysEncryptedAkvAuthType']],
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None):
        """
        Sql always encrypted properties.
        :param pulumi.Input[Union[str, 'SqlAlwaysEncryptedAkvAuthType']] always_encrypted_akv_auth_type: Sql always encrypted AKV authentication type. Type: string (or Expression with resultType string).
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Azure Key Vault authentication. Type: string (or Expression with resultType string).
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] service_principal_key: The key of the service principal used to authenticate against Azure Key Vault.
        """
        pulumi.set(__self__, "always_encrypted_akv_auth_type", always_encrypted_akv_auth_type)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)

    @property
    @pulumi.getter(name="alwaysEncryptedAkvAuthType")
    def always_encrypted_akv_auth_type(self) -> pulumi.Input[Union[str, 'SqlAlwaysEncryptedAkvAuthType']]:
        """
        Sql always encrypted AKV authentication type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "always_encrypted_akv_auth_type")

    @always_encrypted_akv_auth_type.setter
    def always_encrypted_akv_auth_type(self, value: pulumi.Input[Union[str, 'SqlAlwaysEncryptedAkvAuthType']]):
        pulumi.set(self, "always_encrypted_akv_auth_type", value)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Azure Key Vault authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: Optional[Any]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The key of the service principal used to authenticate against Azure Key Vault.
        """
        return pulumi.get(self, "service_principal_key")

    @service_principal_key.setter
    def service_principal_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "service_principal_key", value)


@pulumi.input_type
class SqlDWSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 allow_copy_command: Optional[Any] = None,
                 allow_poly_base: Optional[Any] = None,
                 copy_command_settings: Optional[pulumi.Input['DWCopyCommandSettingsArgs']] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 poly_base_settings: Optional[pulumi.Input['PolybaseSettingsArgs']] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 sql_writer_use_table_lock: Optional[Any] = None,
                 table_option: Optional[Any] = None,
                 upsert_settings: Optional[pulumi.Input['SqlDWUpsertSettingsArgs']] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity SQL Data Warehouse sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SqlDWSink'.
        :param Any allow_copy_command: Indicates to use Copy Command to copy data into SQL Data Warehouse. Type: boolean (or Expression with resultType boolean).
        :param Any allow_poly_base: Indicates to use PolyBase to copy data into SQL Data Warehouse when applicable. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['DWCopyCommandSettingsArgs'] copy_command_settings: Specifies Copy Command related settings when allowCopyCommand is true.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param pulumi.Input['PolybaseSettingsArgs'] poly_base_settings: Specifies PolyBase-related settings when allowPolyBase is true.
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_writer_use_table_lock: Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        :param Any table_option: The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        :param pulumi.Input['SqlDWUpsertSettingsArgs'] upsert_settings: SQL DW upsert settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Write behavior when copying data into azure SQL DW. Type: SqlDWWriteBehaviorEnum (or Expression with resultType SqlDWWriteBehaviorEnum)
        """
        pulumi.set(__self__, "type", 'SqlDWSink')
        if allow_copy_command is not None:
            pulumi.set(__self__, "allow_copy_command", allow_copy_command)
        if allow_poly_base is not None:
            pulumi.set(__self__, "allow_poly_base", allow_poly_base)
        if copy_command_settings is not None:
            pulumi.set(__self__, "copy_command_settings", copy_command_settings)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if poly_base_settings is not None:
            pulumi.set(__self__, "poly_base_settings", poly_base_settings)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if sql_writer_use_table_lock is not None:
            pulumi.set(__self__, "sql_writer_use_table_lock", sql_writer_use_table_lock)
        if table_option is not None:
            pulumi.set(__self__, "table_option", table_option)
        if upsert_settings is not None:
            pulumi.set(__self__, "upsert_settings", upsert_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SqlDWSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowCopyCommand")
    def allow_copy_command(self) -> Optional[Any]:
        """
        Indicates to use Copy Command to copy data into SQL Data Warehouse. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "allow_copy_command")

    @allow_copy_command.setter
    def allow_copy_command(self, value: Optional[Any]):
        pulumi.set(self, "allow_copy_command", value)

    @property
    @pulumi.getter(name="allowPolyBase")
    def allow_poly_base(self) -> Optional[Any]:
        """
        Indicates to use PolyBase to copy data into SQL Data Warehouse when applicable. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "allow_poly_base")

    @allow_poly_base.setter
    def allow_poly_base(self, value: Optional[Any]):
        pulumi.set(self, "allow_poly_base", value)

    @property
    @pulumi.getter(name="copyCommandSettings")
    def copy_command_settings(self) -> Optional[pulumi.Input['DWCopyCommandSettingsArgs']]:
        """
        Specifies Copy Command related settings when allowCopyCommand is true.
        """
        return pulumi.get(self, "copy_command_settings")

    @copy_command_settings.setter
    def copy_command_settings(self, value: Optional[pulumi.Input['DWCopyCommandSettingsArgs']]):
        pulumi.set(self, "copy_command_settings", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="polyBaseSettings")
    def poly_base_settings(self) -> Optional[pulumi.Input['PolybaseSettingsArgs']]:
        """
        Specifies PolyBase-related settings when allowPolyBase is true.
        """
        return pulumi.get(self, "poly_base_settings")

    @poly_base_settings.setter
    def poly_base_settings(self, value: Optional[pulumi.Input['PolybaseSettingsArgs']]):
        pulumi.set(self, "poly_base_settings", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="sqlWriterUseTableLock")
    def sql_writer_use_table_lock(self) -> Optional[Any]:
        """
        Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "sql_writer_use_table_lock")

    @sql_writer_use_table_lock.setter
    def sql_writer_use_table_lock(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_use_table_lock", value)

    @property
    @pulumi.getter(name="tableOption")
    def table_option(self) -> Optional[Any]:
        """
        The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_option")

    @table_option.setter
    def table_option(self, value: Optional[Any]):
        pulumi.set(self, "table_option", value)

    @property
    @pulumi.getter(name="upsertSettings")
    def upsert_settings(self) -> Optional[pulumi.Input['SqlDWUpsertSettingsArgs']]:
        """
        SQL DW upsert settings.
        """
        return pulumi.get(self, "upsert_settings")

    @upsert_settings.setter
    def upsert_settings(self, value: Optional[pulumi.Input['SqlDWUpsertSettingsArgs']]):
        pulumi.set(self, "upsert_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Write behavior when copying data into azure SQL DW. Type: SqlDWWriteBehaviorEnum (or Expression with resultType SqlDWWriteBehaviorEnum)
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SqlDWSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[Any] = None):
        """
        A copy activity SQL Data Warehouse source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SqlDWSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL Data Warehouse reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a SQL Data Warehouse source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param Any stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}". Type: object (or Expression with resultType object), itemType: StoredProcedureParameter.
        """
        pulumi.set(__self__, "type", 'SqlDWSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SqlDWSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL Data Warehouse reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a SQL Data Warehouse source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[Any]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}". Type: object (or Expression with resultType object), itemType: StoredProcedureParameter.
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[Any]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class SqlDWUpsertSettingsArgs:
    def __init__(__self__, *,
                 interim_schema_name: Optional[Any] = None,
                 keys: Optional[Any] = None):
        """
        Sql DW upsert option settings
        :param Any interim_schema_name: Schema name for interim table. Type: string (or Expression with resultType string).
        :param Any keys: Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
        """
        if interim_schema_name is not None:
            pulumi.set(__self__, "interim_schema_name", interim_schema_name)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter(name="interimSchemaName")
    def interim_schema_name(self) -> Optional[Any]:
        """
        Schema name for interim table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "interim_schema_name")

    @interim_schema_name.setter
    def interim_schema_name(self, value: Optional[Any]):
        pulumi.set(self, "interim_schema_name", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[Any]:
        """
        Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[Any]):
        pulumi.set(self, "keys", value)


@pulumi.input_type
class SqlMISinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 sql_writer_stored_procedure_name: Optional[Any] = None,
                 sql_writer_table_type: Optional[Any] = None,
                 sql_writer_use_table_lock: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None,
                 stored_procedure_table_type_parameter_name: Optional[Any] = None,
                 table_option: Optional[Any] = None,
                 upsert_settings: Optional[pulumi.Input['SqlUpsertSettingsArgs']] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity Azure SQL Managed Instance sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SqlMISink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_writer_stored_procedure_name: SQL writer stored procedure name. Type: string (or Expression with resultType string).
        :param Any sql_writer_table_type: SQL writer table type. Type: string (or Expression with resultType string).
        :param Any sql_writer_use_table_lock: Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: SQL stored procedure parameters.
        :param Any stored_procedure_table_type_parameter_name: The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        :param Any table_option: The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        :param pulumi.Input['SqlUpsertSettingsArgs'] upsert_settings: SQL upsert settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: White behavior when copying data into azure SQL MI. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        pulumi.set(__self__, "type", 'SqlMISink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if sql_writer_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_writer_stored_procedure_name", sql_writer_stored_procedure_name)
        if sql_writer_table_type is not None:
            pulumi.set(__self__, "sql_writer_table_type", sql_writer_table_type)
        if sql_writer_use_table_lock is not None:
            pulumi.set(__self__, "sql_writer_use_table_lock", sql_writer_use_table_lock)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)
        if stored_procedure_table_type_parameter_name is not None:
            pulumi.set(__self__, "stored_procedure_table_type_parameter_name", stored_procedure_table_type_parameter_name)
        if table_option is not None:
            pulumi.set(__self__, "table_option", table_option)
        if upsert_settings is not None:
            pulumi.set(__self__, "upsert_settings", upsert_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SqlMISink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="sqlWriterStoredProcedureName")
    def sql_writer_stored_procedure_name(self) -> Optional[Any]:
        """
        SQL writer stored procedure name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_stored_procedure_name")

    @sql_writer_stored_procedure_name.setter
    def sql_writer_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_stored_procedure_name", value)

    @property
    @pulumi.getter(name="sqlWriterTableType")
    def sql_writer_table_type(self) -> Optional[Any]:
        """
        SQL writer table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_table_type")

    @sql_writer_table_type.setter
    def sql_writer_table_type(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_table_type", value)

    @property
    @pulumi.getter(name="sqlWriterUseTableLock")
    def sql_writer_use_table_lock(self) -> Optional[Any]:
        """
        Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "sql_writer_use_table_lock")

    @sql_writer_use_table_lock.setter
    def sql_writer_use_table_lock(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_use_table_lock", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        SQL stored procedure parameters.
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)

    @property
    @pulumi.getter(name="storedProcedureTableTypeParameterName")
    def stored_procedure_table_type_parameter_name(self) -> Optional[Any]:
        """
        The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "stored_procedure_table_type_parameter_name")

    @stored_procedure_table_type_parameter_name.setter
    def stored_procedure_table_type_parameter_name(self, value: Optional[Any]):
        pulumi.set(self, "stored_procedure_table_type_parameter_name", value)

    @property
    @pulumi.getter(name="tableOption")
    def table_option(self) -> Optional[Any]:
        """
        The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_option")

    @table_option.setter
    def table_option(self, value: Optional[Any]):
        pulumi.set(self, "table_option", value)

    @property
    @pulumi.getter(name="upsertSettings")
    def upsert_settings(self) -> Optional[pulumi.Input['SqlUpsertSettingsArgs']]:
        """
        SQL upsert settings.
        """
        return pulumi.get(self, "upsert_settings")

    @upsert_settings.setter
    def upsert_settings(self, value: Optional[pulumi.Input['SqlUpsertSettingsArgs']]):
        pulumi.set(self, "upsert_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        White behavior when copying data into azure SQL MI. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SqlMISourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 produce_additional_types: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None):
        """
        A copy activity Azure SQL Managed Instance source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SqlMISource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any produce_additional_types: Which additional types to produce.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a Azure SQL Managed Instance source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        pulumi.set(__self__, "type", 'SqlMISource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if produce_additional_types is not None:
            pulumi.set(__self__, "produce_additional_types", produce_additional_types)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SqlMISource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="produceAdditionalTypes")
    def produce_additional_types(self) -> Optional[Any]:
        """
        Which additional types to produce.
        """
        return pulumi.get(self, "produce_additional_types")

    @produce_additional_types.setter
    def produce_additional_types(self, value: Optional[Any]):
        pulumi.set(self, "produce_additional_types", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a Azure SQL Managed Instance source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class SqlPartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for Sql source partitioning.
        :param Any partition_column_name: The name of the column in integer or datetime type that will be used for proceeding partitioning. If not specified, the primary key of the table is auto-detected and used as the partition column. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of the partition column for partition range splitting. This value is used to decide the partition stride, not for filtering the rows in table. All rows in the table or query result will be partitioned and copied. Type: string (or Expression with resultType string).
        :param Any partition_upper_bound: The maximum value of the partition column for partition range splitting. This value is used to decide the partition stride, not for filtering the rows in table. All rows in the table or query result will be partitioned and copied. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column in integer or datetime type that will be used for proceeding partitioning. If not specified, the primary key of the table is auto-detected and used as the partition column. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of the partition column for partition range splitting. This value is used to decide the partition stride, not for filtering the rows in table. All rows in the table or query result will be partitioned and copied. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of the partition column for partition range splitting. This value is used to decide the partition stride, not for filtering the rows in table. All rows in the table or query result will be partitioned and copied. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class SqlServerLinkedServiceArgs:
    def __init__(__self__, *,
                 connection_string: Any,
                 type: pulumi.Input[str],
                 always_encrypted_settings: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 user_name: Optional[Any] = None):
        """
        SQL Server linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'SqlServer'.
        :param pulumi.Input['SqlAlwaysEncryptedPropertiesArgs'] always_encrypted_settings: Sql always encrypted properties.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The on-premises Windows authentication password.
        :param Any user_name: The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'SqlServer')
        if always_encrypted_settings is not None:
            pulumi.set(__self__, "always_encrypted_settings", always_encrypted_settings)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Any):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'SqlServer'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="alwaysEncryptedSettings")
    def always_encrypted_settings(self) -> Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]:
        """
        Sql always encrypted properties.
        """
        return pulumi.get(self, "always_encrypted_settings")

    @always_encrypted_settings.setter
    def always_encrypted_settings(self, value: Optional[pulumi.Input['SqlAlwaysEncryptedPropertiesArgs']]):
        pulumi.set(self, "always_encrypted_settings", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The on-premises Windows authentication password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[Any]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class SqlServerSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 sql_writer_stored_procedure_name: Optional[Any] = None,
                 sql_writer_table_type: Optional[Any] = None,
                 sql_writer_use_table_lock: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None,
                 stored_procedure_table_type_parameter_name: Optional[Any] = None,
                 table_option: Optional[Any] = None,
                 upsert_settings: Optional[pulumi.Input['SqlUpsertSettingsArgs']] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity SQL server sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SqlServerSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_writer_stored_procedure_name: SQL writer stored procedure name. Type: string (or Expression with resultType string).
        :param Any sql_writer_table_type: SQL writer table type. Type: string (or Expression with resultType string).
        :param Any sql_writer_use_table_lock: Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: SQL stored procedure parameters.
        :param Any stored_procedure_table_type_parameter_name: The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        :param Any table_option: The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        :param pulumi.Input['SqlUpsertSettingsArgs'] upsert_settings: SQL upsert settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Write behavior when copying data into sql server. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        pulumi.set(__self__, "type", 'SqlServerSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if sql_writer_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_writer_stored_procedure_name", sql_writer_stored_procedure_name)
        if sql_writer_table_type is not None:
            pulumi.set(__self__, "sql_writer_table_type", sql_writer_table_type)
        if sql_writer_use_table_lock is not None:
            pulumi.set(__self__, "sql_writer_use_table_lock", sql_writer_use_table_lock)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)
        if stored_procedure_table_type_parameter_name is not None:
            pulumi.set(__self__, "stored_procedure_table_type_parameter_name", stored_procedure_table_type_parameter_name)
        if table_option is not None:
            pulumi.set(__self__, "table_option", table_option)
        if upsert_settings is not None:
            pulumi.set(__self__, "upsert_settings", upsert_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SqlServerSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="sqlWriterStoredProcedureName")
    def sql_writer_stored_procedure_name(self) -> Optional[Any]:
        """
        SQL writer stored procedure name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_stored_procedure_name")

    @sql_writer_stored_procedure_name.setter
    def sql_writer_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_stored_procedure_name", value)

    @property
    @pulumi.getter(name="sqlWriterTableType")
    def sql_writer_table_type(self) -> Optional[Any]:
        """
        SQL writer table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_table_type")

    @sql_writer_table_type.setter
    def sql_writer_table_type(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_table_type", value)

    @property
    @pulumi.getter(name="sqlWriterUseTableLock")
    def sql_writer_use_table_lock(self) -> Optional[Any]:
        """
        Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "sql_writer_use_table_lock")

    @sql_writer_use_table_lock.setter
    def sql_writer_use_table_lock(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_use_table_lock", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        SQL stored procedure parameters.
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)

    @property
    @pulumi.getter(name="storedProcedureTableTypeParameterName")
    def stored_procedure_table_type_parameter_name(self) -> Optional[Any]:
        """
        The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "stored_procedure_table_type_parameter_name")

    @stored_procedure_table_type_parameter_name.setter
    def stored_procedure_table_type_parameter_name(self, value: Optional[Any]):
        pulumi.set(self, "stored_procedure_table_type_parameter_name", value)

    @property
    @pulumi.getter(name="tableOption")
    def table_option(self) -> Optional[Any]:
        """
        The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_option")

    @table_option.setter
    def table_option(self, value: Optional[Any]):
        pulumi.set(self, "table_option", value)

    @property
    @pulumi.getter(name="upsertSettings")
    def upsert_settings(self) -> Optional[pulumi.Input['SqlUpsertSettingsArgs']]:
        """
        SQL upsert settings.
        """
        return pulumi.get(self, "upsert_settings")

    @upsert_settings.setter
    def upsert_settings(self, value: Optional[pulumi.Input['SqlUpsertSettingsArgs']]):
        pulumi.set(self, "upsert_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Write behavior when copying data into sql server. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SqlServerSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 produce_additional_types: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None):
        """
        A copy activity SQL server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SqlServerSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any produce_additional_types: Which additional types to produce.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        pulumi.set(__self__, "type", 'SqlServerSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if produce_additional_types is not None:
            pulumi.set(__self__, "produce_additional_types", produce_additional_types)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SqlServerSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="produceAdditionalTypes")
    def produce_additional_types(self) -> Optional[Any]:
        """
        Which additional types to produce.
        """
        return pulumi.get(self, "produce_additional_types")

    @produce_additional_types.setter
    def produce_additional_types(self, value: Optional[Any]):
        pulumi.set(self, "produce_additional_types", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class SqlServerStoredProcedureActivityArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 name: pulumi.Input[str],
                 stored_procedure_name: Any,
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        SQL stored procedure activity type.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] name: Activity name.
        :param Any stored_procedure_name: Stored procedure name. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'SqlServerStoredProcedure'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stored_procedure_name", stored_procedure_name)
        pulumi.set(__self__, "type", 'SqlServerStoredProcedure')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storedProcedureName")
    def stored_procedure_name(self) -> Any:
        """
        Stored procedure name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "stored_procedure_name")

    @stored_procedure_name.setter
    def stored_procedure_name(self, value: Any):
        pulumi.set(self, "stored_procedure_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'SqlServerStoredProcedure'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class SqlServerTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The on-premises SQL Server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SqlServerTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SqlServerTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SqlServerTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class SqlSinkArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 pre_copy_script: Optional[Any] = None,
                 sink_retry_count: Optional[Any] = None,
                 sink_retry_wait: Optional[Any] = None,
                 sql_writer_stored_procedure_name: Optional[Any] = None,
                 sql_writer_table_type: Optional[Any] = None,
                 sql_writer_use_table_lock: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None,
                 stored_procedure_table_type_parameter_name: Optional[Any] = None,
                 table_option: Optional[Any] = None,
                 upsert_settings: Optional[pulumi.Input['SqlUpsertSettingsArgs']] = None,
                 write_batch_size: Optional[Any] = None,
                 write_batch_timeout: Optional[Any] = None,
                 write_behavior: Optional[Any] = None):
        """
        A copy activity SQL sink.
        :param pulumi.Input[str] type: Copy sink type.
               Expected value is 'SqlSink'.
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        :param Any pre_copy_script: SQL pre-copy script. Type: string (or Expression with resultType string).
        :param Any sink_retry_count: Sink retry count. Type: integer (or Expression with resultType integer).
        :param Any sink_retry_wait: Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_writer_stored_procedure_name: SQL writer stored procedure name. Type: string (or Expression with resultType string).
        :param Any sql_writer_table_type: SQL writer table type. Type: string (or Expression with resultType string).
        :param Any sql_writer_use_table_lock: Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: SQL stored procedure parameters.
        :param Any stored_procedure_table_type_parameter_name: The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        :param Any table_option: The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        :param pulumi.Input['SqlUpsertSettingsArgs'] upsert_settings: SQL upsert settings.
        :param Any write_batch_size: Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any write_batch_timeout: Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any write_behavior: Write behavior when copying data into sql. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        pulumi.set(__self__, "type", 'SqlSink')
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if pre_copy_script is not None:
            pulumi.set(__self__, "pre_copy_script", pre_copy_script)
        if sink_retry_count is not None:
            pulumi.set(__self__, "sink_retry_count", sink_retry_count)
        if sink_retry_wait is not None:
            pulumi.set(__self__, "sink_retry_wait", sink_retry_wait)
        if sql_writer_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_writer_stored_procedure_name", sql_writer_stored_procedure_name)
        if sql_writer_table_type is not None:
            pulumi.set(__self__, "sql_writer_table_type", sql_writer_table_type)
        if sql_writer_use_table_lock is not None:
            pulumi.set(__self__, "sql_writer_use_table_lock", sql_writer_use_table_lock)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)
        if stored_procedure_table_type_parameter_name is not None:
            pulumi.set(__self__, "stored_procedure_table_type_parameter_name", stored_procedure_table_type_parameter_name)
        if table_option is not None:
            pulumi.set(__self__, "table_option", table_option)
        if upsert_settings is not None:
            pulumi.set(__self__, "upsert_settings", upsert_settings)
        if write_batch_size is not None:
            pulumi.set(__self__, "write_batch_size", write_batch_size)
        if write_batch_timeout is not None:
            pulumi.set(__self__, "write_batch_timeout", write_batch_timeout)
        if write_behavior is not None:
            pulumi.set(__self__, "write_behavior", write_behavior)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy sink type.
        Expected value is 'SqlSink'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="preCopyScript")
    def pre_copy_script(self) -> Optional[Any]:
        """
        SQL pre-copy script. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pre_copy_script")

    @pre_copy_script.setter
    def pre_copy_script(self, value: Optional[Any]):
        pulumi.set(self, "pre_copy_script", value)

    @property
    @pulumi.getter(name="sinkRetryCount")
    def sink_retry_count(self) -> Optional[Any]:
        """
        Sink retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sink_retry_count")

    @sink_retry_count.setter
    def sink_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_count", value)

    @property
    @pulumi.getter(name="sinkRetryWait")
    def sink_retry_wait(self) -> Optional[Any]:
        """
        Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "sink_retry_wait")

    @sink_retry_wait.setter
    def sink_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "sink_retry_wait", value)

    @property
    @pulumi.getter(name="sqlWriterStoredProcedureName")
    def sql_writer_stored_procedure_name(self) -> Optional[Any]:
        """
        SQL writer stored procedure name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_stored_procedure_name")

    @sql_writer_stored_procedure_name.setter
    def sql_writer_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_stored_procedure_name", value)

    @property
    @pulumi.getter(name="sqlWriterTableType")
    def sql_writer_table_type(self) -> Optional[Any]:
        """
        SQL writer table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_writer_table_type")

    @sql_writer_table_type.setter
    def sql_writer_table_type(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_table_type", value)

    @property
    @pulumi.getter(name="sqlWriterUseTableLock")
    def sql_writer_use_table_lock(self) -> Optional[Any]:
        """
        Whether to use table lock during bulk copy. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "sql_writer_use_table_lock")

    @sql_writer_use_table_lock.setter
    def sql_writer_use_table_lock(self, value: Optional[Any]):
        pulumi.set(self, "sql_writer_use_table_lock", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        SQL stored procedure parameters.
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)

    @property
    @pulumi.getter(name="storedProcedureTableTypeParameterName")
    def stored_procedure_table_type_parameter_name(self) -> Optional[Any]:
        """
        The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "stored_procedure_table_type_parameter_name")

    @stored_procedure_table_type_parameter_name.setter
    def stored_procedure_table_type_parameter_name(self, value: Optional[Any]):
        pulumi.set(self, "stored_procedure_table_type_parameter_name", value)

    @property
    @pulumi.getter(name="tableOption")
    def table_option(self) -> Optional[Any]:
        """
        The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_option")

    @table_option.setter
    def table_option(self, value: Optional[Any]):
        pulumi.set(self, "table_option", value)

    @property
    @pulumi.getter(name="upsertSettings")
    def upsert_settings(self) -> Optional[pulumi.Input['SqlUpsertSettingsArgs']]:
        """
        SQL upsert settings.
        """
        return pulumi.get(self, "upsert_settings")

    @upsert_settings.setter
    def upsert_settings(self, value: Optional[pulumi.Input['SqlUpsertSettingsArgs']]):
        pulumi.set(self, "upsert_settings", value)

    @property
    @pulumi.getter(name="writeBatchSize")
    def write_batch_size(self) -> Optional[Any]:
        """
        Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "write_batch_size")

    @write_batch_size.setter
    def write_batch_size(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_size", value)

    @property
    @pulumi.getter(name="writeBatchTimeout")
    def write_batch_timeout(self) -> Optional[Any]:
        """
        Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "write_batch_timeout")

    @write_batch_timeout.setter
    def write_batch_timeout(self, value: Optional[Any]):
        pulumi.set(self, "write_batch_timeout", value)

    @property
    @pulumi.getter(name="writeBehavior")
    def write_behavior(self) -> Optional[Any]:
        """
        Write behavior when copying data into sql. Type: SqlWriteBehaviorEnum (or Expression with resultType SqlWriteBehaviorEnum)
        """
        return pulumi.get(self, "write_behavior")

    @write_behavior.setter
    def write_behavior(self, value: Optional[Any]):
        pulumi.set(self, "write_behavior", value)


@pulumi.input_type
class SqlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 isolation_level: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['SqlPartitionSettingsArgs']] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 sql_reader_query: Optional[Any] = None,
                 sql_reader_stored_procedure_name: Optional[Any] = None,
                 stored_procedure_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]] = None):
        """
        A copy activity SQL source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SqlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any isolation_level: Specifies the transaction locking behavior for the SQL source. Allowed values: ReadCommitted/ReadUncommitted/RepeatableRead/Serializable/Snapshot. The default value is ReadCommitted. Type: string (or Expression with resultType string).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        :param pulumi.Input['SqlPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for Sql source partitioning.
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any sql_reader_query: SQL reader query. Type: string (or Expression with resultType string).
        :param Any sql_reader_stored_procedure_name: Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]] stored_procedure_parameters: Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        pulumi.set(__self__, "type", 'SqlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if isolation_level is not None:
            pulumi.set(__self__, "isolation_level", isolation_level)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if sql_reader_query is not None:
            pulumi.set(__self__, "sql_reader_query", sql_reader_query)
        if sql_reader_stored_procedure_name is not None:
            pulumi.set(__self__, "sql_reader_stored_procedure_name", sql_reader_stored_procedure_name)
        if stored_procedure_parameters is not None:
            pulumi.set(__self__, "stored_procedure_parameters", stored_procedure_parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SqlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="isolationLevel")
    def isolation_level(self) -> Optional[Any]:
        """
        Specifies the transaction locking behavior for the SQL source. Allowed values: ReadCommitted/ReadUncommitted/RepeatableRead/Serializable/Snapshot. The default value is ReadCommitted. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "isolation_level")

    @isolation_level.setter
    def isolation_level(self, value: Optional[Any]):
        pulumi.set(self, "isolation_level", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for Sql read in parallel. Possible values include: "None", "PhysicalPartitionsOfTable", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['SqlPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for Sql source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['SqlPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="sqlReaderQuery")
    def sql_reader_query(self) -> Optional[Any]:
        """
        SQL reader query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_query")

    @sql_reader_query.setter
    def sql_reader_query(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_query", value)

    @property
    @pulumi.getter(name="sqlReaderStoredProcedureName")
    def sql_reader_stored_procedure_name(self) -> Optional[Any]:
        """
        Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sql_reader_stored_procedure_name")

    @sql_reader_stored_procedure_name.setter
    def sql_reader_stored_procedure_name(self, value: Optional[Any]):
        pulumi.set(self, "sql_reader_stored_procedure_name", value)

    @property
    @pulumi.getter(name="storedProcedureParameters")
    def stored_procedure_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]:
        """
        Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
        """
        return pulumi.get(self, "stored_procedure_parameters")

    @stored_procedure_parameters.setter
    def stored_procedure_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['StoredProcedureParameterArgs']]]]):
        pulumi.set(self, "stored_procedure_parameters", value)


@pulumi.input_type
class SqlUpsertSettingsArgs:
    def __init__(__self__, *,
                 interim_schema_name: Optional[Any] = None,
                 keys: Optional[Any] = None,
                 use_temp_db: Optional[Any] = None):
        """
        Sql upsert option settings
        :param Any interim_schema_name: Schema name for interim table. Type: string (or Expression with resultType string).
        :param Any keys: Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
        :param Any use_temp_db: Specifies whether to use temp db for upsert interim table. Type: boolean (or Expression with resultType boolean).
        """
        if interim_schema_name is not None:
            pulumi.set(__self__, "interim_schema_name", interim_schema_name)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if use_temp_db is not None:
            pulumi.set(__self__, "use_temp_db", use_temp_db)

    @property
    @pulumi.getter(name="interimSchemaName")
    def interim_schema_name(self) -> Optional[Any]:
        """
        Schema name for interim table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "interim_schema_name")

    @interim_schema_name.setter
    def interim_schema_name(self, value: Optional[Any]):
        pulumi.set(self, "interim_schema_name", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[Any]:
        """
        Key column names for unique row identification. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[Any]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="useTempDB")
    def use_temp_db(self) -> Optional[Any]:
        """
        Specifies whether to use temp db for upsert interim table. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_temp_db")

    @use_temp_db.setter
    def use_temp_db(self, value: Optional[Any]):
        pulumi.set(self, "use_temp_db", value)


@pulumi.input_type
class SquareLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 redirect_uri: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Square Service linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Square'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client ID associated with your Square application.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] client_secret: The client secret associated with your Square application.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Square. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host: The URLof the Square instance. (i.e. mystore.mysquare.com)
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any redirect_uri: The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Square')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Square'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client ID associated with your Square application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[Any]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The client secret associated with your Square application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Square. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        The URLof the Square instance. (i.e. mystore.mysquare.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[Any]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[Any]:
        """
        The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[Any]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class SquareObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Square Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SquareObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SquareObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SquareObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class SquareSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Square Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SquareSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SquareSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SquareSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class StagingSettingsArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 enable_compression: Optional[Any] = None,
                 path: Optional[Any] = None):
        """
        Staging settings.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Staging linked service reference.
        :param Any enable_compression: Specifies whether to use compression when copying data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any path: The path to storage for storing the interim data. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        if enable_compression is not None:
            pulumi.set(__self__, "enable_compression", enable_compression)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Staging linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="enableCompression")
    def enable_compression(self) -> Optional[Any]:
        """
        Specifies whether to use compression when copying data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_compression")

    @enable_compression.setter
    def enable_compression(self, value: Optional[Any]):
        pulumi.set(self, "enable_compression", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The path to storage for storing the interim data. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class StoredProcedureParameterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'StoredProcedureParameterType']]] = None,
                 value: Optional[Any] = None):
        """
        SQL stored procedure parameter.
        :param pulumi.Input[Union[str, 'StoredProcedureParameterType']] type: Stored procedure parameter type.
        :param Any value: Stored procedure parameter value. Type: string (or Expression with resultType string).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'StoredProcedureParameterType']]]:
        """
        Stored procedure parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'StoredProcedureParameterType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Stored procedure parameter value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SwitchActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 on: pulumi.Input['ExpressionArgs'],
                 type: pulumi.Input[str],
                 cases: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchCaseArgs']]]] = None,
                 default_activities: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity evaluates an expression and executes activities under the cases property that correspond to the expression evaluation expected in the equals property.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input['ExpressionArgs'] on: An expression that would evaluate to a string or integer. This is used to determine the block of activities in cases that will be executed.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Switch'.
        :param pulumi.Input[Sequence[pulumi.Input['SwitchCaseArgs']]] cases: List of cases that correspond to expected values of the 'on' property. This is an optional property and if not provided, the activity will execute activities provided in defaultActivities.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] default_activities: List of activities to execute if no case condition is satisfied. This is an optional property and if not provided, the activity will exit without any action.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on", on)
        pulumi.set(__self__, "type", 'Switch')
        if cases is not None:
            pulumi.set(__self__, "cases", cases)
        if default_activities is not None:
            pulumi.set(__self__, "default_activities", default_activities)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def on(self) -> pulumi.Input['ExpressionArgs']:
        """
        An expression that would evaluate to a string or integer. This is used to determine the block of activities in cases that will be executed.
        """
        return pulumi.get(self, "on")

    @on.setter
    def on(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "on", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Switch'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchCaseArgs']]]]:
        """
        List of cases that correspond to expected values of the 'on' property. This is an optional property and if not provided, the activity will execute activities provided in defaultActivities.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchCaseArgs']]]]):
        pulumi.set(self, "cases", value)

    @property
    @pulumi.getter(name="defaultActivities")
    def default_activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]:
        """
        List of activities to execute if no case condition is satisfied. This is an optional property and if not provided, the activity will exit without any action.
        """
        return pulumi.get(self, "default_activities")

    @default_activities.setter
    def default_activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]):
        pulumi.set(self, "default_activities", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class SwitchCaseArgs:
    def __init__(__self__, *,
                 activities: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Switch cases with have a value and corresponding activities.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] activities: List of activities to execute for satisfied case condition.
        :param pulumi.Input[str] value: Expected value that satisfies the expression result of the 'on' property.
        """
        if activities is not None:
            pulumi.set(__self__, "activities", activities)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]:
        """
        List of activities to execute for satisfied case condition.
        """
        return pulumi.get(self, "activities")

    @activities.setter
    def activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]]):
        pulumi.set(self, "activities", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Expected value that satisfies the expression result of the 'on' property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SybaseLinkedServiceArgs:
    def __init__(__self__, *,
                 database: Any,
                 server: Any,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'SybaseAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 schema: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Sybase data source.
        :param Any database: Database name for connection. Type: string (or Expression with resultType string).
        :param Any server: Server name for connection. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Sybase'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'SybaseAuthenticationType']] authentication_type: AuthenticationType to be used for connection.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for authentication.
        :param Any schema: Schema name for connection. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'Sybase')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        Database name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Any):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        Server name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Any):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Sybase'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'SybaseAuthenticationType']]]:
        """
        AuthenticationType to be used for connection.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'SybaseAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Schema name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SybaseSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for Sybase databases.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'SybaseSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: Database query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'SybaseSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'SybaseSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Database query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class SybaseTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Sybase table dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'SybaseTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Sybase table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SybaseTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'SybaseTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Sybase table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class TabularSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        Copy activity sources of tabular type.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'TabularSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'TabularSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'TabularSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class TarGZipReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_compression_file_name_as_folder: Optional[Any] = None):
        """
        The TarGZip compression read settings.
        :param pulumi.Input[str] type: The Compression setting type.
               Expected value is 'TarGZipReadSettings'.
        :param Any preserve_compression_file_name_as_folder: Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'TarGZipReadSettings')
        if preserve_compression_file_name_as_folder is not None:
            pulumi.set(__self__, "preserve_compression_file_name_as_folder", preserve_compression_file_name_as_folder)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Compression setting type.
        Expected value is 'TarGZipReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveCompressionFileNameAsFolder")
    def preserve_compression_file_name_as_folder(self) -> Optional[Any]:
        """
        Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "preserve_compression_file_name_as_folder")

    @preserve_compression_file_name_as_folder.setter
    def preserve_compression_file_name_as_folder(self, value: Optional[Any]):
        pulumi.set(self, "preserve_compression_file_name_as_folder", value)


@pulumi.input_type
class TarReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_compression_file_name_as_folder: Optional[Any] = None):
        """
        The Tar compression read settings.
        :param pulumi.Input[str] type: The Compression setting type.
               Expected value is 'TarReadSettings'.
        :param Any preserve_compression_file_name_as_folder: Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'TarReadSettings')
        if preserve_compression_file_name_as_folder is not None:
            pulumi.set(__self__, "preserve_compression_file_name_as_folder", preserve_compression_file_name_as_folder)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Compression setting type.
        Expected value is 'TarReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveCompressionFileNameAsFolder")
    def preserve_compression_file_name_as_folder(self) -> Optional[Any]:
        """
        Preserve the compression file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "preserve_compression_file_name_as_folder")

    @preserve_compression_file_name_as_folder.setter
    def preserve_compression_file_name_as_folder(self, value: Optional[Any]):
        pulumi.set(self, "preserve_compression_file_name_as_folder", value)


@pulumi.input_type
class TeradataLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'TeradataAuthenticationType']]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 server: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Teradata data source.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Teradata'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input[Union[str, 'TeradataAuthenticationType']] authentication_type: AuthenticationType to be used for connection.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for authentication.
        :param Any server: Server name for connection. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Teradata')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Teradata'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'TeradataAuthenticationType']]]:
        """
        AuthenticationType to be used for connection.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'TeradataAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Server name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[Any]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class TeradataPartitionSettingsArgs:
    def __init__(__self__, *,
                 partition_column_name: Optional[Any] = None,
                 partition_lower_bound: Optional[Any] = None,
                 partition_upper_bound: Optional[Any] = None):
        """
        The settings that will be leveraged for teradata source partitioning.
        :param Any partition_column_name: The name of the column that will be used for proceeding range or hash partitioning. Type: string (or Expression with resultType string).
        :param Any partition_lower_bound: The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        :param Any partition_upper_bound: The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        if partition_column_name is not None:
            pulumi.set(__self__, "partition_column_name", partition_column_name)
        if partition_lower_bound is not None:
            pulumi.set(__self__, "partition_lower_bound", partition_lower_bound)
        if partition_upper_bound is not None:
            pulumi.set(__self__, "partition_upper_bound", partition_upper_bound)

    @property
    @pulumi.getter(name="partitionColumnName")
    def partition_column_name(self) -> Optional[Any]:
        """
        The name of the column that will be used for proceeding range or hash partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_column_name")

    @partition_column_name.setter
    def partition_column_name(self, value: Optional[Any]):
        pulumi.set(self, "partition_column_name", value)

    @property
    @pulumi.getter(name="partitionLowerBound")
    def partition_lower_bound(self) -> Optional[Any]:
        """
        The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_lower_bound")

    @partition_lower_bound.setter
    def partition_lower_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_lower_bound", value)

    @property
    @pulumi.getter(name="partitionUpperBound")
    def partition_upper_bound(self) -> Optional[Any]:
        """
        The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "partition_upper_bound")

    @partition_upper_bound.setter
    def partition_upper_bound(self, value: Optional[Any]):
        pulumi.set(self, "partition_upper_bound", value)


@pulumi.input_type
class TeradataSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 partition_option: Optional[Any] = None,
                 partition_settings: Optional[pulumi.Input['TeradataPartitionSettingsArgs']] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Teradata source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'TeradataSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any partition_option: The partition mechanism that will be used for teradata read in parallel. Possible values include: "None", "Hash", "DynamicRange".
        :param pulumi.Input['TeradataPartitionSettingsArgs'] partition_settings: The settings that will be leveraged for teradata source partitioning.
        :param Any query: Teradata query. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'TeradataSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if partition_option is not None:
            pulumi.set(__self__, "partition_option", partition_option)
        if partition_settings is not None:
            pulumi.set(__self__, "partition_settings", partition_settings)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'TeradataSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="partitionOption")
    def partition_option(self) -> Optional[Any]:
        """
        The partition mechanism that will be used for teradata read in parallel. Possible values include: "None", "Hash", "DynamicRange".
        """
        return pulumi.get(self, "partition_option")

    @partition_option.setter
    def partition_option(self, value: Optional[Any]):
        pulumi.set(self, "partition_option", value)

    @property
    @pulumi.getter(name="partitionSettings")
    def partition_settings(self) -> Optional[pulumi.Input['TeradataPartitionSettingsArgs']]:
        """
        The settings that will be leveraged for teradata source partitioning.
        """
        return pulumi.get(self, "partition_settings")

    @partition_settings.setter
    def partition_settings(self, value: Optional[pulumi.Input['TeradataPartitionSettingsArgs']]):
        pulumi.set(self, "partition_settings", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        Teradata query. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class TeradataTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 database: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The Teradata database dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'TeradataTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param Any database: The database name of Teradata. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of Teradata. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'TeradataTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'TeradataTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The database name of Teradata. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[Any]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of Teradata. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)


@pulumi.input_type
class TextFormatArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 column_delimiter: Optional[Any] = None,
                 deserializer: Optional[Any] = None,
                 encoding_name: Optional[Any] = None,
                 escape_char: Optional[Any] = None,
                 first_row_as_header: Optional[Any] = None,
                 null_value: Optional[Any] = None,
                 quote_char: Optional[Any] = None,
                 row_delimiter: Optional[Any] = None,
                 serializer: Optional[Any] = None,
                 skip_line_count: Optional[Any] = None,
                 treat_empty_as_null: Optional[Any] = None):
        """
        The data stored in text format.
        :param pulumi.Input[str] type: Type of dataset storage format.
               Expected value is 'TextFormat'.
        :param Any column_delimiter: The column delimiter. Type: string (or Expression with resultType string).
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any encoding_name: The code page name of the preferred encoding. If miss, the default value is utf-8, unless BOM denotes another Unicode encoding. Refer to the Name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param Any escape_char: The escape character. Type: string (or Expression with resultType string).
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param Any quote_char: The quote character. Type: string (or Expression with resultType string).
        :param Any row_delimiter: The row delimiter. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        :param Any skip_line_count: The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with resultType integer).
        :param Any treat_empty_as_null: Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'TextFormat')
        if column_delimiter is not None:
            pulumi.set(__self__, "column_delimiter", column_delimiter)
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if row_delimiter is not None:
            pulumi.set(__self__, "row_delimiter", row_delimiter)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if skip_line_count is not None:
            pulumi.set(__self__, "skip_line_count", skip_line_count)
        if treat_empty_as_null is not None:
            pulumi.set(__self__, "treat_empty_as_null", treat_empty_as_null)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset storage format.
        Expected value is 'TextFormat'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="columnDelimiter")
    def column_delimiter(self) -> Optional[Any]:
        """
        The column delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "column_delimiter")

    @column_delimiter.setter
    def column_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "column_delimiter", value)

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @deserializer.setter
    def deserializer(self, value: Optional[Any]):
        pulumi.set(self, "deserializer", value)

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If miss, the default value is utf-8, unless BOM denotes another Unicode encoding. Refer to the Name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: Optional[Any]):
        pulumi.set(self, "encoding_name", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[Any]:
        """
        The escape character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[Any]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @first_row_as_header.setter
    def first_row_as_header(self, value: Optional[Any]):
        pulumi.set(self, "first_row_as_header", value)

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @null_value.setter
    def null_value(self, value: Optional[Any]):
        pulumi.set(self, "null_value", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[Any]:
        """
        The quote character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[Any]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="rowDelimiter")
    def row_delimiter(self) -> Optional[Any]:
        """
        The row delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "row_delimiter")

    @row_delimiter.setter
    def row_delimiter(self, value: Optional[Any]):
        pulumi.set(self, "row_delimiter", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[Any]):
        pulumi.set(self, "serializer", value)

    @property
    @pulumi.getter(name="skipLineCount")
    def skip_line_count(self) -> Optional[Any]:
        """
        The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip_line_count")

    @skip_line_count.setter
    def skip_line_count(self, value: Optional[Any]):
        pulumi.set(self, "skip_line_count", value)

    @property
    @pulumi.getter(name="treatEmptyAsNull")
    def treat_empty_as_null(self) -> Optional[Any]:
        """
        Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "treat_empty_as_null")

    @treat_empty_as_null.setter
    def treat_empty_as_null(self, value: Optional[Any]):
        pulumi.set(self, "treat_empty_as_null", value)


@pulumi.input_type
class TransformationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowReferenceArgs']] = None):
        """
        A data flow transformation.
        :param pulumi.Input[str] name: Transformation name.
        :param pulumi.Input[str] description: Transformation description.
        :param pulumi.Input['DataFlowReferenceArgs'] flowlet: Flowlet Reference
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowReferenceArgs']]:
        """
        Flowlet Reference
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowReferenceArgs']]):
        pulumi.set(self, "flowlet", value)


@pulumi.input_type
class TriggerDependencyReferenceArgs:
    def __init__(__self__, *,
                 reference_trigger: pulumi.Input['TriggerReferenceArgs'],
                 type: pulumi.Input[str]):
        """
        Trigger referenced dependency.
        :param pulumi.Input['TriggerReferenceArgs'] reference_trigger: Referenced trigger.
        :param pulumi.Input[str] type: The type of dependency reference.
               Expected value is 'TriggerDependencyReference'.
        """
        pulumi.set(__self__, "reference_trigger", reference_trigger)
        pulumi.set(__self__, "type", 'TriggerDependencyReference')

    @property
    @pulumi.getter(name="referenceTrigger")
    def reference_trigger(self) -> pulumi.Input['TriggerReferenceArgs']:
        """
        Referenced trigger.
        """
        return pulumi.get(self, "reference_trigger")

    @reference_trigger.setter
    def reference_trigger(self, value: pulumi.Input['TriggerReferenceArgs']):
        pulumi.set(self, "reference_trigger", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of dependency reference.
        Expected value is 'TriggerDependencyReference'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TriggerPipelineReferenceArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pipeline_reference: Optional[pulumi.Input['PipelineReferenceArgs']] = None):
        """
        Pipeline that needs to be triggered with the given parameters.
        :param pulumi.Input[Mapping[str, Any]] parameters: Pipeline parameters.
        :param pulumi.Input['PipelineReferenceArgs'] pipeline_reference: Pipeline reference.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pipeline_reference is not None:
            pulumi.set(__self__, "pipeline_reference", pipeline_reference)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Pipeline parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="pipelineReference")
    def pipeline_reference(self) -> Optional[pulumi.Input['PipelineReferenceArgs']]:
        """
        Pipeline reference.
        """
        return pulumi.get(self, "pipeline_reference")

    @pipeline_reference.setter
    def pipeline_reference(self, value: Optional[pulumi.Input['PipelineReferenceArgs']]):
        pulumi.set(self, "pipeline_reference", value)


@pulumi.input_type
class TriggerReferenceArgs:
    def __init__(__self__, *,
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Trigger reference type.
        :param pulumi.Input[str] reference_name: Reference trigger name.
        :param pulumi.Input[str] type: Trigger reference type.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference trigger name.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger reference type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TumblingWindowTriggerDependencyReferenceArgs:
    def __init__(__self__, *,
                 reference_trigger: pulumi.Input['TriggerReferenceArgs'],
                 type: pulumi.Input[str],
                 offset: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        """
        Referenced tumbling window trigger dependency.
        :param pulumi.Input['TriggerReferenceArgs'] reference_trigger: Referenced trigger.
        :param pulumi.Input[str] type: The type of dependency reference.
               Expected value is 'TumblingWindowTriggerDependencyReference'.
        :param pulumi.Input[str] offset: Timespan applied to the start time of a tumbling window when evaluating dependency.
        :param pulumi.Input[str] size: The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        pulumi.set(__self__, "reference_trigger", reference_trigger)
        pulumi.set(__self__, "type", 'TumblingWindowTriggerDependencyReference')
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="referenceTrigger")
    def reference_trigger(self) -> pulumi.Input['TriggerReferenceArgs']:
        """
        Referenced trigger.
        """
        return pulumi.get(self, "reference_trigger")

    @reference_trigger.setter
    def reference_trigger(self, value: pulumi.Input['TriggerReferenceArgs']):
        pulumi.set(self, "reference_trigger", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of dependency reference.
        Expected value is 'TumblingWindowTriggerDependencyReference'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[str]]:
        """
        Timespan applied to the start time of a tumbling window when evaluating dependency.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class TumblingWindowTriggerArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[Union[str, 'TumblingWindowFrequency']],
                 interval: pulumi.Input[int],
                 max_concurrency: pulumi.Input[int],
                 pipeline: pulumi.Input['TriggerPipelineReferenceArgs'],
                 start_time: pulumi.Input[str],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 delay: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SelfDependencyTumblingWindowTriggerReferenceArgs', 'TriggerDependencyReferenceArgs', 'TumblingWindowTriggerDependencyReferenceArgs']]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 retry_policy: Optional[pulumi.Input['RetryPolicyArgs']] = None):
        """
        Trigger that schedules pipeline runs for all fixed time interval windows from a start time without gaps and also supports backfill scenarios (when start time is in the past).
        :param pulumi.Input[Union[str, 'TumblingWindowFrequency']] frequency: The frequency of the time windows.
        :param pulumi.Input[int] interval: The interval of the time windows. The minimum interval allowed is 15 Minutes.
        :param pulumi.Input[int] max_concurrency: The max number of parallel time windows (ready for execution) for which a new run is triggered.
        :param pulumi.Input['TriggerPipelineReferenceArgs'] pipeline: Pipeline for which runs are created when an event is fired for trigger window that is ready.
        :param pulumi.Input[str] start_time: The start time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        :param pulumi.Input[str] type: Trigger type.
               Expected value is 'TumblingWindowTrigger'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the trigger.
        :param Any delay: Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time. The default is 0. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Sequence[pulumi.Input[Union['SelfDependencyTumblingWindowTriggerReferenceArgs', 'TriggerDependencyReferenceArgs', 'TumblingWindowTriggerDependencyReferenceArgs']]]] depends_on: Triggers that this trigger depends on. Only tumbling window triggers are supported.
        :param pulumi.Input[str] description: Trigger description.
        :param pulumi.Input[str] end_time: The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        :param pulumi.Input['RetryPolicyArgs'] retry_policy: Retry policy that will be applied for failed pipeline runs.
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "type", 'TumblingWindowTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[Union[str, 'TumblingWindowFrequency']]:
        """
        The frequency of the time windows.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[Union[str, 'TumblingWindowFrequency']]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        The interval of the time windows. The minimum interval allowed is 15 Minutes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> pulumi.Input[int]:
        """
        The max number of parallel time windows (ready for execution) for which a new run is triggered.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_concurrency", value)

    @property
    @pulumi.getter
    def pipeline(self) -> pulumi.Input['TriggerPipelineReferenceArgs']:
        """
        Pipeline for which runs are created when an event is fired for trigger window that is ready.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: pulumi.Input['TriggerPipelineReferenceArgs']):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        The start time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Trigger type.
        Expected value is 'TumblingWindowTrigger'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[Any]:
        """
        Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time. The default is 0. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[Any]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['SelfDependencyTumblingWindowTriggerReferenceArgs', 'TriggerDependencyReferenceArgs', 'TumblingWindowTriggerDependencyReferenceArgs']]]]]:
        """
        Triggers that this trigger depends on. Only tumbling window triggers are supported.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SelfDependencyTumblingWindowTriggerReferenceArgs', 'TriggerDependencyReferenceArgs', 'TumblingWindowTriggerDependencyReferenceArgs']]]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input['RetryPolicyArgs']]:
        """
        Retry policy that will be applied for failed pipeline runs.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input['RetryPolicyArgs']]):
        pulumi.set(self, "retry_policy", value)


@pulumi.input_type
class UntilActivityArgs:
    def __init__(__self__, *,
                 activities: pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]],
                 expression: pulumi.Input['ExpressionArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity executes inner activities until the specified boolean expression results to true or timeout is reached, whichever is earlier.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]] activities: List of activities to execute.
        :param pulumi.Input['ExpressionArgs'] expression: An expression that would evaluate to Boolean. The loop will continue until this expression evaluates to true
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Until'.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any timeout: Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])). Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "activities", activities)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Until')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def activities(self) -> pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]:
        """
        List of activities to execute.
        """
        return pulumi.get(self, "activities")

    @activities.setter
    def activities(self, value: pulumi.Input[Sequence[pulumi.Input[Union['AppendVariableActivityArgs', 'AzureDataExplorerCommandActivityArgs', 'AzureFunctionActivityArgs', 'AzureMLBatchExecutionActivityArgs', 'AzureMLExecutePipelineActivityArgs', 'AzureMLUpdateResourceActivityArgs', 'ControlActivityArgs', 'CopyActivityArgs', 'CustomActivityArgs', 'DataLakeAnalyticsUSQLActivityArgs', 'DatabricksNotebookActivityArgs', 'DatabricksSparkJarActivityArgs', 'DatabricksSparkPythonActivityArgs', 'DeleteActivityArgs', 'ExecuteDataFlowActivityArgs', 'ExecutePipelineActivityArgs', 'ExecuteSSISPackageActivityArgs', 'ExecuteWranglingDataflowActivityArgs', 'ExecutionActivityArgs', 'FilterActivityArgs', 'ForEachActivityArgs', 'GetMetadataActivityArgs', 'HDInsightHiveActivityArgs', 'HDInsightMapReduceActivityArgs', 'HDInsightPigActivityArgs', 'HDInsightSparkActivityArgs', 'HDInsightStreamingActivityArgs', 'IfConditionActivityArgs', 'LookupActivityArgs', 'SetVariableActivityArgs', 'SqlServerStoredProcedureActivityArgs', 'SwitchActivityArgs', 'UntilActivityArgs', 'ValidationActivityArgs', 'WaitActivityArgs', 'WebActivityArgs', 'WebHookActivityArgs']]]]):
        pulumi.set(self, "activities", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input['ExpressionArgs']:
        """
        An expression that would evaluate to Boolean. The loop will continue until this expression evaluates to true
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input['ExpressionArgs']):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Until'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])). Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[Any]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class UserPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Any):
        """
        User property.
        :param pulumi.Input[str] name: User property name.
        :param Any value: User property value. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        User property value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Any):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ValidationActivityArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetReferenceArgs'],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 child_items: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 minimum_size: Optional[Any] = None,
                 sleep: Optional[Any] = None,
                 timeout: Optional[Any] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity verifies that an external resource exists.
        :param pulumi.Input['DatasetReferenceArgs'] dataset: Validation activity dataset reference.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Validation'.
        :param Any child_items: Can be used if dataset points to a folder. If set to true, the folder must have at least one file. If set to false, the folder must be empty. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any minimum_size: Can be used if dataset points to a file. The file must be greater than or equal in size to the value specified. Type: integer (or Expression with resultType integer).
        :param Any sleep: A delay in seconds between validation attempts. If no value is specified, 10 seconds will be used as the default. Type: integer (or Expression with resultType integer).
        :param Any timeout: Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Validation')
        if child_items is not None:
            pulumi.set(__self__, "child_items", child_items)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if minimum_size is not None:
            pulumi.set(__self__, "minimum_size", minimum_size)
        if sleep is not None:
            pulumi.set(__self__, "sleep", sleep)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetReferenceArgs']:
        """
        Validation activity dataset reference.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetReferenceArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Validation'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="childItems")
    def child_items(self) -> Optional[Any]:
        """
        Can be used if dataset points to a folder. If set to true, the folder must have at least one file. If set to false, the folder must be empty. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "child_items")

    @child_items.setter
    def child_items(self, value: Optional[Any]):
        pulumi.set(self, "child_items", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="minimumSize")
    def minimum_size(self) -> Optional[Any]:
        """
        Can be used if dataset points to a file. The file must be greater than or equal in size to the value specified. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "minimum_size")

    @minimum_size.setter
    def minimum_size(self, value: Optional[Any]):
        pulumi.set(self, "minimum_size", value)

    @property
    @pulumi.getter
    def sleep(self) -> Optional[Any]:
        """
        A delay in seconds between validation attempts. If no value is specified, 10 seconds will be used as the default. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "sleep")

    @sleep.setter
    def sleep(self, value: Optional[Any]):
        pulumi.set(self, "sleep", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[Any]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class VariableSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'VariableType']],
                 default_value: Optional[Any] = None):
        """
        Definition of a single variable for a Pipeline.
        :param pulumi.Input[Union[str, 'VariableType']] type: Variable type.
        :param Any default_value: Default value of variable.
        """
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'VariableType']]:
        """
        Variable type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'VariableType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        Default value of variable.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[Any]):
        pulumi.set(self, "default_value", value)


@pulumi.input_type
class VerticaLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 pwd: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']] = None):
        """
        Vertica linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Vertica'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input['AzureKeyVaultSecretReferenceArgs'] pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Vertica')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Vertica'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[Any]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input['AzureKeyVaultSecretReferenceArgs']]):
        pulumi.set(self, "pwd", value)


@pulumi.input_type
class VerticaSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Vertica source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'VerticaSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'VerticaSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'VerticaSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class VerticaTableDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Vertica dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'VerticaTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Vertica. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'VerticaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'VerticaTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Vertica. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[Any]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class WaitActivityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 wait_time_in_seconds: Any,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        This activity suspends pipeline execution for the specified interval.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'Wait'.
        :param Any wait_time_in_seconds: Duration in seconds.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Wait')
        pulumi.set(__self__, "wait_time_in_seconds", wait_time_in_seconds)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'Wait'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="waitTimeInSeconds")
    def wait_time_in_seconds(self) -> Any:
        """
        Duration in seconds.
        """
        return pulumi.get(self, "wait_time_in_seconds")

    @wait_time_in_seconds.setter
    def wait_time_in_seconds(self, value: Any):
        pulumi.set(self, "wait_time_in_seconds", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class WebActivityAuthenticationArgs:
    def __init__(__self__, *,
                 credential: Optional[pulumi.Input['CredentialReferenceArgs']] = None,
                 password: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 pfx: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 resource: Optional[Any] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_tenant: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Web activity authentication properties.
        :param pulumi.Input['CredentialReferenceArgs'] credential: The credential reference containing authentication information.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for the PFX file or basic authentication / Secret when used for ServicePrincipal
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] pfx: Base64-encoded contents of a PFX file or Certificate when used for ServicePrincipal
        :param Any resource: Resource for which Azure Auth token will be requested when using MSI Authentication. Type: string (or Expression with resultType string).
        :param pulumi.Input[str] type: Web activity authentication (Basic/ClientCertificate/MSI/ServicePrincipal)
        :param Any user_tenant: TenantId for which Azure Auth token will be requested when using ServicePrincipal Authentication. Type: string (or Expression with resultType string).
        :param Any username: Web activity authentication user name for basic authentication or ClientID when used for ServicePrincipal. Type: string (or Expression with resultType string).
        """
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pfx is not None:
            pulumi.set(__self__, "pfx", pfx)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_tenant is not None:
            pulumi.set(__self__, "user_tenant", user_tenant)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def credential(self) -> Optional[pulumi.Input['CredentialReferenceArgs']]:
        """
        The credential reference containing authentication information.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: Optional[pulumi.Input['CredentialReferenceArgs']]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Password for the PFX file or basic authentication / Secret when used for ServicePrincipal
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def pfx(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        Base64-encoded contents of a PFX file or Certificate when used for ServicePrincipal
        """
        return pulumi.get(self, "pfx")

    @pfx.setter
    def pfx(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "pfx", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[Any]:
        """
        Resource for which Azure Auth token will be requested when using MSI Authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[Any]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Web activity authentication (Basic/ClientCertificate/MSI/ServicePrincipal)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userTenant")
    def user_tenant(self) -> Optional[Any]:
        """
        TenantId for which Azure Auth token will be requested when using ServicePrincipal Authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_tenant")

    @user_tenant.setter
    def user_tenant(self, value: Optional[Any]):
        pulumi.set(self, "user_tenant", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Web activity authentication user name for basic authentication or ClientID when used for ServicePrincipal. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[Any]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class WebActivityArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'WebActivityMethod']],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 url: Any,
                 authentication: Optional[pulumi.Input['WebActivityAuthenticationArgs']] = None,
                 body: Optional[Any] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 datasets: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[Any] = None,
                 linked_service_name: Optional[pulumi.Input['LinkedServiceReferenceArgs']] = None,
                 linked_services: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]] = None,
                 policy: Optional[pulumi.Input['ActivityPolicyArgs']] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        Web activity.
        :param pulumi.Input[Union[str, 'WebActivityMethod']] method: Rest API method for target endpoint.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'WebActivity'.
        :param Any url: Web activity target endpoint and path. Type: string (or Expression with resultType string).
        :param pulumi.Input['WebActivityAuthenticationArgs'] authentication: Authentication method used for calling the endpoint.
        :param Any body: Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]] datasets: List of datasets passed to web endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any headers: Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]] linked_services: List of linked services passed to web endpoint.
        :param pulumi.Input['ActivityPolicyArgs'] policy: Activity policy.
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'WebActivity')
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if linked_services is not None:
            pulumi.set(__self__, "linked_services", linked_services)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'WebActivityMethod']]:
        """
        Rest API method for target endpoint.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'WebActivityMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'WebActivity'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        Web activity target endpoint and path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['WebActivityAuthenticationArgs']]:
        """
        Authentication method used for calling the endpoint.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['WebActivityAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[Any]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]:
        """
        List of datasets passed to web endpoint.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatasetReferenceArgs']]]]):
        pulumi.set(self, "datasets", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Any]:
        """
        Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Any]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional[pulumi.Input['LinkedServiceReferenceArgs']]:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: Optional[pulumi.Input['LinkedServiceReferenceArgs']]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="linkedServices")
    def linked_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]:
        """
        List of linked services passed to web endpoint.
        """
        return pulumi.get(self, "linked_services")

    @linked_services.setter
    def linked_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedServiceReferenceArgs']]]]):
        pulumi.set(self, "linked_services", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ActivityPolicyArgs']]:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ActivityPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class WebAnonymousAuthenticationArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 url: Any):
        """
        A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
        :param pulumi.Input[str] authentication_type: Type of authentication used to connect to the web table source.
               Expected value is 'Anonymous'.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'Anonymous')
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Type of authentication used to connect to the web table source.
        Expected value is 'Anonymous'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WebBasicAuthenticationArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 password: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 url: Any,
                 username: Any):
        """
        A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
        :param pulumi.Input[str] authentication_type: Type of authentication used to connect to the web table source.
               Expected value is 'Basic'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: The password for Basic authentication.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        :param Any username: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'Basic')
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Type of authentication used to connect to the web table source.
        Expected value is 'Basic'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Any):
        pulumi.set(self, "username", value)


@pulumi.input_type
class WebClientCertificateAuthenticationArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 password: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 pfx: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']],
                 url: Any):
        """
        A WebLinkedService that uses client certificate based authentication to communicate with an HTTP endpoint. This scheme follows mutual authentication; the server must also provide valid credentials to the client.
        :param pulumi.Input[str] authentication_type: Type of authentication used to connect to the web table source.
               Expected value is 'ClientCertificate'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] password: Password for the PFX file.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] pfx: Base64-encoded contents of a PFX file.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'ClientCertificate')
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "pfx", pfx)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Type of authentication used to connect to the web table source.
        Expected value is 'ClientCertificate'.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        Password for the PFX file.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def pfx(self) -> pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]:
        """
        Base64-encoded contents of a PFX file.
        """
        return pulumi.get(self, "pfx")

    @pfx.setter
    def pfx(self, value: pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]):
        pulumi.set(self, "pfx", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WebHookActivityArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'WebHookActivityMethod']],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 url: Any,
                 authentication: Optional[pulumi.Input['WebActivityAuthenticationArgs']] = None,
                 body: Optional[Any] = None,
                 depends_on: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[Any] = None,
                 report_status_on_call_back: Optional[Any] = None,
                 timeout: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]] = None):
        """
        WebHook activity.
        :param pulumi.Input[Union[str, 'WebHookActivityMethod']] method: Rest API method for target endpoint.
        :param pulumi.Input[str] name: Activity name.
        :param pulumi.Input[str] type: Type of activity.
               Expected value is 'WebHook'.
        :param Any url: WebHook activity target endpoint and path. Type: string (or Expression with resultType string).
        :param pulumi.Input['WebActivityAuthenticationArgs'] authentication: Authentication method used for calling the endpoint.
        :param Any body: Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        :param pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]] depends_on: Activity depends on condition.
        :param pulumi.Input[str] description: Activity description.
        :param Any headers: Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        :param Any report_status_on_call_back: When set to true, statusCode, output and error in callback request body will be consumed by activity. The activity can be marked as failed by setting statusCode >= 400 in callback request. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input[str] timeout: The timeout within which the webhook should be called back. If there is no value specified, it defaults to 10 minutes. Type: string. Pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'WebHook')
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if report_status_on_call_back is not None:
            pulumi.set(__self__, "report_status_on_call_back", report_status_on_call_back)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'WebHookActivityMethod']]:
        """
        Rest API method for target endpoint.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'WebHookActivityMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of activity.
        Expected value is 'WebHook'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        WebHook activity target endpoint and path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Any):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['WebActivityAuthenticationArgs']]:
        """
        Authentication method used for calling the endpoint.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['WebActivityAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[Any]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @depends_on.setter
    def depends_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivityDependencyArgs']]]]):
        pulumi.set(self, "depends_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Any]:
        """
        Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Any]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="reportStatusOnCallBack")
    def report_status_on_call_back(self) -> Optional[Any]:
        """
        When set to true, statusCode, output and error in callback request body will be consumed by activity. The activity can be marked as failed by setting statusCode >= 400 in callback request. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "report_status_on_call_back")

    @report_status_on_call_back.setter
    def report_status_on_call_back(self, value: Optional[Any]):
        pulumi.set(self, "report_status_on_call_back", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout within which the webhook should be called back. If there is no value specified, it defaults to 10 minutes. Type: string. Pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


@pulumi.input_type
class WebLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 type_properties: pulumi.Input[Union['WebAnonymousAuthenticationArgs', 'WebBasicAuthenticationArgs', 'WebClientCertificateAuthenticationArgs']],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None):
        """
        Web linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Web'.
        :param pulumi.Input[Union['WebAnonymousAuthenticationArgs', 'WebBasicAuthenticationArgs', 'WebClientCertificateAuthenticationArgs']] type_properties: Web linked service properties.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param pulumi.Input[str] description: Linked service description.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'Web')
        pulumi.set(__self__, "type_properties", type_properties)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Web'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeProperties")
    def type_properties(self) -> pulumi.Input[Union['WebAnonymousAuthenticationArgs', 'WebBasicAuthenticationArgs', 'WebClientCertificateAuthenticationArgs']]:
        """
        Web linked service properties.
        """
        return pulumi.get(self, "type_properties")

    @type_properties.setter
    def type_properties(self, value: pulumi.Input[Union['WebAnonymousAuthenticationArgs', 'WebBasicAuthenticationArgs', 'WebClientCertificateAuthenticationArgs']]):
        pulumi.set(self, "type_properties", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class WebSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity source for web page table.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'WebSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'WebSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'WebSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class WebTableDatasetArgs:
    def __init__(__self__, *,
                 index: Any,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 path: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The dataset points to a HTML table in the web page.
        :param Any index: The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'WebTable'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any path: The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'WebTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def index(self) -> Any:
        """
        The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Any):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'WebTable'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[Any]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class WranglingDataFlowArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 document_locale: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DataFlowFolderArgs']] = None,
                 script: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySourceArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Power Query data flow.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the data flow.
        :param pulumi.Input[str] description: The description of the data flow.
        :param pulumi.Input[str] document_locale: Locale of the Power query mashup document.
        :param pulumi.Input['DataFlowFolderArgs'] folder: The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param pulumi.Input[str] script: Power query mashup script.
        :param pulumi.Input[Sequence[pulumi.Input['PowerQuerySourceArgs']]] sources: List of sources in Power Query.
        :param pulumi.Input[str] type: Type of data flow.
               Expected value is 'WranglingDataFlow'.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document_locale is not None:
            pulumi.set(__self__, "document_locale", document_locale)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if type is not None:
            pulumi.set(__self__, "type", 'WranglingDataFlow')

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the data flow.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the data flow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="documentLocale")
    def document_locale(self) -> Optional[pulumi.Input[str]]:
        """
        Locale of the Power query mashup document.
        """
        return pulumi.get(self, "document_locale")

    @document_locale.setter
    def document_locale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_locale", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DataFlowFolderArgs']]:
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DataFlowFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        Power query mashup script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySourceArgs']]]]:
        """
        List of sources in Power Query.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerQuerySourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of data flow.
        Expected value is 'WranglingDataFlow'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class XeroLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 consumer_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 private_key: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Xero Service linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Xero'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Xero. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] consumer_key: The consumer key associated with the Xero application.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host: The endpoint of the Xero server. (i.e. api.xero.com)
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] private_key: The private key from the .pem file that was generated for your Xero private application. You must include all the text from the .pem file, including the Unix line endings(
               ).
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Xero')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Xero'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Xero. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The consumer key associated with the Xero application.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        The endpoint of the Xero server. (i.e. api.xero.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[Any]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The private key from the .pem file that was generated for your Xero private application. You must include all the text from the .pem file, including the Unix line endings(
        ).
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class XeroObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Xero Service dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'XeroObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'XeroObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'XeroObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class XeroSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Xero Service source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'XeroSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'XeroSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'XeroSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


@pulumi.input_type
class XmlDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 location: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 compression: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encoding_name: Optional[Any] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Xml dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']] location: The location of the json data storage.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'Xml'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']] compression: The data compression method used for the json dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Xml')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]:
        """
        The location of the json data storage.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[Union['AmazonS3CompatibleLocationArgs', 'AmazonS3LocationArgs', 'AzureBlobFSLocationArgs', 'AzureBlobStorageLocationArgs', 'AzureDataLakeStoreLocationArgs', 'AzureFileStorageLocationArgs', 'FileServerLocationArgs', 'FtpServerLocationArgs', 'GoogleCloudStorageLocationArgs', 'HdfsLocationArgs', 'HttpServerLocationArgs', 'OracleCloudStorageLocationArgs', 'SftpLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'Xml'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union['DatasetBZip2CompressionArgs', 'DatasetDeflateCompressionArgs', 'DatasetGZipCompressionArgs', 'DatasetTarCompressionArgs', 'DatasetTarGZipCompressionArgs', 'DatasetZipDeflateCompressionArgs']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: Optional[Any]):
        pulumi.set(self, "encoding_name", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @null_value.setter
    def null_value(self, value: Optional[Any]):
        pulumi.set(self, "null_value", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)


@pulumi.input_type
class XmlReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 compression_properties: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]] = None,
                 detect_data_type: Optional[Any] = None,
                 namespace_prefixes: Optional[Any] = None,
                 namespaces: Optional[Any] = None,
                 validation_mode: Optional[Any] = None):
        """
        Xml read settings.
        :param pulumi.Input[str] type: The read setting type.
               Expected value is 'XmlReadSettings'.
        :param pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']] compression_properties: Compression settings.
        :param Any detect_data_type: Indicates whether type detection is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
        :param Any namespace_prefixes: Namespace uri to prefix mappings to override the prefixes in column names when namespace is enabled, if no prefix is defined for a namespace uri, the prefix of xml element/attribute name in the xml data file will be used. Example: "{"http://www.example.com/xml":"prefix"}" Type: object (or Expression with resultType object).
        :param Any namespaces: Indicates whether namespace is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
        :param Any validation_mode: Indicates what validation method is used when reading the xml files. Allowed values: 'none', 'xsd', or 'dtd'. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'XmlReadSettings')
        if compression_properties is not None:
            pulumi.set(__self__, "compression_properties", compression_properties)
        if detect_data_type is not None:
            pulumi.set(__self__, "detect_data_type", detect_data_type)
        if namespace_prefixes is not None:
            pulumi.set(__self__, "namespace_prefixes", namespace_prefixes)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The read setting type.
        Expected value is 'XmlReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="compressionProperties")
    def compression_properties(self) -> Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]:
        """
        Compression settings.
        """
        return pulumi.get(self, "compression_properties")

    @compression_properties.setter
    def compression_properties(self, value: Optional[pulumi.Input[Union['TarGZipReadSettingsArgs', 'TarReadSettingsArgs', 'ZipDeflateReadSettingsArgs']]]):
        pulumi.set(self, "compression_properties", value)

    @property
    @pulumi.getter(name="detectDataType")
    def detect_data_type(self) -> Optional[Any]:
        """
        Indicates whether type detection is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "detect_data_type")

    @detect_data_type.setter
    def detect_data_type(self, value: Optional[Any]):
        pulumi.set(self, "detect_data_type", value)

    @property
    @pulumi.getter(name="namespacePrefixes")
    def namespace_prefixes(self) -> Optional[Any]:
        """
        Namespace uri to prefix mappings to override the prefixes in column names when namespace is enabled, if no prefix is defined for a namespace uri, the prefix of xml element/attribute name in the xml data file will be used. Example: "{"http://www.example.com/xml":"prefix"}" Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "namespace_prefixes")

    @namespace_prefixes.setter
    def namespace_prefixes(self, value: Optional[Any]):
        pulumi.set(self, "namespace_prefixes", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Any]:
        """
        Indicates whether namespace is enabled when reading the xml files. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[Any]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[Any]:
        """
        Indicates what validation method is used when reading the xml files. Allowed values: 'none', 'xsd', or 'dtd'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[Any]):
        pulumi.set(self, "validation_mode", value)


@pulumi.input_type
class XmlSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 format_settings: Optional[pulumi.Input['XmlReadSettingsArgs']] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None,
                 store_settings: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]] = None):
        """
        A copy activity Xml source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'XmlSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param pulumi.Input['XmlReadSettingsArgs'] format_settings: Xml format settings.
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']] store_settings: Xml store settings.
        """
        pulumi.set(__self__, "type", 'XmlSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if format_settings is not None:
            pulumi.set(__self__, "format_settings", format_settings)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)
        if store_settings is not None:
            pulumi.set(__self__, "store_settings", store_settings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'XmlSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="formatSettings")
    def format_settings(self) -> Optional[pulumi.Input['XmlReadSettingsArgs']]:
        """
        Xml format settings.
        """
        return pulumi.get(self, "format_settings")

    @format_settings.setter
    def format_settings(self, value: Optional[pulumi.Input['XmlReadSettingsArgs']]):
        pulumi.set(self, "format_settings", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)

    @property
    @pulumi.getter(name="storeSettings")
    def store_settings(self) -> Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]:
        """
        Xml store settings.
        """
        return pulumi.get(self, "store_settings")

    @store_settings.setter
    def store_settings(self, value: Optional[pulumi.Input[Union['AmazonS3CompatibleReadSettingsArgs', 'AmazonS3ReadSettingsArgs', 'AzureBlobFSReadSettingsArgs', 'AzureBlobStorageReadSettingsArgs', 'AzureDataLakeStoreReadSettingsArgs', 'AzureFileStorageReadSettingsArgs', 'FileServerReadSettingsArgs', 'FtpReadSettingsArgs', 'GoogleCloudStorageReadSettingsArgs', 'HdfsReadSettingsArgs', 'HttpReadSettingsArgs', 'OracleCloudStorageReadSettingsArgs', 'SftpReadSettingsArgs']]]):
        pulumi.set(self, "store_settings", value)


@pulumi.input_type
class ZipDeflateReadSettingsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_zip_file_name_as_folder: Optional[Any] = None):
        """
        The ZipDeflate compression read settings.
        :param pulumi.Input[str] type: The Compression setting type.
               Expected value is 'ZipDeflateReadSettings'.
        :param Any preserve_zip_file_name_as_folder: Preserve the zip file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'ZipDeflateReadSettings')
        if preserve_zip_file_name_as_folder is not None:
            pulumi.set(__self__, "preserve_zip_file_name_as_folder", preserve_zip_file_name_as_folder)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Compression setting type.
        Expected value is 'ZipDeflateReadSettings'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveZipFileNameAsFolder")
    def preserve_zip_file_name_as_folder(self) -> Optional[Any]:
        """
        Preserve the zip file name as folder path. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "preserve_zip_file_name_as_folder")

    @preserve_zip_file_name_as_folder.setter
    def preserve_zip_file_name_as_folder(self, value: Optional[Any]):
        pulumi.set(self, "preserve_zip_file_name_as_folder", value)


@pulumi.input_type
class ZohoLinkedServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]] = None,
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 connect_via: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encrypted_credential: Optional[Any] = None,
                 endpoint: Optional[Any] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Zoho server linked service.
        :param pulumi.Input[str] type: Type of linked service.
               Expected value is 'Zoho'.
        :param pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']] access_token: The access token for Zoho authentication.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the linked service.
        :param pulumi.Input['IntegrationRuntimeReferenceArgs'] connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Zoho. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param pulumi.Input[str] description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Zoho')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of linked service.
        Expected value is 'Zoho'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]:
        """
        The access token for Zoho authentication.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[Union['AzureKeyVaultSecretReferenceArgs', 'SecureStringArgs']]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @connect_via.setter
    def connect_via(self, value: Optional[pulumi.Input['IntegrationRuntimeReferenceArgs']]):
        pulumi.set(self, "connect_via", value)

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Zoho. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @connection_properties.setter
    def connection_properties(self, value: Optional[Any]):
        pulumi.set(self, "connection_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @encrypted_credential.setter
    def encrypted_credential(self, value: Optional[Any]):
        pulumi.set(self, "encrypted_credential", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[Any]:
        """
        The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[Any]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @use_encrypted_endpoints.setter
    def use_encrypted_endpoints(self, value: Optional[Any]):
        pulumi.set(self, "use_encrypted_endpoints", value)

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @use_host_verification.setter
    def use_host_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_host_verification", value)

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @use_peer_verification.setter
    def use_peer_verification(self, value: Optional[Any]):
        pulumi.set(self, "use_peer_verification", value)


@pulumi.input_type
class ZohoObjectDatasetArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input['LinkedServiceReferenceArgs'],
                 type: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Sequence[Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input['DatasetFolderArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Zoho server dataset.
        :param pulumi.Input['LinkedServiceReferenceArgs'] linked_service_name: Linked service reference.
        :param pulumi.Input[str] type: Type of dataset.
               Expected value is 'ZohoObject'.
        :param pulumi.Input[Sequence[Any]] annotations: List of tags that can be used for describing the Dataset.
        :param pulumi.Input[str] description: Dataset description.
        :param pulumi.Input['DatasetFolderArgs'] folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ZohoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input['LinkedServiceReferenceArgs']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input['LinkedServiceReferenceArgs']):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of dataset.
        Expected value is 'ZohoObject'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input['DatasetFolderArgs']]:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input['DatasetFolderArgs']]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterSpecificationArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: Optional[Any]):
        pulumi.set(self, "structure", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[Any]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class ZohoSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_columns: Optional[Any] = None,
                 disable_metrics_collection: Optional[Any] = None,
                 max_concurrent_connections: Optional[Any] = None,
                 query: Optional[Any] = None,
                 query_timeout: Optional[Any] = None,
                 source_retry_count: Optional[Any] = None,
                 source_retry_wait: Optional[Any] = None):
        """
        A copy activity Zoho server source.
        :param pulumi.Input[str] type: Copy source type.
               Expected value is 'ZohoSource'.
        :param Any additional_columns: Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        :param Any disable_metrics_collection: If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        :param Any max_concurrent_connections: The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        :param Any query: A query to retrieve data from source. Type: string (or Expression with resultType string).
        :param Any query_timeout: Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Any source_retry_count: Source retry count. Type: integer (or Expression with resultType integer).
        :param Any source_retry_wait: Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        pulumi.set(__self__, "type", 'ZohoSource')
        if additional_columns is not None:
            pulumi.set(__self__, "additional_columns", additional_columns)
        if disable_metrics_collection is not None:
            pulumi.set(__self__, "disable_metrics_collection", disable_metrics_collection)
        if max_concurrent_connections is not None:
            pulumi.set(__self__, "max_concurrent_connections", max_concurrent_connections)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if source_retry_count is not None:
            pulumi.set(__self__, "source_retry_count", source_retry_count)
        if source_retry_wait is not None:
            pulumi.set(__self__, "source_retry_wait", source_retry_wait)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Copy source type.
        Expected value is 'ZohoSource'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalColumns")
    def additional_columns(self) -> Optional[Any]:
        """
        Specifies the additional columns to be added to source data. Type: array of objects(AdditionalColumns) (or Expression with resultType array of objects).
        """
        return pulumi.get(self, "additional_columns")

    @additional_columns.setter
    def additional_columns(self, value: Optional[Any]):
        pulumi.set(self, "additional_columns", value)

    @property
    @pulumi.getter(name="disableMetricsCollection")
    def disable_metrics_collection(self) -> Optional[Any]:
        """
        If true, disable data store metrics collection. Default is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "disable_metrics_collection")

    @disable_metrics_collection.setter
    def disable_metrics_collection(self, value: Optional[Any]):
        pulumi.set(self, "disable_metrics_collection", value)

    @property
    @pulumi.getter(name="maxConcurrentConnections")
    def max_concurrent_connections(self) -> Optional[Any]:
        """
        The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "max_concurrent_connections")

    @max_concurrent_connections.setter
    def max_concurrent_connections(self, value: Optional[Any]):
        pulumi.set(self, "max_concurrent_connections", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[Any]:
        """
        A query to retrieve data from source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[Any]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[Any]:
        """
        Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[Any]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter(name="sourceRetryCount")
    def source_retry_count(self) -> Optional[Any]:
        """
        Source retry count. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "source_retry_count")

    @source_retry_count.setter
    def source_retry_count(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_count", value)

    @property
    @pulumi.getter(name="sourceRetryWait")
    def source_retry_wait(self) -> Optional[Any]:
        """
        Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "source_retry_wait")

    @source_retry_wait.setter
    def source_retry_wait(self, value: Optional[Any]):
        pulumi.set(self, "source_retry_wait", value)


