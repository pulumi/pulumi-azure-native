// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.MobileNetwork
{
    /// <summary>
    /// How to authenticate users who access local diagnostics APIs.
    /// </summary>
    [EnumType]
    public readonly struct AuthenticationType : IEquatable<AuthenticationType>
    {
        private readonly string _value;

        private AuthenticationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use AAD SSO to authenticate the user (this requires internet access).
        /// </summary>
        public static AuthenticationType AAD { get; } = new AuthenticationType("AAD");
        /// <summary>
        /// Use locally stored passwords to authenticate the user.
        /// </summary>
        public static AuthenticationType Password { get; } = new AuthenticationType("Password");

        public static bool operator ==(AuthenticationType left, AuthenticationType right) => left.Equals(right);
        public static bool operator !=(AuthenticationType left, AuthenticationType right) => !left.Equals(right);

        public static explicit operator string(AuthenticationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthenticationType other && Equals(other);
        public bool Equals(AuthenticationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU defining the throughput and SIM allowances for this packet core control plane deployment.
    /// </summary>
    [EnumType]
    public readonly struct BillingSku : IEquatable<BillingSku>
    {
        private readonly string _value;

        private BillingSku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 100 Mbps, 20 active SIMs plan, 2 RANs
        /// </summary>
        public static BillingSku G0 { get; } = new BillingSku("G0");
        /// <summary>
        /// 1 Gbps, 100 active SIMs plan, 5 RANs
        /// </summary>
        public static BillingSku G1 { get; } = new BillingSku("G1");
        /// <summary>
        /// 2 Gbps, 200 active SIMs plan, 10 RANs
        /// </summary>
        public static BillingSku G2 { get; } = new BillingSku("G2");
        /// <summary>
        /// 5 Gbps, 500 active SIMs plan
        /// </summary>
        public static BillingSku G5 { get; } = new BillingSku("G5");
        /// <summary>
        /// 10 Gbps, 1000 active SIMs plan
        /// </summary>
        public static BillingSku G10 { get; } = new BillingSku("G10");

        public static bool operator ==(BillingSku left, BillingSku right) => left.Equals(right);
        public static bool operator !=(BillingSku left, BillingSku right) => !left.Equals(right);

        public static explicit operator string(BillingSku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BillingSku other && Equals(other);
        public bool Equals(BillingSku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The core network technology generation (5G core or EPC / 4G core).
    /// </summary>
    [EnumType]
    public readonly struct CoreNetworkType : IEquatable<CoreNetworkType>
    {
        private readonly string _value;

        private CoreNetworkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 5G core
        /// </summary>
        public static CoreNetworkType CoreNetworkType_5GC { get; } = new CoreNetworkType("5GC");
        /// <summary>
        /// EPC / 4G core
        /// </summary>
        public static CoreNetworkType EPC { get; } = new CoreNetworkType("EPC");
        /// <summary>
        /// Combined EPC / 4G and 5G core
        /// </summary>
        public static CoreNetworkType EPC_5GC { get; } = new CoreNetworkType("EPC + 5GC");

        public static bool operator ==(CoreNetworkType left, CoreNetworkType right) => left.Equals(right);
        public static bool operator !=(CoreNetworkType left, CoreNetworkType right) => !left.Equals(right);

        public static explicit operator string(CoreNetworkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CoreNetworkType other && Equals(other);
        public bool Equals(CoreNetworkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired installation state
    /// </summary>
    [EnumType]
    public readonly struct DesiredInstallationState : IEquatable<DesiredInstallationState>
    {
        private readonly string _value;

        private DesiredInstallationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Don't install the packet core.
        /// </summary>
        public static DesiredInstallationState Uninstalled { get; } = new DesiredInstallationState("Uninstalled");
        /// <summary>
        /// Install the packet core.
        /// </summary>
        public static DesiredInstallationState Installed { get; } = new DesiredInstallationState("Installed");

        public static bool operator ==(DesiredInstallationState left, DesiredInstallationState right) => left.Equals(right);
        public static bool operator !=(DesiredInstallationState left, DesiredInstallationState right) => !left.Equals(right);

        public static explicit operator string(DesiredInstallationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DesiredInstallationState other && Equals(other);
        public bool Equals(DesiredInstallationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (currently only UserAssigned allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether NAPT is enabled for connections to this attached data network.
    /// </summary>
    [EnumType]
    public readonly struct NaptEnabled : IEquatable<NaptEnabled>
    {
        private readonly string _value;

        private NaptEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NAPT is enabled
        /// </summary>
        public static NaptEnabled Enabled { get; } = new NaptEnabled("Enabled");
        /// <summary>
        /// NAPT is disabled
        /// </summary>
        public static NaptEnabled Disabled { get; } = new NaptEnabled("Disabled");

        public static bool operator ==(NaptEnabled left, NaptEnabled right) => left.Equals(right);
        public static bool operator !=(NaptEnabled left, NaptEnabled right) => !left.Equals(right);

        public static explicit operator string(NaptEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NaptEnabled other && Equals(other);
        public bool Equals(NaptEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default PDU session type, which is used if the UE does not request a specific session type.
    /// </summary>
    [EnumType]
    public readonly struct PduSessionType : IEquatable<PduSessionType>
    {
        private readonly string _value;

        private PduSessionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PduSessionType IPv4 { get; } = new PduSessionType("IPv4");
        public static PduSessionType IPv6 { get; } = new PduSessionType("IPv6");

        public static bool operator ==(PduSessionType left, PduSessionType right) => left.Equals(right);
        public static bool operator !=(PduSessionType left, PduSessionType right) => !left.Equals(right);

        public static explicit operator string(PduSessionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PduSessionType other && Equals(other);
        public bool Equals(PduSessionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The platform type where packet core is deployed.
    /// </summary>
    [EnumType]
    public readonly struct PlatformType : IEquatable<PlatformType>
    {
        private readonly string _value;

        private PlatformType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If this option is chosen, you must set one of "azureStackEdgeDevice", "connectedCluster" or "customLocation". If multiple are set, they must be consistent with each other.
        /// </summary>
        public static PlatformType AKS_HCI { get; } = new PlatformType("AKS-HCI");
        /// <summary>
        /// If this option is chosen, you must set one of "azureStackHciCluster", "connectedCluster" or "customLocation". If multiple are set, they must be consistent with each other.
        /// </summary>
        public static PlatformType PlatformType_3P_AZURE_STACK_HCI { get; } = new PlatformType("3P-AZURE-STACK-HCI");

        public static bool operator ==(PlatformType left, PlatformType right) => left.Equals(right);
        public static bool operator !=(PlatformType left, PlatformType right) => !left.Equals(right);

        public static explicit operator string(PlatformType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlatformType other && Equals(other);
        public bool Equals(PlatformType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default QoS Flow preemption capability. The preemption capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
    /// </summary>
    [EnumType]
    public readonly struct PreemptionCapability : IEquatable<PreemptionCapability>
    {
        private readonly string _value;

        private PreemptionCapability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cannot preempt
        /// </summary>
        public static PreemptionCapability NotPreempt { get; } = new PreemptionCapability("NotPreempt");
        /// <summary>
        /// May preempt
        /// </summary>
        public static PreemptionCapability MayPreempt { get; } = new PreemptionCapability("MayPreempt");

        public static bool operator ==(PreemptionCapability left, PreemptionCapability right) => left.Equals(right);
        public static bool operator !=(PreemptionCapability left, PreemptionCapability right) => !left.Equals(right);

        public static explicit operator string(PreemptionCapability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PreemptionCapability other && Equals(other);
        public bool Equals(PreemptionCapability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default QoS Flow preemption vulnerability. The preemption vulnerability of a QoS Flow controls whether it can be preempted by a QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
    /// </summary>
    [EnumType]
    public readonly struct PreemptionVulnerability : IEquatable<PreemptionVulnerability>
    {
        private readonly string _value;

        private PreemptionVulnerability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cannot be preempted
        /// </summary>
        public static PreemptionVulnerability NotPreemptable { get; } = new PreemptionVulnerability("NotPreemptable");
        /// <summary>
        /// May be preempted
        /// </summary>
        public static PreemptionVulnerability Preemptable { get; } = new PreemptionVulnerability("Preemptable");

        public static bool operator ==(PreemptionVulnerability left, PreemptionVulnerability right) => left.Equals(right);
        public static bool operator !=(PreemptionVulnerability left, PreemptionVulnerability right) => !left.Equals(right);

        public static explicit operator string(PreemptionVulnerability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PreemptionVulnerability other && Equals(other);
        public bool Equals(PreemptionVulnerability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction of this flow.
    /// </summary>
    [EnumType]
    public readonly struct SdfDirection : IEquatable<SdfDirection>
    {
        private readonly string _value;

        private SdfDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Traffic flowing from the UE to the data network.
        /// </summary>
        public static SdfDirection Uplink { get; } = new SdfDirection("Uplink");
        /// <summary>
        /// Traffic flowing from the data network to the UE.
        /// </summary>
        public static SdfDirection Downlink { get; } = new SdfDirection("Downlink");
        /// <summary>
        /// Traffic flowing both to and from the UE.
        /// </summary>
        public static SdfDirection Bidirectional { get; } = new SdfDirection("Bidirectional");

        public static bool operator ==(SdfDirection left, SdfDirection right) => left.Equals(right);
        public static bool operator !=(SdfDirection left, SdfDirection right) => !left.Equals(right);

        public static explicit operator string(SdfDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SdfDirection other && Equals(other);
        public bool Equals(SdfDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether flows that match this data flow policy rule are permitted.
    /// </summary>
    [EnumType]
    public readonly struct TrafficControlPermission : IEquatable<TrafficControlPermission>
    {
        private readonly string _value;

        private TrafficControlPermission(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Traffic matching this rule is allowed to flow.
        /// </summary>
        public static TrafficControlPermission Enabled { get; } = new TrafficControlPermission("Enabled");
        /// <summary>
        /// Traffic matching this rule is not allowed to flow.
        /// </summary>
        public static TrafficControlPermission Blocked { get; } = new TrafficControlPermission("Blocked");

        public static bool operator ==(TrafficControlPermission left, TrafficControlPermission right) => left.Equals(right);
        public static bool operator !=(TrafficControlPermission left, TrafficControlPermission right) => !left.Equals(right);

        public static explicit operator string(TrafficControlPermission value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrafficControlPermission other && Equals(other);
        public bool Equals(TrafficControlPermission other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
