// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.MobileNetwork
{
    /// <summary>
    /// Packet core control plane resource.
    /// Azure REST API version: 2024-04-01. Prior API version in Azure Native 2.x: 2023-06-01.
    /// </summary>
    [AzureNativeResourceType("azure-native:mobilenetwork:PacketCoreControlPlane")]
    public partial class PacketCoreControlPlane : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The Azure API version of the resource.
        /// </summary>
        [Output("azureApiVersion")]
        public Output<string> AzureApiVersion { get; private set; } = null!;

        /// <summary>
        /// The control plane interface on the access network. For 5G networks, this is the N2 interface. For 4G networks, this is the S1-MME interface.
        /// </summary>
        [Output("controlPlaneAccessInterface")]
        public Output<Outputs.InterfacePropertiesResponse> ControlPlaneAccessInterface { get; private set; } = null!;

        /// <summary>
        /// The virtual IP address(es) for the control plane on the access network in a High Availability (HA) system. In an HA deployment the access network router should be configured to anycast traffic for this address to the control plane access interfaces on the active and standby nodes. In non-HA system this list should be omitted or empty.
        /// </summary>
        [Output("controlPlaneAccessVirtualIpv4Addresses")]
        public Output<ImmutableArray<string>> ControlPlaneAccessVirtualIpv4Addresses { get; private set; } = null!;

        /// <summary>
        /// The core network technology generation (5G core or EPC / 4G core).
        /// </summary>
        [Output("coreNetworkTechnology")]
        public Output<string?> CoreNetworkTechnology { get; private set; } = null!;

        /// <summary>
        /// Configuration for uploading packet core diagnostics
        /// </summary>
        [Output("diagnosticsUpload")]
        public Output<Outputs.DiagnosticsUploadConfigurationResponse?> DiagnosticsUpload { get; private set; } = null!;

        /// <summary>
        /// Configuration for sending packet core events to an Azure Event Hub.
        /// </summary>
        [Output("eventHub")]
        public Output<Outputs.EventHubConfigurationResponse?> EventHub { get; private set; } = null!;

        /// <summary>
        /// The provisioning state of the secret containing private keys and keyIds for SUPI concealment.
        /// </summary>
        [Output("homeNetworkPrivateKeysProvisioning")]
        public Output<Outputs.HomeNetworkPrivateKeysProvisioningResponse> HomeNetworkPrivateKeysProvisioning { get; private set; } = null!;

        /// <summary>
        /// The identity used to retrieve the ingress certificate from Azure key vault.
        /// </summary>
        [Output("identity")]
        public Output<Outputs.ManagedServiceIdentityResponse?> Identity { get; private set; } = null!;

        /// <summary>
        /// The installation state of the packet core control plane resource.
        /// </summary>
        [Output("installation")]
        public Output<Outputs.InstallationResponse?> Installation { get; private set; } = null!;

        /// <summary>
        /// The currently installed version of the packet core software.
        /// </summary>
        [Output("installedVersion")]
        public Output<string> InstalledVersion { get; private set; } = null!;

        /// <summary>
        /// Settings to allow interoperability with third party components e.g. RANs and UEs.
        /// </summary>
        [Output("interopSettings")]
        public Output<object?> InteropSettings { get; private set; } = null!;

        /// <summary>
        /// The kubernetes ingress configuration to control access to packet core diagnostics over local APIs.
        /// </summary>
        [Output("localDiagnosticsAccess")]
        public Output<Outputs.LocalDiagnosticsAccessConfigurationResponse> LocalDiagnosticsAccess { get; private set; } = null!;

        /// <summary>
        /// The geo-location where the resource lives
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// The name of the resource
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The platform where the packet core is deployed.
        /// </summary>
        [Output("platform")]
        public Output<Outputs.PlatformConfigurationResponse> Platform { get; private set; } = null!;

        /// <summary>
        /// The provisioning state of the packet core control plane resource.
        /// </summary>
        [Output("provisioningState")]
        public Output<string> ProvisioningState { get; private set; } = null!;

        /// <summary>
        /// The previous version of the packet core software that was deployed. Used when performing the rollback action.
        /// </summary>
        [Output("rollbackVersion")]
        public Output<string> RollbackVersion { get; private set; } = null!;

        /// <summary>
        /// Signaling configuration for the packet core.
        /// </summary>
        [Output("signaling")]
        public Output<Outputs.SignalingConfigurationResponse?> Signaling { get; private set; } = null!;

        /// <summary>
        /// Site(s) under which this packet core control plane should be deployed. The sites must be in the same location as the packet core control plane.
        /// </summary>
        [Output("sites")]
        public Output<ImmutableArray<Outputs.SiteResourceIdResponse>> Sites { get; private set; } = null!;

        /// <summary>
        /// The SKU defining the throughput and SIM allowances for this packet core control plane deployment.
        /// </summary>
        [Output("sku")]
        public Output<string> Sku { get; private set; } = null!;

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Output("systemData")]
        public Output<Outputs.SystemDataResponse> SystemData { get; private set; } = null!;

        /// <summary>
        /// Resource tags.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// The MTU (in bytes) signaled to the UE. The same MTU is set on the user plane data links for all data networks. The MTU set on the user plane access link is calculated to be 60 bytes greater than this value to allow for GTP encapsulation.
        /// </summary>
        [Output("ueMtu")]
        public Output<int?> UeMtu { get; private set; } = null!;

        /// <summary>
        /// The user consent configuration for the packet core.
        /// </summary>
        [Output("userConsent")]
        public Output<Outputs.UserConsentConfigurationResponse?> UserConsent { get; private set; } = null!;

        /// <summary>
        /// The desired version of the packet core software.
        /// </summary>
        [Output("version")]
        public Output<string?> Version { get; private set; } = null!;


        /// <summary>
        /// Create a PacketCoreControlPlane resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public PacketCoreControlPlane(string name, PacketCoreControlPlaneArgs args, CustomResourceOptions? options = null)
            : base("azure-native:mobilenetwork:PacketCoreControlPlane", name, args ?? new PacketCoreControlPlaneArgs(), MakeResourceOptions(options, ""))
        {
        }

        private PacketCoreControlPlane(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("azure-native:mobilenetwork:PacketCoreControlPlane", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20220301preview:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20220401preview:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20221101:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20230601:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20230901:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20240201:PacketCoreControlPlane" },
                    new global::Pulumi.Alias { Type = "azure-native:mobilenetwork/v20240401:PacketCoreControlPlane" },
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing PacketCoreControlPlane resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static PacketCoreControlPlane Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new PacketCoreControlPlane(name, id, options);
        }
    }

    public sealed class PacketCoreControlPlaneArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The control plane interface on the access network. For 5G networks, this is the N2 interface. For 4G networks, this is the S1-MME interface.
        /// </summary>
        [Input("controlPlaneAccessInterface", required: true)]
        public Input<Inputs.InterfacePropertiesArgs> ControlPlaneAccessInterface { get; set; } = null!;

        [Input("controlPlaneAccessVirtualIpv4Addresses")]
        private InputList<string>? _controlPlaneAccessVirtualIpv4Addresses;

        /// <summary>
        /// The virtual IP address(es) for the control plane on the access network in a High Availability (HA) system. In an HA deployment the access network router should be configured to anycast traffic for this address to the control plane access interfaces on the active and standby nodes. In non-HA system this list should be omitted or empty.
        /// </summary>
        public InputList<string> ControlPlaneAccessVirtualIpv4Addresses
        {
            get => _controlPlaneAccessVirtualIpv4Addresses ?? (_controlPlaneAccessVirtualIpv4Addresses = new InputList<string>());
            set => _controlPlaneAccessVirtualIpv4Addresses = value;
        }

        /// <summary>
        /// The core network technology generation (5G core or EPC / 4G core).
        /// </summary>
        [Input("coreNetworkTechnology")]
        public InputUnion<string, Pulumi.AzureNative.MobileNetwork.CoreNetworkType>? CoreNetworkTechnology { get; set; }

        /// <summary>
        /// Configuration for uploading packet core diagnostics
        /// </summary>
        [Input("diagnosticsUpload")]
        public Input<Inputs.DiagnosticsUploadConfigurationArgs>? DiagnosticsUpload { get; set; }

        /// <summary>
        /// Configuration for sending packet core events to an Azure Event Hub.
        /// </summary>
        [Input("eventHub")]
        public Input<Inputs.EventHubConfigurationArgs>? EventHub { get; set; }

        /// <summary>
        /// The identity used to retrieve the ingress certificate from Azure key vault.
        /// </summary>
        [Input("identity")]
        public Input<Inputs.ManagedServiceIdentityArgs>? Identity { get; set; }

        /// <summary>
        /// The installation state of the packet core control plane resource.
        /// </summary>
        [Input("installation")]
        public Input<Inputs.InstallationArgs>? Installation { get; set; }

        /// <summary>
        /// Settings to allow interoperability with third party components e.g. RANs and UEs.
        /// </summary>
        [Input("interopSettings")]
        public Input<object>? InteropSettings { get; set; }

        /// <summary>
        /// The kubernetes ingress configuration to control access to packet core diagnostics over local APIs.
        /// </summary>
        [Input("localDiagnosticsAccess", required: true)]
        public Input<Inputs.LocalDiagnosticsAccessConfigurationArgs> LocalDiagnosticsAccess { get; set; } = null!;

        /// <summary>
        /// The geo-location where the resource lives
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// The name of the packet core control plane.
        /// </summary>
        [Input("packetCoreControlPlaneName")]
        public Input<string>? PacketCoreControlPlaneName { get; set; }

        /// <summary>
        /// The platform where the packet core is deployed.
        /// </summary>
        [Input("platform", required: true)]
        public Input<Inputs.PlatformConfigurationArgs> Platform { get; set; } = null!;

        /// <summary>
        /// The name of the resource group. The name is case insensitive.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        /// <summary>
        /// Signaling configuration for the packet core.
        /// </summary>
        [Input("signaling")]
        public Input<Inputs.SignalingConfigurationArgs>? Signaling { get; set; }

        [Input("sites", required: true)]
        private InputList<Inputs.SiteResourceIdArgs>? _sites;

        /// <summary>
        /// Site(s) under which this packet core control plane should be deployed. The sites must be in the same location as the packet core control plane.
        /// </summary>
        public InputList<Inputs.SiteResourceIdArgs> Sites
        {
            get => _sites ?? (_sites = new InputList<Inputs.SiteResourceIdArgs>());
            set => _sites = value;
        }

        /// <summary>
        /// The SKU defining the throughput and SIM allowances for this packet core control plane deployment.
        /// </summary>
        [Input("sku", required: true)]
        public InputUnion<string, Pulumi.AzureNative.MobileNetwork.BillingSku> Sku { get; set; } = null!;

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Resource tags.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The MTU (in bytes) signaled to the UE. The same MTU is set on the user plane data links for all data networks. The MTU set on the user plane access link is calculated to be 60 bytes greater than this value to allow for GTP encapsulation.
        /// </summary>
        [Input("ueMtu")]
        public Input<int>? UeMtu { get; set; }

        /// <summary>
        /// The user consent configuration for the packet core.
        /// </summary>
        [Input("userConsent")]
        public Input<Inputs.UserConsentConfigurationArgs>? UserConsent { get; set; }

        /// <summary>
        /// The desired version of the packet core software.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public PacketCoreControlPlaneArgs()
        {
            UeMtu = 1440;
        }
        public static new PacketCoreControlPlaneArgs Empty => new PacketCoreControlPlaneArgs();
    }
}
