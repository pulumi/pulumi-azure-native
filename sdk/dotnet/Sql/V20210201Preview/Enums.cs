// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Sql.V20210201Preview
{
    /// <summary>
    /// Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct AdministratorType : IEquatable<AdministratorType>
    {
        private readonly string _value;

        private AdministratorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdministratorType ActiveDirectory { get; } = new AdministratorType("ActiveDirectory");

        public static bool operator ==(AdministratorType left, AdministratorType right) => left.Equals(right);
        public static bool operator !=(AdministratorType left, AdministratorType right) => !left.Equals(right);

        public static explicit operator string(AdministratorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdministratorType other && Equals(other);
        public bool Equals(AdministratorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType None { get; } = new IdentityType("None");
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type. Possible values are 'LicenseIncluded' (regular price inclusive of a new SQL license) and 'BasePrice' (discounted AHB price for bringing your own SQL licenses).
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceLicenseType : IEquatable<ManagedInstanceLicenseType>
    {
        private readonly string _value;

        private ManagedInstanceLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceLicenseType LicenseIncluded { get; } = new ManagedInstanceLicenseType("LicenseIncluded");
        public static ManagedInstanceLicenseType BasePrice { get; } = new ManagedInstanceLicenseType("BasePrice");

        public static bool operator ==(ManagedInstanceLicenseType left, ManagedInstanceLicenseType right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceLicenseType left, ManagedInstanceLicenseType right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceLicenseType other && Equals(other);
        public bool Equals(ManagedInstanceLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Connection type used for connecting to the instance.
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceProxyOverride : IEquatable<ManagedInstanceProxyOverride>
    {
        private readonly string _value;

        private ManagedInstanceProxyOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceProxyOverride Proxy { get; } = new ManagedInstanceProxyOverride("Proxy");
        public static ManagedInstanceProxyOverride Redirect { get; } = new ManagedInstanceProxyOverride("Redirect");
        public static ManagedInstanceProxyOverride Default { get; } = new ManagedInstanceProxyOverride("Default");

        public static bool operator ==(ManagedInstanceProxyOverride left, ManagedInstanceProxyOverride right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceProxyOverride left, ManagedInstanceProxyOverride right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceProxyOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceProxyOverride other && Equals(other);
        public bool Equals(ManagedInstanceProxyOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of database creation.
    /// 
    /// Default: Regular instance creation.
    /// 
    /// Restore: Creates an instance by restoring a set of backups to specific point in time. RestorePointInTime and SourceManagedInstanceId must be specified.
    /// </summary>
    [EnumType]
    public readonly struct ManagedServerCreateMode : IEquatable<ManagedServerCreateMode>
    {
        private readonly string _value;

        private ManagedServerCreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServerCreateMode Default { get; } = new ManagedServerCreateMode("Default");
        public static ManagedServerCreateMode PointInTimeRestore { get; } = new ManagedServerCreateMode("PointInTimeRestore");

        public static bool operator ==(ManagedServerCreateMode left, ManagedServerCreateMode right) => left.Equals(right);
        public static bool operator !=(ManagedServerCreateMode left, ManagedServerCreateMode right) => !left.Equals(right);

        public static explicit operator string(ManagedServerCreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServerCreateMode other && Equals(other);
        public bool Equals(ManagedServerCreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Principal Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct PrincipalType : IEquatable<PrincipalType>
    {
        private readonly string _value;

        private PrincipalType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrincipalType User { get; } = new PrincipalType("User");
        public static PrincipalType Group { get; } = new PrincipalType("Group");
        public static PrincipalType Application { get; } = new PrincipalType("Application");

        public static bool operator ==(PrincipalType left, PrincipalType right) => left.Equals(right);
        public static bool operator !=(PrincipalType left, PrincipalType right) => !left.Equals(right);

        public static explicit operator string(PrincipalType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrincipalType other && Equals(other);
        public bool Equals(PrincipalType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage account type used to store backups for this instance. The options are LRS (LocallyRedundantStorage), ZRS (ZoneRedundantStorage) and GRS (GeoRedundantStorage)
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountType GRS { get; } = new StorageAccountType("GRS");
        public static StorageAccountType LRS { get; } = new StorageAccountType("LRS");
        public static StorageAccountType ZRS { get; } = new StorageAccountType("ZRS");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
