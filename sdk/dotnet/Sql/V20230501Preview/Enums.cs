// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Sql.V20230501Preview
{
    /// <summary>
    /// Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct AdministratorType : IEquatable<AdministratorType>
    {
        private readonly string _value;

        private AdministratorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdministratorType ActiveDirectory { get; } = new AdministratorType("ActiveDirectory");

        public static bool operator ==(AdministratorType left, AdministratorType right) => left.Equals(right);
        public static bool operator !=(AdministratorType left, AdministratorType right) => !left.Equals(right);

        public static explicit operator string(AdministratorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdministratorType other && Equals(other);
        public bool Equals(AdministratorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of enclave requested on the elastic pool.
    /// </summary>
    [EnumType]
    public readonly struct AlwaysEncryptedEnclaveType : IEquatable<AlwaysEncryptedEnclaveType>
    {
        private readonly string _value;

        private AlwaysEncryptedEnclaveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AlwaysEncryptedEnclaveType Default { get; } = new AlwaysEncryptedEnclaveType("Default");
        public static AlwaysEncryptedEnclaveType VBS { get; } = new AlwaysEncryptedEnclaveType("VBS");

        public static bool operator ==(AlwaysEncryptedEnclaveType left, AlwaysEncryptedEnclaveType right) => left.Equals(right);
        public static bool operator !=(AlwaysEncryptedEnclaveType left, AlwaysEncryptedEnclaveType right) => !left.Equals(right);

        public static explicit operator string(AlwaysEncryptedEnclaveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlwaysEncryptedEnclaveType other && Equals(other);
        public bool Equals(AlwaysEncryptedEnclaveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The managed instance's authentication metadata lookup mode.
    /// </summary>
    [EnumType]
    public readonly struct AuthMetadataLookupModes : IEquatable<AuthMetadataLookupModes>
    {
        private readonly string _value;

        private AuthMetadataLookupModes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthMetadataLookupModes AzureAD { get; } = new AuthMetadataLookupModes("AzureAD");
        public static AuthMetadataLookupModes Paired { get; } = new AuthMetadataLookupModes("Paired");
        public static AuthMetadataLookupModes Windows { get; } = new AuthMetadataLookupModes("Windows");

        public static bool operator ==(AuthMetadataLookupModes left, AuthMetadataLookupModes right) => left.Equals(right);
        public static bool operator !=(AuthMetadataLookupModes left, AuthMetadataLookupModes right) => !left.Equals(right);

        public static explicit operator string(AuthMetadataLookupModes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthMetadataLookupModes other && Equals(other);
        public bool Equals(AuthMetadataLookupModes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Gets the auto-execute status (whether to let the system execute the recommendations) of this advisor. Possible values are 'Enabled' and 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct AutoExecuteStatus : IEquatable<AutoExecuteStatus>
    {
        private readonly string _value;

        private AutoExecuteStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoExecuteStatus Enabled { get; } = new AutoExecuteStatus("Enabled");
        public static AutoExecuteStatus Disabled { get; } = new AutoExecuteStatus("Disabled");
        public static AutoExecuteStatus Default { get; } = new AutoExecuteStatus("Default");

        public static bool operator ==(AutoExecuteStatus left, AutoExecuteStatus right) => left.Equals(right);
        public static bool operator !=(AutoExecuteStatus left, AutoExecuteStatus right) => !left.Equals(right);

        public static explicit operator string(AutoExecuteStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoExecuteStatus other && Equals(other);
        public bool Equals(AutoExecuteStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the availability zone the pool's primary replica is pinned to.
    /// </summary>
    [EnumType]
    public readonly struct AvailabilityZoneType : IEquatable<AvailabilityZoneType>
    {
        private readonly string _value;

        private AvailabilityZoneType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AvailabilityZoneType NoPreference { get; } = new AvailabilityZoneType("NoPreference");
        public static AvailabilityZoneType One { get; } = new AvailabilityZoneType("1");
        public static AvailabilityZoneType Two { get; } = new AvailabilityZoneType("2");
        public static AvailabilityZoneType Three { get; } = new AvailabilityZoneType("3");

        public static bool operator ==(AvailabilityZoneType left, AvailabilityZoneType right) => left.Equals(right);
        public static bool operator !=(AvailabilityZoneType left, AvailabilityZoneType right) => !left.Equals(right);

        public static explicit operator string(AvailabilityZoneType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AvailabilityZoneType other && Equals(other);
        public bool Equals(AvailabilityZoneType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The BackupStorageAccessTier for the LTR backups
    /// </summary>
    [EnumType]
    public readonly struct BackupStorageAccessTier : IEquatable<BackupStorageAccessTier>
    {
        private readonly string _value;

        private BackupStorageAccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackupStorageAccessTier Hot { get; } = new BackupStorageAccessTier("Hot");
        public static BackupStorageAccessTier Archive { get; } = new BackupStorageAccessTier("Archive");

        public static bool operator ==(BackupStorageAccessTier left, BackupStorageAccessTier right) => left.Equals(right);
        public static bool operator !=(BackupStorageAccessTier left, BackupStorageAccessTier right) => !left.Equals(right);

        public static explicit operator string(BackupStorageAccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupStorageAccessTier other && Equals(other);
        public bool Equals(BackupStorageAccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage account type to be used to store backups for this instance. The options are Local (LocallyRedundantStorage), Zone (ZoneRedundantStorage), Geo (GeoRedundantStorage) and GeoZone(GeoZoneRedundantStorage)
    /// </summary>
    [EnumType]
    public readonly struct BackupStorageRedundancy : IEquatable<BackupStorageRedundancy>
    {
        private readonly string _value;

        private BackupStorageRedundancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackupStorageRedundancy Geo { get; } = new BackupStorageRedundancy("Geo");
        public static BackupStorageRedundancy Local { get; } = new BackupStorageRedundancy("Local");
        public static BackupStorageRedundancy Zone { get; } = new BackupStorageRedundancy("Zone");
        public static BackupStorageRedundancy GeoZone { get; } = new BackupStorageRedundancy("GeoZone");

        public static bool operator ==(BackupStorageRedundancy left, BackupStorageRedundancy right) => left.Equals(right);
        public static bool operator !=(BackupStorageRedundancy left, BackupStorageRedundancy right) => !left.Equals(right);

        public static explicit operator string(BackupStorageRedundancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupStorageRedundancy other && Equals(other);
        public bool Equals(BackupStorageRedundancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the state of the audit. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
    /// </summary>
    [EnumType]
    public readonly struct BlobAuditingPolicyState : IEquatable<BlobAuditingPolicyState>
    {
        private readonly string _value;

        private BlobAuditingPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BlobAuditingPolicyState Enabled { get; } = new BlobAuditingPolicyState("Enabled");
        public static BlobAuditingPolicyState Disabled { get; } = new BlobAuditingPolicyState("Disabled");

        public static bool operator ==(BlobAuditingPolicyState left, BlobAuditingPolicyState right) => left.Equals(right);
        public static bool operator !=(BlobAuditingPolicyState left, BlobAuditingPolicyState right) => !left.Equals(right);

        public static explicit operator string(BlobAuditingPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BlobAuditingPolicyState other && Equals(other);
        public bool Equals(BlobAuditingPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Collation of the metadata catalog.
    /// </summary>
    [EnumType]
    public readonly struct CatalogCollationType : IEquatable<CatalogCollationType>
    {
        private readonly string _value;

        private CatalogCollationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CatalogCollationType DATABASE_DEFAULT { get; } = new CatalogCollationType("DATABASE_DEFAULT");
        public static CatalogCollationType SQL_Latin1_General_CP1_CI_AS { get; } = new CatalogCollationType("SQL_Latin1_General_CP1_CI_AS");

        public static bool operator ==(CatalogCollationType left, CatalogCollationType right) => left.Equals(right);
        public static bool operator !=(CatalogCollationType left, CatalogCollationType right) => !left.Equals(right);

        public static explicit operator string(CatalogCollationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CatalogCollationType other && Equals(other);
        public bool Equals(CatalogCollationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ClientClassificationSource : IEquatable<ClientClassificationSource>
    {
        private readonly string _value;

        private ClientClassificationSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClientClassificationSource None { get; } = new ClientClassificationSource("None");
        public static ClientClassificationSource Native { get; } = new ClientClassificationSource("Native");
        public static ClientClassificationSource Recommended { get; } = new ClientClassificationSource("Recommended");
        public static ClientClassificationSource MIP { get; } = new ClientClassificationSource("MIP");

        public static bool operator ==(ClientClassificationSource left, ClientClassificationSource right) => left.Equals(right);
        public static bool operator !=(ClientClassificationSource left, ClientClassificationSource right) => !left.Equals(right);

        public static explicit operator string(ClientClassificationSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClientClassificationSource other && Equals(other);
        public bool Equals(ClientClassificationSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of database creation.
    /// 
    /// Default: regular database creation.
    /// 
    /// Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.
    /// 
    /// Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.
    /// 
    /// PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
    /// 
    /// Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.
    /// 
    /// Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.
    /// 
    /// RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
    /// 
    /// Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
    /// </summary>
    [EnumType]
    public readonly struct CreateMode : IEquatable<CreateMode>
    {
        private readonly string _value;

        private CreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreateMode Default { get; } = new CreateMode("Default");
        public static CreateMode Copy { get; } = new CreateMode("Copy");
        public static CreateMode Secondary { get; } = new CreateMode("Secondary");
        public static CreateMode PointInTimeRestore { get; } = new CreateMode("PointInTimeRestore");
        public static CreateMode Restore { get; } = new CreateMode("Restore");
        public static CreateMode Recovery { get; } = new CreateMode("Recovery");
        public static CreateMode RestoreExternalBackup { get; } = new CreateMode("RestoreExternalBackup");
        public static CreateMode RestoreExternalBackupSecondary { get; } = new CreateMode("RestoreExternalBackupSecondary");
        public static CreateMode RestoreLongTermRetentionBackup { get; } = new CreateMode("RestoreLongTermRetentionBackup");
        public static CreateMode OnlineSecondary { get; } = new CreateMode("OnlineSecondary");

        public static bool operator ==(CreateMode left, CreateMode right) => left.Equals(right);
        public static bool operator !=(CreateMode left, CreateMode right) => !left.Equals(right);

        public static explicit operator string(CreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreateMode other && Equals(other);
        public bool Equals(CreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of the data masking policy.
    /// </summary>
    [EnumType]
    public readonly struct DataMaskingState : IEquatable<DataMaskingState>
    {
        private readonly string _value;

        private DataMaskingState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataMaskingState Enabled { get; } = new DataMaskingState("Enabled");
        public static DataMaskingState Disabled { get; } = new DataMaskingState("Disabled");

        public static bool operator ==(DataMaskingState left, DataMaskingState right) => left.Equals(right);
        public static bool operator !=(DataMaskingState left, DataMaskingState right) => !left.Equals(right);

        public static explicit operator string(DataMaskingState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataMaskingState other && Equals(other);
        public bool Equals(DataMaskingState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type
    /// </summary>
    [EnumType]
    public readonly struct DatabaseIdentityType : IEquatable<DatabaseIdentityType>
    {
        private readonly string _value;

        private DatabaseIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseIdentityType None { get; } = new DatabaseIdentityType("None");
        public static DatabaseIdentityType UserAssigned { get; } = new DatabaseIdentityType("UserAssigned");

        public static bool operator ==(DatabaseIdentityType left, DatabaseIdentityType right) => left.Equals(right);
        public static bool operator !=(DatabaseIdentityType left, DatabaseIdentityType right) => !left.Equals(right);

        public static explicit operator string(DatabaseIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseIdentityType other && Equals(other);
        public bool Equals(DatabaseIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to apply for this database. `LicenseIncluded` if you need a license, or `BasePrice` if you have a license and are eligible for the Azure Hybrid Benefit.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseLicenseType : IEquatable<DatabaseLicenseType>
    {
        private readonly string _value;

        private DatabaseLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseLicenseType LicenseIncluded { get; } = new DatabaseLicenseType("LicenseIncluded");
        public static DatabaseLicenseType BasePrice { get; } = new DatabaseLicenseType("BasePrice");

        public static bool operator ==(DatabaseLicenseType left, DatabaseLicenseType right) => left.Equals(right);
        public static bool operator !=(DatabaseLicenseType left, DatabaseLicenseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseLicenseType other && Equals(other);
        public bool Equals(DatabaseLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of read-only routing. If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale database within an elastic pool.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseReadScale : IEquatable<DatabaseReadScale>
    {
        private readonly string _value;

        private DatabaseReadScale(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseReadScale Enabled { get; } = new DatabaseReadScale("Enabled");
        public static DatabaseReadScale Disabled { get; } = new DatabaseReadScale("Disabled");

        public static bool operator ==(DatabaseReadScale left, DatabaseReadScale right) => left.Equals(right);
        public static bool operator !=(DatabaseReadScale left, DatabaseReadScale right) => !left.Equals(right);

        public static explicit operator string(DatabaseReadScale value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseReadScale other && Equals(other);
        public bool Equals(DatabaseReadScale other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Stop day.
    /// </summary>
    [EnumType]
    public readonly struct DayOfWeek : IEquatable<DayOfWeek>
    {
        private readonly string _value;

        private DayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DayOfWeek Sunday { get; } = new DayOfWeek("Sunday");
        public static DayOfWeek Monday { get; } = new DayOfWeek("Monday");
        public static DayOfWeek Tuesday { get; } = new DayOfWeek("Tuesday");
        public static DayOfWeek Wednesday { get; } = new DayOfWeek("Wednesday");
        public static DayOfWeek Thursday { get; } = new DayOfWeek("Thursday");
        public static DayOfWeek Friday { get; } = new DayOfWeek("Friday");
        public static DayOfWeek Saturday { get; } = new DayOfWeek("Saturday");

        public static bool operator ==(DayOfWeek left, DayOfWeek right) => left.Equals(right);
        public static bool operator !=(DayOfWeek left, DayOfWeek right) => !left.Equals(right);

        public static explicit operator string(DayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DayOfWeek other && Equals(other);
        public bool Equals(DayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to apply for this elastic pool.
    /// </summary>
    [EnumType]
    public readonly struct ElasticPoolLicenseType : IEquatable<ElasticPoolLicenseType>
    {
        private readonly string _value;

        private ElasticPoolLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ElasticPoolLicenseType LicenseIncluded { get; } = new ElasticPoolLicenseType("LicenseIncluded");
        public static ElasticPoolLicenseType BasePrice { get; } = new ElasticPoolLicenseType("BasePrice");

        public static bool operator ==(ElasticPoolLicenseType left, ElasticPoolLicenseType right) => left.Equals(right);
        public static bool operator !=(ElasticPoolLicenseType left, ElasticPoolLicenseType right) => !left.Equals(right);

        public static explicit operator string(ElasticPoolLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ElasticPoolLicenseType other && Equals(other);
        public bool Equals(ElasticPoolLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Databases secondary type on partner server.
    /// </summary>
    [EnumType]
    public readonly struct FailoverGroupDatabasesSecondaryType : IEquatable<FailoverGroupDatabasesSecondaryType>
    {
        private readonly string _value;

        private FailoverGroupDatabasesSecondaryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FailoverGroupDatabasesSecondaryType Geo { get; } = new FailoverGroupDatabasesSecondaryType("Geo");
        public static FailoverGroupDatabasesSecondaryType Standby { get; } = new FailoverGroupDatabasesSecondaryType("Standby");

        public static bool operator ==(FailoverGroupDatabasesSecondaryType left, FailoverGroupDatabasesSecondaryType right) => left.Equals(right);
        public static bool operator !=(FailoverGroupDatabasesSecondaryType left, FailoverGroupDatabasesSecondaryType right) => !left.Equals(right);

        public static explicit operator string(FailoverGroupDatabasesSecondaryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FailoverGroupDatabasesSecondaryType other && Equals(other);
        public bool Equals(FailoverGroupDatabasesSecondaryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The link failover mode - can be Manual if intended to be used for two-way failover with a supported SQL Server, or None for one-way failover to Azure.
    /// </summary>
    [EnumType]
    public readonly struct FailoverModeType : IEquatable<FailoverModeType>
    {
        private readonly string _value;

        private FailoverModeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FailoverModeType None { get; } = new FailoverModeType("None");
        public static FailoverModeType Manual { get; } = new FailoverModeType("Manual");

        public static bool operator ==(FailoverModeType left, FailoverModeType right) => left.Equals(right);
        public static bool operator !=(FailoverModeType left, FailoverModeType right) => !left.Equals(right);

        public static explicit operator string(FailoverModeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FailoverModeType other && Equals(other);
        public bool Equals(FailoverModeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the behavior when monthly free limits are exhausted for the free database.
    /// 
    /// AutoPause: The database will be auto paused upon exhaustion of free limits for remainder of the month.
    /// 
    /// BillForUsage: The database will continue to be online upon exhaustion of free limits and any overage will be billed.
    /// </summary>
    [EnumType]
    public readonly struct FreeLimitExhaustionBehavior : IEquatable<FreeLimitExhaustionBehavior>
    {
        private readonly string _value;

        private FreeLimitExhaustionBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FreeLimitExhaustionBehavior AutoPause { get; } = new FreeLimitExhaustionBehavior("AutoPause");
        public static FreeLimitExhaustionBehavior BillOverUsage { get; } = new FreeLimitExhaustionBehavior("BillOverUsage");

        public static bool operator ==(FreeLimitExhaustionBehavior left, FreeLimitExhaustionBehavior right) => left.Equals(right);
        public static bool operator !=(FreeLimitExhaustionBehavior left, FreeLimitExhaustionBehavior right) => !left.Equals(right);

        public static explicit operator string(FreeLimitExhaustionBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FreeLimitExhaustionBehavior other && Equals(other);
        public bool Equals(FreeLimitExhaustionBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Weather or not Managed Instance is freemium.
    /// </summary>
    [EnumType]
    public readonly struct FreemiumType : IEquatable<FreemiumType>
    {
        private readonly string _value;

        private FreemiumType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FreemiumType Regular { get; } = new FreemiumType("Regular");
        public static FreemiumType Freemium { get; } = new FreemiumType("Freemium");

        public static bool operator ==(FreemiumType left, FreemiumType right) => left.Equals(right);
        public static bool operator !=(FreemiumType left, FreemiumType right) => !left.Equals(right);

        public static explicit operator string(FreemiumType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FreemiumType other && Equals(other);
        public bool Equals(FreemiumType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of the geo backup policy.
    /// </summary>
    [EnumType]
    public readonly struct GeoBackupPolicyState : IEquatable<GeoBackupPolicyState>
    {
        private readonly string _value;

        private GeoBackupPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GeoBackupPolicyState Enabled { get; } = new GeoBackupPolicyState("Enabled");
        public static GeoBackupPolicyState Disabled { get; } = new GeoBackupPolicyState("Disabled");

        public static bool operator ==(GeoBackupPolicyState left, GeoBackupPolicyState right) => left.Equals(right);
        public static bool operator !=(GeoBackupPolicyState left, GeoBackupPolicyState right) => !left.Equals(right);

        public static explicit operator string(GeoBackupPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GeoBackupPolicyState other && Equals(other);
        public bool Equals(GeoBackupPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Hybrid secondary usage. Possible values are 'Active' (default value) and 'Passive' (customer uses the secondary as Passive DR).
    /// </summary>
    [EnumType]
    public readonly struct HybridSecondaryUsage : IEquatable<HybridSecondaryUsage>
    {
        private readonly string _value;

        private HybridSecondaryUsage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HybridSecondaryUsage Active { get; } = new HybridSecondaryUsage("Active");
        public static HybridSecondaryUsage Passive { get; } = new HybridSecondaryUsage("Passive");

        public static bool operator ==(HybridSecondaryUsage left, HybridSecondaryUsage right) => left.Equals(right);
        public static bool operator !=(HybridSecondaryUsage left, HybridSecondaryUsage right) => !left.Equals(right);

        public static explicit operator string(HybridSecondaryUsage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HybridSecondaryUsage other && Equals(other);
        public bool Equals(HybridSecondaryUsage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType None { get; } = new IdentityType("None");
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type. Possible values are 'LicenseIncluded' (price for SQL license is included) and 'BasePrice' (without SQL license price).
    /// </summary>
    [EnumType]
    public readonly struct InstancePoolLicenseType : IEquatable<InstancePoolLicenseType>
    {
        private readonly string _value;

        private InstancePoolLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePoolLicenseType LicenseIncluded { get; } = new InstancePoolLicenseType("LicenseIncluded");
        public static InstancePoolLicenseType BasePrice { get; } = new InstancePoolLicenseType("BasePrice");

        public static bool operator ==(InstancePoolLicenseType left, InstancePoolLicenseType right) => left.Equals(right);
        public static bool operator !=(InstancePoolLicenseType left, InstancePoolLicenseType right) => !left.Equals(right);

        public static explicit operator string(InstancePoolLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePoolLicenseType other && Equals(other);
        public bool Equals(InstancePoolLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The job agent identity type
    /// </summary>
    [EnumType]
    public readonly struct JobAgentIdentityType : IEquatable<JobAgentIdentityType>
    {
        private readonly string _value;

        private JobAgentIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobAgentIdentityType None { get; } = new JobAgentIdentityType("None");
        public static JobAgentIdentityType SystemAssigned { get; } = new JobAgentIdentityType("SystemAssigned");
        public static JobAgentIdentityType UserAssigned { get; } = new JobAgentIdentityType("UserAssigned");
        public static JobAgentIdentityType SystemAssignedUserAssigned { get; } = new JobAgentIdentityType("SystemAssignedUserAssigned");

        public static bool operator ==(JobAgentIdentityType left, JobAgentIdentityType right) => left.Equals(right);
        public static bool operator !=(JobAgentIdentityType left, JobAgentIdentityType right) => !left.Equals(right);

        public static explicit operator string(JobAgentIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobAgentIdentityType other && Equals(other);
        public bool Equals(JobAgentIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Schedule interval type
    /// </summary>
    [EnumType]
    public readonly struct JobScheduleType : IEquatable<JobScheduleType>
    {
        private readonly string _value;

        private JobScheduleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobScheduleType Once { get; } = new JobScheduleType("Once");
        public static JobScheduleType Recurring { get; } = new JobScheduleType("Recurring");

        public static bool operator ==(JobScheduleType left, JobScheduleType right) => left.Equals(right);
        public static bool operator !=(JobScheduleType left, JobScheduleType right) => !left.Equals(right);

        public static explicit operator string(JobScheduleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobScheduleType other && Equals(other);
        public bool Equals(JobScheduleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source of the action to execute.
    /// </summary>
    [EnumType]
    public readonly struct JobStepActionSource : IEquatable<JobStepActionSource>
    {
        private readonly string _value;

        private JobStepActionSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobStepActionSource Inline { get; } = new JobStepActionSource("Inline");

        public static bool operator ==(JobStepActionSource left, JobStepActionSource right) => left.Equals(right);
        public static bool operator !=(JobStepActionSource left, JobStepActionSource right) => !left.Equals(right);

        public static explicit operator string(JobStepActionSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobStepActionSource other && Equals(other);
        public bool Equals(JobStepActionSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of action being executed by the job step.
    /// </summary>
    [EnumType]
    public readonly struct JobStepActionType : IEquatable<JobStepActionType>
    {
        private readonly string _value;

        private JobStepActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobStepActionType TSql { get; } = new JobStepActionType("TSql");

        public static bool operator ==(JobStepActionType left, JobStepActionType right) => left.Equals(right);
        public static bool operator !=(JobStepActionType left, JobStepActionType right) => !left.Equals(right);

        public static explicit operator string(JobStepActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobStepActionType other && Equals(other);
        public bool Equals(JobStepActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The output destination type.
    /// </summary>
    [EnumType]
    public readonly struct JobStepOutputType : IEquatable<JobStepOutputType>
    {
        private readonly string _value;

        private JobStepOutputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobStepOutputType SqlDatabase { get; } = new JobStepOutputType("SqlDatabase");

        public static bool operator ==(JobStepOutputType left, JobStepOutputType right) => left.Equals(right);
        public static bool operator !=(JobStepOutputType left, JobStepOutputType right) => !left.Equals(right);

        public static explicit operator string(JobStepOutputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobStepOutputType other && Equals(other);
        public bool Equals(JobStepOutputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the target is included or excluded from the group.
    /// </summary>
    [EnumType]
    public readonly struct JobTargetGroupMembershipType : IEquatable<JobTargetGroupMembershipType>
    {
        private readonly string _value;

        private JobTargetGroupMembershipType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobTargetGroupMembershipType Include { get; } = new JobTargetGroupMembershipType("Include");
        public static JobTargetGroupMembershipType Exclude { get; } = new JobTargetGroupMembershipType("Exclude");

        public static bool operator ==(JobTargetGroupMembershipType left, JobTargetGroupMembershipType right) => left.Equals(right);
        public static bool operator !=(JobTargetGroupMembershipType left, JobTargetGroupMembershipType right) => !left.Equals(right);

        public static explicit operator string(JobTargetGroupMembershipType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobTargetGroupMembershipType other && Equals(other);
        public bool Equals(JobTargetGroupMembershipType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The target type.
    /// </summary>
    [EnumType]
    public readonly struct JobTargetType : IEquatable<JobTargetType>
    {
        private readonly string _value;

        private JobTargetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobTargetType TargetGroup { get; } = new JobTargetType("TargetGroup");
        public static JobTargetType SqlDatabase { get; } = new JobTargetType("SqlDatabase");
        public static JobTargetType SqlElasticPool { get; } = new JobTargetType("SqlElasticPool");
        public static JobTargetType SqlShardMap { get; } = new JobTargetType("SqlShardMap");
        public static JobTargetType SqlServer { get; } = new JobTargetType("SqlServer");

        public static bool operator ==(JobTargetType left, JobTargetType right) => left.Equals(right);
        public static bool operator !=(JobTargetType left, JobTargetType right) => !left.Equals(right);

        public static explicit operator string(JobTargetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobTargetType other && Equals(other);
        public bool Equals(JobTargetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Managed instance side link role
    /// </summary>
    [EnumType]
    public readonly struct LinkRole : IEquatable<LinkRole>
    {
        private readonly string _value;

        private LinkRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinkRole Primary { get; } = new LinkRole("Primary");
        public static LinkRole Secondary { get; } = new LinkRole("Secondary");

        public static bool operator ==(LinkRole left, LinkRole right) => left.Equals(right);
        public static bool operator !=(LinkRole left, LinkRole right) => !left.Equals(right);

        public static explicit operator string(LinkRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinkRole other && Equals(other);
        public bool Equals(LinkRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Managed database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. SourceDatabaseName, SourceManagedInstanceName and PointInTime must be specified. RestoreExternalBackup: Create a database by restoring from external backup files. Collation, StorageContainerUri and StorageContainerSasToken must be specified. Recovery: Creates a database by restoring a geo-replicated backup. RecoverableDatabaseId must be specified as the recoverable database resource ID to restore. RestoreLongTermRetentionBackup: Create a database by restoring from a long term retention backup (longTermRetentionBackupResourceId required).
    /// </summary>
    [EnumType]
    public readonly struct ManagedDatabaseCreateMode : IEquatable<ManagedDatabaseCreateMode>
    {
        private readonly string _value;

        private ManagedDatabaseCreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedDatabaseCreateMode Default { get; } = new ManagedDatabaseCreateMode("Default");
        public static ManagedDatabaseCreateMode RestoreExternalBackup { get; } = new ManagedDatabaseCreateMode("RestoreExternalBackup");
        public static ManagedDatabaseCreateMode PointInTimeRestore { get; } = new ManagedDatabaseCreateMode("PointInTimeRestore");
        public static ManagedDatabaseCreateMode Recovery { get; } = new ManagedDatabaseCreateMode("Recovery");
        public static ManagedDatabaseCreateMode RestoreLongTermRetentionBackup { get; } = new ManagedDatabaseCreateMode("RestoreLongTermRetentionBackup");

        public static bool operator ==(ManagedDatabaseCreateMode left, ManagedDatabaseCreateMode right) => left.Equals(right);
        public static bool operator !=(ManagedDatabaseCreateMode left, ManagedDatabaseCreateMode right) => !left.Equals(right);

        public static explicit operator string(ManagedDatabaseCreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedDatabaseCreateMode other && Equals(other);
        public bool Equals(ManagedDatabaseCreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the managed instance administrator.
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceAdministratorType : IEquatable<ManagedInstanceAdministratorType>
    {
        private readonly string _value;

        private ManagedInstanceAdministratorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceAdministratorType ActiveDirectory { get; } = new ManagedInstanceAdministratorType("ActiveDirectory");

        public static bool operator ==(ManagedInstanceAdministratorType left, ManagedInstanceAdministratorType right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceAdministratorType left, ManagedInstanceAdministratorType right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceAdministratorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceAdministratorType other && Equals(other);
        public bool Equals(ManagedInstanceAdministratorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the internal format of instance databases specific to the SQL engine version.
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceDatabaseFormat : IEquatable<ManagedInstanceDatabaseFormat>
    {
        private readonly string _value;

        private ManagedInstanceDatabaseFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceDatabaseFormat AlwaysUpToDate { get; } = new ManagedInstanceDatabaseFormat("AlwaysUpToDate");
        public static ManagedInstanceDatabaseFormat SQLServer2022 { get; } = new ManagedInstanceDatabaseFormat("SQLServer2022");

        public static bool operator ==(ManagedInstanceDatabaseFormat left, ManagedInstanceDatabaseFormat right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceDatabaseFormat left, ManagedInstanceDatabaseFormat right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceDatabaseFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceDatabaseFormat other && Equals(other);
        public bool Equals(ManagedInstanceDatabaseFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type. Possible values are 'LicenseIncluded' (regular price inclusive of a new SQL license) and 'BasePrice' (discounted AHB price for bringing your own SQL licenses).
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceLicenseType : IEquatable<ManagedInstanceLicenseType>
    {
        private readonly string _value;

        private ManagedInstanceLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceLicenseType LicenseIncluded { get; } = new ManagedInstanceLicenseType("LicenseIncluded");
        public static ManagedInstanceLicenseType BasePrice { get; } = new ManagedInstanceLicenseType("BasePrice");

        public static bool operator ==(ManagedInstanceLicenseType left, ManagedInstanceLicenseType right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceLicenseType left, ManagedInstanceLicenseType right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceLicenseType other && Equals(other);
        public bool Equals(ManagedInstanceLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Connection type used for connecting to the instance.
    /// </summary>
    [EnumType]
    public readonly struct ManagedInstanceProxyOverride : IEquatable<ManagedInstanceProxyOverride>
    {
        private readonly string _value;

        private ManagedInstanceProxyOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedInstanceProxyOverride Proxy { get; } = new ManagedInstanceProxyOverride("Proxy");
        public static ManagedInstanceProxyOverride Redirect { get; } = new ManagedInstanceProxyOverride("Redirect");
        public static ManagedInstanceProxyOverride Default { get; } = new ManagedInstanceProxyOverride("Default");

        public static bool operator ==(ManagedInstanceProxyOverride left, ManagedInstanceProxyOverride right) => left.Equals(right);
        public static bool operator !=(ManagedInstanceProxyOverride left, ManagedInstanceProxyOverride right) => !left.Equals(right);

        public static explicit operator string(ManagedInstanceProxyOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedInstanceProxyOverride other && Equals(other);
        public bool Equals(ManagedInstanceProxyOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of database creation.
    /// 
    /// Default: Regular instance creation.
    /// 
    /// Restore: Creates an instance by restoring a set of backups to specific point in time. RestorePointInTime and SourceManagedInstanceId must be specified.
    /// </summary>
    [EnumType]
    public readonly struct ManagedServerCreateMode : IEquatable<ManagedServerCreateMode>
    {
        private readonly string _value;

        private ManagedServerCreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServerCreateMode Default { get; } = new ManagedServerCreateMode("Default");
        public static ManagedServerCreateMode PointInTimeRestore { get; } = new ManagedServerCreateMode("PointInTimeRestore");

        public static bool operator ==(ManagedServerCreateMode left, ManagedServerCreateMode right) => left.Equals(right);
        public static bool operator !=(ManagedServerCreateMode left, ManagedServerCreateMode right) => !left.Equals(right);

        public static explicit operator string(ManagedServerCreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServerCreateMode other && Equals(other);
        public bool Equals(ManagedServerCreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Minimal TLS version. Allowed values: 'None', 1.0', '1.1', '1.2', '1.3'
    /// </summary>
    [EnumType]
    public readonly struct MinimalTlsVersion : IEquatable<MinimalTlsVersion>
    {
        private readonly string _value;

        private MinimalTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MinimalTlsVersion None { get; } = new MinimalTlsVersion("None");
        public static MinimalTlsVersion MinimalTlsVersion_1_0 { get; } = new MinimalTlsVersion("1.0");
        public static MinimalTlsVersion MinimalTlsVersion_1_1 { get; } = new MinimalTlsVersion("1.1");
        public static MinimalTlsVersion MinimalTlsVersion_1_2 { get; } = new MinimalTlsVersion("1.2");
        public static MinimalTlsVersion MinimalTlsVersion_1_3 { get; } = new MinimalTlsVersion("1.3");

        public static bool operator ==(MinimalTlsVersion left, MinimalTlsVersion right) => left.Equals(right);
        public static bool operator !=(MinimalTlsVersion left, MinimalTlsVersion right) => !left.Equals(right);

        public static explicit operator string(MinimalTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimalTlsVersion other && Equals(other);
        public bool Equals(MinimalTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Principal Type of the sever administrator.
    /// </summary>
    [EnumType]
    public readonly struct PrincipalType : IEquatable<PrincipalType>
    {
        private readonly string _value;

        private PrincipalType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrincipalType User { get; } = new PrincipalType("User");
        public static PrincipalType Group { get; } = new PrincipalType("Group");
        public static PrincipalType Application { get; } = new PrincipalType("Application");

        public static bool operator ==(PrincipalType left, PrincipalType right) => left.Equals(right);
        public static bool operator !=(PrincipalType left, PrincipalType right) => !left.Equals(right);

        public static explicit operator string(PrincipalType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrincipalType other && Equals(other);
        public bool Equals(PrincipalType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private link service connection status.
    /// </summary>
    [EnumType]
    public readonly struct PrivateLinkServiceConnectionStateStatus : IEquatable<PrivateLinkServiceConnectionStateStatus>
    {
        private readonly string _value;

        private PrivateLinkServiceConnectionStateStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateLinkServiceConnectionStateStatus Approved { get; } = new PrivateLinkServiceConnectionStateStatus("Approved");
        public static PrivateLinkServiceConnectionStateStatus Pending { get; } = new PrivateLinkServiceConnectionStateStatus("Pending");
        public static PrivateLinkServiceConnectionStateStatus Rejected { get; } = new PrivateLinkServiceConnectionStateStatus("Rejected");
        public static PrivateLinkServiceConnectionStateStatus Disconnected { get; } = new PrivateLinkServiceConnectionStateStatus("Disconnected");

        public static bool operator ==(PrivateLinkServiceConnectionStateStatus left, PrivateLinkServiceConnectionStateStatus right) => left.Equals(right);
        public static bool operator !=(PrivateLinkServiceConnectionStateStatus left, PrivateLinkServiceConnectionStateStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateLinkServiceConnectionStateStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateLinkServiceConnectionStateStatus other && Equals(other);
        public bool Equals(PrivateLinkServiceConnectionStateStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Failover policy of the read-only endpoint for the failover group.
    /// </summary>
    [EnumType]
    public readonly struct ReadOnlyEndpointFailoverPolicy : IEquatable<ReadOnlyEndpointFailoverPolicy>
    {
        private readonly string _value;

        private ReadOnlyEndpointFailoverPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReadOnlyEndpointFailoverPolicy Disabled { get; } = new ReadOnlyEndpointFailoverPolicy("Disabled");
        public static ReadOnlyEndpointFailoverPolicy Enabled { get; } = new ReadOnlyEndpointFailoverPolicy("Enabled");

        public static bool operator ==(ReadOnlyEndpointFailoverPolicy left, ReadOnlyEndpointFailoverPolicy right) => left.Equals(right);
        public static bool operator !=(ReadOnlyEndpointFailoverPolicy left, ReadOnlyEndpointFailoverPolicy right) => !left.Equals(right);

        public static explicit operator string(ReadOnlyEndpointFailoverPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReadOnlyEndpointFailoverPolicy other && Equals(other);
        public bool Equals(ReadOnlyEndpointFailoverPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Failover policy of the read-write endpoint for the failover group. If failoverPolicy is Automatic then failoverWithDataLossGracePeriodMinutes is required.
    /// </summary>
    [EnumType]
    public readonly struct ReadWriteEndpointFailoverPolicy : IEquatable<ReadWriteEndpointFailoverPolicy>
    {
        private readonly string _value;

        private ReadWriteEndpointFailoverPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReadWriteEndpointFailoverPolicy Manual { get; } = new ReadWriteEndpointFailoverPolicy("Manual");
        public static ReadWriteEndpointFailoverPolicy Automatic { get; } = new ReadWriteEndpointFailoverPolicy("Automatic");

        public static bool operator ==(ReadWriteEndpointFailoverPolicy left, ReadWriteEndpointFailoverPolicy right) => left.Equals(right);
        public static bool operator !=(ReadWriteEndpointFailoverPolicy left, ReadWriteEndpointFailoverPolicy right) => !left.Equals(right);

        public static explicit operator string(ReadWriteEndpointFailoverPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReadWriteEndpointFailoverPolicy other && Equals(other);
        public bool Equals(ReadWriteEndpointFailoverPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Link type (GEO, NAMED, STANDBY). Update operation does not support NAMED.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationLinkType : IEquatable<ReplicationLinkType>
    {
        private readonly string _value;

        private ReplicationLinkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationLinkType GEO { get; } = new ReplicationLinkType("GEO");
        public static ReplicationLinkType NAMED { get; } = new ReplicationLinkType("NAMED");
        public static ReplicationLinkType STANDBY { get; } = new ReplicationLinkType("STANDBY");

        public static bool operator ==(ReplicationLinkType left, ReplicationLinkType right) => left.Equals(right);
        public static bool operator !=(ReplicationLinkType left, ReplicationLinkType right) => !left.Equals(right);

        public static explicit operator string(ReplicationLinkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationLinkType other && Equals(other);
        public bool Equals(ReplicationLinkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Replication mode of the link
    /// </summary>
    [EnumType]
    public readonly struct ReplicationModeType : IEquatable<ReplicationModeType>
    {
        private readonly string _value;

        private ReplicationModeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationModeType Async { get; } = new ReplicationModeType("Async");
        public static ReplicationModeType Sync { get; } = new ReplicationModeType("Sync");

        public static bool operator ==(ReplicationModeType left, ReplicationModeType right) => left.Equals(right);
        public static bool operator !=(ReplicationModeType left, ReplicationModeType right) => !left.Equals(right);

        public static explicit operator string(ReplicationModeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationModeType other && Equals(other);
        public bool Equals(ReplicationModeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the sample schema to apply when creating this database.
    /// </summary>
    [EnumType]
    public readonly struct SampleName : IEquatable<SampleName>
    {
        private readonly string _value;

        private SampleName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SampleName AdventureWorksLT { get; } = new SampleName("AdventureWorksLT");
        public static SampleName WideWorldImportersStd { get; } = new SampleName("WideWorldImportersStd");
        public static SampleName WideWorldImportersFull { get; } = new SampleName("WideWorldImportersFull");

        public static bool operator ==(SampleName left, SampleName right) => left.Equals(right);
        public static bool operator !=(SampleName left, SampleName right) => !left.Equals(right);

        public static explicit operator string(SampleName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SampleName other && Equals(other);
        public bool Equals(SampleName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the geo-secondary instance. Set 'Standby' if the instance is used as a DR option only.
    /// </summary>
    [EnumType]
    public readonly struct SecondaryInstanceType : IEquatable<SecondaryInstanceType>
    {
        private readonly string _value;

        private SecondaryInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecondaryInstanceType Geo { get; } = new SecondaryInstanceType("Geo");
        public static SecondaryInstanceType Standby { get; } = new SecondaryInstanceType("Standby");

        public static bool operator ==(SecondaryInstanceType left, SecondaryInstanceType right) => left.Equals(right);
        public static bool operator !=(SecondaryInstanceType left, SecondaryInstanceType right) => !left.Equals(right);

        public static explicit operator string(SecondaryInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecondaryInstanceType other && Equals(other);
        public bool Equals(SecondaryInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The secondary type of the database if it is a secondary.  Valid values are Geo, Named and Standby.
    /// </summary>
    [EnumType]
    public readonly struct SecondaryType : IEquatable<SecondaryType>
    {
        private readonly string _value;

        private SecondaryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecondaryType Geo { get; } = new SecondaryType("Geo");
        public static SecondaryType Named { get; } = new SecondaryType("Named");
        public static SecondaryType Standby { get; } = new SecondaryType("Standby");

        public static bool operator ==(SecondaryType left, SecondaryType right) => left.Equals(right);
        public static bool operator !=(SecondaryType left, SecondaryType right) => !left.Equals(right);

        public static explicit operator string(SecondaryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecondaryType other && Equals(other);
        public bool Equals(SecondaryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the state of the policy, whether it is enabled or disabled or a policy has not been applied yet on the specific database.
    /// </summary>
    [EnumType]
    public readonly struct SecurityAlertsPolicyState : IEquatable<SecurityAlertsPolicyState>
    {
        private readonly string _value;

        private SecurityAlertsPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityAlertsPolicyState Enabled { get; } = new SecurityAlertsPolicyState("Enabled");
        public static SecurityAlertsPolicyState Disabled { get; } = new SecurityAlertsPolicyState("Disabled");

        public static bool operator ==(SecurityAlertsPolicyState left, SecurityAlertsPolicyState right) => left.Equals(right);
        public static bool operator !=(SecurityAlertsPolicyState left, SecurityAlertsPolicyState right) => !left.Equals(right);

        public static explicit operator string(SecurityAlertsPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityAlertsPolicyState other && Equals(other);
        public bool Equals(SecurityAlertsPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Database seeding mode  can be Automatic (default), or Manual for supported scenarios.
    /// </summary>
    [EnumType]
    public readonly struct SeedingModeType : IEquatable<SeedingModeType>
    {
        private readonly string _value;

        private SeedingModeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SeedingModeType Automatic { get; } = new SeedingModeType("Automatic");
        public static SeedingModeType Manual { get; } = new SeedingModeType("Manual");

        public static bool operator ==(SeedingModeType left, SeedingModeType right) => left.Equals(right);
        public static bool operator !=(SeedingModeType left, SeedingModeType right) => !left.Equals(right);

        public static explicit operator string(SeedingModeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SeedingModeType other && Equals(other);
        public bool Equals(SeedingModeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SensitivityLabelRank : IEquatable<SensitivityLabelRank>
    {
        private readonly string _value;

        private SensitivityLabelRank(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SensitivityLabelRank None { get; } = new SensitivityLabelRank("None");
        public static SensitivityLabelRank Low { get; } = new SensitivityLabelRank("Low");
        public static SensitivityLabelRank Medium { get; } = new SensitivityLabelRank("Medium");
        public static SensitivityLabelRank High { get; } = new SensitivityLabelRank("High");
        public static SensitivityLabelRank Critical { get; } = new SensitivityLabelRank("Critical");

        public static bool operator ==(SensitivityLabelRank left, SensitivityLabelRank right) => left.Equals(right);
        public static bool operator !=(SensitivityLabelRank left, SensitivityLabelRank right) => !left.Equals(right);

        public static explicit operator string(SensitivityLabelRank value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SensitivityLabelRank other && Equals(other);
        public bool Equals(SensitivityLabelRank other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The server key type like 'ServiceManaged', 'AzureKeyVault'.
    /// </summary>
    [EnumType]
    public readonly struct ServerKeyType : IEquatable<ServerKeyType>
    {
        private readonly string _value;

        private ServerKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerKeyType ServiceManaged { get; } = new ServerKeyType("ServiceManaged");
        public static ServerKeyType AzureKeyVault { get; } = new ServerKeyType("AzureKeyVault");

        public static bool operator ==(ServerKeyType left, ServerKeyType right) => left.Equals(right);
        public static bool operator !=(ServerKeyType left, ServerKeyType right) => !left.Equals(right);

        public static explicit operator string(ServerKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerKeyType other && Equals(other);
        public bool Equals(ServerKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not to restrict outbound network access for this server.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct ServerNetworkAccessFlag : IEquatable<ServerNetworkAccessFlag>
    {
        private readonly string _value;

        private ServerNetworkAccessFlag(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerNetworkAccessFlag Enabled { get; } = new ServerNetworkAccessFlag("Enabled");
        public static ServerNetworkAccessFlag Disabled { get; } = new ServerNetworkAccessFlag("Disabled");

        public static bool operator ==(ServerNetworkAccessFlag left, ServerNetworkAccessFlag right) => left.Equals(right);
        public static bool operator !=(ServerNetworkAccessFlag left, ServerNetworkAccessFlag right) => !left.Equals(right);

        public static explicit operator string(ServerNetworkAccessFlag value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerNetworkAccessFlag other && Equals(other);
        public bool Equals(ServerNetworkAccessFlag other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not public endpoint access is allowed for this server.  Value is optional but if passed in, must be 'Enabled' or 'Disabled' or 'SecuredByPerimeter'
    /// </summary>
    [EnumType]
    public readonly struct ServerPublicNetworkAccessFlag : IEquatable<ServerPublicNetworkAccessFlag>
    {
        private readonly string _value;

        private ServerPublicNetworkAccessFlag(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerPublicNetworkAccessFlag Enabled { get; } = new ServerPublicNetworkAccessFlag("Enabled");
        public static ServerPublicNetworkAccessFlag Disabled { get; } = new ServerPublicNetworkAccessFlag("Disabled");
        public static ServerPublicNetworkAccessFlag SecuredByPerimeter { get; } = new ServerPublicNetworkAccessFlag("SecuredByPerimeter");

        public static bool operator ==(ServerPublicNetworkAccessFlag left, ServerPublicNetworkAccessFlag right) => left.Equals(right);
        public static bool operator !=(ServerPublicNetworkAccessFlag left, ServerPublicNetworkAccessFlag right) => !left.Equals(right);

        public static explicit operator string(ServerPublicNetworkAccessFlag value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerPublicNetworkAccessFlag other && Equals(other);
        public bool Equals(ServerPublicNetworkAccessFlag other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Service principal type.
    /// </summary>
    [EnumType]
    public readonly struct ServicePrincipalType : IEquatable<ServicePrincipalType>
    {
        private readonly string _value;

        private ServicePrincipalType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServicePrincipalType None { get; } = new ServicePrincipalType("None");
        public static ServicePrincipalType SystemAssigned { get; } = new ServicePrincipalType("SystemAssigned");

        public static bool operator ==(ServicePrincipalType left, ServicePrincipalType right) => left.Equals(right);
        public static bool operator !=(ServicePrincipalType left, ServicePrincipalType right) => !left.Equals(right);

        public static explicit operator string(ServicePrincipalType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServicePrincipalType other && Equals(other);
        public bool Equals(ServicePrincipalType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the state of the SQL Vulnerability Assessment, whether it is enabled or disabled or a state has not been applied yet on the specific database or server.
    /// </summary>
    [EnumType]
    public readonly struct SqlVulnerabilityAssessmentState : IEquatable<SqlVulnerabilityAssessmentState>
    {
        private readonly string _value;

        private SqlVulnerabilityAssessmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SqlVulnerabilityAssessmentState Enabled { get; } = new SqlVulnerabilityAssessmentState("Enabled");
        public static SqlVulnerabilityAssessmentState Disabled { get; } = new SqlVulnerabilityAssessmentState("Disabled");

        public static bool operator ==(SqlVulnerabilityAssessmentState left, SqlVulnerabilityAssessmentState right) => left.Equals(right);
        public static bool operator !=(SqlVulnerabilityAssessmentState left, SqlVulnerabilityAssessmentState right) => !left.Equals(right);

        public static explicit operator string(SqlVulnerabilityAssessmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SqlVulnerabilityAssessmentState other && Equals(other);
        public bool Equals(SqlVulnerabilityAssessmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Conflict resolution policy of the sync group.
    /// </summary>
    [EnumType]
    public readonly struct SyncConflictResolutionPolicy : IEquatable<SyncConflictResolutionPolicy>
    {
        private readonly string _value;

        private SyncConflictResolutionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SyncConflictResolutionPolicy HubWin { get; } = new SyncConflictResolutionPolicy("HubWin");
        public static SyncConflictResolutionPolicy MemberWin { get; } = new SyncConflictResolutionPolicy("MemberWin");

        public static bool operator ==(SyncConflictResolutionPolicy left, SyncConflictResolutionPolicy right) => left.Equals(right);
        public static bool operator !=(SyncConflictResolutionPolicy left, SyncConflictResolutionPolicy right) => !left.Equals(right);

        public static explicit operator string(SyncConflictResolutionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SyncConflictResolutionPolicy other && Equals(other);
        public bool Equals(SyncConflictResolutionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sync direction of the sync member.
    /// </summary>
    [EnumType]
    public readonly struct SyncDirection : IEquatable<SyncDirection>
    {
        private readonly string _value;

        private SyncDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SyncDirection Bidirectional { get; } = new SyncDirection("Bidirectional");
        public static SyncDirection OneWayMemberToHub { get; } = new SyncDirection("OneWayMemberToHub");
        public static SyncDirection OneWayHubToMember { get; } = new SyncDirection("OneWayHubToMember");

        public static bool operator ==(SyncDirection left, SyncDirection right) => left.Equals(right);
        public static bool operator !=(SyncDirection left, SyncDirection right) => !left.Equals(right);

        public static explicit operator string(SyncDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SyncDirection other && Equals(other);
        public bool Equals(SyncDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Database type of the sync member.
    /// </summary>
    [EnumType]
    public readonly struct SyncMemberDbType : IEquatable<SyncMemberDbType>
    {
        private readonly string _value;

        private SyncMemberDbType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SyncMemberDbType AzureSqlDatabase { get; } = new SyncMemberDbType("AzureSqlDatabase");
        public static SyncMemberDbType SqlServerDatabase { get; } = new SyncMemberDbType("SqlServerDatabase");

        public static bool operator ==(SyncMemberDbType left, SyncMemberDbType right) => left.Equals(right);
        public static bool operator !=(SyncMemberDbType left, SyncMemberDbType right) => !left.Equals(right);

        public static explicit operator string(SyncMemberDbType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SyncMemberDbType other && Equals(other);
        public bool Equals(SyncMemberDbType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the state of the transparent data encryption.
    /// </summary>
    [EnumType]
    public readonly struct TransparentDataEncryptionState : IEquatable<TransparentDataEncryptionState>
    {
        private readonly string _value;

        private TransparentDataEncryptionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TransparentDataEncryptionState Enabled { get; } = new TransparentDataEncryptionState("Enabled");
        public static TransparentDataEncryptionState Disabled { get; } = new TransparentDataEncryptionState("Disabled");

        public static bool operator ==(TransparentDataEncryptionState left, TransparentDataEncryptionState right) => left.Equals(right);
        public static bool operator !=(TransparentDataEncryptionState left, TransparentDataEncryptionState right) => !left.Equals(right);

        public static explicit operator string(TransparentDataEncryptionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransparentDataEncryptionState other && Equals(other);
        public bool Equals(TransparentDataEncryptionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
