// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.Sql.V20171001Preview
{
    /// <summary>
    /// Collation of the metadata catalog.
    /// </summary>
    [EnumType]
    public readonly struct CatalogCollationType : IEquatable<CatalogCollationType>
    {
        private readonly string _value;

        private CatalogCollationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CatalogCollationType DATABASE_DEFAULT { get; } = new CatalogCollationType("DATABASE_DEFAULT");
        public static CatalogCollationType SQL_Latin1_General_CP1_CI_AS { get; } = new CatalogCollationType("SQL_Latin1_General_CP1_CI_AS");

        public static bool operator ==(CatalogCollationType left, CatalogCollationType right) => left.Equals(right);
        public static bool operator !=(CatalogCollationType left, CatalogCollationType right) => !left.Equals(right);

        public static explicit operator string(CatalogCollationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CatalogCollationType other && Equals(other);
        public bool Equals(CatalogCollationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of database creation.
    /// 
    /// Default: regular database creation.
    /// 
    /// Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.
    /// 
    /// Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.
    /// 
    /// PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
    /// 
    /// Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.
    /// 
    /// Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.
    /// 
    /// RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
    /// 
    /// Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
    /// </summary>
    [EnumType]
    public readonly struct CreateMode : IEquatable<CreateMode>
    {
        private readonly string _value;

        private CreateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreateMode Default { get; } = new CreateMode("Default");
        public static CreateMode Copy { get; } = new CreateMode("Copy");
        public static CreateMode Secondary { get; } = new CreateMode("Secondary");
        public static CreateMode PointInTimeRestore { get; } = new CreateMode("PointInTimeRestore");
        public static CreateMode Restore { get; } = new CreateMode("Restore");
        public static CreateMode Recovery { get; } = new CreateMode("Recovery");
        public static CreateMode RestoreExternalBackup { get; } = new CreateMode("RestoreExternalBackup");
        public static CreateMode RestoreExternalBackupSecondary { get; } = new CreateMode("RestoreExternalBackupSecondary");
        public static CreateMode RestoreLongTermRetentionBackup { get; } = new CreateMode("RestoreLongTermRetentionBackup");
        public static CreateMode OnlineSecondary { get; } = new CreateMode("OnlineSecondary");

        public static bool operator ==(CreateMode left, CreateMode right) => left.Equals(right);
        public static bool operator !=(CreateMode left, CreateMode right) => !left.Equals(right);

        public static explicit operator string(CreateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreateMode other && Equals(other);
        public bool Equals(CreateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to apply for this database. `LicenseIncluded` if you need a license, or `BasePrice` if you have a license and are eligible for the Azure Hybrid Benefit.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseLicenseType : IEquatable<DatabaseLicenseType>
    {
        private readonly string _value;

        private DatabaseLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseLicenseType LicenseIncluded { get; } = new DatabaseLicenseType("LicenseIncluded");
        public static DatabaseLicenseType BasePrice { get; } = new DatabaseLicenseType("BasePrice");

        public static bool operator ==(DatabaseLicenseType left, DatabaseLicenseType right) => left.Equals(right);
        public static bool operator !=(DatabaseLicenseType left, DatabaseLicenseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseLicenseType other && Equals(other);
        public bool Equals(DatabaseLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica. This property is only settable for Premium and Business Critical databases.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseReadScale : IEquatable<DatabaseReadScale>
    {
        private readonly string _value;

        private DatabaseReadScale(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseReadScale Enabled { get; } = new DatabaseReadScale("Enabled");
        public static DatabaseReadScale Disabled { get; } = new DatabaseReadScale("Disabled");

        public static bool operator ==(DatabaseReadScale left, DatabaseReadScale right) => left.Equals(right);
        public static bool operator !=(DatabaseReadScale left, DatabaseReadScale right) => !left.Equals(right);

        public static explicit operator string(DatabaseReadScale value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseReadScale other && Equals(other);
        public bool Equals(DatabaseReadScale other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to apply for this elastic pool.
    /// </summary>
    [EnumType]
    public readonly struct ElasticPoolLicenseType : IEquatable<ElasticPoolLicenseType>
    {
        private readonly string _value;

        private ElasticPoolLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ElasticPoolLicenseType LicenseIncluded { get; } = new ElasticPoolLicenseType("LicenseIncluded");
        public static ElasticPoolLicenseType BasePrice { get; } = new ElasticPoolLicenseType("BasePrice");

        public static bool operator ==(ElasticPoolLicenseType left, ElasticPoolLicenseType right) => left.Equals(right);
        public static bool operator !=(ElasticPoolLicenseType left, ElasticPoolLicenseType right) => !left.Equals(right);

        public static explicit operator string(ElasticPoolLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ElasticPoolLicenseType other && Equals(other);
        public bool Equals(ElasticPoolLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Failover policy of the read-only endpoint for the failover group.
    /// </summary>
    [EnumType]
    public readonly struct ReadOnlyEndpointFailoverPolicy : IEquatable<ReadOnlyEndpointFailoverPolicy>
    {
        private readonly string _value;

        private ReadOnlyEndpointFailoverPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReadOnlyEndpointFailoverPolicy Disabled { get; } = new ReadOnlyEndpointFailoverPolicy("Disabled");
        public static ReadOnlyEndpointFailoverPolicy Enabled { get; } = new ReadOnlyEndpointFailoverPolicy("Enabled");

        public static bool operator ==(ReadOnlyEndpointFailoverPolicy left, ReadOnlyEndpointFailoverPolicy right) => left.Equals(right);
        public static bool operator !=(ReadOnlyEndpointFailoverPolicy left, ReadOnlyEndpointFailoverPolicy right) => !left.Equals(right);

        public static explicit operator string(ReadOnlyEndpointFailoverPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReadOnlyEndpointFailoverPolicy other && Equals(other);
        public bool Equals(ReadOnlyEndpointFailoverPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Failover policy of the read-write endpoint for the failover group. If failoverPolicy is Automatic then failoverWithDataLossGracePeriodMinutes is required.
    /// </summary>
    [EnumType]
    public readonly struct ReadWriteEndpointFailoverPolicy : IEquatable<ReadWriteEndpointFailoverPolicy>
    {
        private readonly string _value;

        private ReadWriteEndpointFailoverPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReadWriteEndpointFailoverPolicy Manual { get; } = new ReadWriteEndpointFailoverPolicy("Manual");
        public static ReadWriteEndpointFailoverPolicy Automatic { get; } = new ReadWriteEndpointFailoverPolicy("Automatic");

        public static bool operator ==(ReadWriteEndpointFailoverPolicy left, ReadWriteEndpointFailoverPolicy right) => left.Equals(right);
        public static bool operator !=(ReadWriteEndpointFailoverPolicy left, ReadWriteEndpointFailoverPolicy right) => !left.Equals(right);

        public static explicit operator string(ReadWriteEndpointFailoverPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReadWriteEndpointFailoverPolicy other && Equals(other);
        public bool Equals(ReadWriteEndpointFailoverPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the sample schema to apply when creating this database.
    /// </summary>
    [EnumType]
    public readonly struct SampleName : IEquatable<SampleName>
    {
        private readonly string _value;

        private SampleName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SampleName AdventureWorksLT { get; } = new SampleName("AdventureWorksLT");
        public static SampleName WideWorldImportersStd { get; } = new SampleName("WideWorldImportersStd");
        public static SampleName WideWorldImportersFull { get; } = new SampleName("WideWorldImportersFull");

        public static bool operator ==(SampleName left, SampleName right) => left.Equals(right);
        public static bool operator !=(SampleName left, SampleName right) => !left.Equals(right);

        public static explicit operator string(SampleName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SampleName other && Equals(other);
        public bool Equals(SampleName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The key type like 'ServiceManaged', 'AzureKeyVault'.
    /// </summary>
    [EnumType]
    public readonly struct ServerKeyType : IEquatable<ServerKeyType>
    {
        private readonly string _value;

        private ServerKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerKeyType ServiceManaged { get; } = new ServerKeyType("ServiceManaged");
        public static ServerKeyType AzureKeyVault { get; } = new ServerKeyType("AzureKeyVault");

        public static bool operator ==(ServerKeyType left, ServerKeyType right) => left.Equals(right);
        public static bool operator !=(ServerKeyType left, ServerKeyType right) => !left.Equals(right);

        public static explicit operator string(ServerKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerKeyType other && Equals(other);
        public bool Equals(ServerKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
