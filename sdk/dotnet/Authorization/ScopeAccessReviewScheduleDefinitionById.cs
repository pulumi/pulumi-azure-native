// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.Authorization
{
    /// <summary>
    /// Access Review Schedule Definition.
    /// 
    /// Uses Azure REST API version 2021-12-01-preview. In version 2.x of the Azure Native provider, it used API version 2021-12-01-preview.
    /// </summary>
    [AzureNativeResourceType("azure-native:authorization:ScopeAccessReviewScheduleDefinitionById")]
    public partial class ScopeAccessReviewScheduleDefinitionById : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Flag to indicate whether auto-apply capability, to automatically change the target object access resource, is enabled. If not enabled, a user must, after the review completes, apply the access review.
        /// </summary>
        [Output("autoApplyDecisionsEnabled")]
        public Output<bool?> AutoApplyDecisionsEnabled { get; private set; } = null!;

        /// <summary>
        /// The Azure API version of the resource.
        /// </summary>
        [Output("azureApiVersion")]
        public Output<string> AzureApiVersion { get; private set; } = null!;

        /// <summary>
        /// This is the collection of backup reviewers.
        /// </summary>
        [Output("backupReviewers")]
        public Output<ImmutableArray<Outputs.AccessReviewReviewerResponse>> BackupReviewers { get; private set; } = null!;

        /// <summary>
        /// This specifies the behavior for the autoReview feature when an access review completes.
        /// </summary>
        [Output("defaultDecision")]
        public Output<string?> DefaultDecision { get; private set; } = null!;

        /// <summary>
        /// Flag to indicate whether reviewers are required to provide a justification when reviewing access.
        /// </summary>
        [Output("defaultDecisionEnabled")]
        public Output<bool?> DefaultDecisionEnabled { get; private set; } = null!;

        /// <summary>
        /// The description provided by the access review creator and visible to admins.
        /// </summary>
        [Output("descriptionForAdmins")]
        public Output<string?> DescriptionForAdmins { get; private set; } = null!;

        /// <summary>
        /// The description provided by the access review creator to be shown to reviewers.
        /// </summary>
        [Output("descriptionForReviewers")]
        public Output<string?> DescriptionForReviewers { get; private set; } = null!;

        /// <summary>
        /// The display name for the schedule definition.
        /// </summary>
        [Output("displayName")]
        public Output<string?> DisplayName { get; private set; } = null!;

        /// <summary>
        /// The duration in days for an instance.
        /// </summary>
        [Output("instanceDurationInDays")]
        public Output<int?> InstanceDurationInDays { get; private set; } = null!;

        /// <summary>
        /// This is the collection of instances returned when one does an expand on it.
        /// </summary>
        [Output("instances")]
        public Output<ImmutableArray<Outputs.AccessReviewInstanceResponse>> Instances { get; private set; } = null!;

        /// <summary>
        /// The interval for recurrence. For a quarterly review, the interval is 3 for type : absoluteMonthly.
        /// </summary>
        [Output("interval")]
        public Output<int?> Interval { get; private set; } = null!;

        /// <summary>
        /// Flag to indicate whether the reviewer is required to pass justification when recording a decision.
        /// </summary>
        [Output("justificationRequiredOnApproval")]
        public Output<bool?> JustificationRequiredOnApproval { get; private set; } = null!;

        /// <summary>
        /// Flag to indicate whether sending mails to reviewers and the review creator is enabled.
        /// </summary>
        [Output("mailNotificationsEnabled")]
        public Output<bool?> MailNotificationsEnabled { get; private set; } = null!;

        /// <summary>
        /// The access review schedule definition unique id.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The identity id
        /// </summary>
        [Output("principalId")]
        public Output<string> PrincipalId { get; private set; } = null!;

        /// <summary>
        /// The identity display name
        /// </summary>
        [Output("principalName")]
        public Output<string> PrincipalName { get; private set; } = null!;

        /// <summary>
        /// The identity type : user/servicePrincipal
        /// </summary>
        [Output("principalType")]
        public Output<string> PrincipalType { get; private set; } = null!;

        /// <summary>
        /// Access Review schedule definition recurrence range.
        /// </summary>
        [Output("range")]
        public Output<Outputs.AccessReviewRecurrenceRangeResponse?> Range { get; private set; } = null!;

        /// <summary>
        /// Recommendations for access reviews are calculated by looking back at 30 days of data(w.r.t the start date of the review) by default. However, in some scenarios, customers want to change how far back to look at and want to configure 60 days, 90 days, etc. instead. This setting allows customers to configure this duration. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        /// </summary>
        [Output("recommendationLookBackDuration")]
        public Output<string?> RecommendationLookBackDuration { get; private set; } = null!;

        /// <summary>
        /// Flag to indicate whether showing recommendations to reviewers is enabled.
        /// </summary>
        [Output("recommendationsEnabled")]
        public Output<bool?> RecommendationsEnabled { get; private set; } = null!;

        /// <summary>
        /// Flag to indicate whether sending reminder emails to reviewers are enabled.
        /// </summary>
        [Output("reminderNotificationsEnabled")]
        public Output<bool?> ReminderNotificationsEnabled { get; private set; } = null!;

        /// <summary>
        /// This is the collection of reviewers.
        /// </summary>
        [Output("reviewers")]
        public Output<ImmutableArray<Outputs.AccessReviewReviewerResponse>> Reviewers { get; private set; } = null!;

        /// <summary>
        /// This field specifies the type of reviewers for a review. Usually for a review, reviewers are explicitly assigned. However, in some cases, the reviewers may not be assigned and instead be chosen dynamically. For example managers review or self review.
        /// </summary>
        [Output("reviewersType")]
        public Output<string> ReviewersType { get; private set; } = null!;

        /// <summary>
        /// This is used to define what to include in scope of the review. The scope definition includes the resourceId and roleDefinitionId.
        /// </summary>
        [Output("scope")]
        public Output<Outputs.AccessReviewScopeResponse> Scope { get; private set; } = null!;

        /// <summary>
        /// This read-only field specifies the status of an accessReview.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// The resource type.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// The user principal name(if valid)
        /// </summary>
        [Output("userPrincipalName")]
        public Output<string> UserPrincipalName { get; private set; } = null!;


        /// <summary>
        /// Create a ScopeAccessReviewScheduleDefinitionById resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ScopeAccessReviewScheduleDefinitionById(string name, ScopeAccessReviewScheduleDefinitionByIdArgs args, CustomResourceOptions? options = null)
            : base("azure-native:authorization:ScopeAccessReviewScheduleDefinitionById", name, args ?? new ScopeAccessReviewScheduleDefinitionByIdArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ScopeAccessReviewScheduleDefinitionById(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("azure-native:authorization:ScopeAccessReviewScheduleDefinitionById", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "azure-native:authorization/v20211201preview:ScopeAccessReviewScheduleDefinitionById" },
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ScopeAccessReviewScheduleDefinitionById resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ScopeAccessReviewScheduleDefinitionById Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new ScopeAccessReviewScheduleDefinitionById(name, id, options);
        }
    }

    public sealed class ScopeAccessReviewScheduleDefinitionByIdArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Flag to indicate whether auto-apply capability, to automatically change the target object access resource, is enabled. If not enabled, a user must, after the review completes, apply the access review.
        /// </summary>
        [Input("autoApplyDecisionsEnabled")]
        public Input<bool>? AutoApplyDecisionsEnabled { get; set; }

        [Input("backupReviewers")]
        private InputList<Inputs.AccessReviewReviewerArgs>? _backupReviewers;

        /// <summary>
        /// This is the collection of backup reviewers.
        /// </summary>
        public InputList<Inputs.AccessReviewReviewerArgs> BackupReviewers
        {
            get => _backupReviewers ?? (_backupReviewers = new InputList<Inputs.AccessReviewReviewerArgs>());
            set => _backupReviewers = value;
        }

        /// <summary>
        /// This specifies the behavior for the autoReview feature when an access review completes.
        /// </summary>
        [Input("defaultDecision")]
        public InputUnion<string, Pulumi.AzureNative.Authorization.DefaultDecisionType>? DefaultDecision { get; set; }

        /// <summary>
        /// Flag to indicate whether reviewers are required to provide a justification when reviewing access.
        /// </summary>
        [Input("defaultDecisionEnabled")]
        public Input<bool>? DefaultDecisionEnabled { get; set; }

        /// <summary>
        /// The description provided by the access review creator and visible to admins.
        /// </summary>
        [Input("descriptionForAdmins")]
        public Input<string>? DescriptionForAdmins { get; set; }

        /// <summary>
        /// The description provided by the access review creator to be shown to reviewers.
        /// </summary>
        [Input("descriptionForReviewers")]
        public Input<string>? DescriptionForReviewers { get; set; }

        /// <summary>
        /// The display name for the schedule definition.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// This is used to indicate the resource id(s) to exclude
        /// </summary>
        [Input("excludeResourceId")]
        public Input<string>? ExcludeResourceId { get; set; }

        /// <summary>
        /// This is used to indicate the role definition id(s) to exclude
        /// </summary>
        [Input("excludeRoleDefinitionId")]
        public Input<string>? ExcludeRoleDefinitionId { get; set; }

        /// <summary>
        /// Flag to indicate whether to expand nested memberships or not.
        /// </summary>
        [Input("expandNestedMemberships")]
        public Input<bool>? ExpandNestedMemberships { get; set; }

        /// <summary>
        /// Duration users are inactive for. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        /// </summary>
        [Input("inactiveDuration")]
        public Input<string>? InactiveDuration { get; set; }

        /// <summary>
        /// Flag to indicate whether to expand nested memberships or not.
        /// </summary>
        [Input("includeAccessBelowResource")]
        public Input<bool>? IncludeAccessBelowResource { get; set; }

        /// <summary>
        /// Flag to indicate whether to expand nested memberships or not.
        /// </summary>
        [Input("includeInheritedAccess")]
        public Input<bool>? IncludeInheritedAccess { get; set; }

        /// <summary>
        /// The duration in days for an instance.
        /// </summary>
        [Input("instanceDurationInDays")]
        public Input<int>? InstanceDurationInDays { get; set; }

        [Input("instances")]
        private InputList<Inputs.AccessReviewInstanceArgs>? _instances;

        /// <summary>
        /// This is the collection of instances returned when one does an expand on it.
        /// </summary>
        public InputList<Inputs.AccessReviewInstanceArgs> Instances
        {
            get => _instances ?? (_instances = new InputList<Inputs.AccessReviewInstanceArgs>());
            set => _instances = value;
        }

        /// <summary>
        /// The interval for recurrence. For a quarterly review, the interval is 3 for type : absoluteMonthly.
        /// </summary>
        [Input("interval")]
        public Input<int>? Interval { get; set; }

        /// <summary>
        /// Flag to indicate whether the reviewer is required to pass justification when recording a decision.
        /// </summary>
        [Input("justificationRequiredOnApproval")]
        public Input<bool>? JustificationRequiredOnApproval { get; set; }

        /// <summary>
        /// Flag to indicate whether sending mails to reviewers and the review creator is enabled.
        /// </summary>
        [Input("mailNotificationsEnabled")]
        public Input<bool>? MailNotificationsEnabled { get; set; }

        /// <summary>
        /// Access Review schedule definition recurrence range.
        /// </summary>
        [Input("range")]
        public Input<Inputs.AccessReviewRecurrenceRangeArgs>? Range { get; set; }

        /// <summary>
        /// Recommendations for access reviews are calculated by looking back at 30 days of data(w.r.t the start date of the review) by default. However, in some scenarios, customers want to change how far back to look at and want to configure 60 days, 90 days, etc. instead. This setting allows customers to configure this duration. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        /// </summary>
        [Input("recommendationLookBackDuration")]
        public Input<string>? RecommendationLookBackDuration { get; set; }

        /// <summary>
        /// Flag to indicate whether showing recommendations to reviewers is enabled.
        /// </summary>
        [Input("recommendationsEnabled")]
        public Input<bool>? RecommendationsEnabled { get; set; }

        /// <summary>
        /// Flag to indicate whether sending reminder emails to reviewers are enabled.
        /// </summary>
        [Input("reminderNotificationsEnabled")]
        public Input<bool>? ReminderNotificationsEnabled { get; set; }

        [Input("reviewers")]
        private InputList<Inputs.AccessReviewReviewerArgs>? _reviewers;

        /// <summary>
        /// This is the collection of reviewers.
        /// </summary>
        public InputList<Inputs.AccessReviewReviewerArgs> Reviewers
        {
            get => _reviewers ?? (_reviewers = new InputList<Inputs.AccessReviewReviewerArgs>());
            set => _reviewers = value;
        }

        /// <summary>
        /// The id of the access review schedule definition.
        /// </summary>
        [Input("scheduleDefinitionId")]
        public Input<string>? ScheduleDefinitionId { get; set; }

        /// <summary>
        /// The scope of the resource.
        /// </summary>
        [Input("scope", required: true)]
        public Input<string> Scope { get; set; } = null!;

        /// <summary>
        /// The recurrence type : weekly, monthly, etc.
        /// </summary>
        [Input("type")]
        public InputUnion<string, Pulumi.AzureNative.Authorization.AccessReviewRecurrencePatternType>? Type { get; set; }

        public ScopeAccessReviewScheduleDefinitionByIdArgs()
        {
        }
        public static new ScopeAccessReviewScheduleDefinitionByIdArgs Empty => new ScopeAccessReviewScheduleDefinitionByIdArgs();
    }
}
