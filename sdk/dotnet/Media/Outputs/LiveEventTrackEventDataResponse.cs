// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.Media.Outputs
{

    /// <summary>
    /// The live event track ingest heart beat event data.
    /// </summary>
    [OutputType]
    public sealed class LiveEventTrackEventDataResponse
    {
        /// <summary>
        /// Bitrate of the track.
        /// </summary>
        public readonly double? Bitrate;
        /// <summary>
        /// Number of discontinuities detected in the last 20 seconds.
        /// </summary>
        public readonly double? DiscontinuityCount;
        /// <summary>
        /// Indicates whether ingest is healthy.
        /// </summary>
        public readonly bool? Healthy;
        /// <summary>
        /// Calculated bitrate based on data chunks coming from encoder.
        /// </summary>
        public readonly double? IncomingBitrate;
        /// <summary>
        /// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data - only data that is delayed in timestamps.
        /// </summary>
        public readonly string? IngestDriftValue;
        /// <summary>
        /// The last timestamp in UTC that a fragment arrived at the ingest endpoint.
        /// </summary>
        public readonly string? LastFragmentArrivalTime;
        /// <summary>
        /// Latest timestamp received for a track in last 20 seconds.
        /// </summary>
        public readonly string? LastTimestamp;
        /// <summary>
        /// Number of data chunks with timestamps in the past that were received in last 20 seconds.
        /// </summary>
        public readonly double? NonincreasingCount;
        /// <summary>
        /// Number of data chunks that had overlapped timestamps in last 20 seconds.
        /// </summary>
        public readonly double? OverlapCount;
        /// <summary>
        /// State of the live event.
        /// </summary>
        public readonly string? State;
        /// <summary>
        /// Timescale in which timestamps are expressed.
        /// </summary>
        public readonly string? Timescale;
        /// <summary>
        /// Name of the track.
        /// </summary>
        public readonly string? TrackName;
        /// <summary>
        /// Type of the track.
        /// </summary>
        public readonly string? TrackType;
        /// <summary>
        /// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.
        /// </summary>
        public readonly string? TranscriptionLanguage;
        /// <summary>
        /// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
        /// </summary>
        public readonly string? TranscriptionState;
        /// <summary>
        /// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
        /// </summary>
        public readonly bool? UnexpectedBitrate;

        [OutputConstructor]
        private LiveEventTrackEventDataResponse(
            double? bitrate,

            double? discontinuityCount,

            bool? healthy,

            double? incomingBitrate,

            string? ingestDriftValue,

            string? lastFragmentArrivalTime,

            string? lastTimestamp,

            double? nonincreasingCount,

            double? overlapCount,

            string? state,

            string? timescale,

            string? trackName,

            string? trackType,

            string? transcriptionLanguage,

            string? transcriptionState,

            bool? unexpectedBitrate)
        {
            Bitrate = bitrate;
            DiscontinuityCount = discontinuityCount;
            Healthy = healthy;
            IncomingBitrate = incomingBitrate;
            IngestDriftValue = ingestDriftValue;
            LastFragmentArrivalTime = lastFragmentArrivalTime;
            LastTimestamp = lastTimestamp;
            NonincreasingCount = nonincreasingCount;
            OverlapCount = overlapCount;
            State = state;
            Timescale = timescale;
            TrackName = trackName;
            TrackType = trackType;
            TranscriptionLanguage = transcriptionLanguage;
            TranscriptionState = transcriptionState;
            UnexpectedBitrate = unexpectedBitrate;
        }
    }
}
