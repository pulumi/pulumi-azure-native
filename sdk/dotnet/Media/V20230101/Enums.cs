// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Media.V20230101
{
    /// <summary>
    /// The type of key used to encrypt the Account Key.
    /// </summary>
    [EnumType]
    public readonly struct AccountEncryptionKeyType : IEquatable<AccountEncryptionKeyType>
    {
        private readonly string _value;

        private AccountEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Account Key is encrypted with a System Key.
        /// </summary>
        public static AccountEncryptionKeyType SystemKey { get; } = new AccountEncryptionKeyType("SystemKey");
        /// <summary>
        /// The Account Key is encrypted with a Customer Key.
        /// </summary>
        public static AccountEncryptionKeyType CustomerKey { get; } = new AccountEncryptionKeyType("CustomerKey");

        public static bool operator ==(AccountEncryptionKeyType left, AccountEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(AccountEncryptionKeyType left, AccountEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(AccountEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountEncryptionKeyType other && Equals(other);
        public bool Equals(AccountEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The permissions to set on the SAS URL.
    /// </summary>
    [EnumType]
    public readonly struct AssetContainerPermission : IEquatable<AssetContainerPermission>
    {
        private readonly string _value;

        private AssetContainerPermission(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The SAS URL will allow read access to the container.
        /// </summary>
        public static AssetContainerPermission Read { get; } = new AssetContainerPermission("Read");
        /// <summary>
        /// The SAS URL will allow read and write access to the container.
        /// </summary>
        public static AssetContainerPermission ReadWrite { get; } = new AssetContainerPermission("ReadWrite");
        /// <summary>
        /// The SAS URL will allow read, write and delete access to the container.
        /// </summary>
        public static AssetContainerPermission ReadWriteDelete { get; } = new AssetContainerPermission("ReadWriteDelete");

        public static bool operator ==(AssetContainerPermission left, AssetContainerPermission right) => left.Equals(right);
        public static bool operator !=(AssetContainerPermission left, AssetContainerPermission right) => !left.Equals(right);

        public static explicit operator string(AssetContainerPermission value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AssetContainerPermission other && Equals(other);
        public bool Equals(AssetContainerPermission other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The rental and lease key type.
    /// </summary>
    [EnumType]
    public readonly struct ContentKeyPolicyFairPlayRentalAndLeaseKeyType : IEquatable<ContentKeyPolicyFairPlayRentalAndLeaseKeyType>
    {
        private readonly string _value;

        private ContentKeyPolicyFairPlayRentalAndLeaseKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a ContentKeyPolicyFairPlayRentalAndLeaseKeyType that is unavailable in current API version.
        /// </summary>
        public static ContentKeyPolicyFairPlayRentalAndLeaseKeyType Unknown { get; } = new ContentKeyPolicyFairPlayRentalAndLeaseKeyType("Unknown");
        /// <summary>
        /// Key duration is not specified.
        /// </summary>
        public static ContentKeyPolicyFairPlayRentalAndLeaseKeyType Undefined { get; } = new ContentKeyPolicyFairPlayRentalAndLeaseKeyType("Undefined");
        /// <summary>
        /// Dual expiry for offline rental.
        /// </summary>
        public static ContentKeyPolicyFairPlayRentalAndLeaseKeyType DualExpiry { get; } = new ContentKeyPolicyFairPlayRentalAndLeaseKeyType("DualExpiry");
        /// <summary>
        /// Content key can be persisted with an unlimited duration
        /// </summary>
        public static ContentKeyPolicyFairPlayRentalAndLeaseKeyType PersistentUnlimited { get; } = new ContentKeyPolicyFairPlayRentalAndLeaseKeyType("PersistentUnlimited");
        /// <summary>
        /// Content key can be persisted and the valid duration is limited by the Rental Duration value
        /// </summary>
        public static ContentKeyPolicyFairPlayRentalAndLeaseKeyType PersistentLimited { get; } = new ContentKeyPolicyFairPlayRentalAndLeaseKeyType("PersistentLimited");

        public static bool operator ==(ContentKeyPolicyFairPlayRentalAndLeaseKeyType left, ContentKeyPolicyFairPlayRentalAndLeaseKeyType right) => left.Equals(right);
        public static bool operator !=(ContentKeyPolicyFairPlayRentalAndLeaseKeyType left, ContentKeyPolicyFairPlayRentalAndLeaseKeyType right) => !left.Equals(right);

        public static explicit operator string(ContentKeyPolicyFairPlayRentalAndLeaseKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentKeyPolicyFairPlayRentalAndLeaseKeyType other && Equals(other);
        public bool Equals(ContentKeyPolicyFairPlayRentalAndLeaseKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The PlayReady content type.
    /// </summary>
    [EnumType]
    public readonly struct ContentKeyPolicyPlayReadyContentType : IEquatable<ContentKeyPolicyPlayReadyContentType>
    {
        private readonly string _value;

        private ContentKeyPolicyPlayReadyContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a ContentKeyPolicyPlayReadyContentType that is unavailable in current API version.
        /// </summary>
        public static ContentKeyPolicyPlayReadyContentType Unknown { get; } = new ContentKeyPolicyPlayReadyContentType("Unknown");
        /// <summary>
        /// Unspecified content type.
        /// </summary>
        public static ContentKeyPolicyPlayReadyContentType Unspecified { get; } = new ContentKeyPolicyPlayReadyContentType("Unspecified");
        /// <summary>
        /// Ultraviolet download content type.
        /// </summary>
        public static ContentKeyPolicyPlayReadyContentType UltraVioletDownload { get; } = new ContentKeyPolicyPlayReadyContentType("UltraVioletDownload");
        /// <summary>
        /// Ultraviolet streaming content type.
        /// </summary>
        public static ContentKeyPolicyPlayReadyContentType UltraVioletStreaming { get; } = new ContentKeyPolicyPlayReadyContentType("UltraVioletStreaming");

        public static bool operator ==(ContentKeyPolicyPlayReadyContentType left, ContentKeyPolicyPlayReadyContentType right) => left.Equals(right);
        public static bool operator !=(ContentKeyPolicyPlayReadyContentType left, ContentKeyPolicyPlayReadyContentType right) => !left.Equals(right);

        public static explicit operator string(ContentKeyPolicyPlayReadyContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentKeyPolicyPlayReadyContentType other && Equals(other);
        public bool Equals(ContentKeyPolicyPlayReadyContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type.
    /// </summary>
    [EnumType]
    public readonly struct ContentKeyPolicyPlayReadyLicenseType : IEquatable<ContentKeyPolicyPlayReadyLicenseType>
    {
        private readonly string _value;

        private ContentKeyPolicyPlayReadyLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a ContentKeyPolicyPlayReadyLicenseType that is unavailable in current API version.
        /// </summary>
        public static ContentKeyPolicyPlayReadyLicenseType Unknown { get; } = new ContentKeyPolicyPlayReadyLicenseType("Unknown");
        /// <summary>
        /// Non persistent license.
        /// </summary>
        public static ContentKeyPolicyPlayReadyLicenseType NonPersistent { get; } = new ContentKeyPolicyPlayReadyLicenseType("NonPersistent");
        /// <summary>
        /// Persistent license. Allows offline playback.
        /// </summary>
        public static ContentKeyPolicyPlayReadyLicenseType Persistent { get; } = new ContentKeyPolicyPlayReadyLicenseType("Persistent");

        public static bool operator ==(ContentKeyPolicyPlayReadyLicenseType left, ContentKeyPolicyPlayReadyLicenseType right) => left.Equals(right);
        public static bool operator !=(ContentKeyPolicyPlayReadyLicenseType left, ContentKeyPolicyPlayReadyLicenseType right) => !left.Equals(right);

        public static explicit operator string(ContentKeyPolicyPlayReadyLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentKeyPolicyPlayReadyLicenseType other && Equals(other);
        public bool Equals(ContentKeyPolicyPlayReadyLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configures Unknown output handling settings of the license.
    /// </summary>
    [EnumType]
    public readonly struct ContentKeyPolicyPlayReadyUnknownOutputPassingOption : IEquatable<ContentKeyPolicyPlayReadyUnknownOutputPassingOption>
    {
        private readonly string _value;

        private ContentKeyPolicyPlayReadyUnknownOutputPassingOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a ContentKeyPolicyPlayReadyUnknownOutputPassingOption that is unavailable in current API version.
        /// </summary>
        public static ContentKeyPolicyPlayReadyUnknownOutputPassingOption Unknown { get; } = new ContentKeyPolicyPlayReadyUnknownOutputPassingOption("Unknown");
        /// <summary>
        /// Passing the video portion of protected content to an Unknown Output is not allowed.
        /// </summary>
        public static ContentKeyPolicyPlayReadyUnknownOutputPassingOption NotAllowed { get; } = new ContentKeyPolicyPlayReadyUnknownOutputPassingOption("NotAllowed");
        /// <summary>
        /// Passing the video portion of protected content to an Unknown Output is allowed.
        /// </summary>
        public static ContentKeyPolicyPlayReadyUnknownOutputPassingOption Allowed { get; } = new ContentKeyPolicyPlayReadyUnknownOutputPassingOption("Allowed");
        /// <summary>
        /// Passing the video portion of protected content to an Unknown Output is allowed but with constrained resolution.
        /// </summary>
        public static ContentKeyPolicyPlayReadyUnknownOutputPassingOption AllowedWithVideoConstriction { get; } = new ContentKeyPolicyPlayReadyUnknownOutputPassingOption("AllowedWithVideoConstriction");

        public static bool operator ==(ContentKeyPolicyPlayReadyUnknownOutputPassingOption left, ContentKeyPolicyPlayReadyUnknownOutputPassingOption right) => left.Equals(right);
        public static bool operator !=(ContentKeyPolicyPlayReadyUnknownOutputPassingOption left, ContentKeyPolicyPlayReadyUnknownOutputPassingOption right) => !left.Equals(right);

        public static explicit operator string(ContentKeyPolicyPlayReadyUnknownOutputPassingOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentKeyPolicyPlayReadyUnknownOutputPassingOption other && Equals(other);
        public bool Equals(ContentKeyPolicyPlayReadyUnknownOutputPassingOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of token.
    /// </summary>
    [EnumType]
    public readonly struct ContentKeyPolicyRestrictionTokenType : IEquatable<ContentKeyPolicyRestrictionTokenType>
    {
        private readonly string _value;

        private ContentKeyPolicyRestrictionTokenType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a ContentKeyPolicyRestrictionTokenType that is unavailable in current API version.
        /// </summary>
        public static ContentKeyPolicyRestrictionTokenType Unknown { get; } = new ContentKeyPolicyRestrictionTokenType("Unknown");
        /// <summary>
        /// Simple Web Token.
        /// </summary>
        public static ContentKeyPolicyRestrictionTokenType Swt { get; } = new ContentKeyPolicyRestrictionTokenType("Swt");
        /// <summary>
        /// JSON Web Token.
        /// </summary>
        public static ContentKeyPolicyRestrictionTokenType Jwt { get; } = new ContentKeyPolicyRestrictionTokenType("Jwt");

        public static bool operator ==(ContentKeyPolicyRestrictionTokenType left, ContentKeyPolicyRestrictionTokenType right) => left.Equals(right);
        public static bool operator !=(ContentKeyPolicyRestrictionTokenType left, ContentKeyPolicyRestrictionTokenType right) => !left.Equals(right);

        public static explicit operator string(ContentKeyPolicyRestrictionTokenType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentKeyPolicyRestrictionTokenType other && Equals(other);
        public bool Equals(ContentKeyPolicyRestrictionTokenType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The behavior for IP access control in Key Delivery.
    /// </summary>
    [EnumType]
    public readonly struct DefaultAction : IEquatable<DefaultAction>
    {
        private readonly string _value;

        private DefaultAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// All public IP addresses are allowed.
        /// </summary>
        public static DefaultAction Allow { get; } = new DefaultAction("Allow");
        /// <summary>
        /// Public IP addresses are blocked.
        /// </summary>
        public static DefaultAction Deny { get; } = new DefaultAction("Deny");

        public static bool operator ==(DefaultAction left, DefaultAction right) => left.Equals(right);
        public static bool operator !=(DefaultAction left, DefaultAction right) => !left.Equals(right);

        public static explicit operator string(DefaultAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultAction other && Equals(other);
        public bool Equals(DefaultAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The track property condition operation.
    /// </summary>
    [EnumType]
    public readonly struct FilterTrackPropertyCompareOperation : IEquatable<FilterTrackPropertyCompareOperation>
    {
        private readonly string _value;

        private FilterTrackPropertyCompareOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The equal operation.
        /// </summary>
        public static FilterTrackPropertyCompareOperation Equal { get; } = new FilterTrackPropertyCompareOperation("Equal");
        /// <summary>
        /// The not equal operation.
        /// </summary>
        public static FilterTrackPropertyCompareOperation NotEqual { get; } = new FilterTrackPropertyCompareOperation("NotEqual");

        public static bool operator ==(FilterTrackPropertyCompareOperation left, FilterTrackPropertyCompareOperation right) => left.Equals(right);
        public static bool operator !=(FilterTrackPropertyCompareOperation left, FilterTrackPropertyCompareOperation right) => !left.Equals(right);

        public static explicit operator string(FilterTrackPropertyCompareOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterTrackPropertyCompareOperation other && Equals(other);
        public bool Equals(FilterTrackPropertyCompareOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The track property type.
    /// </summary>
    [EnumType]
    public readonly struct FilterTrackPropertyType : IEquatable<FilterTrackPropertyType>
    {
        private readonly string _value;

        private FilterTrackPropertyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The unknown track property type.
        /// </summary>
        public static FilterTrackPropertyType Unknown { get; } = new FilterTrackPropertyType("Unknown");
        /// <summary>
        /// The type.
        /// </summary>
        public static FilterTrackPropertyType Type { get; } = new FilterTrackPropertyType("Type");
        /// <summary>
        /// The name.
        /// </summary>
        public static FilterTrackPropertyType Name { get; } = new FilterTrackPropertyType("Name");
        /// <summary>
        /// The language.
        /// </summary>
        public static FilterTrackPropertyType Language { get; } = new FilterTrackPropertyType("Language");
        /// <summary>
        /// The fourCC.
        /// </summary>
        public static FilterTrackPropertyType FourCC { get; } = new FilterTrackPropertyType("FourCC");
        /// <summary>
        /// The bitrate.
        /// </summary>
        public static FilterTrackPropertyType Bitrate { get; } = new FilterTrackPropertyType("Bitrate");

        public static bool operator ==(FilterTrackPropertyType left, FilterTrackPropertyType right) => left.Equals(right);
        public static bool operator !=(FilterTrackPropertyType left, FilterTrackPropertyType right) => !left.Equals(right);

        public static explicit operator string(FilterTrackPropertyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterTrackPropertyType other && Equals(other);
        public bool Equals(FilterTrackPropertyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The minimum TLS version allowed for this account's requests. This is an optional property. If unspecified, a secure default value will be used.
    /// </summary>
    [EnumType]
    public readonly struct MinimumTlsVersion : IEquatable<MinimumTlsVersion>
    {
        private readonly string _value;

        private MinimumTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Minimum TLS version is TLS 1.0.
        /// </summary>
        public static MinimumTlsVersion Tls10 { get; } = new MinimumTlsVersion("Tls10");
        /// <summary>
        /// Minimum TLS version is TLS 1.1.
        /// </summary>
        public static MinimumTlsVersion Tls11 { get; } = new MinimumTlsVersion("Tls11");
        /// <summary>
        /// Minimum TLS version is TLS 1.2.
        /// </summary>
        public static MinimumTlsVersion Tls12 { get; } = new MinimumTlsVersion("Tls12");
        /// <summary>
        /// Minimum TLS version is TLS 1.3.
        /// </summary>
        public static MinimumTlsVersion Tls13 { get; } = new MinimumTlsVersion("Tls13");

        public static bool operator ==(MinimumTlsVersion left, MinimumTlsVersion right) => left.Equals(right);
        public static bool operator !=(MinimumTlsVersion left, MinimumTlsVersion right) => !left.Equals(right);

        public static explicit operator string(MinimumTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimumTlsVersion other && Equals(other);
        public bool Equals(MinimumTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not public network access is allowed for resources under the Media Services account.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public network access is enabled.
        /// </summary>
        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        /// <summary>
        /// Public network access is disabled.
        /// </summary>
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The security level.
    /// </summary>
    [EnumType]
    public readonly struct SecurityLevel : IEquatable<SecurityLevel>
    {
        private readonly string _value;

        private SecurityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents a SecurityLevel that is unavailable in current API version.
        /// </summary>
        public static SecurityLevel Unknown { get; } = new SecurityLevel("Unknown");
        /// <summary>
        /// For clients under development or test. No protection against unauthorized use.
        /// </summary>
        public static SecurityLevel SL150 { get; } = new SecurityLevel("SL150");
        /// <summary>
        /// For hardened devices and applications consuming commercial content. Software or hardware protection.
        /// </summary>
        public static SecurityLevel SL2000 { get; } = new SecurityLevel("SL2000");
        /// <summary>
        /// For hardened devices only. Hardware protection.
        /// </summary>
        public static SecurityLevel SL3000 { get; } = new SecurityLevel("SL3000");

        public static bool operator ==(SecurityLevel left, SecurityLevel right) => left.Equals(right);
        public static bool operator !=(SecurityLevel left, SecurityLevel right) => !left.Equals(right);

        public static explicit operator string(SecurityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityLevel other && Equals(other);
        public bool Equals(SecurityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the storage account.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The primary storage account for the Media Services account.
        /// </summary>
        public static StorageAccountType Primary { get; } = new StorageAccountType("Primary");
        /// <summary>
        /// A secondary storage account for the Media Services account.
        /// </summary>
        public static StorageAccountType Secondary { get; } = new StorageAccountType("Secondary");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StorageAuthentication : IEquatable<StorageAuthentication>
    {
        private readonly string _value;

        private StorageAuthentication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// System authentication.
        /// </summary>
        public static StorageAuthentication System { get; } = new StorageAuthentication("System");
        /// <summary>
        /// Managed Identity authentication.
        /// </summary>
        public static StorageAuthentication ManagedIdentity { get; } = new StorageAuthentication("ManagedIdentity");

        public static bool operator ==(StorageAuthentication left, StorageAuthentication right) => left.Equals(right);
        public static bool operator !=(StorageAuthentication left, StorageAuthentication right) => !left.Equals(right);

        public static explicit operator string(StorageAuthentication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAuthentication other && Equals(other);
        public bool Equals(StorageAuthentication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Track property condition operation
    /// </summary>
    [EnumType]
    public readonly struct TrackPropertyCompareOperation : IEquatable<TrackPropertyCompareOperation>
    {
        private readonly string _value;

        private TrackPropertyCompareOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown track property compare operation
        /// </summary>
        public static TrackPropertyCompareOperation Unknown { get; } = new TrackPropertyCompareOperation("Unknown");
        /// <summary>
        /// Equal operation
        /// </summary>
        public static TrackPropertyCompareOperation Equal { get; } = new TrackPropertyCompareOperation("Equal");

        public static bool operator ==(TrackPropertyCompareOperation left, TrackPropertyCompareOperation right) => left.Equals(right);
        public static bool operator !=(TrackPropertyCompareOperation left, TrackPropertyCompareOperation right) => !left.Equals(right);

        public static explicit operator string(TrackPropertyCompareOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrackPropertyCompareOperation other && Equals(other);
        public bool Equals(TrackPropertyCompareOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Track property type
    /// </summary>
    [EnumType]
    public readonly struct TrackPropertyType : IEquatable<TrackPropertyType>
    {
        private readonly string _value;

        private TrackPropertyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown track property
        /// </summary>
        public static TrackPropertyType Unknown { get; } = new TrackPropertyType("Unknown");
        /// <summary>
        /// Track FourCC
        /// </summary>
        public static TrackPropertyType FourCC { get; } = new TrackPropertyType("FourCC");

        public static bool operator ==(TrackPropertyType left, TrackPropertyType right) => left.Equals(right);
        public static bool operator !=(TrackPropertyType left, TrackPropertyType right) => !left.Equals(right);

        public static explicit operator string(TrackPropertyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrackPropertyType other && Equals(other);
        public bool Equals(TrackPropertyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
    /// </summary>
    [EnumType]
    public readonly struct Visibility : IEquatable<Visibility>
    {
        private readonly string _value;

        private Visibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The track is hidden to video player.
        /// </summary>
        public static Visibility Hidden { get; } = new Visibility("Hidden");
        /// <summary>
        /// The track is visible to video player.
        /// </summary>
        public static Visibility Visible { get; } = new Visibility("Visible");

        public static bool operator ==(Visibility left, Visibility right) => left.Equals(right);
        public static bool operator !=(Visibility left, Visibility right) => !left.Equals(right);

        public static explicit operator string(Visibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Visibility other && Equals(other);
        public bool Equals(Visibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
