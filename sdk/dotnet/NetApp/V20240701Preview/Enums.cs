// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.NetApp.V20240701Preview
{
    /// <summary>
    /// While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted.
    /// </summary>
    [EnumType]
    public readonly struct AcceptGrowCapacityPoolForShortTermCloneSplit : IEquatable<AcceptGrowCapacityPoolForShortTermCloneSplit>
    {
        private readonly string _value;

        private AcceptGrowCapacityPoolForShortTermCloneSplit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Auto grow capacity pool for short term clone split is accepted.
        /// </summary>
        public static AcceptGrowCapacityPoolForShortTermCloneSplit Accepted { get; } = new AcceptGrowCapacityPoolForShortTermCloneSplit("Accepted");
        /// <summary>
        /// Auto grow capacity pool for short term clone split is declined. Short term clone volume creation will not be allowed, to create short term clone volume accept auto grow capacity pool.
        /// </summary>
        public static AcceptGrowCapacityPoolForShortTermCloneSplit Declined { get; } = new AcceptGrowCapacityPoolForShortTermCloneSplit("Declined");

        public static bool operator ==(AcceptGrowCapacityPoolForShortTermCloneSplit left, AcceptGrowCapacityPoolForShortTermCloneSplit right) => left.Equals(right);
        public static bool operator !=(AcceptGrowCapacityPoolForShortTermCloneSplit left, AcceptGrowCapacityPoolForShortTermCloneSplit right) => !left.Equals(right);

        public static explicit operator string(AcceptGrowCapacityPoolForShortTermCloneSplit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AcceptGrowCapacityPoolForShortTermCloneSplit other && Equals(other);
        public bool Equals(AcceptGrowCapacityPoolForShortTermCloneSplit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Application Type
    /// </summary>
    [EnumType]
    public readonly struct ApplicationType : IEquatable<ApplicationType>
    {
        private readonly string _value;

        private ApplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationType SAP_HANA { get; } = new ApplicationType("SAP-HANA");
        public static ApplicationType ORACLE { get; } = new ApplicationType("ORACLE");

        public static bool operator ==(ApplicationType left, ApplicationType right) => left.Equals(right);
        public static bool operator !=(ApplicationType left, ApplicationType right) => !left.Equals(right);

        public static explicit operator string(ApplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationType other && Equals(other);
        public bool Equals(ApplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
    /// </summary>
    [EnumType]
    public readonly struct AvsDataStore : IEquatable<AvsDataStore>
    {
        private readonly string _value;

        private AvsDataStore(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// avsDataStore is enabled
        /// </summary>
        public static AvsDataStore Enabled { get; } = new AvsDataStore("Enabled");
        /// <summary>
        /// avsDataStore is disabled
        /// </summary>
        public static AvsDataStore Disabled { get; } = new AvsDataStore("Disabled");

        public static bool operator ==(AvsDataStore left, AvsDataStore right) => left.Equals(right);
        public static bool operator !=(AvsDataStore left, AvsDataStore right) => !left.Equals(right);

        public static explicit operator string(AvsDataStore value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AvsDataStore other && Equals(other);
        public bool Equals(AvsDataStore other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
    /// </summary>
    [EnumType]
    public readonly struct ChownMode : IEquatable<ChownMode>
    {
        private readonly string _value;

        private ChownMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChownMode Restricted { get; } = new ChownMode("Restricted");
        public static ChownMode Unrestricted { get; } = new ChownMode("Unrestricted");

        public static bool operator ==(ChownMode left, ChownMode right) => left.Equals(right);
        public static bool operator !=(ChownMode left, ChownMode right) => !left.Equals(right);

        public static explicit operator string(ChownMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChownMode other && Equals(other);
        public bool Equals(ChownMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
    ///  Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
    ///  OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
    ///  Never - No client-driven data is pulled from cool tier to standard storage.
    /// </summary>
    [EnumType]
    public readonly struct CoolAccessRetrievalPolicy : IEquatable<CoolAccessRetrievalPolicy>
    {
        private readonly string _value;

        private CoolAccessRetrievalPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CoolAccessRetrievalPolicy Default { get; } = new CoolAccessRetrievalPolicy("Default");
        public static CoolAccessRetrievalPolicy OnRead { get; } = new CoolAccessRetrievalPolicy("OnRead");
        public static CoolAccessRetrievalPolicy Never { get; } = new CoolAccessRetrievalPolicy("Never");

        public static bool operator ==(CoolAccessRetrievalPolicy left, CoolAccessRetrievalPolicy right) => left.Equals(right);
        public static bool operator !=(CoolAccessRetrievalPolicy left, CoolAccessRetrievalPolicy right) => !left.Equals(right);

        public static explicit operator string(CoolAccessRetrievalPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CoolAccessRetrievalPolicy other && Equals(other);
        public bool Equals(CoolAccessRetrievalPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Flag indicating whether subvolume operations are enabled on the volume
    /// </summary>
    [EnumType]
    public readonly struct EnableSubvolumes : IEquatable<EnableSubvolumes>
    {
        private readonly string _value;

        private EnableSubvolumes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// subvolumes are enabled
        /// </summary>
        public static EnableSubvolumes Enabled { get; } = new EnableSubvolumes("Enabled");
        /// <summary>
        /// subvolumes are not enabled
        /// </summary>
        public static EnableSubvolumes Disabled { get; } = new EnableSubvolumes("Disabled");

        public static bool operator ==(EnableSubvolumes left, EnableSubvolumes right) => left.Equals(right);
        public static bool operator !=(EnableSubvolumes left, EnableSubvolumes right) => !left.Equals(right);

        public static explicit operator string(EnableSubvolumes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnableSubvolumes other && Equals(other);
        public bool Equals(EnableSubvolumes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
    /// </summary>
    [EnumType]
    public readonly struct EncryptionKeySource : IEquatable<EncryptionKeySource>
    {
        private readonly string _value;

        private EncryptionKeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft-managed key encryption
        /// </summary>
        public static EncryptionKeySource Microsoft_NetApp { get; } = new EncryptionKeySource("Microsoft.NetApp");
        /// <summary>
        /// Customer-managed key encryption
        /// </summary>
        public static EncryptionKeySource Microsoft_KeyVault { get; } = new EncryptionKeySource("Microsoft.KeyVault");

        public static bool operator ==(EncryptionKeySource left, EncryptionKeySource right) => left.Equals(right);
        public static bool operator !=(EncryptionKeySource left, EncryptionKeySource right) => !left.Equals(right);

        public static explicit operator string(EncryptionKeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionKeySource other && Equals(other);
        public bool Equals(EncryptionKeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Encryption type of the capacity pool, set encryption type for data at rest for this pool and all volumes in it. This value can only be set when creating new pool.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionType : IEquatable<EncryptionType>
    {
        private readonly string _value;

        private EncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EncryptionType Single, volumes will use single encryption at rest
        /// </summary>
        public static EncryptionType Single { get; } = new EncryptionType("Single");
        /// <summary>
        /// EncryptionType Double, volumes will use double encryption at rest
        /// </summary>
        public static EncryptionType Double { get; } = new EncryptionType("Double");

        public static bool operator ==(EncryptionType left, EncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionType left, EncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionType other && Equals(other);
        public bool Equals(EncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the local volume is the source or destination for the Volume Replication
    /// </summary>
    [EnumType]
    public readonly struct EndpointType : IEquatable<EndpointType>
    {
        private readonly string _value;

        private EndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointType Src { get; } = new EndpointType("src");
        public static EndpointType Dst { get; } = new EndpointType("dst");

        public static bool operator ==(EndpointType left, EndpointType right) => left.Equals(right);
        public static bool operator !=(EndpointType left, EndpointType right) => !left.Equals(right);

        public static explicit operator string(EndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointType other && Equals(other);
        public bool Equals(EndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
    /// </summary>
    [EnumType]
    public readonly struct KeySource : IEquatable<KeySource>
    {
        private readonly string _value;

        private KeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft-managed key encryption
        /// </summary>
        public static KeySource Microsoft_NetApp { get; } = new KeySource("Microsoft.NetApp");
        /// <summary>
        /// Customer-managed key encryption
        /// </summary>
        public static KeySource Microsoft_KeyVault { get; } = new KeySource("Microsoft.KeyVault");

        public static bool operator ==(KeySource left, KeySource right) => left.Equals(right);
        public static bool operator !=(KeySource left, KeySource right) => !left.Equals(right);

        public static explicit operator string(KeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeySource other && Equals(other);
        public bool Equals(KeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The original value of the network features type available to the volume at the time it was created.
    /// </summary>
    [EnumType]
    public readonly struct NetworkFeatures : IEquatable<NetworkFeatures>
    {
        private readonly string _value;

        private NetworkFeatures(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Basic network features.
        /// </summary>
        public static NetworkFeatures Basic { get; } = new NetworkFeatures("Basic");
        /// <summary>
        /// Standard network features.
        /// </summary>
        public static NetworkFeatures Standard { get; } = new NetworkFeatures("Standard");
        /// <summary>
        /// Updating from Basic to Standard network features.
        /// </summary>
        public static NetworkFeatures Basic_Standard { get; } = new NetworkFeatures("Basic_Standard");
        /// <summary>
        /// Updating from Standard to Basic network features.
        /// </summary>
        public static NetworkFeatures Standard_Basic { get; } = new NetworkFeatures("Standard_Basic");

        public static bool operator ==(NetworkFeatures left, NetworkFeatures right) => left.Equals(right);
        public static bool operator !=(NetworkFeatures left, NetworkFeatures right) => !left.Equals(right);

        public static explicit operator string(NetworkFeatures value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkFeatures other && Equals(other);
        public bool Equals(NetworkFeatures other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The qos type of the pool
    /// </summary>
    [EnumType]
    public readonly struct QosType : IEquatable<QosType>
    {
        private readonly string _value;

        private QosType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// qos type Auto
        /// </summary>
        public static QosType Auto { get; } = new QosType("Auto");
        /// <summary>
        /// qos type Manual
        /// </summary>
        public static QosType Manual { get; } = new QosType("Manual");

        public static bool operator ==(QosType left, QosType right) => left.Equals(right);
        public static bool operator !=(QosType left, QosType right) => !left.Equals(right);

        public static explicit operator string(QosType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is QosType other && Equals(other);
        public bool Equals(QosType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Schedule
    /// </summary>
    [EnumType]
    public readonly struct ReplicationSchedule : IEquatable<ReplicationSchedule>
    {
        private readonly string _value;

        private ReplicationSchedule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationSchedule ReplicationSchedule_10minutely { get; } = new ReplicationSchedule("_10minutely");
        public static ReplicationSchedule Hourly { get; } = new ReplicationSchedule("hourly");
        public static ReplicationSchedule Daily { get; } = new ReplicationSchedule("daily");

        public static bool operator ==(ReplicationSchedule left, ReplicationSchedule right) => left.Equals(right);
        public static bool operator !=(ReplicationSchedule left, ReplicationSchedule right) => !left.Equals(right);

        public static explicit operator string(ReplicationSchedule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationSchedule other && Equals(other);
        public bool Equals(ReplicationSchedule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
    /// </summary>
    [EnumType]
    public readonly struct SecurityStyle : IEquatable<SecurityStyle>
    {
        private readonly string _value;

        private SecurityStyle(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityStyle Ntfs { get; } = new SecurityStyle("ntfs");
        public static SecurityStyle Unix { get; } = new SecurityStyle("unix");

        public static bool operator ==(SecurityStyle left, SecurityStyle right) => left.Equals(right);
        public static bool operator !=(SecurityStyle left, SecurityStyle right) => !left.Equals(right);

        public static explicit operator string(SecurityStyle value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityStyle other && Equals(other);
        public bool Equals(SecurityStyle other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The service level of the file system
    /// </summary>
    [EnumType]
    public readonly struct ServiceLevel : IEquatable<ServiceLevel>
    {
        private readonly string _value;

        private ServiceLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard service level
        /// </summary>
        public static ServiceLevel Standard { get; } = new ServiceLevel("Standard");
        /// <summary>
        /// Premium service level
        /// </summary>
        public static ServiceLevel Premium { get; } = new ServiceLevel("Premium");
        /// <summary>
        /// Ultra service level
        /// </summary>
        public static ServiceLevel Ultra { get; } = new ServiceLevel("Ultra");
        /// <summary>
        /// Zone redundant storage service level
        /// </summary>
        public static ServiceLevel StandardZRS { get; } = new ServiceLevel("StandardZRS");
        /// <summary>
        /// Flexible service level
        /// </summary>
        public static ServiceLevel Flexible { get; } = new ServiceLevel("Flexible");

        public static bool operator ==(ServiceLevel left, ServiceLevel right) => left.Equals(right);
        public static bool operator !=(ServiceLevel left, ServiceLevel right) => !left.Equals(right);

        public static explicit operator string(ServiceLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceLevel other && Equals(other);
        public bool Equals(ServiceLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
    /// </summary>
    [EnumType]
    public readonly struct SmbAccessBasedEnumeration : IEquatable<SmbAccessBasedEnumeration>
    {
        private readonly string _value;

        private SmbAccessBasedEnumeration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// smbAccessBasedEnumeration share setting is disabled
        /// </summary>
        public static SmbAccessBasedEnumeration Disabled { get; } = new SmbAccessBasedEnumeration("Disabled");
        /// <summary>
        /// smbAccessBasedEnumeration share setting is enabled
        /// </summary>
        public static SmbAccessBasedEnumeration Enabled { get; } = new SmbAccessBasedEnumeration("Enabled");

        public static bool operator ==(SmbAccessBasedEnumeration left, SmbAccessBasedEnumeration right) => left.Equals(right);
        public static bool operator !=(SmbAccessBasedEnumeration left, SmbAccessBasedEnumeration right) => !left.Equals(right);

        public static explicit operator string(SmbAccessBasedEnumeration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SmbAccessBasedEnumeration other && Equals(other);
        public bool Equals(SmbAccessBasedEnumeration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
    /// </summary>
    [EnumType]
    public readonly struct SmbNonBrowsable : IEquatable<SmbNonBrowsable>
    {
        private readonly string _value;

        private SmbNonBrowsable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// smbNonBrowsable share setting is disabled
        /// </summary>
        public static SmbNonBrowsable Disabled { get; } = new SmbNonBrowsable("Disabled");
        /// <summary>
        /// smbNonBrowsable share setting is enabled
        /// </summary>
        public static SmbNonBrowsable Enabled { get; } = new SmbNonBrowsable("Enabled");

        public static bool operator ==(SmbNonBrowsable left, SmbNonBrowsable right) => left.Equals(right);
        public static bool operator !=(SmbNonBrowsable left, SmbNonBrowsable right) => !left.Equals(right);

        public static explicit operator string(SmbNonBrowsable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SmbNonBrowsable other && Equals(other);
        public bool Equals(SmbNonBrowsable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of quota
    /// </summary>
    [EnumType]
    public readonly struct Type : IEquatable<Type>
    {
        private readonly string _value;

        private Type(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default user quota
        /// </summary>
        public static Type DefaultUserQuota { get; } = new Type("DefaultUserQuota");
        /// <summary>
        /// Default group quota
        /// </summary>
        public static Type DefaultGroupQuota { get; } = new Type("DefaultGroupQuota");
        /// <summary>
        /// Individual user quota
        /// </summary>
        public static Type IndividualUserQuota { get; } = new Type("IndividualUserQuota");
        /// <summary>
        /// Individual group quota
        /// </summary>
        public static Type IndividualGroupQuota { get; } = new Type("IndividualGroupQuota");

        public static bool operator ==(Type left, Type right) => left.Equals(right);
        public static bool operator !=(Type left, Type right) => !left.Equals(right);

        public static explicit operator string(Type value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Type other && Equals(other);
        public bool Equals(Type other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Language supported for volume.
    /// </summary>
    [EnumType]
    public readonly struct VolumeLanguage : IEquatable<VolumeLanguage>
    {
        private readonly string _value;

        private VolumeLanguage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Posix with UTF-8
        /// </summary>
        public static VolumeLanguage C_utf_8 { get; } = new VolumeLanguage("c.utf-8");
        /// <summary>
        /// UTF-8 with 4 byte character support
        /// </summary>
        public static VolumeLanguage Utf8mb4 { get; } = new VolumeLanguage("utf8mb4");
        /// <summary>
        /// Arabic - Deprecated
        /// </summary>
        public static VolumeLanguage Ar { get; } = new VolumeLanguage("ar");
        /// <summary>
        /// Arabic with UTF-8
        /// </summary>
        public static VolumeLanguage Ar_utf_8 { get; } = new VolumeLanguage("ar.utf-8");
        /// <summary>
        /// Croatian - Deprecated
        /// </summary>
        public static VolumeLanguage Hr { get; } = new VolumeLanguage("hr");
        /// <summary>
        /// Croatian with UTF-8
        /// </summary>
        public static VolumeLanguage Hr_utf_8 { get; } = new VolumeLanguage("hr.utf-8");
        /// <summary>
        /// Czech - Deprecated
        /// </summary>
        public static VolumeLanguage Cs { get; } = new VolumeLanguage("cs");
        /// <summary>
        /// Czech with UTF-8
        /// </summary>
        public static VolumeLanguage Cs_utf_8 { get; } = new VolumeLanguage("cs.utf-8");
        /// <summary>
        /// Danish - Deprecated
        /// </summary>
        public static VolumeLanguage Da { get; } = new VolumeLanguage("da");
        /// <summary>
        /// Danish with UTF-8
        /// </summary>
        public static VolumeLanguage Da_utf_8 { get; } = new VolumeLanguage("da.utf-8");
        /// <summary>
        /// Dutch - Deprecated
        /// </summary>
        public static VolumeLanguage Nl { get; } = new VolumeLanguage("nl");
        /// <summary>
        /// Dutch with UTF-8
        /// </summary>
        public static VolumeLanguage Nl_utf_8 { get; } = new VolumeLanguage("nl.utf-8");
        /// <summary>
        /// English - Deprecated
        /// </summary>
        public static VolumeLanguage En { get; } = new VolumeLanguage("en");
        /// <summary>
        /// English with UTF-8
        /// </summary>
        public static VolumeLanguage En_utf_8 { get; } = new VolumeLanguage("en.utf-8");
        /// <summary>
        /// Finnish - Deprecated
        /// </summary>
        public static VolumeLanguage Fi { get; } = new VolumeLanguage("fi");
        /// <summary>
        /// Finnish with UTF-8
        /// </summary>
        public static VolumeLanguage Fi_utf_8 { get; } = new VolumeLanguage("fi.utf-8");
        /// <summary>
        /// French - Deprecated
        /// </summary>
        public static VolumeLanguage Fr { get; } = new VolumeLanguage("fr");
        /// <summary>
        /// French with UTF-8
        /// </summary>
        public static VolumeLanguage Fr_utf_8 { get; } = new VolumeLanguage("fr.utf-8");
        /// <summary>
        /// German - Deprecated
        /// </summary>
        public static VolumeLanguage De { get; } = new VolumeLanguage("de");
        /// <summary>
        /// German with UTF-8
        /// </summary>
        public static VolumeLanguage De_utf_8 { get; } = new VolumeLanguage("de.utf-8");
        /// <summary>
        /// Hebrew - Deprecated
        /// </summary>
        public static VolumeLanguage He { get; } = new VolumeLanguage("he");
        /// <summary>
        /// Hebrew with UTF-8
        /// </summary>
        public static VolumeLanguage He_utf_8 { get; } = new VolumeLanguage("he.utf-8");
        /// <summary>
        /// Hungarian - Deprecated
        /// </summary>
        public static VolumeLanguage Hu { get; } = new VolumeLanguage("hu");
        /// <summary>
        /// Hungarian with UTF-8
        /// </summary>
        public static VolumeLanguage Hu_utf_8 { get; } = new VolumeLanguage("hu.utf-8");
        /// <summary>
        /// Italian - Deprecated
        /// </summary>
        public static VolumeLanguage It { get; } = new VolumeLanguage("it");
        /// <summary>
        /// Italian with UTF-8
        /// </summary>
        public static VolumeLanguage It_utf_8 { get; } = new VolumeLanguage("it.utf-8");
        /// <summary>
        /// Japanese euc-j - Deprecated
        /// </summary>
        public static VolumeLanguage Ja { get; } = new VolumeLanguage("ja");
        /// <summary>
        /// Japanese euc-j with UTF-8
        /// </summary>
        public static VolumeLanguage Ja_utf_8 { get; } = new VolumeLanguage("ja.utf-8");
        /// <summary>
        /// Japanese euc-j - Deprecated
        /// </summary>
        public static VolumeLanguage Ja_v1 { get; } = new VolumeLanguage("ja-v1");
        /// <summary>
        /// Japanese euc-j with UTF-8
        /// </summary>
        public static VolumeLanguage Ja_v1_utf_8 { get; } = new VolumeLanguage("ja-v1.utf-8");
        /// <summary>
        /// Japanese pck
        /// </summary>
        public static VolumeLanguage Ja_jp_pck { get; } = new VolumeLanguage("ja-jp.pck");
        /// <summary>
        /// Japanese pck with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Ja_jp_pck_utf_8 { get; } = new VolumeLanguage("ja-jp.pck.utf-8");
        /// <summary>
        /// Japanese cp932
        /// </summary>
        public static VolumeLanguage Ja_jp_932 { get; } = new VolumeLanguage("ja-jp.932");
        /// <summary>
        /// Japanese cp932 with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Ja_jp_932_utf_8 { get; } = new VolumeLanguage("ja-jp.932.utf-8");
        /// <summary>
        /// Japanese pck - sjis
        /// </summary>
        public static VolumeLanguage Ja_jp_pck_v2 { get; } = new VolumeLanguage("ja-jp.pck-v2");
        /// <summary>
        /// Japanese pck - sjis with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Ja_jp_pck_v2_utf_8 { get; } = new VolumeLanguage("ja-jp.pck-v2.utf-8");
        /// <summary>
        /// Korean - Deprecated
        /// </summary>
        public static VolumeLanguage Ko { get; } = new VolumeLanguage("ko");
        /// <summary>
        /// Korean with UTF-8
        /// </summary>
        public static VolumeLanguage Ko_utf_8 { get; } = new VolumeLanguage("ko.utf-8");
        /// <summary>
        /// Norwegian - Deprecated
        /// </summary>
        public static VolumeLanguage No { get; } = new VolumeLanguage("no");
        /// <summary>
        /// Norwegian with UTF-8
        /// </summary>
        public static VolumeLanguage No_utf_8 { get; } = new VolumeLanguage("no.utf-8");
        /// <summary>
        /// Polish - Deprecated
        /// </summary>
        public static VolumeLanguage Pl { get; } = new VolumeLanguage("pl");
        /// <summary>
        /// Polish with UTF-8
        /// </summary>
        public static VolumeLanguage Pl_utf_8 { get; } = new VolumeLanguage("pl.utf-8");
        /// <summary>
        /// Portuguese - Deprecated
        /// </summary>
        public static VolumeLanguage Pt { get; } = new VolumeLanguage("pt");
        /// <summary>
        /// Portuguese with UTF-8
        /// </summary>
        public static VolumeLanguage Pt_utf_8 { get; } = new VolumeLanguage("pt.utf-8");
        /// <summary>
        /// Posix - Deprecated
        /// </summary>
        public static VolumeLanguage C { get; } = new VolumeLanguage("c");
        /// <summary>
        /// Romanian - Deprecated
        /// </summary>
        public static VolumeLanguage Ro { get; } = new VolumeLanguage("ro");
        /// <summary>
        /// Romanian with UTF-8
        /// </summary>
        public static VolumeLanguage Ro_utf_8 { get; } = new VolumeLanguage("ro.utf-8");
        /// <summary>
        /// Russian - Deprecated
        /// </summary>
        public static VolumeLanguage Ru { get; } = new VolumeLanguage("ru");
        /// <summary>
        /// Russian with UTF-8
        /// </summary>
        public static VolumeLanguage Ru_utf_8 { get; } = new VolumeLanguage("ru.utf-8");
        /// <summary>
        /// Simplified Chinese - Deprecated
        /// </summary>
        public static VolumeLanguage Zh { get; } = new VolumeLanguage("zh");
        /// <summary>
        /// Simplified Chinese with UTF-8
        /// </summary>
        public static VolumeLanguage Zh_utf_8 { get; } = new VolumeLanguage("zh.utf-8");
        /// <summary>
        /// Simplified gbk Chinese
        /// </summary>
        public static VolumeLanguage Zh_gbk { get; } = new VolumeLanguage("zh.gbk");
        /// <summary>
        /// Simplified gbk Chinese with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Zh_gbk_utf_8 { get; } = new VolumeLanguage("zh.gbk.utf-8");
        /// <summary>
        /// Traditional Chinese BIG 5
        /// </summary>
        public static VolumeLanguage Zh_tw_big5 { get; } = new VolumeLanguage("zh-tw.big5");
        /// <summary>
        /// Traditional Chinese BIG 5 with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Zh_tw_big5_utf_8 { get; } = new VolumeLanguage("zh-tw.big5.utf-8");
        /// <summary>
        /// Traditional Chinese EUC-TW
        /// </summary>
        public static VolumeLanguage Zh_tw { get; } = new VolumeLanguage("zh-tw");
        /// <summary>
        /// Traditional Chinese EUC-TW with UTF-8 - Deprecated
        /// </summary>
        public static VolumeLanguage Zh_tw_utf_8 { get; } = new VolumeLanguage("zh-tw.utf-8");
        /// <summary>
        /// Slovak - Deprecated
        /// </summary>
        public static VolumeLanguage Sk { get; } = new VolumeLanguage("sk");
        /// <summary>
        /// Slovak with UTF-8
        /// </summary>
        public static VolumeLanguage Sk_utf_8 { get; } = new VolumeLanguage("sk.utf-8");
        /// <summary>
        /// Slovenian - Deprecated
        /// </summary>
        public static VolumeLanguage Sl { get; } = new VolumeLanguage("sl");
        /// <summary>
        /// Slovenian with UTF-8
        /// </summary>
        public static VolumeLanguage Sl_utf_8 { get; } = new VolumeLanguage("sl.utf-8");
        /// <summary>
        /// Spanish - Deprecated
        /// </summary>
        public static VolumeLanguage Es { get; } = new VolumeLanguage("es");
        /// <summary>
        /// Spanish with UTF-8
        /// </summary>
        public static VolumeLanguage Es_utf_8 { get; } = new VolumeLanguage("es.utf-8");
        /// <summary>
        /// Swedish - Deprecated
        /// </summary>
        public static VolumeLanguage Sv { get; } = new VolumeLanguage("sv");
        /// <summary>
        /// Swedish with UTF-8
        /// </summary>
        public static VolumeLanguage Sv_utf_8 { get; } = new VolumeLanguage("sv.utf-8");
        /// <summary>
        /// Turkish - Deprecated
        /// </summary>
        public static VolumeLanguage Tr { get; } = new VolumeLanguage("tr");
        /// <summary>
        /// Turkish with UTF-8
        /// </summary>
        public static VolumeLanguage Tr_utf_8 { get; } = new VolumeLanguage("tr.utf-8");
        /// <summary>
        /// US English - Deprecated
        /// </summary>
        public static VolumeLanguage En_us { get; } = new VolumeLanguage("en-us");
        /// <summary>
        /// US English with UTF-8
        /// </summary>
        public static VolumeLanguage En_us_utf_8 { get; } = new VolumeLanguage("en-us.utf-8");

        public static bool operator ==(VolumeLanguage left, VolumeLanguage right) => left.Equals(right);
        public static bool operator !=(VolumeLanguage left, VolumeLanguage right) => !left.Equals(right);

        public static explicit operator string(VolumeLanguage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VolumeLanguage other && Equals(other);
        public bool Equals(VolumeLanguage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
