// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.NetApp
{
    /// <summary>
    /// Application Type
    /// </summary>
    [EnumType]
    public readonly struct ApplicationType : IEquatable<ApplicationType>
    {
        private readonly string _value;

        private ApplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationType SAP_HANA { get; } = new ApplicationType("SAP-HANA");
        public static ApplicationType ORACLE { get; } = new ApplicationType("ORACLE");

        public static bool operator ==(ApplicationType left, ApplicationType right) => left.Equals(right);
        public static bool operator !=(ApplicationType left, ApplicationType right) => !left.Equals(right);

        public static explicit operator string(ApplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationType other && Equals(other);
        public bool Equals(ApplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
    /// </summary>
    [EnumType]
    public readonly struct AvsDataStore : IEquatable<AvsDataStore>
    {
        private readonly string _value;

        private AvsDataStore(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// avsDataStore is enabled
        /// </summary>
        public static AvsDataStore Enabled { get; } = new AvsDataStore("Enabled");
        /// <summary>
        /// avsDataStore is disabled
        /// </summary>
        public static AvsDataStore Disabled { get; } = new AvsDataStore("Disabled");

        public static bool operator ==(AvsDataStore left, AvsDataStore right) => left.Equals(right);
        public static bool operator !=(AvsDataStore left, AvsDataStore right) => !left.Equals(right);

        public static explicit operator string(AvsDataStore value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AvsDataStore other && Equals(other);
        public bool Equals(AvsDataStore other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
    /// </summary>
    [EnumType]
    public readonly struct ChownMode : IEquatable<ChownMode>
    {
        private readonly string _value;

        private ChownMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChownMode Restricted { get; } = new ChownMode("Restricted");
        public static ChownMode Unrestricted { get; } = new ChownMode("Unrestricted");

        public static bool operator ==(ChownMode left, ChownMode right) => left.Equals(right);
        public static bool operator !=(ChownMode left, ChownMode right) => !left.Equals(right);

        public static explicit operator string(ChownMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChownMode other && Equals(other);
        public bool Equals(ChownMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
    ///  Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
    ///  OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
    ///  Never - No client-driven data is pulled from cool tier to standard storage.
    /// </summary>
    [EnumType]
    public readonly struct CoolAccessRetrievalPolicy : IEquatable<CoolAccessRetrievalPolicy>
    {
        private readonly string _value;

        private CoolAccessRetrievalPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CoolAccessRetrievalPolicy Default { get; } = new CoolAccessRetrievalPolicy("Default");
        public static CoolAccessRetrievalPolicy OnRead { get; } = new CoolAccessRetrievalPolicy("OnRead");
        public static CoolAccessRetrievalPolicy Never { get; } = new CoolAccessRetrievalPolicy("Never");

        public static bool operator ==(CoolAccessRetrievalPolicy left, CoolAccessRetrievalPolicy right) => left.Equals(right);
        public static bool operator !=(CoolAccessRetrievalPolicy left, CoolAccessRetrievalPolicy right) => !left.Equals(right);

        public static explicit operator string(CoolAccessRetrievalPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CoolAccessRetrievalPolicy other && Equals(other);
        public bool Equals(CoolAccessRetrievalPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier.
    /// </summary>
    [EnumType]
    public readonly struct CoolAccessTieringPolicy : IEquatable<CoolAccessTieringPolicy>
    {
        private readonly string _value;

        private CoolAccessTieringPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CoolAccessTieringPolicy Auto { get; } = new CoolAccessTieringPolicy("Auto");
        public static CoolAccessTieringPolicy SnapshotOnly { get; } = new CoolAccessTieringPolicy("SnapshotOnly");

        public static bool operator ==(CoolAccessTieringPolicy left, CoolAccessTieringPolicy right) => left.Equals(right);
        public static bool operator !=(CoolAccessTieringPolicy left, CoolAccessTieringPolicy right) => !left.Equals(right);

        public static explicit operator string(CoolAccessTieringPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CoolAccessTieringPolicy other && Equals(other);
        public bool Equals(CoolAccessTieringPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Flag indicating whether subvolume operations are enabled on the volume
    /// </summary>
    [EnumType]
    public readonly struct EnableSubvolumes : IEquatable<EnableSubvolumes>
    {
        private readonly string _value;

        private EnableSubvolumes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// subvolumes are enabled
        /// </summary>
        public static EnableSubvolumes Enabled { get; } = new EnableSubvolumes("Enabled");
        /// <summary>
        /// subvolumes are not enabled
        /// </summary>
        public static EnableSubvolumes Disabled { get; } = new EnableSubvolumes("Disabled");

        public static bool operator ==(EnableSubvolumes left, EnableSubvolumes right) => left.Equals(right);
        public static bool operator !=(EnableSubvolumes left, EnableSubvolumes right) => !left.Equals(right);

        public static explicit operator string(EnableSubvolumes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnableSubvolumes other && Equals(other);
        public bool Equals(EnableSubvolumes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
    /// </summary>
    [EnumType]
    public readonly struct EncryptionKeySource : IEquatable<EncryptionKeySource>
    {
        private readonly string _value;

        private EncryptionKeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft-managed key encryption
        /// </summary>
        public static EncryptionKeySource Microsoft_NetApp { get; } = new EncryptionKeySource("Microsoft.NetApp");
        /// <summary>
        /// Customer-managed key encryption
        /// </summary>
        public static EncryptionKeySource Microsoft_KeyVault { get; } = new EncryptionKeySource("Microsoft.KeyVault");

        public static bool operator ==(EncryptionKeySource left, EncryptionKeySource right) => left.Equals(right);
        public static bool operator !=(EncryptionKeySource left, EncryptionKeySource right) => !left.Equals(right);

        public static explicit operator string(EncryptionKeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionKeySource other && Equals(other);
        public bool Equals(EncryptionKeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Encryption type of the capacity pool, set encryption type for data at rest for this pool and all volumes in it. This value can only be set when creating new pool.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionType : IEquatable<EncryptionType>
    {
        private readonly string _value;

        private EncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EncryptionType Single, volumes will use single encryption at rest
        /// </summary>
        public static EncryptionType Single { get; } = new EncryptionType("Single");
        /// <summary>
        /// EncryptionType Double, volumes will use double encryption at rest
        /// </summary>
        public static EncryptionType Double { get; } = new EncryptionType("Double");

        public static bool operator ==(EncryptionType left, EncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionType left, EncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionType other && Equals(other);
        public bool Equals(EncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the local volume is the source or destination for the Volume Replication
    /// </summary>
    [EnumType]
    public readonly struct EndpointType : IEquatable<EndpointType>
    {
        private readonly string _value;

        private EndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointType Src { get; } = new EndpointType("src");
        public static EndpointType Dst { get; } = new EndpointType("dst");

        public static bool operator ==(EndpointType left, EndpointType right) => left.Equals(right);
        public static bool operator !=(EndpointType left, EndpointType right) => !left.Equals(right);

        public static explicit operator string(EndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointType other && Equals(other);
        public bool Equals(EndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
    /// </summary>
    [EnumType]
    public readonly struct KeySource : IEquatable<KeySource>
    {
        private readonly string _value;

        private KeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft-managed key encryption
        /// </summary>
        public static KeySource Microsoft_NetApp { get; } = new KeySource("Microsoft.NetApp");
        /// <summary>
        /// Customer-managed key encryption
        /// </summary>
        public static KeySource Microsoft_KeyVault { get; } = new KeySource("Microsoft.KeyVault");

        public static bool operator ==(KeySource left, KeySource right) => left.Equals(right);
        public static bool operator !=(KeySource left, KeySource right) => !left.Equals(right);

        public static explicit operator string(KeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeySource other && Equals(other);
        public bool Equals(KeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The original value of the network features type available to the volume at the time it was created.
    /// </summary>
    [EnumType]
    public readonly struct NetworkFeatures : IEquatable<NetworkFeatures>
    {
        private readonly string _value;

        private NetworkFeatures(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Basic network features.
        /// </summary>
        public static NetworkFeatures Basic { get; } = new NetworkFeatures("Basic");
        /// <summary>
        /// Standard network features.
        /// </summary>
        public static NetworkFeatures Standard { get; } = new NetworkFeatures("Standard");
        /// <summary>
        /// Updating from Basic to Standard network features.
        /// </summary>
        public static NetworkFeatures Basic_Standard { get; } = new NetworkFeatures("Basic_Standard");
        /// <summary>
        /// Updating from Standard to Basic network features.
        /// </summary>
        public static NetworkFeatures Standard_Basic { get; } = new NetworkFeatures("Standard_Basic");

        public static bool operator ==(NetworkFeatures left, NetworkFeatures right) => left.Equals(right);
        public static bool operator !=(NetworkFeatures left, NetworkFeatures right) => !left.Equals(right);

        public static explicit operator string(NetworkFeatures value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkFeatures other && Equals(other);
        public bool Equals(NetworkFeatures other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The qos type of the pool
    /// </summary>
    [EnumType]
    public readonly struct QosType : IEquatable<QosType>
    {
        private readonly string _value;

        private QosType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// qos type Auto
        /// </summary>
        public static QosType Auto { get; } = new QosType("Auto");
        /// <summary>
        /// qos type Manual
        /// </summary>
        public static QosType Manual { get; } = new QosType("Manual");

        public static bool operator ==(QosType left, QosType right) => left.Equals(right);
        public static bool operator !=(QosType left, QosType right) => !left.Equals(right);

        public static explicit operator string(QosType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is QosType other && Equals(other);
        public bool Equals(QosType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Schedule
    /// </summary>
    [EnumType]
    public readonly struct ReplicationSchedule : IEquatable<ReplicationSchedule>
    {
        private readonly string _value;

        private ReplicationSchedule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationSchedule ReplicationSchedule_10minutely { get; } = new ReplicationSchedule("_10minutely");
        public static ReplicationSchedule Hourly { get; } = new ReplicationSchedule("hourly");
        public static ReplicationSchedule Daily { get; } = new ReplicationSchedule("daily");

        public static bool operator ==(ReplicationSchedule left, ReplicationSchedule right) => left.Equals(right);
        public static bool operator !=(ReplicationSchedule left, ReplicationSchedule right) => !left.Equals(right);

        public static explicit operator string(ReplicationSchedule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationSchedule other && Equals(other);
        public bool Equals(ReplicationSchedule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
    /// </summary>
    [EnumType]
    public readonly struct SecurityStyle : IEquatable<SecurityStyle>
    {
        private readonly string _value;

        private SecurityStyle(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityStyle Ntfs { get; } = new SecurityStyle("ntfs");
        public static SecurityStyle Unix { get; } = new SecurityStyle("unix");

        public static bool operator ==(SecurityStyle left, SecurityStyle right) => left.Equals(right);
        public static bool operator !=(SecurityStyle left, SecurityStyle right) => !left.Equals(right);

        public static explicit operator string(SecurityStyle value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityStyle other && Equals(other);
        public bool Equals(SecurityStyle other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The service level of the file system
    /// </summary>
    [EnumType]
    public readonly struct ServiceLevel : IEquatable<ServiceLevel>
    {
        private readonly string _value;

        private ServiceLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard service level
        /// </summary>
        public static ServiceLevel Standard { get; } = new ServiceLevel("Standard");
        /// <summary>
        /// Premium service level
        /// </summary>
        public static ServiceLevel Premium { get; } = new ServiceLevel("Premium");
        /// <summary>
        /// Ultra service level
        /// </summary>
        public static ServiceLevel Ultra { get; } = new ServiceLevel("Ultra");
        /// <summary>
        /// Zone redundant storage service level
        /// </summary>
        public static ServiceLevel StandardZRS { get; } = new ServiceLevel("StandardZRS");

        public static bool operator ==(ServiceLevel left, ServiceLevel right) => left.Equals(right);
        public static bool operator !=(ServiceLevel left, ServiceLevel right) => !left.Equals(right);

        public static explicit operator string(ServiceLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceLevel other && Equals(other);
        public bool Equals(ServiceLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
    /// </summary>
    [EnumType]
    public readonly struct SmbAccessBasedEnumeration : IEquatable<SmbAccessBasedEnumeration>
    {
        private readonly string _value;

        private SmbAccessBasedEnumeration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// smbAccessBasedEnumeration share setting is disabled
        /// </summary>
        public static SmbAccessBasedEnumeration Disabled { get; } = new SmbAccessBasedEnumeration("Disabled");
        /// <summary>
        /// smbAccessBasedEnumeration share setting is enabled
        /// </summary>
        public static SmbAccessBasedEnumeration Enabled { get; } = new SmbAccessBasedEnumeration("Enabled");

        public static bool operator ==(SmbAccessBasedEnumeration left, SmbAccessBasedEnumeration right) => left.Equals(right);
        public static bool operator !=(SmbAccessBasedEnumeration left, SmbAccessBasedEnumeration right) => !left.Equals(right);

        public static explicit operator string(SmbAccessBasedEnumeration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SmbAccessBasedEnumeration other && Equals(other);
        public bool Equals(SmbAccessBasedEnumeration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
    /// </summary>
    [EnumType]
    public readonly struct SmbNonBrowsable : IEquatable<SmbNonBrowsable>
    {
        private readonly string _value;

        private SmbNonBrowsable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// smbNonBrowsable share setting is disabled
        /// </summary>
        public static SmbNonBrowsable Disabled { get; } = new SmbNonBrowsable("Disabled");
        /// <summary>
        /// smbNonBrowsable share setting is enabled
        /// </summary>
        public static SmbNonBrowsable Enabled { get; } = new SmbNonBrowsable("Enabled");

        public static bool operator ==(SmbNonBrowsable left, SmbNonBrowsable right) => left.Equals(right);
        public static bool operator !=(SmbNonBrowsable left, SmbNonBrowsable right) => !left.Equals(right);

        public static explicit operator string(SmbNonBrowsable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SmbNonBrowsable other && Equals(other);
        public bool Equals(SmbNonBrowsable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of quota
    /// </summary>
    [EnumType]
    public readonly struct Type : IEquatable<Type>
    {
        private readonly string _value;

        private Type(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default user quota
        /// </summary>
        public static Type DefaultUserQuota { get; } = new Type("DefaultUserQuota");
        /// <summary>
        /// Default group quota
        /// </summary>
        public static Type DefaultGroupQuota { get; } = new Type("DefaultGroupQuota");
        /// <summary>
        /// Individual user quota
        /// </summary>
        public static Type IndividualUserQuota { get; } = new Type("IndividualUserQuota");
        /// <summary>
        /// Individual group quota
        /// </summary>
        public static Type IndividualGroupQuota { get; } = new Type("IndividualGroupQuota");

        public static bool operator ==(Type left, Type right) => left.Equals(right);
        public static bool operator !=(Type left, Type right) => !left.Equals(right);

        public static explicit operator string(Type value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Type other && Equals(other);
        public bool Equals(Type other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
