// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.Compute.Latest
{
    /// <summary>
    /// Specifies the caching requirements. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **None** &lt;br&gt;&lt;br&gt; **ReadOnly** &lt;br&gt;&lt;br&gt; **ReadWrite** &lt;br&gt;&lt;br&gt; Default: **None** for Standard storage. **ReadOnly** for Premium storage.
    /// </summary>
    [EnumType]
    public readonly struct CachingTypes : IEquatable<CachingTypes>
    {
        private readonly string _value;

        private CachingTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CachingTypes None { get; } = new CachingTypes("None");
        public static CachingTypes ReadOnly { get; } = new CachingTypes("ReadOnly");
        public static CachingTypes ReadWrite { get; } = new CachingTypes("ReadWrite");

        public static bool operator ==(CachingTypes left, CachingTypes right) => left.Equals(right);
        public static bool operator !=(CachingTypes left, CachingTypes right) => !left.Equals(right);

        public static explicit operator string(CachingTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CachingTypes other && Equals(other);
        public bool Equals(CachingTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
    /// </summary>
    [EnumType]
    public readonly struct ComponentNames : IEquatable<ComponentNames>
    {
        private readonly string _value;

        private ComponentNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComponentNames Microsoft_Windows_Shell_Setup { get; } = new ComponentNames("Microsoft-Windows-Shell-Setup");

        public static bool operator ==(ComponentNames left, ComponentNames right) => left.Equals(right);
        public static bool operator !=(ComponentNames left, ComponentNames right) => !left.Equals(right);

        public static explicit operator string(ComponentNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComponentNames other && Equals(other);
        public bool Equals(ComponentNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the software license type that will be applied to the VMs deployed on the dedicated host. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **None** &lt;br&gt;&lt;br&gt; **Windows_Server_Hybrid** &lt;br&gt;&lt;br&gt; **Windows_Server_Perpetual** &lt;br&gt;&lt;br&gt; Default: **None**
    /// </summary>
    [EnumType]
    public readonly struct DedicatedHostLicenseTypes : IEquatable<DedicatedHostLicenseTypes>
    {
        private readonly string _value;

        private DedicatedHostLicenseTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DedicatedHostLicenseTypes None { get; } = new DedicatedHostLicenseTypes("None");
        public static DedicatedHostLicenseTypes Windows_Server_Hybrid { get; } = new DedicatedHostLicenseTypes("Windows_Server_Hybrid");
        public static DedicatedHostLicenseTypes Windows_Server_Perpetual { get; } = new DedicatedHostLicenseTypes("Windows_Server_Perpetual");

        public static bool operator ==(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => left.Equals(right);
        public static bool operator !=(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => !left.Equals(right);

        public static explicit operator string(DedicatedHostLicenseTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DedicatedHostLicenseTypes other && Equals(other);
        public bool Equals(DedicatedHostLicenseTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk settings for operating system disk.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskOptions : IEquatable<DiffDiskOptions>
    {
        private readonly string _value;

        private DiffDiskOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiffDiskOptions Local { get; } = new DiffDiskOptions("Local");

        public static bool operator ==(DiffDiskOptions left, DiffDiskOptions right) => left.Equals(right);
        public static bool operator !=(DiffDiskOptions left, DiffDiskOptions right) => !left.Equals(right);

        public static explicit operator string(DiffDiskOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskOptions other && Equals(other);
        public bool Equals(DiffDiskOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk placement for operating system disk.&lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **CacheDisk** &lt;br&gt;&lt;br&gt; **ResourceDisk** &lt;br&gt;&lt;br&gt; Default: **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk** is used.&lt;br&gt;&lt;br&gt; Refer to VM size documentation for Windows VM at https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to check which VM sizes exposes a cache disk.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskPlacement : IEquatable<DiffDiskPlacement>
    {
        private readonly string _value;

        private DiffDiskPlacement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiffDiskPlacement CacheDisk { get; } = new DiffDiskPlacement("CacheDisk");
        public static DiffDiskPlacement ResourceDisk { get; } = new DiffDiskPlacement("ResourceDisk");

        public static bool operator ==(DiffDiskPlacement left, DiffDiskPlacement right) => left.Equals(right);
        public static bool operator !=(DiffDiskPlacement left, DiffDiskPlacement right) => !left.Equals(right);

        public static explicit operator string(DiffDiskPlacement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskPlacement other && Equals(other);
        public bool Equals(DiffDiskPlacement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This enumerates the possible sources of a disk's creation.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOption : IEquatable<DiskCreateOption>
    {
        private readonly string _value;

        private DiskCreateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create an empty data disk of a size given by diskSizeGB.
        /// </summary>
        public static DiskCreateOption Empty { get; } = new DiskCreateOption("Empty");
        /// <summary>
        /// Disk will be attached to a VM.
        /// </summary>
        public static DiskCreateOption Attach { get; } = new DiskCreateOption("Attach");
        /// <summary>
        /// Create a new disk from a platform image specified by the given imageReference or galleryImageReference.
        /// </summary>
        public static DiskCreateOption FromImage { get; } = new DiskCreateOption("FromImage");
        /// <summary>
        /// Create a disk by importing from a blob specified by a sourceUri in a storage account specified by storageAccountId.
        /// </summary>
        public static DiskCreateOption Import { get; } = new DiskCreateOption("Import");
        /// <summary>
        /// Create a new disk or snapshot by copying from a disk or snapshot specified by the given sourceResourceId.
        /// </summary>
        public static DiskCreateOption Copy { get; } = new DiskCreateOption("Copy");
        /// <summary>
        /// Create a new disk by copying from a backup recovery point.
        /// </summary>
        public static DiskCreateOption Restore { get; } = new DiskCreateOption("Restore");
        /// <summary>
        /// Create a new disk by obtaining a write token and using it to directly upload the contents of the disk.
        /// </summary>
        public static DiskCreateOption Upload { get; } = new DiskCreateOption("Upload");

        public static bool operator ==(DiskCreateOption left, DiskCreateOption right) => left.Equals(right);
        public static bool operator !=(DiskCreateOption left, DiskCreateOption right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOption other && Equals(other);
        public bool Equals(DiskCreateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the virtual machine should be created.&lt;br&gt;&lt;br&gt; Possible values are:&lt;br&gt;&lt;br&gt; **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.&lt;br&gt;&lt;br&gt; **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOptionTypes : IEquatable<DiskCreateOptionTypes>
    {
        private readonly string _value;

        private DiskCreateOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskCreateOptionTypes FromImage { get; } = new DiskCreateOptionTypes("FromImage");
        public static DiskCreateOptionTypes Empty { get; } = new DiskCreateOptionTypes("Empty");
        public static DiskCreateOptionTypes Attach { get; } = new DiskCreateOptionTypes("Attach");

        public static bool operator ==(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOptionTypes other && Equals(other);
        public bool Equals(DiskCreateOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations. Disk Encryption Sets can be updated with Identity type None during migration of subscription to a new Azure Active Directory tenant; it will cause the encrypted resources to lose access to the keys.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetIdentityType : IEquatable<DiskEncryptionSetIdentityType>
    {
        private readonly string _value;

        private DiskEncryptionSetIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskEncryptionSetIdentityType SystemAssigned { get; } = new DiskEncryptionSetIdentityType("SystemAssigned");
        public static DiskEncryptionSetIdentityType None { get; } = new DiskEncryptionSetIdentityType("None");

        public static bool operator ==(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetIdentityType other && Equals(other);
        public bool Equals(DiskEncryptionSetIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetType : IEquatable<DiskEncryptionSetType>
    {
        private readonly string _value;

        private DiskEncryptionSetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithCustomerKey { get; } = new DiskEncryptionSetType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with two layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new DiskEncryptionSetType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(DiskEncryptionSetType left, DiskEncryptionSetType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetType left, DiskEncryptionSetType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetType other && Equals(other);
        public bool Equals(DiskEncryptionSetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct DiskStorageAccountTypes : IEquatable<DiskStorageAccountTypes>
    {
        private readonly string _value;

        private DiskStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access.
        /// </summary>
        public static DiskStorageAccountTypes Standard_LRS { get; } = new DiskStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage. Best for production and performance sensitive workloads.
        /// </summary>
        public static DiskStorageAccountTypes Premium_LRS { get; } = new DiskStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test.
        /// </summary>
        public static DiskStorageAccountTypes StandardSSD_LRS { get; } = new DiskStorageAccountTypes("StandardSSD_LRS");
        /// <summary>
        /// Ultra SSD locally redundant storage. Best for IO-intensive workloads such as SAP HANA, top tier databases (for example, SQL, Oracle), and other transaction-heavy workloads.
        /// </summary>
        public static DiskStorageAccountTypes UltraSSD_LRS { get; } = new DiskStorageAccountTypes("UltraSSD_LRS");

        public static bool operator ==(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(DiskStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskStorageAccountTypes other && Equals(other);
        public bool Equals(DiskStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionType : IEquatable<EncryptionType>
    {
        private readonly string _value;

        private EncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disk is encrypted at rest with Platform managed key. It is the default encryption type. This is not a valid encryption type for disk encryption sets.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformKey { get; } = new EncryptionType("EncryptionAtRestWithPlatformKey");
        /// <summary>
        /// Disk is encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithCustomerKey { get; } = new EncryptionType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Disk is encrypted at rest with 2 layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new EncryptionType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(EncryptionType left, EncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionType left, EncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionType other && Equals(other);
        public bool Equals(EncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the permission of sharing gallery. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Private** &lt;br&gt;&lt;br&gt; **Groups**
    /// </summary>
    [EnumType]
    public readonly struct GallerySharingPermissionTypes : IEquatable<GallerySharingPermissionTypes>
    {
        private readonly string _value;

        private GallerySharingPermissionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GallerySharingPermissionTypes Private { get; } = new GallerySharingPermissionTypes("Private");
        public static GallerySharingPermissionTypes Groups { get; } = new GallerySharingPermissionTypes("Groups");

        public static bool operator ==(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => left.Equals(right);
        public static bool operator !=(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => !left.Equals(right);

        public static explicit operator string(GallerySharingPermissionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GallerySharingPermissionTypes other && Equals(other);
        public bool Equals(GallerySharingPermissionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The host caching of the disk. Valid values are 'None', 'ReadOnly', and 'ReadWrite'
    /// </summary>
    [EnumType]
    public readonly struct HostCaching : IEquatable<HostCaching>
    {
        private readonly string _value;

        private HostCaching(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostCaching None { get; } = new HostCaching("None");
        public static HostCaching ReadOnly { get; } = new HostCaching("ReadOnly");
        public static HostCaching ReadWrite { get; } = new HostCaching("ReadWrite");

        public static bool operator ==(HostCaching left, HostCaching right) => left.Equals(right);
        public static bool operator !=(HostCaching left, HostCaching right) => !left.Equals(right);

        public static explicit operator string(HostCaching value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostCaching other && Equals(other);
        public bool Equals(HostCaching other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Gets the HyperVGenerationType of the VirtualMachine created from the image
    /// </summary>
    [EnumType]
    public readonly struct HyperVGenerationTypes : IEquatable<HyperVGenerationTypes>
    {
        private readonly string _value;

        private HyperVGenerationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGenerationTypes V1 { get; } = new HyperVGenerationTypes("V1");
        public static HyperVGenerationTypes V2 { get; } = new HyperVGenerationTypes("V2");

        public static bool operator ==(HyperVGenerationTypes left, HyperVGenerationTypes right) => left.Equals(right);
        public static bool operator !=(HyperVGenerationTypes left, HyperVGenerationTypes right) => !left.Equals(right);

        public static explicit operator string(HyperVGenerationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGenerationTypes other && Equals(other);
        public bool Equals(HyperVGenerationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
    /// </summary>
    [EnumType]
    public readonly struct IPVersion : IEquatable<IPVersion>
    {
        private readonly string _value;

        private IPVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPVersion IPv4 { get; } = new IPVersion("IPv4");
        public static IPVersion IPv6 { get; } = new IPVersion("IPv6");

        public static bool operator ==(IPVersion left, IPVersion right) => left.Equals(right);
        public static bool operator !=(IPVersion left, IPVersion right) => !left.Equals(right);

        public static explicit operator string(IPVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPVersion other && Equals(other);
        public bool Equals(IPVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of in-guest patching to IaaS virtual machine.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **Manual** - You  control the application of patches to a virtual machine. You do this by applying patches manually inside the VM. In this mode, automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be false&lt;br /&gt;&lt;br /&gt; **AutomaticByOS** - The virtual machine will automatically be updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates must be true. &lt;br /&gt;&lt;br /&gt; ** AutomaticByPlatform** - the virtual machine will automatically updated by the platform. The properties provisionVMAgent and WindowsConfiguration.enableAutomaticUpdates must be true 
    /// </summary>
    [EnumType]
    public readonly struct InGuestPatchMode : IEquatable<InGuestPatchMode>
    {
        private readonly string _value;

        private InGuestPatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InGuestPatchMode Manual { get; } = new InGuestPatchMode("Manual");
        public static InGuestPatchMode AutomaticByOS { get; } = new InGuestPatchMode("AutomaticByOS");
        public static InGuestPatchMode AutomaticByPlatform { get; } = new InGuestPatchMode("AutomaticByPlatform");

        public static bool operator ==(InGuestPatchMode left, InGuestPatchMode right) => left.Equals(right);
        public static bool operator !=(InGuestPatchMode left, InGuestPatchMode right) => !left.Equals(right);

        public static explicit operator string(InGuestPatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InGuestPatchMode other && Equals(other);
        public bool Equals(InGuestPatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Interval value in minutes used to create LogAnalytics call rate logs.
    /// </summary>
    [EnumType]
    public readonly struct IntervalInMins : IEquatable<IntervalInMins>
    {
        private readonly string _value;

        private IntervalInMins(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntervalInMins ThreeMins { get; } = new IntervalInMins("ThreeMins");
        public static IntervalInMins FiveMins { get; } = new IntervalInMins("FiveMins");
        public static IntervalInMins ThirtyMins { get; } = new IntervalInMins("ThirtyMins");
        public static IntervalInMins SixtyMins { get; } = new IntervalInMins("SixtyMins");

        public static bool operator ==(IntervalInMins left, IntervalInMins right) => left.Equals(right);
        public static bool operator !=(IntervalInMins left, IntervalInMins right) => !left.Equals(right);

        public static explicit operator string(IntervalInMins value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntervalInMins other && Equals(other);
        public bool Equals(IntervalInMins other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Policy for accessing the disk via network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkAccessPolicy : IEquatable<NetworkAccessPolicy>
    {
        private readonly string _value;

        private NetworkAccessPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The disk can be exported or uploaded to from any network.
        /// </summary>
        public static NetworkAccessPolicy AllowAll { get; } = new NetworkAccessPolicy("AllowAll");
        /// <summary>
        /// The disk can be exported or uploaded to using a DiskAccess resource's private endpoints.
        /// </summary>
        public static NetworkAccessPolicy AllowPrivate { get; } = new NetworkAccessPolicy("AllowPrivate");
        /// <summary>
        /// The disk cannot be exported.
        /// </summary>
        public static NetworkAccessPolicy DenyAll { get; } = new NetworkAccessPolicy("DenyAll");

        public static bool operator ==(NetworkAccessPolicy left, NetworkAccessPolicy right) => left.Equals(right);
        public static bool operator !=(NetworkAccessPolicy left, NetworkAccessPolicy right) => !left.Equals(right);

        public static explicit operator string(NetworkAccessPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkAccessPolicy other && Equals(other);
        public bool Equals(NetworkAccessPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS State.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemStateTypes : IEquatable<OperatingSystemStateTypes>
    {
        private readonly string _value;

        private OperatingSystemStateTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Generalized image. Needs to be provisioned during deployment time.
        /// </summary>
        public static OperatingSystemStateTypes Generalized { get; } = new OperatingSystemStateTypes("Generalized");
        /// <summary>
        /// Specialized image. Contains already provisioned OS Disk.
        /// </summary>
        public static OperatingSystemStateTypes Specialized { get; } = new OperatingSystemStateTypes("Specialized");

        public static bool operator ==(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemStateTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemStateTypes other && Equals(other);
        public bool Equals(OperatingSystemStateTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Windows** &lt;br&gt;&lt;br&gt; **Linux**
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pass name. Currently, the only allowable value is OobeSystem.
    /// </summary>
    [EnumType]
    public readonly struct PassNames : IEquatable<PassNames>
    {
        private readonly string _value;

        private PassNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PassNames OobeSystem { get; } = new PassNames("OobeSystem");

        public static bool operator ==(PassNames left, PassNames right) => left.Equals(right);
        public static bool operator !=(PassNames left, PassNames right) => !left.Equals(right);

        public static explicit operator string(PassNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PassNames other && Equals(other);
        public bool Equals(PassNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the protocol of WinRM listener. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;**http** &lt;br&gt;&lt;br&gt; **https**
    /// </summary>
    [EnumType]
    public readonly struct ProtocolTypes : IEquatable<ProtocolTypes>
    {
        private readonly string _value;

        private ProtocolTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProtocolTypes Http { get; } = new ProtocolTypes("Http");
        public static ProtocolTypes Https { get; } = new ProtocolTypes("Https");

        public static bool operator ==(ProtocolTypes left, ProtocolTypes right) => left.Equals(right);
        public static bool operator !=(ProtocolTypes left, ProtocolTypes right) => !left.Equals(right);

        public static explicit operator string(ProtocolTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProtocolTypes other && Equals(other);
        public bool Equals(ProtocolTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the proximity placement group. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Standard** : Co-locate resources within an Azure region or Availability Zone. &lt;br&gt;&lt;br&gt; **Ultra** : For future use.
    /// </summary>
    [EnumType]
    public readonly struct ProximityPlacementGroupType : IEquatable<ProximityPlacementGroupType>
    {
        private readonly string _value;

        private ProximityPlacementGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProximityPlacementGroupType Standard { get; } = new ProximityPlacementGroupType("Standard");
        public static ProximityPlacementGroupType Ultra { get; } = new ProximityPlacementGroupType("Ultra");

        public static bool operator ==(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => left.Equals(right);
        public static bool operator !=(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => !left.Equals(right);

        public static explicit operator string(ProximityPlacementGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProximityPlacementGroupType other && Equals(other);
        public bool Equals(ProximityPlacementGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine scale set.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        public static ResourceIdentityType SystemAssigned_UserAssigned { get; } = new ResourceIdentityType("SystemAssigned, UserAssigned");
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
    /// </summary>
    [EnumType]
    public readonly struct SettingNames : IEquatable<SettingNames>
    {
        private readonly string _value;

        private SettingNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SettingNames AutoLogon { get; } = new SettingNames("AutoLogon");
        public static SettingNames FirstLogonCommands { get; } = new SettingNames("FirstLogonCommands");

        public static bool operator ==(SettingNames left, SettingNames right) => left.Equals(right);
        public static bool operator !=(SettingNames left, SettingNames right) => !left.Equals(right);

        public static explicit operator string(SettingNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingNames other && Equals(other);
        public bool Equals(SettingNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotStorageAccountTypes : IEquatable<SnapshotStorageAccountTypes>
    {
        private readonly string _value;

        private SnapshotStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_LRS { get; } = new SnapshotStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Premium_LRS { get; } = new SnapshotStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard zone redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_ZRS { get; } = new SnapshotStorageAccountTypes("Standard_ZRS");

        public static bool operator ==(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(SnapshotStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotStorageAccountTypes other && Equals(other);
        public bool Equals(SnapshotStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The level code.
    /// </summary>
    [EnumType]
    public readonly struct StatusLevelTypes : IEquatable<StatusLevelTypes>
    {
        private readonly string _value;

        private StatusLevelTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StatusLevelTypes Info { get; } = new StatusLevelTypes("Info");
        public static StatusLevelTypes Warning { get; } = new StatusLevelTypes("Warning");
        public static StatusLevelTypes Error { get; } = new StatusLevelTypes("Error");

        public static bool operator ==(StatusLevelTypes left, StatusLevelTypes right) => left.Equals(right);
        public static bool operator !=(StatusLevelTypes left, StatusLevelTypes right) => !left.Equals(right);

        public static explicit operator string(StatusLevelTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusLevelTypes other && Equals(other);
        public bool Equals(StatusLevelTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type to be used to store the image. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountType Standard_LRS { get; } = new StorageAccountType("Standard_LRS");
        public static StorageAccountType Standard_ZRS { get; } = new StorageAccountType("Standard_ZRS");
        public static StorageAccountType Premium_LRS { get; } = new StorageAccountType("Premium_LRS");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountTypes : IEquatable<StorageAccountTypes>
    {
        private readonly string _value;

        private StorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountTypes Standard_LRS { get; } = new StorageAccountTypes("Standard_LRS");
        public static StorageAccountTypes Premium_LRS { get; } = new StorageAccountTypes("Premium_LRS");
        public static StorageAccountTypes StandardSSD_LRS { get; } = new StorageAccountTypes("StandardSSD_LRS");
        public static StorageAccountTypes UltraSSD_LRS { get; } = new StorageAccountTypes("UltraSSD_LRS");

        public static bool operator ==(StorageAccountTypes left, StorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(StorageAccountTypes left, StorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(StorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountTypes other && Equals(other);
        public bool Equals(StorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of an upgrade to virtual machines in the scale set.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **Manual** - You  control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.&lt;br /&gt;&lt;br /&gt; **Automatic** - All virtual machines in the scale set are  automatically updated at the same time.
    /// </summary>
    [EnumType]
    public readonly struct UpgradeMode : IEquatable<UpgradeMode>
    {
        private readonly string _value;

        private UpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UpgradeMode Automatic { get; } = new UpgradeMode("Automatic");
        public static UpgradeMode Manual { get; } = new UpgradeMode("Manual");
        public static UpgradeMode Rolling { get; } = new UpgradeMode("Rolling");

        public static bool operator ==(UpgradeMode left, UpgradeMode right) => left.Equals(right);
        public static bool operator !=(UpgradeMode left, UpgradeMode right) => !left.Equals(right);

        public static explicit operator string(UpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradeMode other && Equals(other);
        public bool Equals(UpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set. &lt;br&gt;&lt;br&gt;For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01. &lt;br&gt;&lt;br&gt;For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2017-10-30-preview.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineEvictionPolicyTypes : IEquatable<VirtualMachineEvictionPolicyTypes>
    {
        private readonly string _value;

        private VirtualMachineEvictionPolicyTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineEvictionPolicyTypes Deallocate { get; } = new VirtualMachineEvictionPolicyTypes("Deallocate");
        public static VirtualMachineEvictionPolicyTypes Delete { get; } = new VirtualMachineEvictionPolicyTypes("Delete");

        public static bool operator ==(VirtualMachineEvictionPolicyTypes left, VirtualMachineEvictionPolicyTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachineEvictionPolicyTypes left, VirtualMachineEvictionPolicyTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineEvictionPolicyTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineEvictionPolicyTypes other && Equals(other);
        public bool Equals(VirtualMachineEvictionPolicyTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the priority for the virtual machines in the scale set. &lt;br&gt;&lt;br&gt;Minimum api-version: 2017-10-30-preview
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePriorityTypes : IEquatable<VirtualMachinePriorityTypes>
    {
        private readonly string _value;

        private VirtualMachinePriorityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePriorityTypes Regular { get; } = new VirtualMachinePriorityTypes("Regular");
        public static VirtualMachinePriorityTypes Low { get; } = new VirtualMachinePriorityTypes("Low");
        public static VirtualMachinePriorityTypes Spot { get; } = new VirtualMachinePriorityTypes("Spot");

        public static bool operator ==(VirtualMachinePriorityTypes left, VirtualMachinePriorityTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePriorityTypes left, VirtualMachinePriorityTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePriorityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePriorityTypes other && Equals(other);
        public bool Equals(VirtualMachinePriorityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct VirtualMachineScaleSetScaleInRules : IEquatable<VirtualMachineScaleSetScaleInRules>
    {
        private readonly string _value;

        private VirtualMachineScaleSetScaleInRules(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineScaleSetScaleInRules Default { get; } = new VirtualMachineScaleSetScaleInRules("Default");
        public static VirtualMachineScaleSetScaleInRules OldestVM { get; } = new VirtualMachineScaleSetScaleInRules("OldestVM");
        public static VirtualMachineScaleSetScaleInRules NewestVM { get; } = new VirtualMachineScaleSetScaleInRules("NewestVM");

        public static bool operator ==(VirtualMachineScaleSetScaleInRules left, VirtualMachineScaleSetScaleInRules right) => left.Equals(right);
        public static bool operator !=(VirtualMachineScaleSetScaleInRules left, VirtualMachineScaleSetScaleInRules right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineScaleSetScaleInRules value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineScaleSetScaleInRules other && Equals(other);
        public bool Equals(VirtualMachineScaleSetScaleInRules other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the size of the virtual machine. For more information about virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/en-us/azure/virtual-machines/sizes). &lt;br&gt;&lt;br&gt; The available VM sizes depend on region and availability set. For a list of available sizes use these APIs:  &lt;br&gt;&lt;br&gt; [List all available virtual machine sizes in an availability set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes) &lt;br&gt;&lt;br&gt; [List all available virtual machine sizes in a region]( https://docs.microsoft.com/en-us/rest/api/compute/resourceskus/list) &lt;br&gt;&lt;br&gt; [List all available virtual machine sizes for resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes). &lt;br&gt;&lt;br&gt; This list of sizes is no longer updated and the **VirtualMachineSizeTypes** string constants will be removed from the subsequent REST API specification. Use [List all available virtual machine sizes in a region]( https://docs.microsoft.com/en-us/rest/api/compute/resourceskus/list) to get the latest sizes.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineSizeTypes : IEquatable<VirtualMachineSizeTypes>
    {
        private readonly string _value;

        private VirtualMachineSizeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineSizeTypes Basic_A0 { get; } = new VirtualMachineSizeTypes("Basic_A0");
        public static VirtualMachineSizeTypes Basic_A1 { get; } = new VirtualMachineSizeTypes("Basic_A1");
        public static VirtualMachineSizeTypes Basic_A2 { get; } = new VirtualMachineSizeTypes("Basic_A2");
        public static VirtualMachineSizeTypes Basic_A3 { get; } = new VirtualMachineSizeTypes("Basic_A3");
        public static VirtualMachineSizeTypes Basic_A4 { get; } = new VirtualMachineSizeTypes("Basic_A4");
        public static VirtualMachineSizeTypes Standard_A0 { get; } = new VirtualMachineSizeTypes("Standard_A0");
        public static VirtualMachineSizeTypes Standard_A1 { get; } = new VirtualMachineSizeTypes("Standard_A1");
        public static VirtualMachineSizeTypes Standard_A2 { get; } = new VirtualMachineSizeTypes("Standard_A2");
        public static VirtualMachineSizeTypes Standard_A3 { get; } = new VirtualMachineSizeTypes("Standard_A3");
        public static VirtualMachineSizeTypes Standard_A4 { get; } = new VirtualMachineSizeTypes("Standard_A4");
        public static VirtualMachineSizeTypes Standard_A5 { get; } = new VirtualMachineSizeTypes("Standard_A5");
        public static VirtualMachineSizeTypes Standard_A6 { get; } = new VirtualMachineSizeTypes("Standard_A6");
        public static VirtualMachineSizeTypes Standard_A7 { get; } = new VirtualMachineSizeTypes("Standard_A7");
        public static VirtualMachineSizeTypes Standard_A8 { get; } = new VirtualMachineSizeTypes("Standard_A8");
        public static VirtualMachineSizeTypes Standard_A9 { get; } = new VirtualMachineSizeTypes("Standard_A9");
        public static VirtualMachineSizeTypes Standard_A10 { get; } = new VirtualMachineSizeTypes("Standard_A10");
        public static VirtualMachineSizeTypes Standard_A11 { get; } = new VirtualMachineSizeTypes("Standard_A11");
        public static VirtualMachineSizeTypes Standard_A1_v2 { get; } = new VirtualMachineSizeTypes("Standard_A1_v2");
        public static VirtualMachineSizeTypes Standard_A2_v2 { get; } = new VirtualMachineSizeTypes("Standard_A2_v2");
        public static VirtualMachineSizeTypes Standard_A4_v2 { get; } = new VirtualMachineSizeTypes("Standard_A4_v2");
        public static VirtualMachineSizeTypes Standard_A8_v2 { get; } = new VirtualMachineSizeTypes("Standard_A8_v2");
        public static VirtualMachineSizeTypes Standard_A2m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A2m_v2");
        public static VirtualMachineSizeTypes Standard_A4m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A4m_v2");
        public static VirtualMachineSizeTypes Standard_A8m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A8m_v2");
        public static VirtualMachineSizeTypes Standard_B1s { get; } = new VirtualMachineSizeTypes("Standard_B1s");
        public static VirtualMachineSizeTypes Standard_B1ms { get; } = new VirtualMachineSizeTypes("Standard_B1ms");
        public static VirtualMachineSizeTypes Standard_B2s { get; } = new VirtualMachineSizeTypes("Standard_B2s");
        public static VirtualMachineSizeTypes Standard_B2ms { get; } = new VirtualMachineSizeTypes("Standard_B2ms");
        public static VirtualMachineSizeTypes Standard_B4ms { get; } = new VirtualMachineSizeTypes("Standard_B4ms");
        public static VirtualMachineSizeTypes Standard_B8ms { get; } = new VirtualMachineSizeTypes("Standard_B8ms");
        public static VirtualMachineSizeTypes Standard_D1 { get; } = new VirtualMachineSizeTypes("Standard_D1");
        public static VirtualMachineSizeTypes Standard_D2 { get; } = new VirtualMachineSizeTypes("Standard_D2");
        public static VirtualMachineSizeTypes Standard_D3 { get; } = new VirtualMachineSizeTypes("Standard_D3");
        public static VirtualMachineSizeTypes Standard_D4 { get; } = new VirtualMachineSizeTypes("Standard_D4");
        public static VirtualMachineSizeTypes Standard_D11 { get; } = new VirtualMachineSizeTypes("Standard_D11");
        public static VirtualMachineSizeTypes Standard_D12 { get; } = new VirtualMachineSizeTypes("Standard_D12");
        public static VirtualMachineSizeTypes Standard_D13 { get; } = new VirtualMachineSizeTypes("Standard_D13");
        public static VirtualMachineSizeTypes Standard_D14 { get; } = new VirtualMachineSizeTypes("Standard_D14");
        public static VirtualMachineSizeTypes Standard_D1_v2 { get; } = new VirtualMachineSizeTypes("Standard_D1_v2");
        public static VirtualMachineSizeTypes Standard_D2_v2 { get; } = new VirtualMachineSizeTypes("Standard_D2_v2");
        public static VirtualMachineSizeTypes Standard_D3_v2 { get; } = new VirtualMachineSizeTypes("Standard_D3_v2");
        public static VirtualMachineSizeTypes Standard_D4_v2 { get; } = new VirtualMachineSizeTypes("Standard_D4_v2");
        public static VirtualMachineSizeTypes Standard_D5_v2 { get; } = new VirtualMachineSizeTypes("Standard_D5_v2");
        public static VirtualMachineSizeTypes Standard_D2_v3 { get; } = new VirtualMachineSizeTypes("Standard_D2_v3");
        public static VirtualMachineSizeTypes Standard_D4_v3 { get; } = new VirtualMachineSizeTypes("Standard_D4_v3");
        public static VirtualMachineSizeTypes Standard_D8_v3 { get; } = new VirtualMachineSizeTypes("Standard_D8_v3");
        public static VirtualMachineSizeTypes Standard_D16_v3 { get; } = new VirtualMachineSizeTypes("Standard_D16_v3");
        public static VirtualMachineSizeTypes Standard_D32_v3 { get; } = new VirtualMachineSizeTypes("Standard_D32_v3");
        public static VirtualMachineSizeTypes Standard_D64_v3 { get; } = new VirtualMachineSizeTypes("Standard_D64_v3");
        public static VirtualMachineSizeTypes Standard_D2s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D2s_v3");
        public static VirtualMachineSizeTypes Standard_D4s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D4s_v3");
        public static VirtualMachineSizeTypes Standard_D8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D8s_v3");
        public static VirtualMachineSizeTypes Standard_D16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D16s_v3");
        public static VirtualMachineSizeTypes Standard_D32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D32s_v3");
        public static VirtualMachineSizeTypes Standard_D64s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D64s_v3");
        public static VirtualMachineSizeTypes Standard_D11_v2 { get; } = new VirtualMachineSizeTypes("Standard_D11_v2");
        public static VirtualMachineSizeTypes Standard_D12_v2 { get; } = new VirtualMachineSizeTypes("Standard_D12_v2");
        public static VirtualMachineSizeTypes Standard_D13_v2 { get; } = new VirtualMachineSizeTypes("Standard_D13_v2");
        public static VirtualMachineSizeTypes Standard_D14_v2 { get; } = new VirtualMachineSizeTypes("Standard_D14_v2");
        public static VirtualMachineSizeTypes Standard_D15_v2 { get; } = new VirtualMachineSizeTypes("Standard_D15_v2");
        public static VirtualMachineSizeTypes Standard_DS1 { get; } = new VirtualMachineSizeTypes("Standard_DS1");
        public static VirtualMachineSizeTypes Standard_DS2 { get; } = new VirtualMachineSizeTypes("Standard_DS2");
        public static VirtualMachineSizeTypes Standard_DS3 { get; } = new VirtualMachineSizeTypes("Standard_DS3");
        public static VirtualMachineSizeTypes Standard_DS4 { get; } = new VirtualMachineSizeTypes("Standard_DS4");
        public static VirtualMachineSizeTypes Standard_DS11 { get; } = new VirtualMachineSizeTypes("Standard_DS11");
        public static VirtualMachineSizeTypes Standard_DS12 { get; } = new VirtualMachineSizeTypes("Standard_DS12");
        public static VirtualMachineSizeTypes Standard_DS13 { get; } = new VirtualMachineSizeTypes("Standard_DS13");
        public static VirtualMachineSizeTypes Standard_DS14 { get; } = new VirtualMachineSizeTypes("Standard_DS14");
        public static VirtualMachineSizeTypes Standard_DS1_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS1_v2");
        public static VirtualMachineSizeTypes Standard_DS2_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS2_v2");
        public static VirtualMachineSizeTypes Standard_DS3_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS3_v2");
        public static VirtualMachineSizeTypes Standard_DS4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS4_v2");
        public static VirtualMachineSizeTypes Standard_DS5_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS5_v2");
        public static VirtualMachineSizeTypes Standard_DS11_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS11_v2");
        public static VirtualMachineSizeTypes Standard_DS12_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS12_v2");
        public static VirtualMachineSizeTypes Standard_DS13_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13_v2");
        public static VirtualMachineSizeTypes Standard_DS14_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14_v2");
        public static VirtualMachineSizeTypes Standard_DS15_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS15_v2");
        public static VirtualMachineSizeTypes Standard_DS13_4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13-4_v2");
        public static VirtualMachineSizeTypes Standard_DS13_2_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13-2_v2");
        public static VirtualMachineSizeTypes Standard_DS14_8_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14-8_v2");
        public static VirtualMachineSizeTypes Standard_DS14_4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14-4_v2");
        public static VirtualMachineSizeTypes Standard_E2_v3 { get; } = new VirtualMachineSizeTypes("Standard_E2_v3");
        public static VirtualMachineSizeTypes Standard_E4_v3 { get; } = new VirtualMachineSizeTypes("Standard_E4_v3");
        public static VirtualMachineSizeTypes Standard_E8_v3 { get; } = new VirtualMachineSizeTypes("Standard_E8_v3");
        public static VirtualMachineSizeTypes Standard_E16_v3 { get; } = new VirtualMachineSizeTypes("Standard_E16_v3");
        public static VirtualMachineSizeTypes Standard_E32_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32_v3");
        public static VirtualMachineSizeTypes Standard_E64_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64_v3");
        public static VirtualMachineSizeTypes Standard_E2s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E2s_v3");
        public static VirtualMachineSizeTypes Standard_E4s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E4s_v3");
        public static VirtualMachineSizeTypes Standard_E8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E8s_v3");
        public static VirtualMachineSizeTypes Standard_E16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E16s_v3");
        public static VirtualMachineSizeTypes Standard_E32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32s_v3");
        public static VirtualMachineSizeTypes Standard_E64s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64s_v3");
        public static VirtualMachineSizeTypes Standard_E32_16_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32-16_v3");
        public static VirtualMachineSizeTypes Standard_E32_8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32-8s_v3");
        public static VirtualMachineSizeTypes Standard_E64_32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64-32s_v3");
        public static VirtualMachineSizeTypes Standard_E64_16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64-16s_v3");
        public static VirtualMachineSizeTypes Standard_F1 { get; } = new VirtualMachineSizeTypes("Standard_F1");
        public static VirtualMachineSizeTypes Standard_F2 { get; } = new VirtualMachineSizeTypes("Standard_F2");
        public static VirtualMachineSizeTypes Standard_F4 { get; } = new VirtualMachineSizeTypes("Standard_F4");
        public static VirtualMachineSizeTypes Standard_F8 { get; } = new VirtualMachineSizeTypes("Standard_F8");
        public static VirtualMachineSizeTypes Standard_F16 { get; } = new VirtualMachineSizeTypes("Standard_F16");
        public static VirtualMachineSizeTypes Standard_F1s { get; } = new VirtualMachineSizeTypes("Standard_F1s");
        public static VirtualMachineSizeTypes Standard_F2s { get; } = new VirtualMachineSizeTypes("Standard_F2s");
        public static VirtualMachineSizeTypes Standard_F4s { get; } = new VirtualMachineSizeTypes("Standard_F4s");
        public static VirtualMachineSizeTypes Standard_F8s { get; } = new VirtualMachineSizeTypes("Standard_F8s");
        public static VirtualMachineSizeTypes Standard_F16s { get; } = new VirtualMachineSizeTypes("Standard_F16s");
        public static VirtualMachineSizeTypes Standard_F2s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F2s_v2");
        public static VirtualMachineSizeTypes Standard_F4s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F4s_v2");
        public static VirtualMachineSizeTypes Standard_F8s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F8s_v2");
        public static VirtualMachineSizeTypes Standard_F16s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F16s_v2");
        public static VirtualMachineSizeTypes Standard_F32s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F32s_v2");
        public static VirtualMachineSizeTypes Standard_F64s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F64s_v2");
        public static VirtualMachineSizeTypes Standard_F72s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F72s_v2");
        public static VirtualMachineSizeTypes Standard_G1 { get; } = new VirtualMachineSizeTypes("Standard_G1");
        public static VirtualMachineSizeTypes Standard_G2 { get; } = new VirtualMachineSizeTypes("Standard_G2");
        public static VirtualMachineSizeTypes Standard_G3 { get; } = new VirtualMachineSizeTypes("Standard_G3");
        public static VirtualMachineSizeTypes Standard_G4 { get; } = new VirtualMachineSizeTypes("Standard_G4");
        public static VirtualMachineSizeTypes Standard_G5 { get; } = new VirtualMachineSizeTypes("Standard_G5");
        public static VirtualMachineSizeTypes Standard_GS1 { get; } = new VirtualMachineSizeTypes("Standard_GS1");
        public static VirtualMachineSizeTypes Standard_GS2 { get; } = new VirtualMachineSizeTypes("Standard_GS2");
        public static VirtualMachineSizeTypes Standard_GS3 { get; } = new VirtualMachineSizeTypes("Standard_GS3");
        public static VirtualMachineSizeTypes Standard_GS4 { get; } = new VirtualMachineSizeTypes("Standard_GS4");
        public static VirtualMachineSizeTypes Standard_GS5 { get; } = new VirtualMachineSizeTypes("Standard_GS5");
        public static VirtualMachineSizeTypes Standard_GS4_8 { get; } = new VirtualMachineSizeTypes("Standard_GS4-8");
        public static VirtualMachineSizeTypes Standard_GS4_4 { get; } = new VirtualMachineSizeTypes("Standard_GS4-4");
        public static VirtualMachineSizeTypes Standard_GS5_16 { get; } = new VirtualMachineSizeTypes("Standard_GS5-16");
        public static VirtualMachineSizeTypes Standard_GS5_8 { get; } = new VirtualMachineSizeTypes("Standard_GS5-8");
        public static VirtualMachineSizeTypes Standard_H8 { get; } = new VirtualMachineSizeTypes("Standard_H8");
        public static VirtualMachineSizeTypes Standard_H16 { get; } = new VirtualMachineSizeTypes("Standard_H16");
        public static VirtualMachineSizeTypes Standard_H8m { get; } = new VirtualMachineSizeTypes("Standard_H8m");
        public static VirtualMachineSizeTypes Standard_H16m { get; } = new VirtualMachineSizeTypes("Standard_H16m");
        public static VirtualMachineSizeTypes Standard_H16r { get; } = new VirtualMachineSizeTypes("Standard_H16r");
        public static VirtualMachineSizeTypes Standard_H16mr { get; } = new VirtualMachineSizeTypes("Standard_H16mr");
        public static VirtualMachineSizeTypes Standard_L4s { get; } = new VirtualMachineSizeTypes("Standard_L4s");
        public static VirtualMachineSizeTypes Standard_L8s { get; } = new VirtualMachineSizeTypes("Standard_L8s");
        public static VirtualMachineSizeTypes Standard_L16s { get; } = new VirtualMachineSizeTypes("Standard_L16s");
        public static VirtualMachineSizeTypes Standard_L32s { get; } = new VirtualMachineSizeTypes("Standard_L32s");
        public static VirtualMachineSizeTypes Standard_M64s { get; } = new VirtualMachineSizeTypes("Standard_M64s");
        public static VirtualMachineSizeTypes Standard_M64ms { get; } = new VirtualMachineSizeTypes("Standard_M64ms");
        public static VirtualMachineSizeTypes Standard_M128s { get; } = new VirtualMachineSizeTypes("Standard_M128s");
        public static VirtualMachineSizeTypes Standard_M128ms { get; } = new VirtualMachineSizeTypes("Standard_M128ms");
        public static VirtualMachineSizeTypes Standard_M64_32ms { get; } = new VirtualMachineSizeTypes("Standard_M64-32ms");
        public static VirtualMachineSizeTypes Standard_M64_16ms { get; } = new VirtualMachineSizeTypes("Standard_M64-16ms");
        public static VirtualMachineSizeTypes Standard_M128_64ms { get; } = new VirtualMachineSizeTypes("Standard_M128-64ms");
        public static VirtualMachineSizeTypes Standard_M128_32ms { get; } = new VirtualMachineSizeTypes("Standard_M128-32ms");
        public static VirtualMachineSizeTypes Standard_NC6 { get; } = new VirtualMachineSizeTypes("Standard_NC6");
        public static VirtualMachineSizeTypes Standard_NC12 { get; } = new VirtualMachineSizeTypes("Standard_NC12");
        public static VirtualMachineSizeTypes Standard_NC24 { get; } = new VirtualMachineSizeTypes("Standard_NC24");
        public static VirtualMachineSizeTypes Standard_NC24r { get; } = new VirtualMachineSizeTypes("Standard_NC24r");
        public static VirtualMachineSizeTypes Standard_NC6s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC6s_v2");
        public static VirtualMachineSizeTypes Standard_NC12s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC12s_v2");
        public static VirtualMachineSizeTypes Standard_NC24s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC24s_v2");
        public static VirtualMachineSizeTypes Standard_NC24rs_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC24rs_v2");
        public static VirtualMachineSizeTypes Standard_NC6s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC6s_v3");
        public static VirtualMachineSizeTypes Standard_NC12s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC12s_v3");
        public static VirtualMachineSizeTypes Standard_NC24s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC24s_v3");
        public static VirtualMachineSizeTypes Standard_NC24rs_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC24rs_v3");
        public static VirtualMachineSizeTypes Standard_ND6s { get; } = new VirtualMachineSizeTypes("Standard_ND6s");
        public static VirtualMachineSizeTypes Standard_ND12s { get; } = new VirtualMachineSizeTypes("Standard_ND12s");
        public static VirtualMachineSizeTypes Standard_ND24s { get; } = new VirtualMachineSizeTypes("Standard_ND24s");
        public static VirtualMachineSizeTypes Standard_ND24rs { get; } = new VirtualMachineSizeTypes("Standard_ND24rs");
        public static VirtualMachineSizeTypes Standard_NV6 { get; } = new VirtualMachineSizeTypes("Standard_NV6");
        public static VirtualMachineSizeTypes Standard_NV12 { get; } = new VirtualMachineSizeTypes("Standard_NV12");
        public static VirtualMachineSizeTypes Standard_NV24 { get; } = new VirtualMachineSizeTypes("Standard_NV24");

        public static bool operator ==(VirtualMachineSizeTypes left, VirtualMachineSizeTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachineSizeTypes left, VirtualMachineSizeTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineSizeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineSizeTypes other && Equals(other);
        public bool Equals(VirtualMachineSizeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
