// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Compute.V20201201
{
    /// <summary>
    /// Specifies the caching requirements. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **None** &lt;br&gt;&lt;br&gt; **ReadOnly** &lt;br&gt;&lt;br&gt; **ReadWrite** &lt;br&gt;&lt;br&gt; Default: **None for Standard storage. ReadOnly for Premium storage**
    /// </summary>
    [EnumType]
    public readonly struct CachingTypes : IEquatable<CachingTypes>
    {
        private readonly string _value;

        private CachingTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CachingTypes None { get; } = new CachingTypes("None");
        public static CachingTypes ReadOnly { get; } = new CachingTypes("ReadOnly");
        public static CachingTypes ReadWrite { get; } = new CachingTypes("ReadWrite");

        public static bool operator ==(CachingTypes left, CachingTypes right) => left.Equals(right);
        public static bool operator !=(CachingTypes left, CachingTypes right) => !left.Equals(right);

        public static explicit operator string(CachingTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CachingTypes other && Equals(other);
        public bool Equals(CachingTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the software license type that will be applied to the VMs deployed on the dedicated host. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **None** &lt;br&gt;&lt;br&gt; **Windows_Server_Hybrid** &lt;br&gt;&lt;br&gt; **Windows_Server_Perpetual** &lt;br&gt;&lt;br&gt; Default: **None**
    /// </summary>
    [EnumType]
    public readonly struct DedicatedHostLicenseTypes : IEquatable<DedicatedHostLicenseTypes>
    {
        private readonly string _value;

        private DedicatedHostLicenseTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DedicatedHostLicenseTypes None { get; } = new DedicatedHostLicenseTypes("None");
        public static DedicatedHostLicenseTypes Windows_Server_Hybrid { get; } = new DedicatedHostLicenseTypes("Windows_Server_Hybrid");
        public static DedicatedHostLicenseTypes Windows_Server_Perpetual { get; } = new DedicatedHostLicenseTypes("Windows_Server_Perpetual");

        public static bool operator ==(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => left.Equals(right);
        public static bool operator !=(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => !left.Equals(right);

        public static explicit operator string(DedicatedHostLicenseTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DedicatedHostLicenseTypes other && Equals(other);
        public bool Equals(DedicatedHostLicenseTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This enumerates the possible sources of a disk's creation.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOption : IEquatable<DiskCreateOption>
    {
        private readonly string _value;

        private DiskCreateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create an empty data disk of a size given by diskSizeGB.
        /// </summary>
        public static DiskCreateOption Empty { get; } = new DiskCreateOption("Empty");
        /// <summary>
        /// Disk will be attached to a VM.
        /// </summary>
        public static DiskCreateOption Attach { get; } = new DiskCreateOption("Attach");
        /// <summary>
        /// Create a new disk from a platform image specified by the given imageReference or galleryImageReference.
        /// </summary>
        public static DiskCreateOption FromImage { get; } = new DiskCreateOption("FromImage");
        /// <summary>
        /// Create a disk by importing from a blob specified by a sourceUri in a storage account specified by storageAccountId.
        /// </summary>
        public static DiskCreateOption Import { get; } = new DiskCreateOption("Import");
        /// <summary>
        /// Create a new disk or snapshot by copying from a disk or snapshot specified by the given sourceResourceId.
        /// </summary>
        public static DiskCreateOption Copy { get; } = new DiskCreateOption("Copy");
        /// <summary>
        /// Create a new disk by copying from a backup recovery point.
        /// </summary>
        public static DiskCreateOption Restore { get; } = new DiskCreateOption("Restore");
        /// <summary>
        /// Create a new disk by obtaining a write token and using it to directly upload the contents of the disk.
        /// </summary>
        public static DiskCreateOption Upload { get; } = new DiskCreateOption("Upload");

        public static bool operator ==(DiskCreateOption left, DiskCreateOption right) => left.Equals(right);
        public static bool operator !=(DiskCreateOption left, DiskCreateOption right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOption other && Equals(other);
        public bool Equals(DiskCreateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations. Disk Encryption Sets can be updated with Identity type None during migration of subscription to a new Azure Active Directory tenant; it will cause the encrypted resources to lose access to the keys.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetIdentityType : IEquatable<DiskEncryptionSetIdentityType>
    {
        private readonly string _value;

        private DiskEncryptionSetIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskEncryptionSetIdentityType SystemAssigned { get; } = new DiskEncryptionSetIdentityType("SystemAssigned");
        public static DiskEncryptionSetIdentityType None { get; } = new DiskEncryptionSetIdentityType("None");

        public static bool operator ==(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetIdentityType other && Equals(other);
        public bool Equals(DiskEncryptionSetIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetType : IEquatable<DiskEncryptionSetType>
    {
        private readonly string _value;

        private DiskEncryptionSetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithCustomerKey { get; } = new DiskEncryptionSetType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with two layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new DiskEncryptionSetType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(DiskEncryptionSetType left, DiskEncryptionSetType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetType left, DiskEncryptionSetType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetType other && Equals(other);
        public bool Equals(DiskEncryptionSetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the SecurityType of the VM. Applicable for OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct DiskSecurityTypes : IEquatable<DiskSecurityTypes>
    {
        private readonly string _value;

        private DiskSecurityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Trusted Launch provides security features such as secure boot and virtual Trusted Platform Module (vTPM)
        /// </summary>
        public static DiskSecurityTypes TrustedLaunch { get; } = new DiskSecurityTypes("TrustedLaunch");

        public static bool operator ==(DiskSecurityTypes left, DiskSecurityTypes right) => left.Equals(right);
        public static bool operator !=(DiskSecurityTypes left, DiskSecurityTypes right) => !left.Equals(right);

        public static explicit operator string(DiskSecurityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskSecurityTypes other && Equals(other);
        public bool Equals(DiskSecurityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct DiskStorageAccountTypes : IEquatable<DiskStorageAccountTypes>
    {
        private readonly string _value;

        private DiskStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access.
        /// </summary>
        public static DiskStorageAccountTypes Standard_LRS { get; } = new DiskStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage. Best for production and performance sensitive workloads.
        /// </summary>
        public static DiskStorageAccountTypes Premium_LRS { get; } = new DiskStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test.
        /// </summary>
        public static DiskStorageAccountTypes StandardSSD_LRS { get; } = new DiskStorageAccountTypes("StandardSSD_LRS");
        /// <summary>
        /// Ultra SSD locally redundant storage. Best for IO-intensive workloads such as SAP HANA, top tier databases (for example, SQL, Oracle), and other transaction-heavy workloads.
        /// </summary>
        public static DiskStorageAccountTypes UltraSSD_LRS { get; } = new DiskStorageAccountTypes("UltraSSD_LRS");
        /// <summary>
        /// Premium SSD zone redundant storage. Best for the production workloads that need storage resiliency against zone failures.
        /// </summary>
        public static DiskStorageAccountTypes Premium_ZRS { get; } = new DiskStorageAccountTypes("Premium_ZRS");
        /// <summary>
        /// Standard SSD zone redundant storage. Best for web servers, lightly used enterprise applications and dev/test that need storage resiliency against zone failures.
        /// </summary>
        public static DiskStorageAccountTypes StandardSSD_ZRS { get; } = new DiskStorageAccountTypes("StandardSSD_ZRS");

        public static bool operator ==(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(DiskStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskStorageAccountTypes other && Equals(other);
        public bool Equals(DiskStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionType : IEquatable<EncryptionType>
    {
        private readonly string _value;

        private EncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disk is encrypted at rest with Platform managed key. It is the default encryption type. This is not a valid encryption type for disk encryption sets.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformKey { get; } = new EncryptionType("EncryptionAtRestWithPlatformKey");
        /// <summary>
        /// Disk is encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithCustomerKey { get; } = new EncryptionType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Disk is encrypted at rest with 2 layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new EncryptionType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(EncryptionType left, EncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionType left, EncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionType other && Equals(other);
        public bool Equals(EncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the HyperVGenerationType of the VirtualMachine created from the image. From API Version 2019-03-01 if the image source is a blob, then we need the user to specify the value, if the source is managed resource like disk or snapshot, we may require the user to specify the property if we cannot deduce it from the source managed resource.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGenerationTypes : IEquatable<HyperVGenerationTypes>
    {
        private readonly string _value;

        private HyperVGenerationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGenerationTypes V1 { get; } = new HyperVGenerationTypes("V1");
        public static HyperVGenerationTypes V2 { get; } = new HyperVGenerationTypes("V2");

        public static bool operator ==(HyperVGenerationTypes left, HyperVGenerationTypes right) => left.Equals(right);
        public static bool operator !=(HyperVGenerationTypes left, HyperVGenerationTypes right) => !left.Equals(right);

        public static explicit operator string(HyperVGenerationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGenerationTypes other && Equals(other);
        public bool Equals(HyperVGenerationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Interval value in minutes used to create LogAnalytics call rate logs.
    /// </summary>
    [EnumType]
    public readonly struct IntervalInMins : IEquatable<IntervalInMins>
    {
        private readonly string _value;

        private IntervalInMins(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntervalInMins ThreeMins { get; } = new IntervalInMins("ThreeMins");
        public static IntervalInMins FiveMins { get; } = new IntervalInMins("FiveMins");
        public static IntervalInMins ThirtyMins { get; } = new IntervalInMins("ThirtyMins");
        public static IntervalInMins SixtyMins { get; } = new IntervalInMins("SixtyMins");

        public static bool operator ==(IntervalInMins left, IntervalInMins right) => left.Equals(right);
        public static bool operator !=(IntervalInMins left, IntervalInMins right) => !left.Equals(right);

        public static explicit operator string(IntervalInMins value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntervalInMins other && Equals(other);
        public bool Equals(IntervalInMins other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Policy for accessing the disk via network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkAccessPolicy : IEquatable<NetworkAccessPolicy>
    {
        private readonly string _value;

        private NetworkAccessPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The disk can be exported or uploaded to from any network.
        /// </summary>
        public static NetworkAccessPolicy AllowAll { get; } = new NetworkAccessPolicy("AllowAll");
        /// <summary>
        /// The disk can be exported or uploaded to using a DiskAccess resource's private endpoints.
        /// </summary>
        public static NetworkAccessPolicy AllowPrivate { get; } = new NetworkAccessPolicy("AllowPrivate");
        /// <summary>
        /// The disk cannot be exported.
        /// </summary>
        public static NetworkAccessPolicy DenyAll { get; } = new NetworkAccessPolicy("DenyAll");

        public static bool operator ==(NetworkAccessPolicy left, NetworkAccessPolicy right) => left.Equals(right);
        public static bool operator !=(NetworkAccessPolicy left, NetworkAccessPolicy right) => !left.Equals(right);

        public static explicit operator string(NetworkAccessPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkAccessPolicy other && Equals(other);
        public bool Equals(NetworkAccessPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS State.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemStateTypes : IEquatable<OperatingSystemStateTypes>
    {
        private readonly string _value;

        private OperatingSystemStateTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Generalized image. Needs to be provisioned during deployment time.
        /// </summary>
        public static OperatingSystemStateTypes Generalized { get; } = new OperatingSystemStateTypes("Generalized");
        /// <summary>
        /// Specialized image. Contains already provisioned OS Disk.
        /// </summary>
        public static OperatingSystemStateTypes Specialized { get; } = new OperatingSystemStateTypes("Specialized");

        public static bool operator ==(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemStateTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemStateTypes other && Equals(other);
        public bool Equals(OperatingSystemStateTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Operating System type.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the proximity placement group. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Standard** : Co-locate resources within an Azure region or Availability Zone. &lt;br&gt;&lt;br&gt; **Ultra** : For future use.
    /// </summary>
    [EnumType]
    public readonly struct ProximityPlacementGroupType : IEquatable<ProximityPlacementGroupType>
    {
        private readonly string _value;

        private ProximityPlacementGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProximityPlacementGroupType Standard { get; } = new ProximityPlacementGroupType("Standard");
        public static ProximityPlacementGroupType Ultra { get; } = new ProximityPlacementGroupType("Ultra");

        public static bool operator ==(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => left.Equals(right);
        public static bool operator !=(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => !left.Equals(right);

        public static explicit operator string(ProximityPlacementGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProximityPlacementGroupType other && Equals(other);
        public bool Equals(ProximityPlacementGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotStorageAccountTypes : IEquatable<SnapshotStorageAccountTypes>
    {
        private readonly string _value;

        private SnapshotStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_LRS { get; } = new SnapshotStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Premium_LRS { get; } = new SnapshotStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard zone redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_ZRS { get; } = new SnapshotStorageAccountTypes("Standard_ZRS");

        public static bool operator ==(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(SnapshotStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotStorageAccountTypes other && Equals(other);
        public bool Equals(SnapshotStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The level code.
    /// </summary>
    [EnumType]
    public readonly struct StatusLevelTypes : IEquatable<StatusLevelTypes>
    {
        private readonly string _value;

        private StatusLevelTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StatusLevelTypes Info { get; } = new StatusLevelTypes("Info");
        public static StatusLevelTypes Warning { get; } = new StatusLevelTypes("Warning");
        public static StatusLevelTypes Error { get; } = new StatusLevelTypes("Error");

        public static bool operator ==(StatusLevelTypes left, StatusLevelTypes right) => left.Equals(right);
        public static bool operator !=(StatusLevelTypes left, StatusLevelTypes right) => !left.Equals(right);

        public static explicit operator string(StatusLevelTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusLevelTypes other && Equals(other);
        public bool Equals(StatusLevelTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountTypes : IEquatable<StorageAccountTypes>
    {
        private readonly string _value;

        private StorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountTypes Standard_LRS { get; } = new StorageAccountTypes("Standard_LRS");
        public static StorageAccountTypes Premium_LRS { get; } = new StorageAccountTypes("Premium_LRS");
        public static StorageAccountTypes StandardSSD_LRS { get; } = new StorageAccountTypes("StandardSSD_LRS");
        public static StorageAccountTypes UltraSSD_LRS { get; } = new StorageAccountTypes("UltraSSD_LRS");
        public static StorageAccountTypes Premium_ZRS { get; } = new StorageAccountTypes("Premium_ZRS");
        public static StorageAccountTypes StandardSSD_ZRS { get; } = new StorageAccountTypes("StandardSSD_ZRS");

        public static bool operator ==(StorageAccountTypes left, StorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(StorageAccountTypes left, StorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(StorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountTypes other && Equals(other);
        public bool Equals(StorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
