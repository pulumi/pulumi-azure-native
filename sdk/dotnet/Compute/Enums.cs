// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Compute
{
    /// <summary>
    /// This property allows you to specify whether the access control rules are in Audit mode, in Enforce mode or Disabled. Possible values are: 'Audit', 'Enforce' or 'Disabled'.
    /// </summary>
    [EnumType]
    public readonly struct AccessControlRulesMode : IEquatable<AccessControlRulesMode>
    {
        private readonly string _value;

        private AccessControlRulesMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessControlRulesMode Audit { get; } = new AccessControlRulesMode("Audit");
        public static AccessControlRulesMode Enforce { get; } = new AccessControlRulesMode("Enforce");
        public static AccessControlRulesMode Disabled { get; } = new AccessControlRulesMode("Disabled");

        public static bool operator ==(AccessControlRulesMode left, AccessControlRulesMode right) => left.Equals(right);
        public static bool operator !=(AccessControlRulesMode left, AccessControlRulesMode right) => !left.Equals(right);

        public static explicit operator string(AccessControlRulesMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessControlRulesMode other && Equals(other);
        public bool Equals(AccessControlRulesMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the allocation strategy for the virtual machine scale set based on which the VMs will be allocated.
    /// </summary>
    [EnumType]
    public readonly struct AllocationStrategy : IEquatable<AllocationStrategy>
    {
        private readonly string _value;

        private AllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllocationStrategy LowestPrice { get; } = new AllocationStrategy("LowestPrice");
        public static AllocationStrategy CapacityOptimized { get; } = new AllocationStrategy("CapacityOptimized");
        public static AllocationStrategy Prioritized { get; } = new AllocationStrategy("Prioritized");

        public static bool operator ==(AllocationStrategy left, AllocationStrategy right) => left.Equals(right);
        public static bool operator !=(AllocationStrategy left, AllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(AllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationStrategy other && Equals(other);
        public bool Equals(AllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CPU architecture supported by an OS disk.
    /// </summary>
    [EnumType]
    public readonly struct Architecture : IEquatable<Architecture>
    {
        private readonly string _value;

        private Architecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Architecture X64 { get; } = new Architecture("x64");
        public static Architecture Arm64 { get; } = new Architecture("Arm64");

        public static bool operator ==(Architecture left, Architecture right) => left.Equals(right);
        public static bool operator !=(Architecture left, Architecture right) => !left.Equals(right);

        public static explicit operator string(Architecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Architecture other && Equals(other);
        public bool Equals(Architecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the caching requirements. Possible values are: **None,** **ReadOnly,** **ReadWrite.** The defaulting behavior is: **None for Standard storage. ReadOnly for Premium storage.**
    /// </summary>
    [EnumType]
    public readonly struct CachingTypes : IEquatable<CachingTypes>
    {
        private readonly string _value;

        private CachingTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CachingTypes None { get; } = new CachingTypes("None");
        public static CachingTypes ReadOnly { get; } = new CachingTypes("ReadOnly");
        public static CachingTypes ReadWrite { get; } = new CachingTypes("ReadWrite");

        public static bool operator ==(CachingTypes left, CachingTypes right) => left.Equals(right);
        public static bool operator !=(CachingTypes left, CachingTypes right) => !left.Equals(right);

        public static explicit operator string(CachingTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CachingTypes other && Equals(other);
        public bool Equals(CachingTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Slot type for the cloud service.
    /// Possible values are &lt;br /&gt;&lt;br /&gt;**Production**&lt;br /&gt;&lt;br /&gt;**Staging**&lt;br /&gt;&lt;br /&gt;
    /// If not specified, the default value is Production.
    /// </summary>
    [EnumType]
    public readonly struct CloudServiceSlotType : IEquatable<CloudServiceSlotType>
    {
        private readonly string _value;

        private CloudServiceSlotType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudServiceSlotType Production { get; } = new CloudServiceSlotType("Production");
        public static CloudServiceSlotType Staging { get; } = new CloudServiceSlotType("Staging");

        public static bool operator ==(CloudServiceSlotType left, CloudServiceSlotType right) => left.Equals(right);
        public static bool operator !=(CloudServiceSlotType left, CloudServiceSlotType right) => !left.Equals(right);

        public static explicit operator string(CloudServiceSlotType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudServiceSlotType other && Equals(other);
        public bool Equals(CloudServiceSlotType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Update mode for the cloud service. Role instances are allocated to update domains when the service is deployed. Updates can be initiated manually in each update domain or initiated automatically in all update domains.
    /// Possible Values are &lt;br /&gt;&lt;br /&gt;**Auto**&lt;br /&gt;&lt;br /&gt;**Manual** &lt;br /&gt;&lt;br /&gt;**Simultaneous**&lt;br /&gt;&lt;br /&gt;
    /// If not specified, the default value is Auto. If set to Manual, PUT UpdateDomain must be called to apply the update. If set to Auto, the update is automatically applied to each update domain in sequence.
    /// </summary>
    [EnumType]
    public readonly struct CloudServiceUpgradeMode : IEquatable<CloudServiceUpgradeMode>
    {
        private readonly string _value;

        private CloudServiceUpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudServiceUpgradeMode Auto { get; } = new CloudServiceUpgradeMode("Auto");
        public static CloudServiceUpgradeMode Manual { get; } = new CloudServiceUpgradeMode("Manual");
        public static CloudServiceUpgradeMode Simultaneous { get; } = new CloudServiceUpgradeMode("Simultaneous");

        public static bool operator ==(CloudServiceUpgradeMode left, CloudServiceUpgradeMode right) => left.Equals(right);
        public static bool operator !=(CloudServiceUpgradeMode left, CloudServiceUpgradeMode right) => !left.Equals(right);

        public static explicit operator string(CloudServiceUpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudServiceUpgradeMode other && Equals(other);
        public bool Equals(CloudServiceUpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
    /// </summary>
    [EnumType]
    public readonly struct ComponentNames : IEquatable<ComponentNames>
    {
        private readonly string _value;

        private ComponentNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComponentNames Microsoft_Windows_Shell_Setup { get; } = new ComponentNames("Microsoft-Windows-Shell-Setup");

        public static bool operator ==(ComponentNames left, ComponentNames right) => left.Equals(right);
        public static bool operator !=(ComponentNames left, ComponentNames right) => !left.Equals(right);

        public static explicit operator string(ComponentNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComponentNames other && Equals(other);
        public bool Equals(ComponentNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// confidential VM encryption types
    /// </summary>
    [EnumType]
    public readonly struct ConfidentialVMEncryptionType : IEquatable<ConfidentialVMEncryptionType>
    {
        private readonly string _value;

        private ConfidentialVMEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConfidentialVMEncryptionType EncryptedVMGuestStateOnlyWithPmk { get; } = new ConfidentialVMEncryptionType("EncryptedVMGuestStateOnlyWithPmk");
        public static ConfidentialVMEncryptionType EncryptedWithPmk { get; } = new ConfidentialVMEncryptionType("EncryptedWithPmk");
        public static ConfidentialVMEncryptionType EncryptedWithCmk { get; } = new ConfidentialVMEncryptionType("EncryptedWithCmk");
        public static ConfidentialVMEncryptionType NonPersistedTPM { get; } = new ConfidentialVMEncryptionType("NonPersistedTPM");

        public static bool operator ==(ConfidentialVMEncryptionType left, ConfidentialVMEncryptionType right) => left.Equals(right);
        public static bool operator !=(ConfidentialVMEncryptionType left, ConfidentialVMEncryptionType right) => !left.Equals(right);

        public static explicit operator string(ConfidentialVMEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConfidentialVMEncryptionType other && Equals(other);
        public bool Equals(ConfidentialVMEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ConsistencyMode of the RestorePoint. Can be specified in the input while creating a restore point. For now, only CrashConsistent is accepted as a valid input. Please refer to https://aka.ms/RestorePoints for more details.
    /// </summary>
    [EnumType]
    public readonly struct ConsistencyModeTypes : IEquatable<ConsistencyModeTypes>
    {
        private readonly string _value;

        private ConsistencyModeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConsistencyModeTypes CrashConsistent { get; } = new ConsistencyModeTypes("CrashConsistent");
        public static ConsistencyModeTypes FileSystemConsistent { get; } = new ConsistencyModeTypes("FileSystemConsistent");
        public static ConsistencyModeTypes ApplicationConsistent { get; } = new ConsistencyModeTypes("ApplicationConsistent");

        public static bool operator ==(ConsistencyModeTypes left, ConsistencyModeTypes right) => left.Equals(right);
        public static bool operator !=(ConsistencyModeTypes left, ConsistencyModeTypes right) => !left.Equals(right);

        public static explicit operator string(ConsistencyModeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsistencyModeTypes other && Equals(other);
        public bool Equals(ConsistencyModeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the error code if the background copy of a resource created via the CopyStart operation fails.
    /// </summary>
    [EnumType]
    public readonly struct CopyCompletionErrorReason : IEquatable<CopyCompletionErrorReason>
    {
        private readonly string _value;

        private CopyCompletionErrorReason(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that the source snapshot was deleted while the background copy of the resource created via CopyStart operation was in progress.
        /// </summary>
        public static CopyCompletionErrorReason CopySourceNotFound { get; } = new CopyCompletionErrorReason("CopySourceNotFound");

        public static bool operator ==(CopyCompletionErrorReason left, CopyCompletionErrorReason right) => left.Equals(right);
        public static bool operator !=(CopyCompletionErrorReason left, CopyCompletionErrorReason right) => !left.Equals(right);

        public static explicit operator string(CopyCompletionErrorReason value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CopyCompletionErrorReason other && Equals(other);
        public bool Equals(CopyCompletionErrorReason other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Additional authentication requirements when exporting or uploading to a disk or snapshot.
    /// </summary>
    [EnumType]
    public readonly struct DataAccessAuthMode : IEquatable<DataAccessAuthMode>
    {
        private readonly string _value;

        private DataAccessAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// When export/upload URL is used, the system checks if the user has an identity in Azure Active Directory and has necessary permissions to export/upload the data. Please refer to aka.ms/DisksAzureADAuth.
        /// </summary>
        public static DataAccessAuthMode AzureActiveDirectory { get; } = new DataAccessAuthMode("AzureActiveDirectory");
        /// <summary>
        /// No additional authentication would be performed when accessing export/upload URL.
        /// </summary>
        public static DataAccessAuthMode None { get; } = new DataAccessAuthMode("None");

        public static bool operator ==(DataAccessAuthMode left, DataAccessAuthMode right) => left.Equals(right);
        public static bool operator !=(DataAccessAuthMode left, DataAccessAuthMode right) => !left.Equals(right);

        public static explicit operator string(DataAccessAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataAccessAuthMode other && Equals(other);
        public bool Equals(DataAccessAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the software license type that will be applied to the VMs deployed on the dedicated host. Possible values are: **None,** **Windows_Server_Hybrid,** **Windows_Server_Perpetual.** The default value is: **None.**
    /// </summary>
    [EnumType]
    public readonly struct DedicatedHostLicenseTypes : IEquatable<DedicatedHostLicenseTypes>
    {
        private readonly string _value;

        private DedicatedHostLicenseTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DedicatedHostLicenseTypes None { get; } = new DedicatedHostLicenseTypes("None");
        public static DedicatedHostLicenseTypes Windows_Server_Hybrid { get; } = new DedicatedHostLicenseTypes("Windows_Server_Hybrid");
        public static DedicatedHostLicenseTypes Windows_Server_Perpetual { get; } = new DedicatedHostLicenseTypes("Windows_Server_Perpetual");

        public static bool operator ==(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => left.Equals(right);
        public static bool operator !=(DedicatedHostLicenseTypes left, DedicatedHostLicenseTypes right) => !left.Equals(right);

        public static explicit operator string(DedicatedHostLicenseTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DedicatedHostLicenseTypes other && Equals(other);
        public bool Equals(DedicatedHostLicenseTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify what happens to the public IP when the VM is deleted
    /// </summary>
    [EnumType]
    public readonly struct DeleteOptions : IEquatable<DeleteOptions>
    {
        private readonly string _value;

        private DeleteOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeleteOptions Delete { get; } = new DeleteOptions("Delete");
        public static DeleteOptions Detach { get; } = new DeleteOptions("Detach");

        public static bool operator ==(DeleteOptions left, DeleteOptions right) => left.Equals(right);
        public static bool operator !=(DeleteOptions left, DeleteOptions right) => !left.Equals(right);

        public static explicit operator string(DeleteOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeleteOptions other && Equals(other);
        public bool Equals(DeleteOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk settings for operating system disk.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskOptions : IEquatable<DiffDiskOptions>
    {
        private readonly string _value;

        private DiffDiskOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiffDiskOptions Local { get; } = new DiffDiskOptions("Local");

        public static bool operator ==(DiffDiskOptions left, DiffDiskOptions right) => left.Equals(right);
        public static bool operator !=(DiffDiskOptions left, DiffDiskOptions right) => !left.Equals(right);

        public static explicit operator string(DiffDiskOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskOptions other && Equals(other);
        public bool Equals(DiffDiskOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk placement for operating system disk. Possible values are: **CacheDisk,** **ResourceDisk,** **NvmeDisk.** The defaulting behavior is: **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk** or **NvmeDisk** is used. Refer to the VM size documentation for Windows VM at https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM sizes exposes a cache disk. Minimum api-version for NvmeDisk: 2024-03-01.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskPlacement : IEquatable<DiffDiskPlacement>
    {
        private readonly string _value;

        private DiffDiskPlacement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiffDiskPlacement CacheDisk { get; } = new DiffDiskPlacement("CacheDisk");
        public static DiffDiskPlacement ResourceDisk { get; } = new DiffDiskPlacement("ResourceDisk");
        public static DiffDiskPlacement NvmeDisk { get; } = new DiffDiskPlacement("NvmeDisk");

        public static bool operator ==(DiffDiskPlacement left, DiffDiskPlacement right) => left.Equals(right);
        public static bool operator !=(DiffDiskPlacement left, DiffDiskPlacement right) => !left.Equals(right);

        public static explicit operator string(DiffDiskPlacement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskPlacement other && Equals(other);
        public bool Equals(DiffDiskPlacement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk controller type configured for the VM. **Note:** This property will be set to the default disk controller type if not specified provided virtual machine is being created with 'hyperVGeneration' set to V2 based on the capabilities of the operating system disk and VM size from the the specified minimum api version. You need to deallocate the VM before updating its disk controller type unless you are updating the VM size in the VM configuration which implicitly deallocates and reallocates the VM. Minimum api-version: 2022-08-01.
    /// </summary>
    [EnumType]
    public readonly struct DiskControllerTypes : IEquatable<DiskControllerTypes>
    {
        private readonly string _value;

        private DiskControllerTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskControllerTypes SCSI { get; } = new DiskControllerTypes("SCSI");
        public static DiskControllerTypes NVMe { get; } = new DiskControllerTypes("NVMe");

        public static bool operator ==(DiskControllerTypes left, DiskControllerTypes right) => left.Equals(right);
        public static bool operator !=(DiskControllerTypes left, DiskControllerTypes right) => !left.Equals(right);

        public static explicit operator string(DiskControllerTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskControllerTypes other && Equals(other);
        public bool Equals(DiskControllerTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This enumerates the possible sources of a disk's creation.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOption : IEquatable<DiskCreateOption>
    {
        private readonly string _value;

        private DiskCreateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create an empty data disk of a size given by diskSizeGB.
        /// </summary>
        public static DiskCreateOption Empty { get; } = new DiskCreateOption("Empty");
        /// <summary>
        /// Disk will be attached to a VM.
        /// </summary>
        public static DiskCreateOption Attach { get; } = new DiskCreateOption("Attach");
        /// <summary>
        /// Create a new disk from a platform image specified by the given imageReference or galleryImageReference.
        /// </summary>
        public static DiskCreateOption FromImage { get; } = new DiskCreateOption("FromImage");
        /// <summary>
        /// Create a disk by importing from a blob specified by a sourceUri in a storage account specified by storageAccountId.
        /// </summary>
        public static DiskCreateOption Import { get; } = new DiskCreateOption("Import");
        /// <summary>
        /// Create a new disk or snapshot by copying from a disk or snapshot specified by the given sourceResourceId.
        /// </summary>
        public static DiskCreateOption Copy { get; } = new DiskCreateOption("Copy");
        /// <summary>
        /// Create a new disk by copying from a backup recovery point.
        /// </summary>
        public static DiskCreateOption Restore { get; } = new DiskCreateOption("Restore");
        /// <summary>
        /// Create a new disk by obtaining a write token and using it to directly upload the contents of the disk.
        /// </summary>
        public static DiskCreateOption Upload { get; } = new DiskCreateOption("Upload");
        /// <summary>
        /// Create a new disk by using a deep copy process, where the resource creation is considered complete only after all data has been copied from the source.
        /// </summary>
        public static DiskCreateOption CopyStart { get; } = new DiskCreateOption("CopyStart");
        /// <summary>
        /// Similar to Import create option. Create a new Trusted Launch VM or Confidential VM supported disk by importing additional blob for VM guest state specified by securityDataUri in storage account specified by storageAccountId
        /// </summary>
        public static DiskCreateOption ImportSecure { get; } = new DiskCreateOption("ImportSecure");
        /// <summary>
        /// Similar to Upload create option. Create a new Trusted Launch VM or Confidential VM supported disk and upload using write token in both disk and VM guest state
        /// </summary>
        public static DiskCreateOption UploadPreparedSecure { get; } = new DiskCreateOption("UploadPreparedSecure");
        /// <summary>
        /// Create a new disk by exporting from elastic san volume snapshot
        /// </summary>
        public static DiskCreateOption CopyFromSanSnapshot { get; } = new DiskCreateOption("CopyFromSanSnapshot");

        public static bool operator ==(DiskCreateOption left, DiskCreateOption right) => left.Equals(right);
        public static bool operator !=(DiskCreateOption left, DiskCreateOption right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOption other && Equals(other);
        public bool Equals(DiskCreateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the virtual machine disk should be created. Possible values are **Attach:** This value is used when you are using a specialized disk to create the virtual machine. **FromImage:** This value is used when you are using an image to create the virtual machine. If you are using a platform image, you should also use the imageReference element described above. If you are using a marketplace image, you should also use the plan element previously described.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOptionTypes : IEquatable<DiskCreateOptionTypes>
    {
        private readonly string _value;

        private DiskCreateOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskCreateOptionTypes FromImage { get; } = new DiskCreateOptionTypes("FromImage");
        public static DiskCreateOptionTypes Empty { get; } = new DiskCreateOptionTypes("Empty");
        public static DiskCreateOptionTypes Attach { get; } = new DiskCreateOptionTypes("Attach");
        public static DiskCreateOptionTypes Copy { get; } = new DiskCreateOptionTypes("Copy");
        public static DiskCreateOptionTypes Restore { get; } = new DiskCreateOptionTypes("Restore");

        public static bool operator ==(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOptionTypes other && Equals(other);
        public bool Equals(DiskCreateOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether OS Disk should be deleted or detached upon VM deletion. Possible values are: **Delete.** If this value is used, the OS disk is deleted when VM is deleted. **Detach.** If this value is used, the os disk is retained after VM is deleted. The default value is set to **Detach**. For an ephemeral OS Disk, the default value is set to **Delete**. The user cannot change the delete option for an ephemeral OS Disk.
    /// </summary>
    [EnumType]
    public readonly struct DiskDeleteOptionTypes : IEquatable<DiskDeleteOptionTypes>
    {
        private readonly string _value;

        private DiskDeleteOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskDeleteOptionTypes Delete { get; } = new DiskDeleteOptionTypes("Delete");
        public static DiskDeleteOptionTypes Detach { get; } = new DiskDeleteOptionTypes("Detach");

        public static bool operator ==(DiskDeleteOptionTypes left, DiskDeleteOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskDeleteOptionTypes left, DiskDeleteOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskDeleteOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskDeleteOptionTypes other && Equals(other);
        public bool Equals(DiskDeleteOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the detach behavior to be used while detaching a disk or which is already in the process of detachment from the virtual machine. Supported values: **ForceDetach.** detachOption: **ForceDetach** is applicable only for managed data disks. If a previous detachment attempt of the data disk did not complete due to an unexpected failure from the virtual machine and the disk is still not released then use force-detach as a last resort option to detach the disk forcibly from the VM. All writes might not have been flushed when using this detach behavior. To force-detach a data disk update toBeDetached to 'true' along with setting detachOption: 'ForceDetach'.
    /// </summary>
    [EnumType]
    public readonly struct DiskDetachOptionTypes : IEquatable<DiskDetachOptionTypes>
    {
        private readonly string _value;

        private DiskDetachOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskDetachOptionTypes ForceDetach { get; } = new DiskDetachOptionTypes("ForceDetach");

        public static bool operator ==(DiskDetachOptionTypes left, DiskDetachOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskDetachOptionTypes left, DiskDetachOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskDetachOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskDetachOptionTypes other && Equals(other);
        public bool Equals(DiskDetachOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations. Disk Encryption Sets can be updated with Identity type None during migration of subscription to a new Azure Active Directory tenant; it will cause the encrypted resources to lose access to the keys.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetIdentityType : IEquatable<DiskEncryptionSetIdentityType>
    {
        private readonly string _value;

        private DiskEncryptionSetIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskEncryptionSetIdentityType SystemAssigned { get; } = new DiskEncryptionSetIdentityType("SystemAssigned");
        public static DiskEncryptionSetIdentityType UserAssigned { get; } = new DiskEncryptionSetIdentityType("UserAssigned");
        public static DiskEncryptionSetIdentityType SystemAssigned_UserAssigned { get; } = new DiskEncryptionSetIdentityType("SystemAssigned, UserAssigned");
        public static DiskEncryptionSetIdentityType None { get; } = new DiskEncryptionSetIdentityType("None");

        public static bool operator ==(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetIdentityType left, DiskEncryptionSetIdentityType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetIdentityType other && Equals(other);
        public bool Equals(DiskEncryptionSetIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct DiskEncryptionSetType : IEquatable<DiskEncryptionSetType>
    {
        private readonly string _value;

        private DiskEncryptionSetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithCustomerKey { get; } = new DiskEncryptionSetType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Resource using diskEncryptionSet would be encrypted at rest with two layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static DiskEncryptionSetType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new DiskEncryptionSetType("EncryptionAtRestWithPlatformAndCustomerKeys");
        /// <summary>
        /// Confidential VM supported disk and VM guest state would be encrypted with customer managed key.
        /// </summary>
        public static DiskEncryptionSetType ConfidentialVmEncryptedWithCustomerKey { get; } = new DiskEncryptionSetType("ConfidentialVmEncryptedWithCustomerKey");

        public static bool operator ==(DiskEncryptionSetType left, DiskEncryptionSetType right) => left.Equals(right);
        public static bool operator !=(DiskEncryptionSetType left, DiskEncryptionSetType right) => !left.Equals(right);

        public static explicit operator string(DiskEncryptionSetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskEncryptionSetType other && Equals(other);
        public bool Equals(DiskEncryptionSetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the SecurityType of the VM. Applicable for OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct DiskSecurityTypes : IEquatable<DiskSecurityTypes>
    {
        private readonly string _value;

        private DiskSecurityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Trusted Launch provides security features such as secure boot and virtual Trusted Platform Module (vTPM)
        /// </summary>
        public static DiskSecurityTypes TrustedLaunch { get; } = new DiskSecurityTypes("TrustedLaunch");
        /// <summary>
        /// Indicates Confidential VM disk with only VM guest state encrypted
        /// </summary>
        public static DiskSecurityTypes ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey { get; } = new DiskSecurityTypes("ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey");
        /// <summary>
        /// Indicates Confidential VM disk with both OS disk and VM guest state encrypted with a platform managed key
        /// </summary>
        public static DiskSecurityTypes ConfidentialVM_DiskEncryptedWithPlatformKey { get; } = new DiskSecurityTypes("ConfidentialVM_DiskEncryptedWithPlatformKey");
        /// <summary>
        /// Indicates Confidential VM disk with both OS disk and VM guest state encrypted with a customer managed key
        /// </summary>
        public static DiskSecurityTypes ConfidentialVM_DiskEncryptedWithCustomerKey { get; } = new DiskSecurityTypes("ConfidentialVM_DiskEncryptedWithCustomerKey");
        /// <summary>
        /// Indicates Confidential VM disk with a ephemeral vTPM. vTPM state is not persisted across VM reboots.
        /// </summary>
        public static DiskSecurityTypes ConfidentialVM_NonPersistedTPM { get; } = new DiskSecurityTypes("ConfidentialVM_NonPersistedTPM");

        public static bool operator ==(DiskSecurityTypes left, DiskSecurityTypes right) => left.Equals(right);
        public static bool operator !=(DiskSecurityTypes left, DiskSecurityTypes right) => !left.Equals(right);

        public static explicit operator string(DiskSecurityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskSecurityTypes other && Equals(other);
        public bool Equals(DiskSecurityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct DiskStorageAccountTypes : IEquatable<DiskStorageAccountTypes>
    {
        private readonly string _value;

        private DiskStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access.
        /// </summary>
        public static DiskStorageAccountTypes Standard_LRS { get; } = new DiskStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage. Best for production and performance sensitive workloads.
        /// </summary>
        public static DiskStorageAccountTypes Premium_LRS { get; } = new DiskStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test.
        /// </summary>
        public static DiskStorageAccountTypes StandardSSD_LRS { get; } = new DiskStorageAccountTypes("StandardSSD_LRS");
        /// <summary>
        /// Ultra SSD locally redundant storage. Best for IO-intensive workloads such as SAP HANA, top tier databases (for example, SQL, Oracle), and other transaction-heavy workloads.
        /// </summary>
        public static DiskStorageAccountTypes UltraSSD_LRS { get; } = new DiskStorageAccountTypes("UltraSSD_LRS");
        /// <summary>
        /// Premium SSD zone redundant storage. Best for the production workloads that need storage resiliency against zone failures.
        /// </summary>
        public static DiskStorageAccountTypes Premium_ZRS { get; } = new DiskStorageAccountTypes("Premium_ZRS");
        /// <summary>
        /// Standard SSD zone redundant storage. Best for web servers, lightly used enterprise applications and dev/test that need storage resiliency against zone failures.
        /// </summary>
        public static DiskStorageAccountTypes StandardSSD_ZRS { get; } = new DiskStorageAccountTypes("StandardSSD_ZRS");
        /// <summary>
        /// Premium SSD v2 locally redundant storage. Best for production and performance-sensitive workloads that consistently require low latency and high IOPS and throughput.
        /// </summary>
        public static DiskStorageAccountTypes PremiumV2_LRS { get; } = new DiskStorageAccountTypes("PremiumV2_LRS");

        public static bool operator ==(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(DiskStorageAccountTypes left, DiskStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(DiskStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskStorageAccountTypes other && Equals(other);
        public bool Equals(DiskStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Domain name label scope.The concatenation of the hashed domain name label that generated according to the policy from domain name label scope and vm index will be the domain name labels of the PublicIPAddress resources that will be created
    /// </summary>
    [EnumType]
    public readonly struct DomainNameLabelScopeTypes : IEquatable<DomainNameLabelScopeTypes>
    {
        private readonly string _value;

        private DomainNameLabelScopeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainNameLabelScopeTypes TenantReuse { get; } = new DomainNameLabelScopeTypes("TenantReuse");
        public static DomainNameLabelScopeTypes SubscriptionReuse { get; } = new DomainNameLabelScopeTypes("SubscriptionReuse");
        public static DomainNameLabelScopeTypes ResourceGroupReuse { get; } = new DomainNameLabelScopeTypes("ResourceGroupReuse");
        public static DomainNameLabelScopeTypes NoReuse { get; } = new DomainNameLabelScopeTypes("NoReuse");

        public static bool operator ==(DomainNameLabelScopeTypes left, DomainNameLabelScopeTypes right) => left.Equals(right);
        public static bool operator !=(DomainNameLabelScopeTypes left, DomainNameLabelScopeTypes right) => !left.Equals(right);

        public static explicit operator string(DomainNameLabelScopeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainNameLabelScopeTypes other && Equals(other);
        public bool Equals(DomainNameLabelScopeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type to be used to store the image. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct EdgeZoneStorageAccountType : IEquatable<EdgeZoneStorageAccountType>
    {
        private readonly string _value;

        private EdgeZoneStorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EdgeZoneStorageAccountType Standard_LRS { get; } = new EdgeZoneStorageAccountType("Standard_LRS");
        public static EdgeZoneStorageAccountType Standard_ZRS { get; } = new EdgeZoneStorageAccountType("Standard_ZRS");
        public static EdgeZoneStorageAccountType StandardSSD_LRS { get; } = new EdgeZoneStorageAccountType("StandardSSD_LRS");
        public static EdgeZoneStorageAccountType Premium_LRS { get; } = new EdgeZoneStorageAccountType("Premium_LRS");

        public static bool operator ==(EdgeZoneStorageAccountType left, EdgeZoneStorageAccountType right) => left.Equals(right);
        public static bool operator !=(EdgeZoneStorageAccountType left, EdgeZoneStorageAccountType right) => !left.Equals(right);

        public static explicit operator string(EdgeZoneStorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EdgeZoneStorageAccountType other && Equals(other);
        public bool Equals(EdgeZoneStorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionType : IEquatable<EncryptionType>
    {
        private readonly string _value;

        private EncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disk is encrypted at rest with Platform managed key. It is the default encryption type. This is not a valid encryption type for disk encryption sets.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformKey { get; } = new EncryptionType("EncryptionAtRestWithPlatformKey");
        /// <summary>
        /// Disk is encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithCustomerKey { get; } = new EncryptionType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Disk is encrypted at rest with 2 layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static EncryptionType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new EncryptionType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(EncryptionType left, EncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionType left, EncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionType other && Equals(other);
        public bool Equals(EncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify if the requests will be allowed to access the host endpoints. Possible values are: 'Allow', 'Deny'.
    /// </summary>
    [EnumType]
    public readonly struct EndpointAccess : IEquatable<EndpointAccess>
    {
        private readonly string _value;

        private EndpointAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointAccess Allow { get; } = new EndpointAccess("Allow");
        public static EndpointAccess Deny { get; } = new EndpointAccess("Deny");

        public static bool operator ==(EndpointAccess left, EndpointAccess right) => left.Equals(right);
        public static bool operator !=(EndpointAccess left, EndpointAccess right) => !left.Equals(right);

        public static explicit operator string(EndpointAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointAccess other && Equals(other);
        public bool Equals(EndpointAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the Endpoint type for which this profile is defining the access control for. Possible values are: 'WireServer' or 'IMDS'
    /// </summary>
    [EnumType]
    public readonly struct EndpointTypes : IEquatable<EndpointTypes>
    {
        private readonly string _value;

        private EndpointTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointTypes WireServer { get; } = new EndpointTypes("WireServer");
        public static EndpointTypes IMDS { get; } = new EndpointTypes("IMDS");

        public static bool operator ==(EndpointTypes left, EndpointTypes right) => left.Equals(right);
        public static bool operator !=(EndpointTypes left, EndpointTypes right) => !left.Equals(right);

        public static explicit operator string(EndpointTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointTypes other && Equals(other);
        public bool Equals(EndpointTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the custom action parameter. Possible values are: String, ConfigurationDataBlob or LogOutputBlob
    /// </summary>
    [EnumType]
    public readonly struct GalleryApplicationCustomActionParameterType : IEquatable<GalleryApplicationCustomActionParameterType>
    {
        private readonly string _value;

        private GalleryApplicationCustomActionParameterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GalleryApplicationCustomActionParameterType String { get; } = new GalleryApplicationCustomActionParameterType("String");
        public static GalleryApplicationCustomActionParameterType ConfigurationDataBlob { get; } = new GalleryApplicationCustomActionParameterType("ConfigurationDataBlob");
        public static GalleryApplicationCustomActionParameterType LogOutputBlob { get; } = new GalleryApplicationCustomActionParameterType("LogOutputBlob");

        public static bool operator ==(GalleryApplicationCustomActionParameterType left, GalleryApplicationCustomActionParameterType right) => left.Equals(right);
        public static bool operator !=(GalleryApplicationCustomActionParameterType left, GalleryApplicationCustomActionParameterType right) => !left.Equals(right);

        public static explicit operator string(GalleryApplicationCustomActionParameterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GalleryApplicationCustomActionParameterType other && Equals(other);
        public bool Equals(GalleryApplicationCustomActionParameterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The action to be taken with regards to install/update/remove of the gallery application in the event of a reboot.
    /// </summary>
    [EnumType]
    public readonly struct GalleryApplicationScriptRebootBehavior : IEquatable<GalleryApplicationScriptRebootBehavior>
    {
        private readonly string _value;

        private GalleryApplicationScriptRebootBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GalleryApplicationScriptRebootBehavior None { get; } = new GalleryApplicationScriptRebootBehavior("None");
        public static GalleryApplicationScriptRebootBehavior Rerun { get; } = new GalleryApplicationScriptRebootBehavior("Rerun");

        public static bool operator ==(GalleryApplicationScriptRebootBehavior left, GalleryApplicationScriptRebootBehavior right) => left.Equals(right);
        public static bool operator !=(GalleryApplicationScriptRebootBehavior left, GalleryApplicationScriptRebootBehavior right) => !left.Equals(right);

        public static explicit operator string(GalleryApplicationScriptRebootBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GalleryApplicationScriptRebootBehavior other && Equals(other);
        public bool Equals(GalleryApplicationScriptRebootBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// It is type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct GalleryExtendedLocationType : IEquatable<GalleryExtendedLocationType>
    {
        private readonly string _value;

        private GalleryExtendedLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GalleryExtendedLocationType EdgeZone { get; } = new GalleryExtendedLocationType("EdgeZone");
        public static GalleryExtendedLocationType Unknown { get; } = new GalleryExtendedLocationType("Unknown");

        public static bool operator ==(GalleryExtendedLocationType left, GalleryExtendedLocationType right) => left.Equals(right);
        public static bool operator !=(GalleryExtendedLocationType left, GalleryExtendedLocationType right) => !left.Equals(right);

        public static explicit operator string(GalleryExtendedLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GalleryExtendedLocationType other && Equals(other);
        public bool Equals(GalleryExtendedLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the permission of sharing gallery. Possible values are: **Private,** **Groups,** **Community.**
    /// </summary>
    [EnumType]
    public readonly struct GallerySharingPermissionTypes : IEquatable<GallerySharingPermissionTypes>
    {
        private readonly string _value;

        private GallerySharingPermissionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GallerySharingPermissionTypes Private { get; } = new GallerySharingPermissionTypes("Private");
        public static GallerySharingPermissionTypes Groups { get; } = new GallerySharingPermissionTypes("Groups");
        public static GallerySharingPermissionTypes Community { get; } = new GallerySharingPermissionTypes("Community");

        public static bool operator ==(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => left.Equals(right);
        public static bool operator !=(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => !left.Equals(right);

        public static explicit operator string(GallerySharingPermissionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GallerySharingPermissionTypes other && Equals(other);
        public bool Equals(GallerySharingPermissionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The host caching of the disk. Valid values are 'None', 'ReadOnly', and 'ReadWrite'
    /// </summary>
    [EnumType]
    public readonly struct HostCaching : IEquatable<HostCaching>
    {
        private readonly string _value;

        private HostCaching(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostCaching None { get; } = new HostCaching("None");
        public static HostCaching ReadOnly { get; } = new HostCaching("ReadOnly");
        public static HostCaching ReadWrite { get; } = new HostCaching("ReadWrite");

        public static bool operator ==(HostCaching left, HostCaching right) => left.Equals(right);
        public static bool operator !=(HostCaching left, HostCaching right) => !left.Equals(right);

        public static explicit operator string(HostCaching value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostCaching other && Equals(other);
        public bool Equals(HostCaching other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the HyperVGenerationType of the VirtualMachine created from the image. From API Version 2019-03-01 if the image source is a blob, then we need the user to specify the value, if the source is managed resource like disk or snapshot, we may require the user to specify the property if we cannot deduce it from the source managed resource.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGenerationTypes : IEquatable<HyperVGenerationTypes>
    {
        private readonly string _value;

        private HyperVGenerationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGenerationTypes V1 { get; } = new HyperVGenerationTypes("V1");
        public static HyperVGenerationTypes V2 { get; } = new HyperVGenerationTypes("V2");

        public static bool operator ==(HyperVGenerationTypes left, HyperVGenerationTypes right) => left.Equals(right);
        public static bool operator !=(HyperVGenerationTypes left, HyperVGenerationTypes right) => !left.Equals(right);

        public static explicit operator string(HyperVGenerationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGenerationTypes other && Equals(other);
        public bool Equals(HyperVGenerationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
    /// </summary>
    [EnumType]
    public readonly struct IPVersion : IEquatable<IPVersion>
    {
        private readonly string _value;

        private IPVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPVersion IPv4 { get; } = new IPVersion("IPv4");
        public static IPVersion IPv6 { get; } = new IPVersion("IPv6");

        public static bool operator ==(IPVersion left, IPVersion right) => left.Equals(right);
        public static bool operator !=(IPVersion left, IPVersion right) => !left.Equals(right);

        public static explicit operator string(IPVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPVersion other && Equals(other);
        public bool Equals(IPVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
    /// </summary>
    [EnumType]
    public readonly struct IPVersions : IEquatable<IPVersions>
    {
        private readonly string _value;

        private IPVersions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPVersions IPv4 { get; } = new IPVersions("IPv4");
        public static IPVersions IPv6 { get; } = new IPVersions("IPv6");

        public static bool operator ==(IPVersions left, IPVersions right) => left.Equals(right);
        public static bool operator !=(IPVersions left, IPVersions right) => !left.Equals(right);

        public static explicit operator string(IPVersions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPVersions other && Equals(other);
        public bool Equals(IPVersions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Interval value in minutes used to create LogAnalytics call rate logs.
    /// </summary>
    [EnumType]
    public readonly struct IntervalInMins : IEquatable<IntervalInMins>
    {
        private readonly string _value;

        private IntervalInMins(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntervalInMins ThreeMins { get; } = new IntervalInMins("ThreeMins");
        public static IntervalInMins FiveMins { get; } = new IntervalInMins("FiveMins");
        public static IntervalInMins ThirtyMins { get; } = new IntervalInMins("ThirtyMins");
        public static IntervalInMins SixtyMins { get; } = new IntervalInMins("SixtyMins");

        public static bool operator ==(IntervalInMins left, IntervalInMins right) => left.Equals(right);
        public static bool operator !=(IntervalInMins left, IntervalInMins right) => !left.Equals(right);

        public static explicit operator string(IntervalInMins value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntervalInMins other && Equals(other);
        public bool Equals(IntervalInMins other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual machine.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - You control the timing of patch assessments on a virtual machine. &lt;br /&gt;&lt;br /&gt; **AutomaticByPlatform** - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
    /// </summary>
    [EnumType]
    public readonly struct LinuxPatchAssessmentMode : IEquatable<LinuxPatchAssessmentMode>
    {
        private readonly string _value;

        private LinuxPatchAssessmentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinuxPatchAssessmentMode ImageDefault { get; } = new LinuxPatchAssessmentMode("ImageDefault");
        public static LinuxPatchAssessmentMode AutomaticByPlatform { get; } = new LinuxPatchAssessmentMode("AutomaticByPlatform");

        public static bool operator ==(LinuxPatchAssessmentMode left, LinuxPatchAssessmentMode right) => left.Equals(right);
        public static bool operator !=(LinuxPatchAssessmentMode left, LinuxPatchAssessmentMode right) => !left.Equals(right);

        public static explicit operator string(LinuxPatchAssessmentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxPatchAssessmentMode other && Equals(other);
        public bool Equals(LinuxPatchAssessmentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
    /// </summary>
    [EnumType]
    public readonly struct LinuxVMGuestPatchAutomaticByPlatformRebootSetting : IEquatable<LinuxVMGuestPatchAutomaticByPlatformRebootSetting>
    {
        private readonly string _value;

        private LinuxVMGuestPatchAutomaticByPlatformRebootSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Unknown { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Unknown");
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting IfRequired { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("IfRequired");
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Never { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Never");
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Always { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Always");

        public static bool operator ==(LinuxVMGuestPatchAutomaticByPlatformRebootSetting left, LinuxVMGuestPatchAutomaticByPlatformRebootSetting right) => left.Equals(right);
        public static bool operator !=(LinuxVMGuestPatchAutomaticByPlatformRebootSetting left, LinuxVMGuestPatchAutomaticByPlatformRebootSetting right) => !left.Equals(right);

        public static explicit operator string(LinuxVMGuestPatchAutomaticByPlatformRebootSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxVMGuestPatchAutomaticByPlatformRebootSetting other && Equals(other);
        public bool Equals(LinuxVMGuestPatchAutomaticByPlatformRebootSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual machine scale set with OrchestrationMode as Flexible.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - The virtual machine's default patching configuration is used. &lt;br /&gt;&lt;br /&gt; **AutomaticByPlatform** - The virtual machine will be automatically updated by the platform. The property provisionVMAgent must be true
    /// </summary>
    [EnumType]
    public readonly struct LinuxVMGuestPatchMode : IEquatable<LinuxVMGuestPatchMode>
    {
        private readonly string _value;

        private LinuxVMGuestPatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinuxVMGuestPatchMode ImageDefault { get; } = new LinuxVMGuestPatchMode("ImageDefault");
        public static LinuxVMGuestPatchMode AutomaticByPlatform { get; } = new LinuxVMGuestPatchMode("AutomaticByPlatform");

        public static bool operator ==(LinuxVMGuestPatchMode left, LinuxVMGuestPatchMode right) => left.Equals(right);
        public static bool operator !=(LinuxVMGuestPatchMode left, LinuxVMGuestPatchMode right) => !left.Equals(right);

        public static explicit operator string(LinuxVMGuestPatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxVMGuestPatchMode other && Equals(other);
        public bool Equals(LinuxVMGuestPatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode that ProxyAgent will execute on. Warning: this property has been deprecated, please specify 'mode' under particular hostendpoint setting.
    /// </summary>
    [EnumType]
    public readonly struct Mode : IEquatable<Mode>
    {
        private readonly string _value;

        private Mode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Mode Audit { get; } = new Mode("Audit");
        public static Mode Enforce { get; } = new Mode("Enforce");

        public static bool operator ==(Mode left, Mode right) => left.Equals(right);
        public static bool operator !=(Mode left, Mode right) => !left.Equals(right);

        public static explicit operator string(Mode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Mode other && Equals(other);
        public bool Equals(Mode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the execution mode. In Audit mode, the system acts as if it is enforcing the access control policy, including emitting access denial entries in the logs but it does not actually deny any requests to host endpoints. In Enforce mode, the system will enforce the access control and it is the recommended mode of operation.
    /// </summary>
    [EnumType]
    public readonly struct Modes : IEquatable<Modes>
    {
        private readonly string _value;

        private Modes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Modes Audit { get; } = new Modes("Audit");
        public static Modes Enforce { get; } = new Modes("Enforce");
        public static Modes Disabled { get; } = new Modes("Disabled");

        public static bool operator ==(Modes left, Modes right) => left.Equals(right);
        public static bool operator !=(Modes left, Modes right) => !left.Equals(right);

        public static explicit operator string(Modes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Modes other && Equals(other);
        public bool Equals(Modes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Policy for accessing the disk via network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkAccessPolicy : IEquatable<NetworkAccessPolicy>
    {
        private readonly string _value;

        private NetworkAccessPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The disk can be exported or uploaded to from any network.
        /// </summary>
        public static NetworkAccessPolicy AllowAll { get; } = new NetworkAccessPolicy("AllowAll");
        /// <summary>
        /// The disk can be exported or uploaded to using a DiskAccess resource's private endpoints.
        /// </summary>
        public static NetworkAccessPolicy AllowPrivate { get; } = new NetworkAccessPolicy("AllowPrivate");
        /// <summary>
        /// The disk cannot be exported.
        /// </summary>
        public static NetworkAccessPolicy DenyAll { get; } = new NetworkAccessPolicy("DenyAll");

        public static bool operator ==(NetworkAccessPolicy left, NetworkAccessPolicy right) => left.Equals(right);
        public static bool operator !=(NetworkAccessPolicy left, NetworkAccessPolicy right) => !left.Equals(right);

        public static explicit operator string(NetworkAccessPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkAccessPolicy other && Equals(other);
        public bool Equals(NetworkAccessPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// specifies the Microsoft.Network API version used when creating networking resources in the Network Interface Configurations
    /// </summary>
    [EnumType]
    public readonly struct NetworkApiVersion : IEquatable<NetworkApiVersion>
    {
        private readonly string _value;

        private NetworkApiVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkApiVersion NetworkApiVersion_2020_11_01 { get; } = new NetworkApiVersion("2020-11-01");
        public static NetworkApiVersion NetworkApiVersion_2022_11_01 { get; } = new NetworkApiVersion("2022-11-01");

        public static bool operator ==(NetworkApiVersion left, NetworkApiVersion right) => left.Equals(right);
        public static bool operator !=(NetworkApiVersion left, NetworkApiVersion right) => !left.Equals(right);

        public static explicit operator string(NetworkApiVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkApiVersion other && Equals(other);
        public bool Equals(NetworkApiVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the Auxiliary mode is enabled for the Network Interface resource.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceAuxiliaryMode : IEquatable<NetworkInterfaceAuxiliaryMode>
    {
        private readonly string _value;

        private NetworkInterfaceAuxiliaryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInterfaceAuxiliaryMode None { get; } = new NetworkInterfaceAuxiliaryMode("None");
        public static NetworkInterfaceAuxiliaryMode AcceleratedConnections { get; } = new NetworkInterfaceAuxiliaryMode("AcceleratedConnections");
        public static NetworkInterfaceAuxiliaryMode Floating { get; } = new NetworkInterfaceAuxiliaryMode("Floating");

        public static bool operator ==(NetworkInterfaceAuxiliaryMode left, NetworkInterfaceAuxiliaryMode right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceAuxiliaryMode left, NetworkInterfaceAuxiliaryMode right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceAuxiliaryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceAuxiliaryMode other && Equals(other);
        public bool Equals(NetworkInterfaceAuxiliaryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the Auxiliary sku is enabled for the Network Interface resource.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceAuxiliarySku : IEquatable<NetworkInterfaceAuxiliarySku>
    {
        private readonly string _value;

        private NetworkInterfaceAuxiliarySku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInterfaceAuxiliarySku None { get; } = new NetworkInterfaceAuxiliarySku("None");
        public static NetworkInterfaceAuxiliarySku A1 { get; } = new NetworkInterfaceAuxiliarySku("A1");
        public static NetworkInterfaceAuxiliarySku A2 { get; } = new NetworkInterfaceAuxiliarySku("A2");
        public static NetworkInterfaceAuxiliarySku A4 { get; } = new NetworkInterfaceAuxiliarySku("A4");
        public static NetworkInterfaceAuxiliarySku A8 { get; } = new NetworkInterfaceAuxiliarySku("A8");

        public static bool operator ==(NetworkInterfaceAuxiliarySku left, NetworkInterfaceAuxiliarySku right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceAuxiliarySku left, NetworkInterfaceAuxiliarySku right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceAuxiliarySku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceAuxiliarySku other && Equals(other);
        public bool Equals(NetworkInterfaceAuxiliarySku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS State. For managed images, use Generalized.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemStateTypes : IEquatable<OperatingSystemStateTypes>
    {
        private readonly string _value;

        private OperatingSystemStateTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Generalized image. Needs to be provisioned during deployment time.
        /// </summary>
        public static OperatingSystemStateTypes Generalized { get; } = new OperatingSystemStateTypes("Generalized");
        /// <summary>
        /// Specialized image. Contains already provisioned OS Disk.
        /// </summary>
        public static OperatingSystemStateTypes Specialized { get; } = new OperatingSystemStateTypes("Specialized");

        public static bool operator ==(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemStateTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemStateTypes other && Equals(other);
        public bool Equals(OperatingSystemStateTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: **Windows,** **Linux.**
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the orchestration mode for the virtual machine scale set.
    /// </summary>
    [EnumType]
    public readonly struct OrchestrationMode : IEquatable<OrchestrationMode>
    {
        private readonly string _value;

        private OrchestrationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OrchestrationMode Uniform { get; } = new OrchestrationMode("Uniform");
        public static OrchestrationMode Flexible { get; } = new OrchestrationMode("Flexible");

        public static bool operator ==(OrchestrationMode left, OrchestrationMode right) => left.Equals(right);
        public static bool operator !=(OrchestrationMode left, OrchestrationMode right) => !left.Equals(right);

        public static explicit operator string(OrchestrationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrchestrationMode other && Equals(other);
        public bool Equals(OrchestrationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pass name. Currently, the only allowable value is OobeSystem.
    /// </summary>
    [EnumType]
    public readonly struct PassNames : IEquatable<PassNames>
    {
        private readonly string _value;

        private PassNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PassNames OobeSystem { get; } = new PassNames("OobeSystem");

        public static bool operator ==(PassNames left, PassNames right) => left.Equals(right);
        public static bool operator !=(PassNames left, PassNames right) => !left.Equals(right);

        public static explicit operator string(PassNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PassNames other && Equals(other);
        public bool Equals(PassNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the protocol of WinRM listener. Possible values are: **http,** **https.**
    /// </summary>
    [EnumType]
    public readonly struct ProtocolTypes : IEquatable<ProtocolTypes>
    {
        private readonly string _value;

        private ProtocolTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProtocolTypes Http { get; } = new ProtocolTypes("Http");
        public static ProtocolTypes Https { get; } = new ProtocolTypes("Https");

        public static bool operator ==(ProtocolTypes left, ProtocolTypes right) => left.Equals(right);
        public static bool operator !=(ProtocolTypes left, ProtocolTypes right) => !left.Equals(right);

        public static explicit operator string(ProtocolTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProtocolTypes other && Equals(other);
        public bool Equals(ProtocolTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If this field is set on a snapshot and createOption is CopyStart, the snapshot will be copied at a quicker speed.
    /// </summary>
    [EnumType]
    public readonly struct ProvisionedBandwidthCopyOption : IEquatable<ProvisionedBandwidthCopyOption>
    {
        private readonly string _value;

        private ProvisionedBandwidthCopyOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProvisionedBandwidthCopyOption None { get; } = new ProvisionedBandwidthCopyOption("None");
        public static ProvisionedBandwidthCopyOption Enhanced { get; } = new ProvisionedBandwidthCopyOption("Enhanced");

        public static bool operator ==(ProvisionedBandwidthCopyOption left, ProvisionedBandwidthCopyOption right) => left.Equals(right);
        public static bool operator !=(ProvisionedBandwidthCopyOption left, ProvisionedBandwidthCopyOption right) => !left.Equals(right);

        public static explicit operator string(ProvisionedBandwidthCopyOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProvisionedBandwidthCopyOption other && Equals(other);
        public bool Equals(ProvisionedBandwidthCopyOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the proximity placement group. Possible values are: **Standard** : Co-locate resources within an Azure region or Availability Zone. **Ultra** : For future use.
    /// </summary>
    [EnumType]
    public readonly struct ProximityPlacementGroupType : IEquatable<ProximityPlacementGroupType>
    {
        private readonly string _value;

        private ProximityPlacementGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProximityPlacementGroupType Standard { get; } = new ProximityPlacementGroupType("Standard");
        public static ProximityPlacementGroupType Ultra { get; } = new ProximityPlacementGroupType("Ultra");

        public static bool operator ==(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => left.Equals(right);
        public static bool operator !=(ProximityPlacementGroupType left, ProximityPlacementGroupType right) => !left.Equals(right);

        public static explicit operator string(ProximityPlacementGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProximityPlacementGroupType other && Equals(other);
        public bool Equals(ProximityPlacementGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify public IP sku name
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAddressSkuName : IEquatable<PublicIPAddressSkuName>
    {
        private readonly string _value;

        private PublicIPAddressSkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicIPAddressSkuName Basic { get; } = new PublicIPAddressSkuName("Basic");
        public static PublicIPAddressSkuName Standard { get; } = new PublicIPAddressSkuName("Standard");

        public static bool operator ==(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => left.Equals(right);
        public static bool operator !=(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => !left.Equals(right);

        public static explicit operator string(PublicIPAddressSkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAddressSkuName other && Equals(other);
        public bool Equals(PublicIPAddressSkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify public IP sku tier
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAddressSkuTier : IEquatable<PublicIPAddressSkuTier>
    {
        private readonly string _value;

        private PublicIPAddressSkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicIPAddressSkuTier Regional { get; } = new PublicIPAddressSkuTier("Regional");
        public static PublicIPAddressSkuTier Global { get; } = new PublicIPAddressSkuTier("Global");

        public static bool operator ==(PublicIPAddressSkuTier left, PublicIPAddressSkuTier right) => left.Equals(right);
        public static bool operator !=(PublicIPAddressSkuTier left, PublicIPAddressSkuTier right) => !left.Equals(right);

        public static explicit operator string(PublicIPAddressSkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAddressSkuTier other && Equals(other);
        public bool Equals(PublicIPAddressSkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the public IP allocation type
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAllocationMethod : IEquatable<PublicIPAllocationMethod>
    {
        private readonly string _value;

        private PublicIPAllocationMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicIPAllocationMethod Dynamic { get; } = new PublicIPAllocationMethod("Dynamic");
        public static PublicIPAllocationMethod Static { get; } = new PublicIPAllocationMethod("Static");

        public static bool operator ==(PublicIPAllocationMethod left, PublicIPAllocationMethod right) => left.Equals(right);
        public static bool operator !=(PublicIPAllocationMethod left, PublicIPAllocationMethod right) => !left.Equals(right);

        public static explicit operator string(PublicIPAllocationMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAllocationMethod other && Equals(other);
        public bool Equals(PublicIPAllocationMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Policy for controlling export on the disk.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// You can generate a SAS URI to access the underlying data of the disk publicly on the internet when NetworkAccessPolicy is set to AllowAll. You can access the data via the SAS URI only from your trusted Azure VNET when NetworkAccessPolicy is set to AllowPrivate.
        /// </summary>
        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        /// <summary>
        /// You cannot access the underlying data of the disk publicly on the internet even when NetworkAccessPolicy is set to AllowAll. You can access the data via the SAS URI only from your trusted Azure VNET when NetworkAccessPolicy is set to AllowPrivate.
        /// </summary>
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of rebalance behavior that will be used for recreating virtual machines in the scale set across availability zones. Default and only supported value for now is CreateBeforeDelete.
    /// </summary>
    [EnumType]
    public readonly struct RebalanceBehavior : IEquatable<RebalanceBehavior>
    {
        private readonly string _value;

        private RebalanceBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RebalanceBehavior CreateBeforeDelete { get; } = new RebalanceBehavior("CreateBeforeDelete");

        public static bool operator ==(RebalanceBehavior left, RebalanceBehavior right) => left.Equals(right);
        public static bool operator !=(RebalanceBehavior left, RebalanceBehavior right) => !left.Equals(right);

        public static explicit operator string(RebalanceBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RebalanceBehavior other && Equals(other);
        public bool Equals(RebalanceBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of rebalance strategy that will be used for rebalancing virtual machines in the scale set across availability zones. Default and only supported value for now is Recreate.
    /// </summary>
    [EnumType]
    public readonly struct RebalanceStrategy : IEquatable<RebalanceStrategy>
    {
        private readonly string _value;

        private RebalanceStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RebalanceStrategy Recreate { get; } = new RebalanceStrategy("Recreate");

        public static bool operator ==(RebalanceStrategy left, RebalanceStrategy right) => left.Equals(right);
        public static bool operator !=(RebalanceStrategy left, RebalanceStrategy right) => !left.Equals(right);

        public static explicit operator string(RebalanceStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RebalanceStrategy other && Equals(other);
        public bool Equals(RebalanceStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of repair action (replace, restart, reimage) that will be used for repairing unhealthy virtual machines in the scale set. Default value is replace.
    /// </summary>
    [EnumType]
    public readonly struct RepairAction : IEquatable<RepairAction>
    {
        private readonly string _value;

        private RepairAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RepairAction Replace { get; } = new RepairAction("Replace");
        public static RepairAction Restart { get; } = new RepairAction("Restart");
        public static RepairAction Reimage { get; } = new RepairAction("Reimage");

        public static bool operator ==(RepairAction left, RepairAction right) => left.Equals(right);
        public static bool operator !=(RepairAction left, RepairAction right) => !left.Equals(right);

        public static explicit operator string(RepairAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RepairAction other && Equals(other);
        public bool Equals(RepairAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional parameter which specifies the mode to be used for replication. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationMode : IEquatable<ReplicationMode>
    {
        private readonly string _value;

        private ReplicationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationMode Full { get; } = new ReplicationMode("Full");
        public static ReplicationMode Shallow { get; } = new ReplicationMode("Shallow");

        public static bool operator ==(ReplicationMode left, ReplicationMode right) => left.Equals(right);
        public static bool operator !=(ReplicationMode left, ReplicationMode right) => !left.Equals(right);

        public static explicit operator string(ReplicationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationMode other && Equals(other);
        public bool Equals(ReplicationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the resilient VM deletion status for the virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct ResilientVMDeletionStatus : IEquatable<ResilientVMDeletionStatus>
    {
        private readonly string _value;

        private ResilientVMDeletionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResilientVMDeletionStatus Enabled { get; } = new ResilientVMDeletionStatus("Enabled");
        public static ResilientVMDeletionStatus Disabled { get; } = new ResilientVMDeletionStatus("Disabled");
        public static ResilientVMDeletionStatus InProgress { get; } = new ResilientVMDeletionStatus("InProgress");
        public static ResilientVMDeletionStatus Failed { get; } = new ResilientVMDeletionStatus("Failed");

        public static bool operator ==(ResilientVMDeletionStatus left, ResilientVMDeletionStatus right) => left.Equals(right);
        public static bool operator !=(ResilientVMDeletionStatus left, ResilientVMDeletionStatus right) => !left.Equals(right);

        public static explicit operator string(ResilientVMDeletionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResilientVMDeletionStatus other && Equals(other);
        public bool Equals(ResilientVMDeletionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        public static ResourceIdentityType SystemAssigned_UserAssigned { get; } = new ResourceIdentityType("SystemAssigned, UserAssigned");
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the data of the disk restore point.
    /// </summary>
    [EnumType]
    public readonly struct RestorePointEncryptionType : IEquatable<RestorePointEncryptionType>
    {
        private readonly string _value;

        private RestorePointEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disk Restore Point is encrypted at rest with Platform managed key. 
        /// </summary>
        public static RestorePointEncryptionType EncryptionAtRestWithPlatformKey { get; } = new RestorePointEncryptionType("EncryptionAtRestWithPlatformKey");
        /// <summary>
        /// Disk Restore Point is encrypted at rest with Customer managed key that can be changed and revoked by a customer.
        /// </summary>
        public static RestorePointEncryptionType EncryptionAtRestWithCustomerKey { get; } = new RestorePointEncryptionType("EncryptionAtRestWithCustomerKey");
        /// <summary>
        /// Disk Restore Point is encrypted at rest with 2 layers of encryption. One of the keys is Customer managed and the other key is Platform managed.
        /// </summary>
        public static RestorePointEncryptionType EncryptionAtRestWithPlatformAndCustomerKeys { get; } = new RestorePointEncryptionType("EncryptionAtRestWithPlatformAndCustomerKeys");

        public static bool operator ==(RestorePointEncryptionType left, RestorePointEncryptionType right) => left.Equals(right);
        public static bool operator !=(RestorePointEncryptionType left, RestorePointEncryptionType right) => !left.Equals(right);

        public static explicit operator string(RestorePointEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RestorePointEncryptionType other && Equals(other);
        public bool Equals(RestorePointEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the EncryptionType of the managed disk. It is set to DiskWithVMGuestState for encryption of the managed disk along with VMGuestState blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob.. **Note:** It can be set for only Confidential VMs.
    /// </summary>
    [EnumType]
    public readonly struct SecurityEncryptionTypes : IEquatable<SecurityEncryptionTypes>
    {
        private readonly string _value;

        private SecurityEncryptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityEncryptionTypes VMGuestStateOnly { get; } = new SecurityEncryptionTypes("VMGuestStateOnly");
        public static SecurityEncryptionTypes DiskWithVMGuestState { get; } = new SecurityEncryptionTypes("DiskWithVMGuestState");
        public static SecurityEncryptionTypes NonPersistedTPM { get; } = new SecurityEncryptionTypes("NonPersistedTPM");

        public static bool operator ==(SecurityEncryptionTypes left, SecurityEncryptionTypes right) => left.Equals(right);
        public static bool operator !=(SecurityEncryptionTypes left, SecurityEncryptionTypes right) => !left.Equals(right);

        public static explicit operator string(SecurityEncryptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityEncryptionTypes other && Equals(other);
        public bool Equals(SecurityEncryptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings. The default behavior is: UefiSettings will not be enabled unless this property is set.
    /// </summary>
    [EnumType]
    public readonly struct SecurityTypes : IEquatable<SecurityTypes>
    {
        private readonly string _value;

        private SecurityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityTypes TrustedLaunch { get; } = new SecurityTypes("TrustedLaunch");
        public static SecurityTypes ConfidentialVM { get; } = new SecurityTypes("ConfidentialVM");

        public static bool operator ==(SecurityTypes left, SecurityTypes right) => left.Equals(right);
        public static bool operator !=(SecurityTypes left, SecurityTypes right) => !left.Equals(right);

        public static explicit operator string(SecurityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityTypes other && Equals(other);
        public bool Equals(SecurityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
    /// </summary>
    [EnumType]
    public readonly struct SettingNames : IEquatable<SettingNames>
    {
        private readonly string _value;

        private SettingNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SettingNames AutoLogon { get; } = new SettingNames("AutoLogon");
        public static SettingNames FirstLogonCommands { get; } = new SettingNames("FirstLogonCommands");

        public static bool operator ==(SettingNames left, SettingNames right) => left.Equals(right);
        public static bool operator !=(SettingNames left, SettingNames right) => !left.Equals(right);

        public static explicit operator string(SettingNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingNames other && Equals(other);
        public bool Equals(SettingNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sku name.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotStorageAccountTypes : IEquatable<SnapshotStorageAccountTypes>
    {
        private readonly string _value;

        private SnapshotStorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard HDD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_LRS { get; } = new SnapshotStorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium SSD locally redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Premium_LRS { get; } = new SnapshotStorageAccountTypes("Premium_LRS");
        /// <summary>
        /// Standard zone redundant storage
        /// </summary>
        public static SnapshotStorageAccountTypes Standard_ZRS { get; } = new SnapshotStorageAccountTypes("Standard_ZRS");

        public static bool operator ==(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(SnapshotStorageAccountTypes left, SnapshotStorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(SnapshotStorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotStorageAccountTypes other && Equals(other);
        public bool Equals(SnapshotStorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The level code.
    /// </summary>
    [EnumType]
    public readonly struct StatusLevelTypes : IEquatable<StatusLevelTypes>
    {
        private readonly string _value;

        private StatusLevelTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StatusLevelTypes Info { get; } = new StatusLevelTypes("Info");
        public static StatusLevelTypes Warning { get; } = new StatusLevelTypes("Warning");
        public static StatusLevelTypes Error { get; } = new StatusLevelTypes("Error");

        public static bool operator ==(StatusLevelTypes left, StatusLevelTypes right) => left.Equals(right);
        public static bool operator !=(StatusLevelTypes left, StatusLevelTypes right) => !left.Equals(right);

        public static explicit operator string(StatusLevelTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusLevelTypes other && Equals(other);
        public bool Equals(StatusLevelTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type to be used to store the image. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountType Standard_LRS { get; } = new StorageAccountType("Standard_LRS");
        public static StorageAccountType Standard_ZRS { get; } = new StorageAccountType("Standard_ZRS");
        public static StorageAccountType Premium_LRS { get; } = new StorageAccountType("Premium_LRS");
        public static StorageAccountType PremiumV2_LRS { get; } = new StorageAccountType("PremiumV2_LRS");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountTypes : IEquatable<StorageAccountTypes>
    {
        private readonly string _value;

        private StorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountTypes Standard_LRS { get; } = new StorageAccountTypes("Standard_LRS");
        public static StorageAccountTypes Premium_LRS { get; } = new StorageAccountTypes("Premium_LRS");
        public static StorageAccountTypes StandardSSD_LRS { get; } = new StorageAccountTypes("StandardSSD_LRS");
        public static StorageAccountTypes UltraSSD_LRS { get; } = new StorageAccountTypes("UltraSSD_LRS");
        public static StorageAccountTypes Premium_ZRS { get; } = new StorageAccountTypes("Premium_ZRS");
        public static StorageAccountTypes StandardSSD_ZRS { get; } = new StorageAccountTypes("StandardSSD_ZRS");
        public static StorageAccountTypes PremiumV2_LRS { get; } = new StorageAccountTypes("PremiumV2_LRS");

        public static bool operator ==(StorageAccountTypes left, StorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(StorageAccountTypes left, StorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(StorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountTypes other && Equals(other);
        public bool Equals(StorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key signature.
    /// </summary>
    [EnumType]
    public readonly struct UefiKeyType : IEquatable<UefiKeyType>
    {
        private readonly string _value;

        private UefiKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UefiKeyType Sha256 { get; } = new UefiKeyType("sha256");
        public static UefiKeyType X509 { get; } = new UefiKeyType("x509");

        public static bool operator ==(UefiKeyType left, UefiKeyType right) => left.Equals(right);
        public static bool operator !=(UefiKeyType left, UefiKeyType right) => !left.Equals(right);

        public static explicit operator string(UefiKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UefiKeyType other && Equals(other);
        public bool Equals(UefiKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the signature template that contains default UEFI keys.
    /// </summary>
    [EnumType]
    public readonly struct UefiSignatureTemplateName : IEquatable<UefiSignatureTemplateName>
    {
        private readonly string _value;

        private UefiSignatureTemplateName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UefiSignatureTemplateName NoSignatureTemplate { get; } = new UefiSignatureTemplateName("NoSignatureTemplate");
        public static UefiSignatureTemplateName MicrosoftUefiCertificateAuthorityTemplate { get; } = new UefiSignatureTemplateName("MicrosoftUefiCertificateAuthorityTemplate");
        public static UefiSignatureTemplateName MicrosoftWindowsTemplate { get; } = new UefiSignatureTemplateName("MicrosoftWindowsTemplate");

        public static bool operator ==(UefiSignatureTemplateName left, UefiSignatureTemplateName right) => left.Equals(right);
        public static bool operator !=(UefiSignatureTemplateName left, UefiSignatureTemplateName right) => !left.Equals(right);

        public static explicit operator string(UefiSignatureTemplateName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UefiSignatureTemplateName other && Equals(other);
        public bool Equals(UefiSignatureTemplateName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of an upgrade to virtual machines in the scale set.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **Manual** - You  control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.&lt;br /&gt;&lt;br /&gt; **Automatic** - All virtual machines in the scale set are  automatically updated at the same time.
    /// </summary>
    [EnumType]
    public readonly struct UpgradeMode : IEquatable<UpgradeMode>
    {
        private readonly string _value;

        private UpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UpgradeMode Automatic { get; } = new UpgradeMode("Automatic");
        public static UpgradeMode Manual { get; } = new UpgradeMode("Manual");
        public static UpgradeMode Rolling { get; } = new UpgradeMode("Rolling");

        public static bool operator ==(UpgradeMode left, UpgradeMode right) => left.Equals(right);
        public static bool operator !=(UpgradeMode left, UpgradeMode right) => !left.Equals(right);

        public static explicit operator string(UpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradeMode other && Equals(other);
        public bool Equals(UpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set. For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01. For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2017-10-30-preview.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineEvictionPolicyTypes : IEquatable<VirtualMachineEvictionPolicyTypes>
    {
        private readonly string _value;

        private VirtualMachineEvictionPolicyTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineEvictionPolicyTypes Deallocate { get; } = new VirtualMachineEvictionPolicyTypes("Deallocate");
        public static VirtualMachineEvictionPolicyTypes Delete { get; } = new VirtualMachineEvictionPolicyTypes("Delete");

        public static bool operator ==(VirtualMachineEvictionPolicyTypes left, VirtualMachineEvictionPolicyTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachineEvictionPolicyTypes left, VirtualMachineEvictionPolicyTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineEvictionPolicyTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineEvictionPolicyTypes other && Equals(other);
        public bool Equals(VirtualMachineEvictionPolicyTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the priority for the virtual machines in the scale set. Minimum api-version: 2017-10-30-preview.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePriorityTypes : IEquatable<VirtualMachinePriorityTypes>
    {
        private readonly string _value;

        private VirtualMachinePriorityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePriorityTypes Regular { get; } = new VirtualMachinePriorityTypes("Regular");
        public static VirtualMachinePriorityTypes Low { get; } = new VirtualMachinePriorityTypes("Low");
        public static VirtualMachinePriorityTypes Spot { get; } = new VirtualMachinePriorityTypes("Spot");

        public static bool operator ==(VirtualMachinePriorityTypes left, VirtualMachinePriorityTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePriorityTypes left, VirtualMachinePriorityTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePriorityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePriorityTypes other && Equals(other);
        public bool Equals(VirtualMachinePriorityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct VirtualMachineScaleSetScaleInRules : IEquatable<VirtualMachineScaleSetScaleInRules>
    {
        private readonly string _value;

        private VirtualMachineScaleSetScaleInRules(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineScaleSetScaleInRules Default { get; } = new VirtualMachineScaleSetScaleInRules("Default");
        public static VirtualMachineScaleSetScaleInRules OldestVM { get; } = new VirtualMachineScaleSetScaleInRules("OldestVM");
        public static VirtualMachineScaleSetScaleInRules NewestVM { get; } = new VirtualMachineScaleSetScaleInRules("NewestVM");

        public static bool operator ==(VirtualMachineScaleSetScaleInRules left, VirtualMachineScaleSetScaleInRules right) => left.Equals(right);
        public static bool operator !=(VirtualMachineScaleSetScaleInRules left, VirtualMachineScaleSetScaleInRules right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineScaleSetScaleInRules value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineScaleSetScaleInRules other && Equals(other);
        public bool Equals(VirtualMachineScaleSetScaleInRules other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the size of the virtual machine. The enum data type is currently deprecated and will be removed by December 23rd 2023. The recommended way to get the list of available sizes is using these APIs: [List all available virtual machine sizes in an availability set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes), [List all available virtual machine sizes in a region]( https://docs.microsoft.com/rest/api/compute/resourceskus/list), [List all available virtual machine sizes for resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes). For more information about virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/sizes). The available VM sizes depend on region and availability set.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineSizeTypes : IEquatable<VirtualMachineSizeTypes>
    {
        private readonly string _value;

        private VirtualMachineSizeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineSizeTypes Basic_A0 { get; } = new VirtualMachineSizeTypes("Basic_A0");
        public static VirtualMachineSizeTypes Basic_A1 { get; } = new VirtualMachineSizeTypes("Basic_A1");
        public static VirtualMachineSizeTypes Basic_A2 { get; } = new VirtualMachineSizeTypes("Basic_A2");
        public static VirtualMachineSizeTypes Basic_A3 { get; } = new VirtualMachineSizeTypes("Basic_A3");
        public static VirtualMachineSizeTypes Basic_A4 { get; } = new VirtualMachineSizeTypes("Basic_A4");
        public static VirtualMachineSizeTypes Standard_A0 { get; } = new VirtualMachineSizeTypes("Standard_A0");
        public static VirtualMachineSizeTypes Standard_A1 { get; } = new VirtualMachineSizeTypes("Standard_A1");
        public static VirtualMachineSizeTypes Standard_A2 { get; } = new VirtualMachineSizeTypes("Standard_A2");
        public static VirtualMachineSizeTypes Standard_A3 { get; } = new VirtualMachineSizeTypes("Standard_A3");
        public static VirtualMachineSizeTypes Standard_A4 { get; } = new VirtualMachineSizeTypes("Standard_A4");
        public static VirtualMachineSizeTypes Standard_A5 { get; } = new VirtualMachineSizeTypes("Standard_A5");
        public static VirtualMachineSizeTypes Standard_A6 { get; } = new VirtualMachineSizeTypes("Standard_A6");
        public static VirtualMachineSizeTypes Standard_A7 { get; } = new VirtualMachineSizeTypes("Standard_A7");
        public static VirtualMachineSizeTypes Standard_A8 { get; } = new VirtualMachineSizeTypes("Standard_A8");
        public static VirtualMachineSizeTypes Standard_A9 { get; } = new VirtualMachineSizeTypes("Standard_A9");
        public static VirtualMachineSizeTypes Standard_A10 { get; } = new VirtualMachineSizeTypes("Standard_A10");
        public static VirtualMachineSizeTypes Standard_A11 { get; } = new VirtualMachineSizeTypes("Standard_A11");
        public static VirtualMachineSizeTypes Standard_A1_v2 { get; } = new VirtualMachineSizeTypes("Standard_A1_v2");
        public static VirtualMachineSizeTypes Standard_A2_v2 { get; } = new VirtualMachineSizeTypes("Standard_A2_v2");
        public static VirtualMachineSizeTypes Standard_A4_v2 { get; } = new VirtualMachineSizeTypes("Standard_A4_v2");
        public static VirtualMachineSizeTypes Standard_A8_v2 { get; } = new VirtualMachineSizeTypes("Standard_A8_v2");
        public static VirtualMachineSizeTypes Standard_A2m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A2m_v2");
        public static VirtualMachineSizeTypes Standard_A4m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A4m_v2");
        public static VirtualMachineSizeTypes Standard_A8m_v2 { get; } = new VirtualMachineSizeTypes("Standard_A8m_v2");
        public static VirtualMachineSizeTypes Standard_B1s { get; } = new VirtualMachineSizeTypes("Standard_B1s");
        public static VirtualMachineSizeTypes Standard_B1ms { get; } = new VirtualMachineSizeTypes("Standard_B1ms");
        public static VirtualMachineSizeTypes Standard_B2s { get; } = new VirtualMachineSizeTypes("Standard_B2s");
        public static VirtualMachineSizeTypes Standard_B2ms { get; } = new VirtualMachineSizeTypes("Standard_B2ms");
        public static VirtualMachineSizeTypes Standard_B4ms { get; } = new VirtualMachineSizeTypes("Standard_B4ms");
        public static VirtualMachineSizeTypes Standard_B8ms { get; } = new VirtualMachineSizeTypes("Standard_B8ms");
        public static VirtualMachineSizeTypes Standard_D1 { get; } = new VirtualMachineSizeTypes("Standard_D1");
        public static VirtualMachineSizeTypes Standard_D2 { get; } = new VirtualMachineSizeTypes("Standard_D2");
        public static VirtualMachineSizeTypes Standard_D3 { get; } = new VirtualMachineSizeTypes("Standard_D3");
        public static VirtualMachineSizeTypes Standard_D4 { get; } = new VirtualMachineSizeTypes("Standard_D4");
        public static VirtualMachineSizeTypes Standard_D11 { get; } = new VirtualMachineSizeTypes("Standard_D11");
        public static VirtualMachineSizeTypes Standard_D12 { get; } = new VirtualMachineSizeTypes("Standard_D12");
        public static VirtualMachineSizeTypes Standard_D13 { get; } = new VirtualMachineSizeTypes("Standard_D13");
        public static VirtualMachineSizeTypes Standard_D14 { get; } = new VirtualMachineSizeTypes("Standard_D14");
        public static VirtualMachineSizeTypes Standard_D1_v2 { get; } = new VirtualMachineSizeTypes("Standard_D1_v2");
        public static VirtualMachineSizeTypes Standard_D2_v2 { get; } = new VirtualMachineSizeTypes("Standard_D2_v2");
        public static VirtualMachineSizeTypes Standard_D3_v2 { get; } = new VirtualMachineSizeTypes("Standard_D3_v2");
        public static VirtualMachineSizeTypes Standard_D4_v2 { get; } = new VirtualMachineSizeTypes("Standard_D4_v2");
        public static VirtualMachineSizeTypes Standard_D5_v2 { get; } = new VirtualMachineSizeTypes("Standard_D5_v2");
        public static VirtualMachineSizeTypes Standard_D2_v3 { get; } = new VirtualMachineSizeTypes("Standard_D2_v3");
        public static VirtualMachineSizeTypes Standard_D4_v3 { get; } = new VirtualMachineSizeTypes("Standard_D4_v3");
        public static VirtualMachineSizeTypes Standard_D8_v3 { get; } = new VirtualMachineSizeTypes("Standard_D8_v3");
        public static VirtualMachineSizeTypes Standard_D16_v3 { get; } = new VirtualMachineSizeTypes("Standard_D16_v3");
        public static VirtualMachineSizeTypes Standard_D32_v3 { get; } = new VirtualMachineSizeTypes("Standard_D32_v3");
        public static VirtualMachineSizeTypes Standard_D64_v3 { get; } = new VirtualMachineSizeTypes("Standard_D64_v3");
        public static VirtualMachineSizeTypes Standard_D2s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D2s_v3");
        public static VirtualMachineSizeTypes Standard_D4s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D4s_v3");
        public static VirtualMachineSizeTypes Standard_D8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D8s_v3");
        public static VirtualMachineSizeTypes Standard_D16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D16s_v3");
        public static VirtualMachineSizeTypes Standard_D32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D32s_v3");
        public static VirtualMachineSizeTypes Standard_D64s_v3 { get; } = new VirtualMachineSizeTypes("Standard_D64s_v3");
        public static VirtualMachineSizeTypes Standard_D11_v2 { get; } = new VirtualMachineSizeTypes("Standard_D11_v2");
        public static VirtualMachineSizeTypes Standard_D12_v2 { get; } = new VirtualMachineSizeTypes("Standard_D12_v2");
        public static VirtualMachineSizeTypes Standard_D13_v2 { get; } = new VirtualMachineSizeTypes("Standard_D13_v2");
        public static VirtualMachineSizeTypes Standard_D14_v2 { get; } = new VirtualMachineSizeTypes("Standard_D14_v2");
        public static VirtualMachineSizeTypes Standard_D15_v2 { get; } = new VirtualMachineSizeTypes("Standard_D15_v2");
        public static VirtualMachineSizeTypes Standard_DS1 { get; } = new VirtualMachineSizeTypes("Standard_DS1");
        public static VirtualMachineSizeTypes Standard_DS2 { get; } = new VirtualMachineSizeTypes("Standard_DS2");
        public static VirtualMachineSizeTypes Standard_DS3 { get; } = new VirtualMachineSizeTypes("Standard_DS3");
        public static VirtualMachineSizeTypes Standard_DS4 { get; } = new VirtualMachineSizeTypes("Standard_DS4");
        public static VirtualMachineSizeTypes Standard_DS11 { get; } = new VirtualMachineSizeTypes("Standard_DS11");
        public static VirtualMachineSizeTypes Standard_DS12 { get; } = new VirtualMachineSizeTypes("Standard_DS12");
        public static VirtualMachineSizeTypes Standard_DS13 { get; } = new VirtualMachineSizeTypes("Standard_DS13");
        public static VirtualMachineSizeTypes Standard_DS14 { get; } = new VirtualMachineSizeTypes("Standard_DS14");
        public static VirtualMachineSizeTypes Standard_DS1_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS1_v2");
        public static VirtualMachineSizeTypes Standard_DS2_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS2_v2");
        public static VirtualMachineSizeTypes Standard_DS3_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS3_v2");
        public static VirtualMachineSizeTypes Standard_DS4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS4_v2");
        public static VirtualMachineSizeTypes Standard_DS5_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS5_v2");
        public static VirtualMachineSizeTypes Standard_DS11_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS11_v2");
        public static VirtualMachineSizeTypes Standard_DS12_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS12_v2");
        public static VirtualMachineSizeTypes Standard_DS13_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13_v2");
        public static VirtualMachineSizeTypes Standard_DS14_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14_v2");
        public static VirtualMachineSizeTypes Standard_DS15_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS15_v2");
        public static VirtualMachineSizeTypes Standard_DS13_4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13-4_v2");
        public static VirtualMachineSizeTypes Standard_DS13_2_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS13-2_v2");
        public static VirtualMachineSizeTypes Standard_DS14_8_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14-8_v2");
        public static VirtualMachineSizeTypes Standard_DS14_4_v2 { get; } = new VirtualMachineSizeTypes("Standard_DS14-4_v2");
        public static VirtualMachineSizeTypes Standard_E2_v3 { get; } = new VirtualMachineSizeTypes("Standard_E2_v3");
        public static VirtualMachineSizeTypes Standard_E4_v3 { get; } = new VirtualMachineSizeTypes("Standard_E4_v3");
        public static VirtualMachineSizeTypes Standard_E8_v3 { get; } = new VirtualMachineSizeTypes("Standard_E8_v3");
        public static VirtualMachineSizeTypes Standard_E16_v3 { get; } = new VirtualMachineSizeTypes("Standard_E16_v3");
        public static VirtualMachineSizeTypes Standard_E32_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32_v3");
        public static VirtualMachineSizeTypes Standard_E64_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64_v3");
        public static VirtualMachineSizeTypes Standard_E2s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E2s_v3");
        public static VirtualMachineSizeTypes Standard_E4s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E4s_v3");
        public static VirtualMachineSizeTypes Standard_E8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E8s_v3");
        public static VirtualMachineSizeTypes Standard_E16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E16s_v3");
        public static VirtualMachineSizeTypes Standard_E32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32s_v3");
        public static VirtualMachineSizeTypes Standard_E64s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64s_v3");
        public static VirtualMachineSizeTypes Standard_E32_16_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32-16_v3");
        public static VirtualMachineSizeTypes Standard_E32_8s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E32-8s_v3");
        public static VirtualMachineSizeTypes Standard_E64_32s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64-32s_v3");
        public static VirtualMachineSizeTypes Standard_E64_16s_v3 { get; } = new VirtualMachineSizeTypes("Standard_E64-16s_v3");
        public static VirtualMachineSizeTypes Standard_F1 { get; } = new VirtualMachineSizeTypes("Standard_F1");
        public static VirtualMachineSizeTypes Standard_F2 { get; } = new VirtualMachineSizeTypes("Standard_F2");
        public static VirtualMachineSizeTypes Standard_F4 { get; } = new VirtualMachineSizeTypes("Standard_F4");
        public static VirtualMachineSizeTypes Standard_F8 { get; } = new VirtualMachineSizeTypes("Standard_F8");
        public static VirtualMachineSizeTypes Standard_F16 { get; } = new VirtualMachineSizeTypes("Standard_F16");
        public static VirtualMachineSizeTypes Standard_F1s { get; } = new VirtualMachineSizeTypes("Standard_F1s");
        public static VirtualMachineSizeTypes Standard_F2s { get; } = new VirtualMachineSizeTypes("Standard_F2s");
        public static VirtualMachineSizeTypes Standard_F4s { get; } = new VirtualMachineSizeTypes("Standard_F4s");
        public static VirtualMachineSizeTypes Standard_F8s { get; } = new VirtualMachineSizeTypes("Standard_F8s");
        public static VirtualMachineSizeTypes Standard_F16s { get; } = new VirtualMachineSizeTypes("Standard_F16s");
        public static VirtualMachineSizeTypes Standard_F2s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F2s_v2");
        public static VirtualMachineSizeTypes Standard_F4s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F4s_v2");
        public static VirtualMachineSizeTypes Standard_F8s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F8s_v2");
        public static VirtualMachineSizeTypes Standard_F16s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F16s_v2");
        public static VirtualMachineSizeTypes Standard_F32s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F32s_v2");
        public static VirtualMachineSizeTypes Standard_F64s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F64s_v2");
        public static VirtualMachineSizeTypes Standard_F72s_v2 { get; } = new VirtualMachineSizeTypes("Standard_F72s_v2");
        public static VirtualMachineSizeTypes Standard_G1 { get; } = new VirtualMachineSizeTypes("Standard_G1");
        public static VirtualMachineSizeTypes Standard_G2 { get; } = new VirtualMachineSizeTypes("Standard_G2");
        public static VirtualMachineSizeTypes Standard_G3 { get; } = new VirtualMachineSizeTypes("Standard_G3");
        public static VirtualMachineSizeTypes Standard_G4 { get; } = new VirtualMachineSizeTypes("Standard_G4");
        public static VirtualMachineSizeTypes Standard_G5 { get; } = new VirtualMachineSizeTypes("Standard_G5");
        public static VirtualMachineSizeTypes Standard_GS1 { get; } = new VirtualMachineSizeTypes("Standard_GS1");
        public static VirtualMachineSizeTypes Standard_GS2 { get; } = new VirtualMachineSizeTypes("Standard_GS2");
        public static VirtualMachineSizeTypes Standard_GS3 { get; } = new VirtualMachineSizeTypes("Standard_GS3");
        public static VirtualMachineSizeTypes Standard_GS4 { get; } = new VirtualMachineSizeTypes("Standard_GS4");
        public static VirtualMachineSizeTypes Standard_GS5 { get; } = new VirtualMachineSizeTypes("Standard_GS5");
        public static VirtualMachineSizeTypes Standard_GS4_8 { get; } = new VirtualMachineSizeTypes("Standard_GS4-8");
        public static VirtualMachineSizeTypes Standard_GS4_4 { get; } = new VirtualMachineSizeTypes("Standard_GS4-4");
        public static VirtualMachineSizeTypes Standard_GS5_16 { get; } = new VirtualMachineSizeTypes("Standard_GS5-16");
        public static VirtualMachineSizeTypes Standard_GS5_8 { get; } = new VirtualMachineSizeTypes("Standard_GS5-8");
        public static VirtualMachineSizeTypes Standard_H8 { get; } = new VirtualMachineSizeTypes("Standard_H8");
        public static VirtualMachineSizeTypes Standard_H16 { get; } = new VirtualMachineSizeTypes("Standard_H16");
        public static VirtualMachineSizeTypes Standard_H8m { get; } = new VirtualMachineSizeTypes("Standard_H8m");
        public static VirtualMachineSizeTypes Standard_H16m { get; } = new VirtualMachineSizeTypes("Standard_H16m");
        public static VirtualMachineSizeTypes Standard_H16r { get; } = new VirtualMachineSizeTypes("Standard_H16r");
        public static VirtualMachineSizeTypes Standard_H16mr { get; } = new VirtualMachineSizeTypes("Standard_H16mr");
        public static VirtualMachineSizeTypes Standard_L4s { get; } = new VirtualMachineSizeTypes("Standard_L4s");
        public static VirtualMachineSizeTypes Standard_L8s { get; } = new VirtualMachineSizeTypes("Standard_L8s");
        public static VirtualMachineSizeTypes Standard_L16s { get; } = new VirtualMachineSizeTypes("Standard_L16s");
        public static VirtualMachineSizeTypes Standard_L32s { get; } = new VirtualMachineSizeTypes("Standard_L32s");
        public static VirtualMachineSizeTypes Standard_M64s { get; } = new VirtualMachineSizeTypes("Standard_M64s");
        public static VirtualMachineSizeTypes Standard_M64ms { get; } = new VirtualMachineSizeTypes("Standard_M64ms");
        public static VirtualMachineSizeTypes Standard_M128s { get; } = new VirtualMachineSizeTypes("Standard_M128s");
        public static VirtualMachineSizeTypes Standard_M128ms { get; } = new VirtualMachineSizeTypes("Standard_M128ms");
        public static VirtualMachineSizeTypes Standard_M64_32ms { get; } = new VirtualMachineSizeTypes("Standard_M64-32ms");
        public static VirtualMachineSizeTypes Standard_M64_16ms { get; } = new VirtualMachineSizeTypes("Standard_M64-16ms");
        public static VirtualMachineSizeTypes Standard_M128_64ms { get; } = new VirtualMachineSizeTypes("Standard_M128-64ms");
        public static VirtualMachineSizeTypes Standard_M128_32ms { get; } = new VirtualMachineSizeTypes("Standard_M128-32ms");
        public static VirtualMachineSizeTypes Standard_NC6 { get; } = new VirtualMachineSizeTypes("Standard_NC6");
        public static VirtualMachineSizeTypes Standard_NC12 { get; } = new VirtualMachineSizeTypes("Standard_NC12");
        public static VirtualMachineSizeTypes Standard_NC24 { get; } = new VirtualMachineSizeTypes("Standard_NC24");
        public static VirtualMachineSizeTypes Standard_NC24r { get; } = new VirtualMachineSizeTypes("Standard_NC24r");
        public static VirtualMachineSizeTypes Standard_NC6s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC6s_v2");
        public static VirtualMachineSizeTypes Standard_NC12s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC12s_v2");
        public static VirtualMachineSizeTypes Standard_NC24s_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC24s_v2");
        public static VirtualMachineSizeTypes Standard_NC24rs_v2 { get; } = new VirtualMachineSizeTypes("Standard_NC24rs_v2");
        public static VirtualMachineSizeTypes Standard_NC6s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC6s_v3");
        public static VirtualMachineSizeTypes Standard_NC12s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC12s_v3");
        public static VirtualMachineSizeTypes Standard_NC24s_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC24s_v3");
        public static VirtualMachineSizeTypes Standard_NC24rs_v3 { get; } = new VirtualMachineSizeTypes("Standard_NC24rs_v3");
        public static VirtualMachineSizeTypes Standard_ND6s { get; } = new VirtualMachineSizeTypes("Standard_ND6s");
        public static VirtualMachineSizeTypes Standard_ND12s { get; } = new VirtualMachineSizeTypes("Standard_ND12s");
        public static VirtualMachineSizeTypes Standard_ND24s { get; } = new VirtualMachineSizeTypes("Standard_ND24s");
        public static VirtualMachineSizeTypes Standard_ND24rs { get; } = new VirtualMachineSizeTypes("Standard_ND24rs");
        public static VirtualMachineSizeTypes Standard_NV6 { get; } = new VirtualMachineSizeTypes("Standard_NV6");
        public static VirtualMachineSizeTypes Standard_NV12 { get; } = new VirtualMachineSizeTypes("Standard_NV12");
        public static VirtualMachineSizeTypes Standard_NV24 { get; } = new VirtualMachineSizeTypes("Standard_NV24");

        public static bool operator ==(VirtualMachineSizeTypes left, VirtualMachineSizeTypes right) => left.Equals(right);
        public static bool operator !=(VirtualMachineSizeTypes left, VirtualMachineSizeTypes right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineSizeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineSizeTypes other && Equals(other);
        public bool Equals(VirtualMachineSizeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest patch assessment for the IaaS virtual machine.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - You control the timing of patch assessments on a virtual machine.&lt;br /&gt;&lt;br /&gt; **AutomaticByPlatform** - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true. 
    /// </summary>
    [EnumType]
    public readonly struct WindowsPatchAssessmentMode : IEquatable<WindowsPatchAssessmentMode>
    {
        private readonly string _value;

        private WindowsPatchAssessmentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WindowsPatchAssessmentMode ImageDefault { get; } = new WindowsPatchAssessmentMode("ImageDefault");
        public static WindowsPatchAssessmentMode AutomaticByPlatform { get; } = new WindowsPatchAssessmentMode("AutomaticByPlatform");

        public static bool operator ==(WindowsPatchAssessmentMode left, WindowsPatchAssessmentMode right) => left.Equals(right);
        public static bool operator !=(WindowsPatchAssessmentMode left, WindowsPatchAssessmentMode right) => !left.Equals(right);

        public static explicit operator string(WindowsPatchAssessmentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsPatchAssessmentMode other && Equals(other);
        public bool Equals(WindowsPatchAssessmentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
    /// </summary>
    [EnumType]
    public readonly struct WindowsVMGuestPatchAutomaticByPlatformRebootSetting : IEquatable<WindowsVMGuestPatchAutomaticByPlatformRebootSetting>
    {
        private readonly string _value;

        private WindowsVMGuestPatchAutomaticByPlatformRebootSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Unknown { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Unknown");
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting IfRequired { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("IfRequired");
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Never { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Never");
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Always { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Always");

        public static bool operator ==(WindowsVMGuestPatchAutomaticByPlatformRebootSetting left, WindowsVMGuestPatchAutomaticByPlatformRebootSetting right) => left.Equals(right);
        public static bool operator !=(WindowsVMGuestPatchAutomaticByPlatformRebootSetting left, WindowsVMGuestPatchAutomaticByPlatformRebootSetting right) => !left.Equals(right);

        public static explicit operator string(WindowsVMGuestPatchAutomaticByPlatformRebootSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsVMGuestPatchAutomaticByPlatformRebootSetting other && Equals(other);
        public bool Equals(WindowsVMGuestPatchAutomaticByPlatformRebootSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual machine scale set with OrchestrationMode as Flexible.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **Manual** - You  control the application of patches to a virtual machine. You do this by applying patches manually inside the VM. In this mode, automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be false&lt;br /&gt;&lt;br /&gt; **AutomaticByOS** - The virtual machine will automatically be updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates must be true. &lt;br /&gt;&lt;br /&gt; **AutomaticByPlatform** - the virtual machine will automatically updated by the platform. The properties provisionVMAgent and WindowsConfiguration.enableAutomaticUpdates must be true 
    /// </summary>
    [EnumType]
    public readonly struct WindowsVMGuestPatchMode : IEquatable<WindowsVMGuestPatchMode>
    {
        private readonly string _value;

        private WindowsVMGuestPatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WindowsVMGuestPatchMode Manual { get; } = new WindowsVMGuestPatchMode("Manual");
        public static WindowsVMGuestPatchMode AutomaticByOS { get; } = new WindowsVMGuestPatchMode("AutomaticByOS");
        public static WindowsVMGuestPatchMode AutomaticByPlatform { get; } = new WindowsVMGuestPatchMode("AutomaticByPlatform");

        public static bool operator ==(WindowsVMGuestPatchMode left, WindowsVMGuestPatchMode right) => left.Equals(right);
        public static bool operator !=(WindowsVMGuestPatchMode left, WindowsVMGuestPatchMode right) => !left.Equals(right);

        public static explicit operator string(WindowsVMGuestPatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsVMGuestPatchMode other && Equals(other);
        public bool Equals(WindowsVMGuestPatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the align mode between Virtual Machine Scale Set compute and storage Fault Domain count.
    /// </summary>
    [EnumType]
    public readonly struct ZonalPlatformFaultDomainAlignMode : IEquatable<ZonalPlatformFaultDomainAlignMode>
    {
        private readonly string _value;

        private ZonalPlatformFaultDomainAlignMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ZonalPlatformFaultDomainAlignMode Aligned { get; } = new ZonalPlatformFaultDomainAlignMode("Aligned");
        public static ZonalPlatformFaultDomainAlignMode Unaligned { get; } = new ZonalPlatformFaultDomainAlignMode("Unaligned");

        public static bool operator ==(ZonalPlatformFaultDomainAlignMode left, ZonalPlatformFaultDomainAlignMode right) => left.Equals(right);
        public static bool operator !=(ZonalPlatformFaultDomainAlignMode left, ZonalPlatformFaultDomainAlignMode right) => !left.Equals(right);

        public static explicit operator string(ZonalPlatformFaultDomainAlignMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZonalPlatformFaultDomainAlignMode other && Equals(other);
        public bool Equals(ZonalPlatformFaultDomainAlignMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the policy for virtual machine's placement in availability zone. Possible values are: **Any** - An availability zone will be automatically picked by system as part of virtual machine creation.
    /// </summary>
    [EnumType]
    public readonly struct ZonePlacementPolicyType : IEquatable<ZonePlacementPolicyType>
    {
        private readonly string _value;

        private ZonePlacementPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ZonePlacementPolicyType Any { get; } = new ZonePlacementPolicyType("Any");

        public static bool operator ==(ZonePlacementPolicyType left, ZonePlacementPolicyType right) => left.Equals(right);
        public static bool operator !=(ZonePlacementPolicyType left, ZonePlacementPolicyType right) => !left.Equals(right);

        public static explicit operator string(ZonePlacementPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZonePlacementPolicyType other && Equals(other);
        public bool Equals(ZonePlacementPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
