// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Compute.V20220303
{
    /// <summary>
    /// The architecture of the image. Applicable to OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct Architecture : IEquatable<Architecture>
    {
        private readonly string _value;

        private Architecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Architecture X64 { get; } = new Architecture("x64");
        public static Architecture Arm64 { get; } = new Architecture("Arm64");

        public static bool operator ==(Architecture left, Architecture right) => left.Equals(right);
        public static bool operator !=(Architecture left, Architecture right) => !left.Equals(right);

        public static explicit operator string(Architecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Architecture other && Equals(other);
        public bool Equals(Architecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// confidential VM encryption types
    /// </summary>
    [EnumType]
    public readonly struct ConfidentialVMEncryptionType : IEquatable<ConfidentialVMEncryptionType>
    {
        private readonly string _value;

        private ConfidentialVMEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConfidentialVMEncryptionType EncryptedVMGuestStateOnlyWithPmk { get; } = new ConfidentialVMEncryptionType("EncryptedVMGuestStateOnlyWithPmk");
        public static ConfidentialVMEncryptionType EncryptedWithPmk { get; } = new ConfidentialVMEncryptionType("EncryptedWithPmk");
        public static ConfidentialVMEncryptionType EncryptedWithCmk { get; } = new ConfidentialVMEncryptionType("EncryptedWithCmk");

        public static bool operator ==(ConfidentialVMEncryptionType left, ConfidentialVMEncryptionType right) => left.Equals(right);
        public static bool operator !=(ConfidentialVMEncryptionType left, ConfidentialVMEncryptionType right) => !left.Equals(right);

        public static explicit operator string(ConfidentialVMEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConfidentialVMEncryptionType other && Equals(other);
        public bool Equals(ConfidentialVMEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type to be used to store the image. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct EdgeZoneStorageAccountType : IEquatable<EdgeZoneStorageAccountType>
    {
        private readonly string _value;

        private EdgeZoneStorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EdgeZoneStorageAccountType Standard_LRS { get; } = new EdgeZoneStorageAccountType("Standard_LRS");
        public static EdgeZoneStorageAccountType Standard_ZRS { get; } = new EdgeZoneStorageAccountType("Standard_ZRS");
        public static EdgeZoneStorageAccountType StandardSSD_LRS { get; } = new EdgeZoneStorageAccountType("StandardSSD_LRS");
        public static EdgeZoneStorageAccountType Premium_LRS { get; } = new EdgeZoneStorageAccountType("Premium_LRS");

        public static bool operator ==(EdgeZoneStorageAccountType left, EdgeZoneStorageAccountType right) => left.Equals(right);
        public static bool operator !=(EdgeZoneStorageAccountType left, EdgeZoneStorageAccountType right) => !left.Equals(right);

        public static explicit operator string(EdgeZoneStorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EdgeZoneStorageAccountType other && Equals(other);
        public bool Equals(EdgeZoneStorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the custom action parameter. Possible values are: String, ConfigurationDataBlob or LogOutputBlob
    /// </summary>
    [EnumType]
    public readonly struct GalleryApplicationCustomActionParameterType : IEquatable<GalleryApplicationCustomActionParameterType>
    {
        private readonly string _value;

        private GalleryApplicationCustomActionParameterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GalleryApplicationCustomActionParameterType String { get; } = new GalleryApplicationCustomActionParameterType("String");
        public static GalleryApplicationCustomActionParameterType ConfigurationDataBlob { get; } = new GalleryApplicationCustomActionParameterType("ConfigurationDataBlob");
        public static GalleryApplicationCustomActionParameterType LogOutputBlob { get; } = new GalleryApplicationCustomActionParameterType("LogOutputBlob");

        public static bool operator ==(GalleryApplicationCustomActionParameterType left, GalleryApplicationCustomActionParameterType right) => left.Equals(right);
        public static bool operator !=(GalleryApplicationCustomActionParameterType left, GalleryApplicationCustomActionParameterType right) => !left.Equals(right);

        public static explicit operator string(GalleryApplicationCustomActionParameterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GalleryApplicationCustomActionParameterType other && Equals(other);
        public bool Equals(GalleryApplicationCustomActionParameterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// It is type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct GalleryExtendedLocationType : IEquatable<GalleryExtendedLocationType>
    {
        private readonly string _value;

        private GalleryExtendedLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GalleryExtendedLocationType EdgeZone { get; } = new GalleryExtendedLocationType("EdgeZone");
        public static GalleryExtendedLocationType Unknown { get; } = new GalleryExtendedLocationType("Unknown");

        public static bool operator ==(GalleryExtendedLocationType left, GalleryExtendedLocationType right) => left.Equals(right);
        public static bool operator !=(GalleryExtendedLocationType left, GalleryExtendedLocationType right) => !left.Equals(right);

        public static explicit operator string(GalleryExtendedLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GalleryExtendedLocationType other && Equals(other);
        public bool Equals(GalleryExtendedLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the permission of sharing gallery. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Private** &lt;br&gt;&lt;br&gt; **Groups** &lt;br&gt;&lt;br&gt; **Community**
    /// </summary>
    [EnumType]
    public readonly struct GallerySharingPermissionTypes : IEquatable<GallerySharingPermissionTypes>
    {
        private readonly string _value;

        private GallerySharingPermissionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GallerySharingPermissionTypes Private { get; } = new GallerySharingPermissionTypes("Private");
        public static GallerySharingPermissionTypes Groups { get; } = new GallerySharingPermissionTypes("Groups");
        public static GallerySharingPermissionTypes Community { get; } = new GallerySharingPermissionTypes("Community");

        public static bool operator ==(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => left.Equals(right);
        public static bool operator !=(GallerySharingPermissionTypes left, GallerySharingPermissionTypes right) => !left.Equals(right);

        public static explicit operator string(GallerySharingPermissionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GallerySharingPermissionTypes other && Equals(other);
        public bool Equals(GallerySharingPermissionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The host caching of the disk. Valid values are 'None', 'ReadOnly', and 'ReadWrite'
    /// </summary>
    [EnumType]
    public readonly struct HostCaching : IEquatable<HostCaching>
    {
        private readonly string _value;

        private HostCaching(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostCaching None { get; } = new HostCaching("None");
        public static HostCaching ReadOnly { get; } = new HostCaching("ReadOnly");
        public static HostCaching ReadWrite { get; } = new HostCaching("ReadWrite");

        public static bool operator ==(HostCaching left, HostCaching right) => left.Equals(right);
        public static bool operator !=(HostCaching left, HostCaching right) => !left.Equals(right);

        public static explicit operator string(HostCaching value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostCaching other && Equals(other);
        public bool Equals(HostCaching other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows the user to specify whether the virtual machines created under this image are 'Generalized' or 'Specialized'.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemStateTypes : IEquatable<OperatingSystemStateTypes>
    {
        private readonly string _value;

        private OperatingSystemStateTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemStateTypes Generalized { get; } = new OperatingSystemStateTypes("Generalized");
        public static OperatingSystemStateTypes Specialized { get; } = new OperatingSystemStateTypes("Specialized");

        public static bool operator ==(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemStateTypes left, OperatingSystemStateTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemStateTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemStateTypes other && Equals(other);
        public bool Equals(OperatingSystemStateTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the type of the OS that is included in the disk when creating a VM from a managed image. &lt;br&gt;&lt;br&gt; Possible values are: &lt;br&gt;&lt;br&gt; **Windows** &lt;br&gt;&lt;br&gt; **Linux**
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional parameter which specifies the mode to be used for replication. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationMode : IEquatable<ReplicationMode>
    {
        private readonly string _value;

        private ReplicationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReplicationMode Full { get; } = new ReplicationMode("Full");
        public static ReplicationMode Shallow { get; } = new ReplicationMode("Shallow");

        public static bool operator ==(ReplicationMode left, ReplicationMode right) => left.Equals(right);
        public static bool operator !=(ReplicationMode left, ReplicationMode right) => !left.Equals(right);

        public static explicit operator string(ReplicationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationMode other && Equals(other);
        public bool Equals(ReplicationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type to be used to store the image. This property is not updatable.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountType Standard_LRS { get; } = new StorageAccountType("Standard_LRS");
        public static StorageAccountType Standard_ZRS { get; } = new StorageAccountType("Standard_ZRS");
        public static StorageAccountType Premium_LRS { get; } = new StorageAccountType("Premium_LRS");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
