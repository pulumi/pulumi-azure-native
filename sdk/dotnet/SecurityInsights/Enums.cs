// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.SecurityInsights
{
    /// <summary>
    /// The alert rule kind
    /// </summary>
    [EnumType]
    public readonly struct AlertRuleKind : IEquatable<AlertRuleKind>
    {
        private readonly string _value;

        private AlertRuleKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AlertRuleKind Scheduled { get; } = new AlertRuleKind("Scheduled");
        public static AlertRuleKind MicrosoftSecurityIncidentCreation { get; } = new AlertRuleKind("MicrosoftSecurityIncidentCreation");
        public static AlertRuleKind Fusion { get; } = new AlertRuleKind("Fusion");

        public static bool operator ==(AlertRuleKind left, AlertRuleKind right) => left.Equals(right);
        public static bool operator !=(AlertRuleKind left, AlertRuleKind right) => !left.Equals(right);

        public static explicit operator string(AlertRuleKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlertRuleKind other && Equals(other);
        public bool Equals(AlertRuleKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity for alerts created by this alert rule.
    /// </summary>
    [EnumType]
    public readonly struct AlertSeverity : IEquatable<AlertSeverity>
    {
        private readonly string _value;

        private AlertSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// High severity
        /// </summary>
        public static AlertSeverity High { get; } = new AlertSeverity("High");
        /// <summary>
        /// Medium severity
        /// </summary>
        public static AlertSeverity Medium { get; } = new AlertSeverity("Medium");
        /// <summary>
        /// Low severity
        /// </summary>
        public static AlertSeverity Low { get; } = new AlertSeverity("Low");
        /// <summary>
        /// Informational severity
        /// </summary>
        public static AlertSeverity Informational { get; } = new AlertSeverity("Informational");

        public static bool operator ==(AlertSeverity left, AlertSeverity right) => left.Equals(right);
        public static bool operator !=(AlertSeverity left, AlertSeverity right) => !left.Equals(right);

        public static explicit operator string(AlertSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlertSeverity other && Equals(other);
        public bool Equals(AlertSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity for alerts created by this alert rule.
    /// </summary>
    [EnumType]
    public readonly struct AttackTactic : IEquatable<AttackTactic>
    {
        private readonly string _value;

        private AttackTactic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttackTactic InitialAccess { get; } = new AttackTactic("InitialAccess");
        public static AttackTactic Execution { get; } = new AttackTactic("Execution");
        public static AttackTactic Persistence { get; } = new AttackTactic("Persistence");
        public static AttackTactic PrivilegeEscalation { get; } = new AttackTactic("PrivilegeEscalation");
        public static AttackTactic DefenseEvasion { get; } = new AttackTactic("DefenseEvasion");
        public static AttackTactic CredentialAccess { get; } = new AttackTactic("CredentialAccess");
        public static AttackTactic Discovery { get; } = new AttackTactic("Discovery");
        public static AttackTactic LateralMovement { get; } = new AttackTactic("LateralMovement");
        public static AttackTactic Collection { get; } = new AttackTactic("Collection");
        public static AttackTactic Exfiltration { get; } = new AttackTactic("Exfiltration");
        public static AttackTactic CommandAndControl { get; } = new AttackTactic("CommandAndControl");
        public static AttackTactic Impact { get; } = new AttackTactic("Impact");

        public static bool operator ==(AttackTactic left, AttackTactic right) => left.Equals(right);
        public static bool operator !=(AttackTactic left, AttackTactic right) => !left.Equals(right);

        public static explicit operator string(AttackTactic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttackTactic other && Equals(other);
        public bool Equals(AttackTactic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the automation rule action
    /// </summary>
    [EnumType]
    public readonly struct AutomationRuleActionType : IEquatable<AutomationRuleActionType>
    {
        private readonly string _value;

        private AutomationRuleActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Modify an object's properties
        /// </summary>
        public static AutomationRuleActionType ModifyProperties { get; } = new AutomationRuleActionType("ModifyProperties");
        /// <summary>
        /// Run a playbook on an object
        /// </summary>
        public static AutomationRuleActionType RunPlaybook { get; } = new AutomationRuleActionType("RunPlaybook");

        public static bool operator ==(AutomationRuleActionType left, AutomationRuleActionType right) => left.Equals(right);
        public static bool operator !=(AutomationRuleActionType left, AutomationRuleActionType right) => !left.Equals(right);

        public static explicit operator string(AutomationRuleActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutomationRuleActionType other && Equals(other);
        public bool Equals(AutomationRuleActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the automation rule condition
    /// </summary>
    [EnumType]
    public readonly struct AutomationRuleConditionType : IEquatable<AutomationRuleConditionType>
    {
        private readonly string _value;

        private AutomationRuleConditionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Evaluate an object property value
        /// </summary>
        public static AutomationRuleConditionType Property { get; } = new AutomationRuleConditionType("Property");

        public static bool operator ==(AutomationRuleConditionType left, AutomationRuleConditionType right) => left.Equals(right);
        public static bool operator !=(AutomationRuleConditionType left, AutomationRuleConditionType right) => !left.Equals(right);

        public static explicit operator string(AutomationRuleConditionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutomationRuleConditionType other && Equals(other);
        public bool Equals(AutomationRuleConditionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator to use for evaluation the condition
    /// </summary>
    [EnumType]
    public readonly struct AutomationRulePropertyConditionSupportedOperator : IEquatable<AutomationRulePropertyConditionSupportedOperator>
    {
        private readonly string _value;

        private AutomationRulePropertyConditionSupportedOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Evaluates if the property equals at least one of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator EqualsValue { get; } = new AutomationRulePropertyConditionSupportedOperator("Equals");
        /// <summary>
        /// Evaluates if the property does not equal any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator NotEquals { get; } = new AutomationRulePropertyConditionSupportedOperator("NotEquals");
        /// <summary>
        /// Evaluates if the property contains at least one of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator Contains { get; } = new AutomationRulePropertyConditionSupportedOperator("Contains");
        /// <summary>
        /// Evaluates if the property does not contain any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator NotContains { get; } = new AutomationRulePropertyConditionSupportedOperator("NotContains");
        /// <summary>
        /// Evaluates if the property starts with any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator StartsWith { get; } = new AutomationRulePropertyConditionSupportedOperator("StartsWith");
        /// <summary>
        /// Evaluates if the property does not start with any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator NotStartsWith { get; } = new AutomationRulePropertyConditionSupportedOperator("NotStartsWith");
        /// <summary>
        /// Evaluates if the property ends with any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator EndsWith { get; } = new AutomationRulePropertyConditionSupportedOperator("EndsWith");
        /// <summary>
        /// Evaluates if the property does not end with any of the condition values
        /// </summary>
        public static AutomationRulePropertyConditionSupportedOperator NotEndsWith { get; } = new AutomationRulePropertyConditionSupportedOperator("NotEndsWith");

        public static bool operator ==(AutomationRulePropertyConditionSupportedOperator left, AutomationRulePropertyConditionSupportedOperator right) => left.Equals(right);
        public static bool operator !=(AutomationRulePropertyConditionSupportedOperator left, AutomationRulePropertyConditionSupportedOperator right) => !left.Equals(right);

        public static explicit operator string(AutomationRulePropertyConditionSupportedOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutomationRulePropertyConditionSupportedOperator other && Equals(other);
        public bool Equals(AutomationRulePropertyConditionSupportedOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The property to evaluate
    /// </summary>
    [EnumType]
    public readonly struct AutomationRulePropertyConditionSupportedProperty : IEquatable<AutomationRulePropertyConditionSupportedProperty>
    {
        private readonly string _value;

        private AutomationRulePropertyConditionSupportedProperty(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The title of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentTitle { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentTitle");
        /// <summary>
        /// The description of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentDescription { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentDescription");
        /// <summary>
        /// The severity of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentSeverity { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentSeverity");
        /// <summary>
        /// The status of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentStatus { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentStatus");
        /// <summary>
        /// The tactics of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentTactics { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentTactics");
        /// <summary>
        /// The related Analytic rule ids of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentRelatedAnalyticRuleIds { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentRelatedAnalyticRuleIds");
        /// <summary>
        /// The provider name of the incident
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IncidentProviderName { get; } = new AutomationRulePropertyConditionSupportedProperty("IncidentProviderName");
        /// <summary>
        /// The account Azure Active Directory tenant id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountAadTenantId { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountAadTenantId");
        /// <summary>
        /// The account Azure Active Directory user id.
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountAadUserId { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountAadUserId");
        /// <summary>
        /// The account name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountName { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountName");
        /// <summary>
        /// The account NetBIOS domain name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountNTDomain { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountNTDomain");
        /// <summary>
        /// The account Azure Active Directory Passport User ID
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountPUID { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountPUID");
        /// <summary>
        /// The account security identifier
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountSid { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountSid");
        /// <summary>
        /// The account unique identifier
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountObjectGuid { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountObjectGuid");
        /// <summary>
        /// The account user principal name suffix
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AccountUPNSuffix { get; } = new AutomationRulePropertyConditionSupportedProperty("AccountUPNSuffix");
        /// <summary>
        /// The Azure resource id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AzureResourceResourceId { get; } = new AutomationRulePropertyConditionSupportedProperty("AzureResourceResourceId");
        /// <summary>
        /// The Azure resource subscription id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty AzureResourceSubscriptionId { get; } = new AutomationRulePropertyConditionSupportedProperty("AzureResourceSubscriptionId");
        /// <summary>
        /// The cloud application identifier
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty CloudApplicationAppId { get; } = new AutomationRulePropertyConditionSupportedProperty("CloudApplicationAppId");
        /// <summary>
        /// The cloud application name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty CloudApplicationAppName { get; } = new AutomationRulePropertyConditionSupportedProperty("CloudApplicationAppName");
        /// <summary>
        /// The dns record domain name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty DNSDomainName { get; } = new AutomationRulePropertyConditionSupportedProperty("DNSDomainName");
        /// <summary>
        /// The file directory full path
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty FileDirectory { get; } = new AutomationRulePropertyConditionSupportedProperty("FileDirectory");
        /// <summary>
        /// The file name without path
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty FileName { get; } = new AutomationRulePropertyConditionSupportedProperty("FileName");
        /// <summary>
        /// The file hash value
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty FileHashValue { get; } = new AutomationRulePropertyConditionSupportedProperty("FileHashValue");
        /// <summary>
        /// The host Azure resource id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty HostAzureID { get; } = new AutomationRulePropertyConditionSupportedProperty("HostAzureID");
        /// <summary>
        /// The host name without domain
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty HostName { get; } = new AutomationRulePropertyConditionSupportedProperty("HostName");
        /// <summary>
        /// The host NetBIOS name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty HostNetBiosName { get; } = new AutomationRulePropertyConditionSupportedProperty("HostNetBiosName");
        /// <summary>
        /// The host NT domain
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty HostNTDomain { get; } = new AutomationRulePropertyConditionSupportedProperty("HostNTDomain");
        /// <summary>
        /// The host operating system
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty HostOSVersion { get; } = new AutomationRulePropertyConditionSupportedProperty("HostOSVersion");
        /// <summary>
        /// The IoT device id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceId { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceId");
        /// <summary>
        /// The IoT device name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceName { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceName");
        /// <summary>
        /// The IoT device type
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceType { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceType");
        /// <summary>
        /// The IoT device vendor
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceVendor { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceVendor");
        /// <summary>
        /// The IoT device model
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceModel { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceModel");
        /// <summary>
        /// The IoT device operating system
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IoTDeviceOperatingSystem { get; } = new AutomationRulePropertyConditionSupportedProperty("IoTDeviceOperatingSystem");
        /// <summary>
        /// The IP address
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty IPAddress { get; } = new AutomationRulePropertyConditionSupportedProperty("IPAddress");
        /// <summary>
        /// The mailbox display name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailboxDisplayName { get; } = new AutomationRulePropertyConditionSupportedProperty("MailboxDisplayName");
        /// <summary>
        /// The mailbox primary address
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailboxPrimaryAddress { get; } = new AutomationRulePropertyConditionSupportedProperty("MailboxPrimaryAddress");
        /// <summary>
        /// The mailbox user principal name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailboxUPN { get; } = new AutomationRulePropertyConditionSupportedProperty("MailboxUPN");
        /// <summary>
        /// The mail message delivery action
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageDeliveryAction { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageDeliveryAction");
        /// <summary>
        /// The mail message delivery location
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageDeliveryLocation { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageDeliveryLocation");
        /// <summary>
        /// The mail message recipient
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageRecipient { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageRecipient");
        /// <summary>
        /// The mail message sender IP address
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageSenderIP { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageSenderIP");
        /// <summary>
        /// The mail message subject
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageSubject { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageSubject");
        /// <summary>
        /// The mail message P1 sender
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageP1Sender { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageP1Sender");
        /// <summary>
        /// The mail message P2 sender
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MailMessageP2Sender { get; } = new AutomationRulePropertyConditionSupportedProperty("MailMessageP2Sender");
        /// <summary>
        /// The malware category
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MalwareCategory { get; } = new AutomationRulePropertyConditionSupportedProperty("MalwareCategory");
        /// <summary>
        /// The malware name
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty MalwareName { get; } = new AutomationRulePropertyConditionSupportedProperty("MalwareName");
        /// <summary>
        /// The process execution command line
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty ProcessCommandLine { get; } = new AutomationRulePropertyConditionSupportedProperty("ProcessCommandLine");
        /// <summary>
        /// The process id
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty ProcessId { get; } = new AutomationRulePropertyConditionSupportedProperty("ProcessId");
        /// <summary>
        /// The registry key path
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty RegistryKey { get; } = new AutomationRulePropertyConditionSupportedProperty("RegistryKey");
        /// <summary>
        /// The registry key value in string formatted representation
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty RegistryValueData { get; } = new AutomationRulePropertyConditionSupportedProperty("RegistryValueData");
        /// <summary>
        /// The url
        /// </summary>
        public static AutomationRulePropertyConditionSupportedProperty Url { get; } = new AutomationRulePropertyConditionSupportedProperty("Url");

        public static bool operator ==(AutomationRulePropertyConditionSupportedProperty left, AutomationRulePropertyConditionSupportedProperty right) => left.Equals(right);
        public static bool operator !=(AutomationRulePropertyConditionSupportedProperty left, AutomationRulePropertyConditionSupportedProperty right) => !left.Equals(right);

        public static explicit operator string(AutomationRulePropertyConditionSupportedProperty value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutomationRulePropertyConditionSupportedProperty other && Equals(other);
        public bool Equals(AutomationRulePropertyConditionSupportedProperty other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity of the incident
    /// </summary>
    [EnumType]
    public readonly struct CaseSeverity : IEquatable<CaseSeverity>
    {
        private readonly string _value;

        private CaseSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Critical severity
        /// </summary>
        public static CaseSeverity Critical { get; } = new CaseSeverity("Critical");
        /// <summary>
        /// High severity
        /// </summary>
        public static CaseSeverity High { get; } = new CaseSeverity("High");
        /// <summary>
        /// Medium severity
        /// </summary>
        public static CaseSeverity Medium { get; } = new CaseSeverity("Medium");
        /// <summary>
        /// Low severity
        /// </summary>
        public static CaseSeverity Low { get; } = new CaseSeverity("Low");
        /// <summary>
        /// Informational severity
        /// </summary>
        public static CaseSeverity Informational { get; } = new CaseSeverity("Informational");

        public static bool operator ==(CaseSeverity left, CaseSeverity right) => left.Equals(right);
        public static bool operator !=(CaseSeverity left, CaseSeverity right) => !left.Equals(right);

        public static explicit operator string(CaseSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CaseSeverity other && Equals(other);
        public bool Equals(CaseSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The data connector kind
    /// </summary>
    [EnumType]
    public readonly struct DataConnectorKind : IEquatable<DataConnectorKind>
    {
        private readonly string _value;

        private DataConnectorKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataConnectorKind AzureActiveDirectory { get; } = new DataConnectorKind("AzureActiveDirectory");
        public static DataConnectorKind AzureSecurityCenter { get; } = new DataConnectorKind("AzureSecurityCenter");
        public static DataConnectorKind MicrosoftCloudAppSecurity { get; } = new DataConnectorKind("MicrosoftCloudAppSecurity");
        public static DataConnectorKind ThreatIntelligence { get; } = new DataConnectorKind("ThreatIntelligence");
        public static DataConnectorKind Office365 { get; } = new DataConnectorKind("Office365");
        public static DataConnectorKind AmazonWebServicesCloudTrail { get; } = new DataConnectorKind("AmazonWebServicesCloudTrail");
        public static DataConnectorKind AzureAdvancedThreatProtection { get; } = new DataConnectorKind("AzureAdvancedThreatProtection");
        public static DataConnectorKind MicrosoftDefenderAdvancedThreatProtection { get; } = new DataConnectorKind("MicrosoftDefenderAdvancedThreatProtection");

        public static bool operator ==(DataConnectorKind left, DataConnectorKind right) => left.Equals(right);
        public static bool operator !=(DataConnectorKind left, DataConnectorKind right) => !left.Equals(right);

        public static explicit operator string(DataConnectorKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataConnectorKind other && Equals(other);
        public bool Equals(DataConnectorKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describe whether this data type connection is enabled or not.
    /// </summary>
    [EnumType]
    public readonly struct DataTypeState : IEquatable<DataTypeState>
    {
        private readonly string _value;

        private DataTypeState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataTypeState Enabled { get; } = new DataTypeState("Enabled");
        public static DataTypeState Disabled { get; } = new DataTypeState("Disabled");

        public static bool operator ==(DataTypeState left, DataTypeState right) => left.Equals(right);
        public static bool operator !=(DataTypeState left, DataTypeState right) => !left.Equals(right);

        public static explicit operator string(DataTypeState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataTypeState other && Equals(other);
        public bool Equals(DataTypeState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The entity query kind
    /// </summary>
    [EnumType]
    public readonly struct EntityTimelineKind : IEquatable<EntityTimelineKind>
    {
        private readonly string _value;

        private EntityTimelineKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// activity
        /// </summary>
        public static EntityTimelineKind Activity { get; } = new EntityTimelineKind("Activity");
        /// <summary>
        /// bookmarks
        /// </summary>
        public static EntityTimelineKind Bookmark { get; } = new EntityTimelineKind("Bookmark");
        /// <summary>
        /// security alerts
        /// </summary>
        public static EntityTimelineKind SecurityAlert { get; } = new EntityTimelineKind("SecurityAlert");

        public static bool operator ==(EntityTimelineKind left, EntityTimelineKind right) => left.Equals(right);
        public static bool operator !=(EntityTimelineKind left, EntityTimelineKind right) => !left.Equals(right);

        public static explicit operator string(EntityTimelineKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EntityTimelineKind other && Equals(other);
        public bool Equals(EntityTimelineKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The reason the incident was closed
    /// </summary>
    [EnumType]
    public readonly struct IncidentClassification : IEquatable<IncidentClassification>
    {
        private readonly string _value;

        private IncidentClassification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Incident classification was undetermined
        /// </summary>
        public static IncidentClassification Undetermined { get; } = new IncidentClassification("Undetermined");
        /// <summary>
        /// Incident was true positive
        /// </summary>
        public static IncidentClassification TruePositive { get; } = new IncidentClassification("TruePositive");
        /// <summary>
        /// Incident was benign positive
        /// </summary>
        public static IncidentClassification BenignPositive { get; } = new IncidentClassification("BenignPositive");
        /// <summary>
        /// Incident was false positive
        /// </summary>
        public static IncidentClassification FalsePositive { get; } = new IncidentClassification("FalsePositive");

        public static bool operator ==(IncidentClassification left, IncidentClassification right) => left.Equals(right);
        public static bool operator !=(IncidentClassification left, IncidentClassification right) => !left.Equals(right);

        public static explicit operator string(IncidentClassification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IncidentClassification other && Equals(other);
        public bool Equals(IncidentClassification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The classification reason the incident was closed with
    /// </summary>
    [EnumType]
    public readonly struct IncidentClassificationReason : IEquatable<IncidentClassificationReason>
    {
        private readonly string _value;

        private IncidentClassificationReason(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Classification reason was suspicious activity
        /// </summary>
        public static IncidentClassificationReason SuspiciousActivity { get; } = new IncidentClassificationReason("SuspiciousActivity");
        /// <summary>
        /// Classification reason was suspicious but expected
        /// </summary>
        public static IncidentClassificationReason SuspiciousButExpected { get; } = new IncidentClassificationReason("SuspiciousButExpected");
        /// <summary>
        /// Classification reason was incorrect alert logic
        /// </summary>
        public static IncidentClassificationReason IncorrectAlertLogic { get; } = new IncidentClassificationReason("IncorrectAlertLogic");
        /// <summary>
        /// Classification reason was inaccurate data
        /// </summary>
        public static IncidentClassificationReason InaccurateData { get; } = new IncidentClassificationReason("InaccurateData");

        public static bool operator ==(IncidentClassificationReason left, IncidentClassificationReason right) => left.Equals(right);
        public static bool operator !=(IncidentClassificationReason left, IncidentClassificationReason right) => !left.Equals(right);

        public static explicit operator string(IncidentClassificationReason value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IncidentClassificationReason other && Equals(other);
        public bool Equals(IncidentClassificationReason other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity of the incident
    /// </summary>
    [EnumType]
    public readonly struct IncidentSeverity : IEquatable<IncidentSeverity>
    {
        private readonly string _value;

        private IncidentSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// High severity
        /// </summary>
        public static IncidentSeverity High { get; } = new IncidentSeverity("High");
        /// <summary>
        /// Medium severity
        /// </summary>
        public static IncidentSeverity Medium { get; } = new IncidentSeverity("Medium");
        /// <summary>
        /// Low severity
        /// </summary>
        public static IncidentSeverity Low { get; } = new IncidentSeverity("Low");
        /// <summary>
        /// Informational severity
        /// </summary>
        public static IncidentSeverity Informational { get; } = new IncidentSeverity("Informational");

        public static bool operator ==(IncidentSeverity left, IncidentSeverity right) => left.Equals(right);
        public static bool operator !=(IncidentSeverity left, IncidentSeverity right) => !left.Equals(right);

        public static explicit operator string(IncidentSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IncidentSeverity other && Equals(other);
        public bool Equals(IncidentSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the incident
    /// </summary>
    [EnumType]
    public readonly struct IncidentStatus : IEquatable<IncidentStatus>
    {
        private readonly string _value;

        private IncidentStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An active incident which isn't being handled currently
        /// </summary>
        public static IncidentStatus New { get; } = new IncidentStatus("New");
        /// <summary>
        /// An active incident which is being handled
        /// </summary>
        public static IncidentStatus Active { get; } = new IncidentStatus("Active");
        /// <summary>
        /// A non-active incident
        /// </summary>
        public static IncidentStatus Closed { get; } = new IncidentStatus("Closed");

        public static bool operator ==(IncidentStatus left, IncidentStatus right) => left.Equals(right);
        public static bool operator !=(IncidentStatus left, IncidentStatus right) => !left.Equals(right);

        public static explicit operator string(IncidentStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IncidentStatus other && Equals(other);
        public bool Equals(IncidentStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The alerts' productName on which the cases will be generated
    /// </summary>
    [EnumType]
    public readonly struct MicrosoftSecurityProductName : IEquatable<MicrosoftSecurityProductName>
    {
        private readonly string _value;

        private MicrosoftSecurityProductName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MicrosoftSecurityProductName Microsoft_Cloud_App_Security { get; } = new MicrosoftSecurityProductName("Microsoft Cloud App Security");
        public static MicrosoftSecurityProductName Azure_Security_Center { get; } = new MicrosoftSecurityProductName("Azure Security Center");
        public static MicrosoftSecurityProductName Azure_Advanced_Threat_Protection { get; } = new MicrosoftSecurityProductName("Azure Advanced Threat Protection");
        public static MicrosoftSecurityProductName Azure_Active_Directory_Identity_Protection { get; } = new MicrosoftSecurityProductName("Azure Active Directory Identity Protection");
        public static MicrosoftSecurityProductName Azure_Security_Center_for_IoT { get; } = new MicrosoftSecurityProductName("Azure Security Center for IoT");

        public static bool operator ==(MicrosoftSecurityProductName left, MicrosoftSecurityProductName right) => left.Equals(right);
        public static bool operator !=(MicrosoftSecurityProductName left, MicrosoftSecurityProductName right) => !left.Equals(right);

        public static explicit operator string(MicrosoftSecurityProductName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MicrosoftSecurityProductName other && Equals(other);
        public bool Equals(MicrosoftSecurityProductName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of the setting
    /// </summary>
    [EnumType]
    public readonly struct SettingKind : IEquatable<SettingKind>
    {
        private readonly string _value;

        private SettingKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SettingKind EyesOn { get; } = new SettingKind("EyesOn");
        public static SettingKind EntityAnalytics { get; } = new SettingKind("EntityAnalytics");
        public static SettingKind Ueba { get; } = new SettingKind("Ueba");

        public static bool operator ==(SettingKind left, SettingKind right) => left.Equals(right);
        public static bool operator !=(SettingKind left, SettingKind right) => !left.Equals(right);

        public static explicit operator string(SettingKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingKind other && Equals(other);
        public bool Equals(SettingKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source of the watchlist
    /// </summary>
    [EnumType]
    public readonly struct Source : IEquatable<Source>
    {
        private readonly string _value;

        private Source(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Source Local_file { get; } = new Source("Local file");
        public static Source Remote_storage { get; } = new Source("Remote storage");

        public static bool operator ==(Source left, Source right) => left.Equals(right);
        public static bool operator !=(Source left, Source right) => !left.Equals(right);

        public static explicit operator string(Source value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Source other && Equals(other);
        public bool Equals(Source other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of the entity.
    /// </summary>
    [EnumType]
    public readonly struct ThreatIntelligenceResourceKind : IEquatable<ThreatIntelligenceResourceKind>
    {
        private readonly string _value;

        private ThreatIntelligenceResourceKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Entity represents threat intelligence indicator in the system.
        /// </summary>
        public static ThreatIntelligenceResourceKind Indicator { get; } = new ThreatIntelligenceResourceKind("indicator");

        public static bool operator ==(ThreatIntelligenceResourceKind left, ThreatIntelligenceResourceKind right) => left.Equals(right);
        public static bool operator !=(ThreatIntelligenceResourceKind left, ThreatIntelligenceResourceKind right) => !left.Equals(right);

        public static explicit operator string(ThreatIntelligenceResourceKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThreatIntelligenceResourceKind other && Equals(other);
        public bool Equals(ThreatIntelligenceResourceKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operation against the threshold that triggers alert rule.
    /// </summary>
    [EnumType]
    public readonly struct TriggerOperator : IEquatable<TriggerOperator>
    {
        private readonly string _value;

        private TriggerOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TriggerOperator GreaterThan { get; } = new TriggerOperator("GreaterThan");
        public static TriggerOperator LessThan { get; } = new TriggerOperator("LessThan");
        public static TriggerOperator Equal { get; } = new TriggerOperator("Equal");
        public static TriggerOperator NotEqual { get; } = new TriggerOperator("NotEqual");

        public static bool operator ==(TriggerOperator left, TriggerOperator right) => left.Equals(right);
        public static bool operator !=(TriggerOperator left, TriggerOperator right) => !left.Equals(right);

        public static explicit operator string(TriggerOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggerOperator other && Equals(other);
        public bool Equals(TriggerOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of object the automation rule triggers on
    /// </summary>
    [EnumType]
    public readonly struct TriggersOn : IEquatable<TriggersOn>
    {
        private readonly string _value;

        private TriggersOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Trigger on Incidents
        /// </summary>
        public static TriggersOn Incidents { get; } = new TriggersOn("Incidents");

        public static bool operator ==(TriggersOn left, TriggersOn right) => left.Equals(right);
        public static bool operator !=(TriggersOn left, TriggersOn right) => !left.Equals(right);

        public static explicit operator string(TriggersOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggersOn other && Equals(other);
        public bool Equals(TriggersOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of event the automation rule triggers on
    /// </summary>
    [EnumType]
    public readonly struct TriggersWhen : IEquatable<TriggersWhen>
    {
        private readonly string _value;

        private TriggersWhen(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Trigger on created objects
        /// </summary>
        public static TriggersWhen Created { get; } = new TriggersWhen("Created");

        public static bool operator ==(TriggersWhen left, TriggersWhen right) => left.Equals(right);
        public static bool operator !=(TriggersWhen left, TriggersWhen right) => !left.Equals(right);

        public static explicit operator string(TriggersWhen value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggersWhen other && Equals(other);
        public bool Equals(TriggersWhen other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The data source that enriched by ueba.
    /// </summary>
    [EnumType]
    public readonly struct UebaDataSources : IEquatable<UebaDataSources>
    {
        private readonly string _value;

        private UebaDataSources(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UebaDataSources AuditLogs { get; } = new UebaDataSources("AuditLogs");
        public static UebaDataSources AzureActivity { get; } = new UebaDataSources("AzureActivity");
        public static UebaDataSources SecurityEvent { get; } = new UebaDataSources("SecurityEvent");
        public static UebaDataSources SigninLogs { get; } = new UebaDataSources("SigninLogs");

        public static bool operator ==(UebaDataSources left, UebaDataSources right) => left.Equals(right);
        public static bool operator !=(UebaDataSources left, UebaDataSources right) => !left.Equals(right);

        public static explicit operator string(UebaDataSources value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UebaDataSources other && Equals(other);
        public bool Equals(UebaDataSources other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
