// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.IoTOperationsMQ
{
    /// <summary>
    /// Memory profile of broker.
    /// </summary>
    [EnumType]
    public readonly struct BrokerMemoryProfile : IEquatable<BrokerMemoryProfile>
    {
        private readonly string _value;

        private BrokerMemoryProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Tiny memory profile.
        /// </summary>
        public static BrokerMemoryProfile Tiny { get; } = new BrokerMemoryProfile("tiny");
        /// <summary>
        /// Low memory profile.
        /// </summary>
        public static BrokerMemoryProfile Low { get; } = new BrokerMemoryProfile("low");
        /// <summary>
        /// Medium memory profile.
        /// </summary>
        public static BrokerMemoryProfile Medium { get; } = new BrokerMemoryProfile("medium");
        /// <summary>
        /// High memory profile.
        /// </summary>
        public static BrokerMemoryProfile High { get; } = new BrokerMemoryProfile("high");

        public static bool operator ==(BrokerMemoryProfile left, BrokerMemoryProfile right) => left.Equals(right);
        public static bool operator !=(BrokerMemoryProfile left, BrokerMemoryProfile right) => !left.Equals(right);

        public static explicit operator string(BrokerMemoryProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BrokerMemoryProfile other && Equals(other);
        public bool Equals(BrokerMemoryProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// DataLake database format to use.
    /// </summary>
    [EnumType]
    public readonly struct DataLakeDatabaseFormat : IEquatable<DataLakeDatabaseFormat>
    {
        private readonly string _value;

        private DataLakeDatabaseFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Delta format.
        /// </summary>
        public static DataLakeDatabaseFormat Delta { get; } = new DataLakeDatabaseFormat("delta");
        /// <summary>
        /// Parquet format.
        /// </summary>
        public static DataLakeDatabaseFormat Parquet { get; } = new DataLakeDatabaseFormat("parquet");

        public static bool operator ==(DataLakeDatabaseFormat left, DataLakeDatabaseFormat right) => left.Equals(right);
        public static bool operator !=(DataLakeDatabaseFormat left, DataLakeDatabaseFormat right) => !left.Equals(right);

        public static explicit operator string(DataLakeDatabaseFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataLakeDatabaseFormat other && Equals(other);
        public bool Equals(DataLakeDatabaseFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Delta table format supported.
    /// </summary>
    [EnumType]
    public readonly struct DeltaTableFormatEnum : IEquatable<DeltaTableFormatEnum>
    {
        private readonly string _value;

        private DeltaTableFormatEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Bool format
        /// </summary>
        public static DeltaTableFormatEnum Boolean { get; } = new DeltaTableFormatEnum("boolean");
        /// <summary>
        /// Signed integer 8
        /// </summary>
        public static DeltaTableFormatEnum Int8 { get; } = new DeltaTableFormatEnum("int8");
        /// <summary>
        /// Signed integer 16
        /// </summary>
        public static DeltaTableFormatEnum Int16 { get; } = new DeltaTableFormatEnum("int16");
        /// <summary>
        /// Signed integer 32
        /// </summary>
        public static DeltaTableFormatEnum Int32 { get; } = new DeltaTableFormatEnum("int32");
        /// <summary>
        /// Unsigned integer 8
        /// </summary>
        public static DeltaTableFormatEnum UInt8 { get; } = new DeltaTableFormatEnum("uInt8");
        /// <summary>
        /// Unsigned integer 16
        /// </summary>
        public static DeltaTableFormatEnum UInt16 { get; } = new DeltaTableFormatEnum("uInt16");
        /// <summary>
        /// Unsigned integer 32
        /// </summary>
        public static DeltaTableFormatEnum UInt32 { get; } = new DeltaTableFormatEnum("uInt32");
        /// <summary>
        /// Unsigned integer 64
        /// </summary>
        public static DeltaTableFormatEnum UInt64 { get; } = new DeltaTableFormatEnum("uInt64");
        /// <summary>
        /// Float 16
        /// </summary>
        public static DeltaTableFormatEnum Float16 { get; } = new DeltaTableFormatEnum("float16");
        /// <summary>
        /// Float 32
        /// </summary>
        public static DeltaTableFormatEnum Float32 { get; } = new DeltaTableFormatEnum("float32");
        /// <summary>
        /// Float 64
        /// </summary>
        public static DeltaTableFormatEnum Float64 { get; } = new DeltaTableFormatEnum("float64");
        /// <summary>
        /// Date 32
        /// </summary>
        public static DeltaTableFormatEnum Date32 { get; } = new DeltaTableFormatEnum("date32");
        /// <summary>
        /// Date 64
        /// </summary>
        public static DeltaTableFormatEnum Date64 { get; } = new DeltaTableFormatEnum("date64");
        /// <summary>
        /// Binary data
        /// </summary>
        public static DeltaTableFormatEnum Binary { get; } = new DeltaTableFormatEnum("binary");
        /// <summary>
        /// UTF8 format
        /// </summary>
        public static DeltaTableFormatEnum Utf8 { get; } = new DeltaTableFormatEnum("utf8");

        public static bool operator ==(DeltaTableFormatEnum left, DeltaTableFormatEnum right) => left.Equals(right);
        public static bool operator !=(DeltaTableFormatEnum left, DeltaTableFormatEnum right) => !left.Equals(right);

        public static explicit operator string(DeltaTableFormatEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeltaTableFormatEnum other && Equals(other);
        public bool Equals(DeltaTableFormatEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of ExtendedLocation.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationType : IEquatable<ExtendedLocationType>
    {
        private readonly string _value;

        private ExtendedLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CustomLocation type
        /// </summary>
        public static ExtendedLocationType CustomLocation { get; } = new ExtendedLocationType("CustomLocation");

        public static bool operator ==(ExtendedLocationType left, ExtendedLocationType right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationType left, ExtendedLocationType right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationType other && Equals(other);
        public bool Equals(ExtendedLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Fabric path type to use.
    /// </summary>
    [EnumType]
    public readonly struct FabricPathType : IEquatable<FabricPathType>
    {
        private readonly string _value;

        private FabricPathType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Fabric path type is Files.
        /// </summary>
        public static FabricPathType Files { get; } = new FabricPathType("files");
        /// <summary>
        /// Fabric path type is Tables.
        /// </summary>
        public static FabricPathType Tables { get; } = new FabricPathType("tables");

        public static bool operator ==(FabricPathType left, FabricPathType right) => left.Equals(right);
        public static bool operator !=(FabricPathType left, FabricPathType right) => !left.Equals(right);

        public static explicit operator string(FabricPathType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FabricPathType other && Equals(other);
        public bool Equals(FabricPathType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kafka acks to use.
    /// </summary>
    [EnumType]
    public readonly struct KafkaAcks : IEquatable<KafkaAcks>
    {
        private readonly string _value;

        private KafkaAcks(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Kafka acks zero.
        /// </summary>
        public static KafkaAcks Zero { get; } = new KafkaAcks("zero");
        /// <summary>
        /// Kafka acks one.
        /// </summary>
        public static KafkaAcks One { get; } = new KafkaAcks("one");
        /// <summary>
        /// Kafka acks all.
        /// </summary>
        public static KafkaAcks All { get; } = new KafkaAcks("all");

        public static bool operator ==(KafkaAcks left, KafkaAcks right) => left.Equals(right);
        public static bool operator !=(KafkaAcks left, KafkaAcks right) => !left.Equals(right);

        public static explicit operator string(KafkaAcks value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KafkaAcks other && Equals(other);
        public bool Equals(KafkaAcks other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The compression to use for kafka messages.
    /// </summary>
    [EnumType]
    public readonly struct KafkaMessageCompressionType : IEquatable<KafkaMessageCompressionType>
    {
        private readonly string _value;

        private KafkaMessageCompressionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No Kafka message compression.
        /// </summary>
        public static KafkaMessageCompressionType None { get; } = new KafkaMessageCompressionType("none");
        /// <summary>
        /// Gzip Kafka message compression.
        /// </summary>
        public static KafkaMessageCompressionType Gzip { get; } = new KafkaMessageCompressionType("gzip");
        /// <summary>
        /// Snappy Kafka message compression.
        /// </summary>
        public static KafkaMessageCompressionType Snappy { get; } = new KafkaMessageCompressionType("snappy");
        /// <summary>
        /// Lz4 Kafka message compression.
        /// </summary>
        public static KafkaMessageCompressionType Lz4 { get; } = new KafkaMessageCompressionType("lz4");

        public static bool operator ==(KafkaMessageCompressionType left, KafkaMessageCompressionType right) => left.Equals(right);
        public static bool operator !=(KafkaMessageCompressionType left, KafkaMessageCompressionType right) => !left.Equals(right);

        public static explicit operator string(KafkaMessageCompressionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KafkaMessageCompressionType other && Equals(other);
        public bool Equals(KafkaMessageCompressionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The partition strategy to use for Kafka.
    /// </summary>
    [EnumType]
    public readonly struct KafkaPartitionStrategy : IEquatable<KafkaPartitionStrategy>
    {
        private readonly string _value;

        private KafkaPartitionStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default partition strategy.
        /// </summary>
        public static KafkaPartitionStrategy @Default { get; } = new KafkaPartitionStrategy("default");
        /// <summary>
        /// Static partition strategy.
        /// </summary>
        public static KafkaPartitionStrategy @Static { get; } = new KafkaPartitionStrategy("static");
        /// <summary>
        /// Topic partition strategy.
        /// </summary>
        public static KafkaPartitionStrategy Topic { get; } = new KafkaPartitionStrategy("topic");
        /// <summary>
        /// Property partition strategy.
        /// </summary>
        public static KafkaPartitionStrategy Property { get; } = new KafkaPartitionStrategy("property");

        public static bool operator ==(KafkaPartitionStrategy left, KafkaPartitionStrategy right) => left.Equals(right);
        public static bool operator !=(KafkaPartitionStrategy left, KafkaPartitionStrategy right) => !left.Equals(right);

        public static explicit operator string(KafkaPartitionStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KafkaPartitionStrategy other && Equals(other);
        public bool Equals(KafkaPartitionStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sasl Mechanism for remote broker authentication.
    /// </summary>
    [EnumType]
    public readonly struct KafkaSaslType : IEquatable<KafkaSaslType>
    {
        private readonly string _value;

        private KafkaSaslType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Sasl Plain authentication.
        /// </summary>
        public static KafkaSaslType Plain { get; } = new KafkaSaslType("plain");
        /// <summary>
        /// Sasl ScramSha256 authentication.
        /// </summary>
        public static KafkaSaslType ScramSha256 { get; } = new KafkaSaslType("scramSha256");
        /// <summary>
        /// Sasl ScramSha512 authentication.
        /// </summary>
        public static KafkaSaslType ScramSha512 { get; } = new KafkaSaslType("scramSha512");

        public static bool operator ==(KafkaSaslType left, KafkaSaslType right) => left.Equals(right);
        public static bool operator !=(KafkaSaslType left, KafkaSaslType right) => !left.Equals(right);

        public static explicit operator string(KafkaSaslType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KafkaSaslType other && Equals(other);
        public bool Equals(KafkaSaslType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol for remote connection.
    /// </summary>
    [EnumType]
    public readonly struct MqttBridgeRemoteBrokerProtocol : IEquatable<MqttBridgeRemoteBrokerProtocol>
    {
        private readonly string _value;

        private MqttBridgeRemoteBrokerProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MQTT protocol.
        /// </summary>
        public static MqttBridgeRemoteBrokerProtocol Mqtt { get; } = new MqttBridgeRemoteBrokerProtocol("mqtt");
        /// <summary>
        /// MQTT over WebSocket protocol.
        /// </summary>
        public static MqttBridgeRemoteBrokerProtocol WebSocket { get; } = new MqttBridgeRemoteBrokerProtocol("webSocket");

        public static bool operator ==(MqttBridgeRemoteBrokerProtocol left, MqttBridgeRemoteBrokerProtocol right) => left.Equals(right);
        public static bool operator !=(MqttBridgeRemoteBrokerProtocol left, MqttBridgeRemoteBrokerProtocol right) => !left.Equals(right);

        public static explicit operator string(MqttBridgeRemoteBrokerProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MqttBridgeRemoteBrokerProtocol other && Equals(other);
        public bool Equals(MqttBridgeRemoteBrokerProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of the route.
    /// </summary>
    [EnumType]
    public readonly struct MqttBridgeRouteDirection : IEquatable<MqttBridgeRouteDirection>
    {
        private readonly string _value;

        private MqttBridgeRouteDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Remote to Local Broker.
        /// </summary>
        public static MqttBridgeRouteDirection RemoteToLocal { get; } = new MqttBridgeRouteDirection("remote-to-local");
        /// <summary>
        /// Local to Remote Broker.
        /// </summary>
        public static MqttBridgeRouteDirection LocalToRemote { get; } = new MqttBridgeRouteDirection("local-to-remote");

        public static bool operator ==(MqttBridgeRouteDirection left, MqttBridgeRouteDirection right) => left.Equals(right);
        public static bool operator !=(MqttBridgeRouteDirection left, MqttBridgeRouteDirection right) => !left.Equals(right);

        public static explicit operator string(MqttBridgeRouteDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MqttBridgeRouteDirection other && Equals(other);
        public bool Equals(MqttBridgeRouteDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol to use for connecting with Brokers.
    /// </summary>
    [EnumType]
    public readonly struct MqttProtocol : IEquatable<MqttProtocol>
    {
        private readonly string _value;

        private MqttProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mqttv3
        /// </summary>
        public static MqttProtocol V3 { get; } = new MqttProtocol("v3");
        /// <summary>
        /// Mqttv5
        /// </summary>
        public static MqttProtocol V5 { get; } = new MqttProtocol("v5");

        public static bool operator ==(MqttProtocol left, MqttProtocol right) => left.Equals(right);
        public static bool operator !=(MqttProtocol left, MqttProtocol right) => !left.Equals(right);

        public static explicit operator string(MqttProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MqttProtocol other && Equals(other);
        public bool Equals(MqttProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of action that the clients can perform on the broker: Connect, Publish or Subscribe.
    /// </summary>
    [EnumType]
    public readonly struct ResourceInfoDefinitionMethods : IEquatable<ResourceInfoDefinitionMethods>
    {
        private readonly string _value;

        private ResourceInfoDefinitionMethods(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Allowed Connecting to Broker
        /// </summary>
        public static ResourceInfoDefinitionMethods Connect { get; } = new ResourceInfoDefinitionMethods("Connect");
        /// <summary>
        /// Allowed Publishing to Broker
        /// </summary>
        public static ResourceInfoDefinitionMethods Publish { get; } = new ResourceInfoDefinitionMethods("Publish");
        /// <summary>
        /// Allowed Subscribing to Broker
        /// </summary>
        public static ResourceInfoDefinitionMethods Subscribe { get; } = new ResourceInfoDefinitionMethods("Subscribe");

        public static bool operator ==(ResourceInfoDefinitionMethods left, ResourceInfoDefinitionMethods right) => left.Equals(right);
        public static bool operator !=(ResourceInfoDefinitionMethods left, ResourceInfoDefinitionMethods right) => !left.Equals(right);

        public static explicit operator string(ResourceInfoDefinitionMethods value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceInfoDefinitionMethods other && Equals(other);
        public bool Equals(ResourceInfoDefinitionMethods other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Running Mode of the Broker Deployment.
    /// </summary>
    [EnumType]
    public readonly struct RunMode : IEquatable<RunMode>
    {
        private readonly string _value;

        private RunMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically provision Frontend and Backend pods.
        /// </summary>
        public static RunMode Auto { get; } = new RunMode("auto");
        /// <summary>
        /// Use Cardinality to set Frontend and Backend pods.
        /// </summary>
        public static RunMode Distributed { get; } = new RunMode("distributed");

        public static bool operator ==(RunMode left, RunMode right) => left.Equals(right);
        public static bool operator !=(RunMode left, RunMode right) => !left.Equals(right);

        public static explicit operator string(RunMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RunMode other && Equals(other);
        public bool Equals(RunMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Kubernetes Service type to deploy for Listener.
    /// </summary>
    [EnumType]
    public readonly struct ServiceType : IEquatable<ServiceType>
    {
        private readonly string _value;

        private ServiceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cluster IP Service.
        /// </summary>
        public static ServiceType ClusterIp { get; } = new ServiceType("clusterIp");
        /// <summary>
        /// Load Balancer Service.
        /// </summary>
        public static ServiceType LoadBalancer { get; } = new ServiceType("loadBalancer");
        /// <summary>
        /// Node Port Service.
        /// </summary>
        public static ServiceType NodePort { get; } = new ServiceType("nodePort");

        public static bool operator ==(ServiceType left, ServiceType right) => left.Equals(right);
        public static bool operator !=(ServiceType left, ServiceType right) => !left.Equals(right);

        public static explicit operator string(ServiceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceType other && Equals(other);
        public bool Equals(ServiceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
