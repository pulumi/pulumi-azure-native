// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ApiManagement.V20230901Preview
{
    /// <summary>
    /// Specifies for what type of messages sampling settings should not apply.
    /// </summary>
    [EnumType]
    public readonly struct AlwaysLog : IEquatable<AlwaysLog>
    {
        private readonly string _value;

        private AlwaysLog(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Always log all erroneous request regardless of sampling settings.
        /// </summary>
        public static AlwaysLog AllErrors { get; } = new AlwaysLog("allErrors");

        public static bool operator ==(AlwaysLog left, AlwaysLog right) => left.Equals(right);
        public static bool operator !=(AlwaysLog left, AlwaysLog right) => !left.Equals(right);

        public static explicit operator string(AlwaysLog value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlwaysLog other && Equals(other);
        public bool Equals(AlwaysLog other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Backend communication protocol.
    /// </summary>
    [EnumType]
    public readonly struct BackendProtocol : IEquatable<BackendProtocol>
    {
        private readonly string _value;

        private BackendProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Backend is a RESTful service.
        /// </summary>
        public static BackendProtocol Http { get; } = new BackendProtocol("http");
        /// <summary>
        /// The Backend is a SOAP service.
        /// </summary>
        public static BackendProtocol Soap { get; } = new BackendProtocol("soap");

        public static bool operator ==(BackendProtocol left, BackendProtocol right) => left.Equals(right);
        public static bool operator !=(BackendProtocol left, BackendProtocol right) => !left.Equals(right);

        public static explicit operator string(BackendProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendProtocol other && Equals(other);
        public bool Equals(BackendProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the backend. A backend can be either Single or Pool.
    /// </summary>
    [EnumType]
    public readonly struct BackendType : IEquatable<BackendType>
    {
        private readonly string _value;

        private BackendType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// supports single backend
        /// </summary>
        public static BackendType Single { get; } = new BackendType("Single");
        /// <summary>
        /// supports pool backend
        /// </summary>
        public static BackendType Pool { get; } = new BackendType("Pool");

        public static bool operator ==(BackendType left, BackendType right) => left.Equals(right);
        public static bool operator !=(BackendType left, BackendType right) => !left.Equals(right);

        public static explicit operator string(BackendType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendType other && Equals(other);
        public bool Equals(BackendType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data masking mode.
    /// </summary>
    [EnumType]
    public readonly struct DataMaskingMode : IEquatable<DataMaskingMode>
    {
        private readonly string _value;

        private DataMaskingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mask the value of an entity.
        /// </summary>
        public static DataMaskingMode Mask { get; } = new DataMaskingMode("Mask");
        /// <summary>
        /// Hide the presence of an entity.
        /// </summary>
        public static DataMaskingMode Hide { get; } = new DataMaskingMode("Hide");

        public static bool operator ==(DataMaskingMode left, DataMaskingMode right) => left.Equals(right);
        public static bool operator !=(DataMaskingMode left, DataMaskingMode right) => !left.Equals(right);

        public static explicit operator string(DataMaskingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataMaskingMode other && Equals(other);
        public bool Equals(DataMaskingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets correlation protocol to use for Application Insights diagnostics.
    /// </summary>
    [EnumType]
    public readonly struct HttpCorrelationProtocol : IEquatable<HttpCorrelationProtocol>
    {
        private readonly string _value;

        private HttpCorrelationProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not read and inject correlation headers.
        /// </summary>
        public static HttpCorrelationProtocol None { get; } = new HttpCorrelationProtocol("None");
        /// <summary>
        /// Inject Request-Id and Request-Context headers with request correlation data. See https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md.
        /// </summary>
        public static HttpCorrelationProtocol Legacy { get; } = new HttpCorrelationProtocol("Legacy");
        /// <summary>
        /// Inject Trace Context headers. See https://w3c.github.io/trace-context.
        /// </summary>
        public static HttpCorrelationProtocol W3C { get; } = new HttpCorrelationProtocol("W3C");

        public static bool operator ==(HttpCorrelationProtocol left, HttpCorrelationProtocol right) => left.Equals(right);
        public static bool operator !=(HttpCorrelationProtocol left, HttpCorrelationProtocol right) => !left.Equals(right);

        public static explicit operator string(HttpCorrelationProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpCorrelationProtocol other && Equals(other);
        public bool Equals(HttpCorrelationProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logger type.
    /// </summary>
    [EnumType]
    public readonly struct LoggerType : IEquatable<LoggerType>
    {
        private readonly string _value;

        private LoggerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Azure Event Hub as log destination.
        /// </summary>
        public static LoggerType AzureEventHub { get; } = new LoggerType("azureEventHub");
        /// <summary>
        /// Azure Application Insights as log destination.
        /// </summary>
        public static LoggerType ApplicationInsights { get; } = new LoggerType("applicationInsights");
        /// <summary>
        /// Azure Monitor
        /// </summary>
        public static LoggerType AzureMonitor { get; } = new LoggerType("azureMonitor");

        public static bool operator ==(LoggerType left, LoggerType right) => left.Equals(right);
        public static bool operator !=(LoggerType left, LoggerType right) => !left.Equals(right);

        public static explicit operator string(LoggerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggerType other && Equals(other);
        public bool Equals(LoggerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the Operation Name for Application Insights telemetries. Default is Name.
    /// </summary>
    [EnumType]
    public readonly struct OperationNameFormat : IEquatable<OperationNameFormat>
    {
        private readonly string _value;

        private OperationNameFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// API_NAME;rev=API_REVISION - OPERATION_NAME
        /// </summary>
        public static OperationNameFormat Name { get; } = new OperationNameFormat("Name");
        /// <summary>
        /// HTTP_VERB URL
        /// </summary>
        public static OperationNameFormat Url { get; } = new OperationNameFormat("Url");

        public static bool operator ==(OperationNameFormat left, OperationNameFormat right) => left.Equals(right);
        public static bool operator !=(OperationNameFormat left, OperationNameFormat right) => !left.Equals(right);

        public static explicit operator string(OperationNameFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationNameFormat other && Equals(other);
        public bool Equals(OperationNameFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sampling type.
    /// </summary>
    [EnumType]
    public readonly struct SamplingType : IEquatable<SamplingType>
    {
        private readonly string _value;

        private SamplingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Fixed-rate sampling.
        /// </summary>
        public static SamplingType @Fixed { get; } = new SamplingType("fixed");

        public static bool operator ==(SamplingType left, SamplingType right) => left.Equals(right);
        public static bool operator !=(SamplingType left, SamplingType right) => !left.Equals(right);

        public static explicit operator string(SamplingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SamplingType other && Equals(other);
        public bool Equals(SamplingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the Sku.
    /// </summary>
    [EnumType]
    public readonly struct SkuType : IEquatable<SkuType>
    {
        private readonly string _value;

        private SkuType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard SKU of the API gateway.
        /// </summary>
        public static SkuType Standard { get; } = new SkuType("Standard");
        /// <summary>
        /// Standard SKU of the API gateway to be used in Workspaces.
        /// </summary>
        public static SkuType WorkspaceGatewayStandard { get; } = new SkuType("WorkspaceGatewayStandard");
        /// <summary>
        /// Premium SKU of the API gateway to be used in Workspaces.
        /// </summary>
        public static SkuType WorkspaceGatewayPremium { get; } = new SkuType("WorkspaceGatewayPremium");

        public static bool operator ==(SkuType left, SkuType right) => left.Equals(right);
        public static bool operator !=(SkuType left, SkuType right) => !left.Equals(right);

        public static explicit operator string(SkuType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuType other && Equals(other);
        public bool Equals(SkuType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The verbosity level applied to traces emitted by trace policies.
    /// </summary>
    [EnumType]
    public readonly struct Verbosity : IEquatable<Verbosity>
    {
        private readonly string _value;

        private Verbosity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// All the traces emitted by trace policies will be sent to the logger attached to this diagnostic instance.
        /// </summary>
        public static Verbosity Verbose { get; } = new Verbosity("verbose");
        /// <summary>
        /// Traces with 'severity' set to 'information' and 'error' will be sent to the logger attached to this diagnostic instance.
        /// </summary>
        public static Verbosity Information { get; } = new Verbosity("information");
        /// <summary>
        /// Only traces with 'severity' set to 'error' will be sent to the logger attached to this diagnostic instance.
        /// </summary>
        public static Verbosity Error { get; } = new Verbosity("error");

        public static bool operator ==(Verbosity left, Verbosity right) => left.Equals(right);
        public static bool operator !=(Verbosity left, Verbosity right) => !left.Equals(right);

        public static explicit operator string(Verbosity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Verbosity other && Equals(other);
        public bool Equals(Verbosity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of VPN in which API Management gateway needs to be configured in. 
    /// </summary>
    [EnumType]
    public readonly struct VirtualNetworkType : IEquatable<VirtualNetworkType>
    {
        private readonly string _value;

        private VirtualNetworkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The API Management gateway is not part of any Virtual Network.
        /// </summary>
        public static VirtualNetworkType None { get; } = new VirtualNetworkType("None");
        /// <summary>
        /// The API Management gateway is part of Virtual Network and it is accessible from Internet.
        /// </summary>
        public static VirtualNetworkType External { get; } = new VirtualNetworkType("External");
        /// <summary>
        /// The API Management gateway is part of Virtual Network and it is only accessible from within the virtual network.
        /// </summary>
        public static VirtualNetworkType Internal { get; } = new VirtualNetworkType("Internal");

        public static bool operator ==(VirtualNetworkType left, VirtualNetworkType right) => left.Equals(right);
        public static bool operator !=(VirtualNetworkType left, VirtualNetworkType right) => !left.Equals(right);

        public static explicit operator string(VirtualNetworkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualNetworkType other && Equals(other);
        public bool Equals(VirtualNetworkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
