// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ApiManagement.V20180601Preview
{
    /// <summary>
    /// Type of API.
    /// </summary>
    [EnumType]
    public readonly struct ApiType : IEquatable<ApiType>
    {
        private readonly string _value;

        private ApiType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApiType Http { get; } = new ApiType("http");
        public static ApiType Soap { get; } = new ApiType("soap");

        public static bool operator ==(ApiType left, ApiType right) => left.Equals(right);
        public static bool operator !=(ApiType left, ApiType right) => !left.Equals(right);

        public static explicit operator string(ApiType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiType other && Equals(other);
        public bool Equals(ApiType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Form of an authorization grant, which the client uses to request the access token.
    /// </summary>
    [EnumType]
    public readonly struct BearerTokenSendingMethods : IEquatable<BearerTokenSendingMethods>
    {
        private readonly string _value;

        private BearerTokenSendingMethods(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Access token will be transmitted in the Authorization header using Bearer schema
        /// </summary>
        public static BearerTokenSendingMethods AuthorizationHeader { get; } = new BearerTokenSendingMethods("authorizationHeader");
        /// <summary>
        /// Access token will be transmitted as query parameters.
        /// </summary>
        public static BearerTokenSendingMethods Query { get; } = new BearerTokenSendingMethods("query");

        public static bool operator ==(BearerTokenSendingMethods left, BearerTokenSendingMethods right) => left.Equals(right);
        public static bool operator !=(BearerTokenSendingMethods left, BearerTokenSendingMethods right) => !left.Equals(right);

        public static explicit operator string(BearerTokenSendingMethods value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BearerTokenSendingMethods other && Equals(other);
        public bool Equals(BearerTokenSendingMethods other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Format of the Content in which the API is getting imported.
    /// </summary>
    [EnumType]
    public readonly struct ContentFormat : IEquatable<ContentFormat>
    {
        private readonly string _value;

        private ContentFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The contents are inline and Content type is a WADL document.
        /// </summary>
        public static ContentFormat Wadl_xml { get; } = new ContentFormat("wadl-xml");
        /// <summary>
        /// The WADL document is hosted on a publicly accessible internet address.
        /// </summary>
        public static ContentFormat Wadl_link_json { get; } = new ContentFormat("wadl-link-json");
        /// <summary>
        /// The contents are inline and Content Type is a OpenApi 2.0 Document.
        /// </summary>
        public static ContentFormat Swagger_json { get; } = new ContentFormat("swagger-json");
        /// <summary>
        /// The Open Api 2.0 document is hosted on a publicly accessible internet address.
        /// </summary>
        public static ContentFormat Swagger_link_json { get; } = new ContentFormat("swagger-link-json");
        /// <summary>
        /// The contents are inline and the document is a WSDL/Soap document.
        /// </summary>
        public static ContentFormat Wsdl { get; } = new ContentFormat("wsdl");
        /// <summary>
        /// The WSDL document is hosted on a publicly accessible internet address.
        /// </summary>
        public static ContentFormat Wsdl_link { get; } = new ContentFormat("wsdl-link");
        /// <summary>
        /// The contents are inline and Content Type is a OpenApi 3.0 Document in YAML format.
        /// </summary>
        public static ContentFormat Openapi { get; } = new ContentFormat("openapi");
        /// <summary>
        /// The contents are inline and Content Type is a OpenApi 3.0 Document in JSON format.
        /// </summary>
        public static ContentFormat Openapi_json { get; } = new ContentFormat("openapi+json");
        /// <summary>
        /// The Open Api 3.0 document is hosted on a publicly accessible internet address.
        /// </summary>
        public static ContentFormat Openapi_link { get; } = new ContentFormat("openapi-link");

        public static bool operator ==(ContentFormat left, ContentFormat right) => left.Equals(right);
        public static bool operator !=(ContentFormat left, ContentFormat right) => !left.Equals(right);

        public static explicit operator string(ContentFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentFormat other && Equals(other);
        public bool Equals(ContentFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Key to be used to generate token for user.
    /// </summary>
    [EnumType]
    public readonly struct KeyType : IEquatable<KeyType>
    {
        private readonly string _value;

        private KeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyType Primary { get; } = new KeyType("primary");
        public static KeyType Secondary { get; } = new KeyType("secondary");

        public static bool operator ==(KeyType left, KeyType right) => left.Equals(right);
        public static bool operator !=(KeyType left, KeyType right) => !left.Equals(right);

        public static explicit operator string(KeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyType other && Equals(other);
        public bool Equals(KeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Format of the policyContent.
    /// </summary>
    [EnumType]
    public readonly struct PolicyContentFormat : IEquatable<PolicyContentFormat>
    {
        private readonly string _value;

        private PolicyContentFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The contents are inline and Content type is an XML document.
        /// </summary>
        public static PolicyContentFormat Xml { get; } = new PolicyContentFormat("xml");
        /// <summary>
        /// The policy XML document is hosted on a http endpoint accessible from the API Management service.
        /// </summary>
        public static PolicyContentFormat Xml_link { get; } = new PolicyContentFormat("xml-link");
        /// <summary>
        /// The contents are inline and Content type is a non XML encoded policy document.
        /// </summary>
        public static PolicyContentFormat Rawxml { get; } = new PolicyContentFormat("rawxml");
        /// <summary>
        /// The policy document is not Xml encoded and is hosted on a http endpoint accessible from the API Management service.
        /// </summary>
        public static PolicyContentFormat Rawxml_link { get; } = new PolicyContentFormat("rawxml-link");

        public static bool operator ==(PolicyContentFormat left, PolicyContentFormat right) => left.Equals(right);
        public static bool operator !=(PolicyContentFormat left, PolicyContentFormat right) => !left.Equals(right);

        public static explicit operator string(PolicyContentFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyContentFormat other && Equals(other);
        public bool Equals(PolicyContentFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Protocol Http { get; } = new Protocol("http");
        public static Protocol Https { get; } = new Protocol("https");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of Api to create. 
    ///  * `http` creates a SOAP to REST API 
    ///  * `soap` creates a SOAP pass-through API .
    /// </summary>
    [EnumType]
    public readonly struct SoapApiType : IEquatable<SoapApiType>
    {
        private readonly string _value;

        private SoapApiType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Imports a SOAP API having a RESTful front end.
        /// </summary>
        public static SoapApiType SoapToRest { get; } = new SoapApiType("http");
        /// <summary>
        /// Imports the Soap API having a SOAP front end.
        /// </summary>
        public static SoapApiType SoapPassThrough { get; } = new SoapApiType("soap");

        public static bool operator ==(SoapApiType left, SoapApiType right) => left.Equals(right);
        public static bool operator !=(SoapApiType left, SoapApiType right) => !left.Equals(right);

        public static explicit operator string(SoapApiType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoapApiType other && Equals(other);
        public bool Equals(SoapApiType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
