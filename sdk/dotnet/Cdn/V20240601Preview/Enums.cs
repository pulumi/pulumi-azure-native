// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Cdn.V20240601Preview
{
    /// <summary>
    /// Supported protocols for the customer's endpoint.
    /// </summary>
    [EnumType]
    public readonly struct AFDEndpointProtocols : IEquatable<AFDEndpointProtocols>
    {
        private readonly string _value;

        private AFDEndpointProtocols(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AFDEndpointProtocols Http { get; } = new AFDEndpointProtocols("Http");
        public static AFDEndpointProtocols Https { get; } = new AFDEndpointProtocols("Https");

        public static bool operator ==(AFDEndpointProtocols left, AFDEndpointProtocols right) => left.Equals(right);
        public static bool operator !=(AFDEndpointProtocols left, AFDEndpointProtocols right) => !left.Equals(right);

        public static explicit operator string(AFDEndpointProtocols value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AFDEndpointProtocols other && Equals(other);
        public bool Equals(AFDEndpointProtocols other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not gRPC is enabled on this route. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct AFDRouteGrpcState : IEquatable<AFDRouteGrpcState>
    {
        private readonly string _value;

        private AFDRouteGrpcState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AFDRouteGrpcState Enabled { get; } = new AFDRouteGrpcState("Enabled");
        public static AFDRouteGrpcState Disabled { get; } = new AFDRouteGrpcState("Disabled");

        public static bool operator ==(AFDRouteGrpcState left, AFDRouteGrpcState right) => left.Equals(right);
        public static bool operator !=(AFDRouteGrpcState left, AFDRouteGrpcState right) => !left.Equals(right);

        public static explicit operator string(AFDRouteGrpcState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AFDRouteGrpcState other && Equals(other);
        public bool Equals(AFDRouteGrpcState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the source of the SSL certificate.
    /// </summary>
    [EnumType]
    public readonly struct AfdCertificateType : IEquatable<AfdCertificateType>
    {
        private readonly string _value;

        private AfdCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdCertificateType CustomerCertificate { get; } = new AfdCertificateType("CustomerCertificate");
        public static AfdCertificateType ManagedCertificate { get; } = new AfdCertificateType("ManagedCertificate");
        public static AfdCertificateType AzureFirstPartyManagedCertificate { get; } = new AfdCertificateType("AzureFirstPartyManagedCertificate");

        public static bool operator ==(AfdCertificateType left, AfdCertificateType right) => left.Equals(right);
        public static bool operator !=(AfdCertificateType left, AfdCertificateType right) => !left.Equals(right);

        public static explicit operator string(AfdCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdCertificateType other && Equals(other);
        public bool Equals(AfdCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cipher suite set type that will be used for Https
    /// </summary>
    [EnumType]
    public readonly struct AfdCipherSuiteSetType : IEquatable<AfdCipherSuiteSetType>
    {
        private readonly string _value;

        private AfdCipherSuiteSetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdCipherSuiteSetType Customized { get; } = new AfdCipherSuiteSetType("Customized");
        public static AfdCipherSuiteSetType TLS10_2019 { get; } = new AfdCipherSuiteSetType("TLS10_2019");
        public static AfdCipherSuiteSetType TLS12_2022 { get; } = new AfdCipherSuiteSetType("TLS12_2022");
        public static AfdCipherSuiteSetType TLS12_2023 { get; } = new AfdCipherSuiteSetType("TLS12_2023");

        public static bool operator ==(AfdCipherSuiteSetType left, AfdCipherSuiteSetType right) => left.Equals(right);
        public static bool operator !=(AfdCipherSuiteSetType left, AfdCipherSuiteSetType right) => !left.Equals(right);

        public static explicit operator string(AfdCipherSuiteSetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdCipherSuiteSetType other && Equals(other);
        public bool Equals(AfdCipherSuiteSetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct AfdCustomizedCipherSuiteForTls10 : IEquatable<AfdCustomizedCipherSuiteForTls10>
    {
        private readonly string _value;

        private AfdCustomizedCipherSuiteForTls10(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdCustomizedCipherSuiteForTls10 ECDHE_RSA_AES128_SHA { get; } = new AfdCustomizedCipherSuiteForTls10("ECDHE_RSA_AES128_SHA");
        public static AfdCustomizedCipherSuiteForTls10 ECDHE_RSA_AES256_SHA { get; } = new AfdCustomizedCipherSuiteForTls10("ECDHE_RSA_AES256_SHA");
        public static AfdCustomizedCipherSuiteForTls10 AES256_SHA { get; } = new AfdCustomizedCipherSuiteForTls10("AES256_SHA");
        public static AfdCustomizedCipherSuiteForTls10 AES128_SHA { get; } = new AfdCustomizedCipherSuiteForTls10("AES128_SHA");

        public static bool operator ==(AfdCustomizedCipherSuiteForTls10 left, AfdCustomizedCipherSuiteForTls10 right) => left.Equals(right);
        public static bool operator !=(AfdCustomizedCipherSuiteForTls10 left, AfdCustomizedCipherSuiteForTls10 right) => !left.Equals(right);

        public static explicit operator string(AfdCustomizedCipherSuiteForTls10 value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdCustomizedCipherSuiteForTls10 other && Equals(other);
        public bool Equals(AfdCustomizedCipherSuiteForTls10 other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct AfdCustomizedCipherSuiteForTls12 : IEquatable<AfdCustomizedCipherSuiteForTls12>
    {
        private readonly string _value;

        private AfdCustomizedCipherSuiteForTls12(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdCustomizedCipherSuiteForTls12 ECDHE_RSA_AES128_GCM_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("ECDHE_RSA_AES128_GCM_SHA256");
        public static AfdCustomizedCipherSuiteForTls12 ECDHE_RSA_AES256_GCM_SHA384 { get; } = new AfdCustomizedCipherSuiteForTls12("ECDHE_RSA_AES256_GCM_SHA384");
        public static AfdCustomizedCipherSuiteForTls12 DHE_RSA_AES256_GCM_SHA384 { get; } = new AfdCustomizedCipherSuiteForTls12("DHE_RSA_AES256_GCM_SHA384");
        public static AfdCustomizedCipherSuiteForTls12 DHE_RSA_AES128_GCM_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("DHE_RSA_AES128_GCM_SHA256");
        public static AfdCustomizedCipherSuiteForTls12 ECDHE_RSA_AES128_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("ECDHE_RSA_AES128_SHA256");
        public static AfdCustomizedCipherSuiteForTls12 ECDHE_RSA_AES256_SHA384 { get; } = new AfdCustomizedCipherSuiteForTls12("ECDHE_RSA_AES256_SHA384");
        public static AfdCustomizedCipherSuiteForTls12 AES256_GCM_SHA384 { get; } = new AfdCustomizedCipherSuiteForTls12("AES256_GCM_SHA384");
        public static AfdCustomizedCipherSuiteForTls12 AES128_GCM_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("AES128_GCM_SHA256");
        public static AfdCustomizedCipherSuiteForTls12 AES256_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("AES256_SHA256");
        public static AfdCustomizedCipherSuiteForTls12 AES128_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls12("AES128_SHA256");

        public static bool operator ==(AfdCustomizedCipherSuiteForTls12 left, AfdCustomizedCipherSuiteForTls12 right) => left.Equals(right);
        public static bool operator !=(AfdCustomizedCipherSuiteForTls12 left, AfdCustomizedCipherSuiteForTls12 right) => !left.Equals(right);

        public static explicit operator string(AfdCustomizedCipherSuiteForTls12 value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdCustomizedCipherSuiteForTls12 other && Equals(other);
        public bool Equals(AfdCustomizedCipherSuiteForTls12 other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct AfdCustomizedCipherSuiteForTls13 : IEquatable<AfdCustomizedCipherSuiteForTls13>
    {
        private readonly string _value;

        private AfdCustomizedCipherSuiteForTls13(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdCustomizedCipherSuiteForTls13 TLS_AES_128_GCM_SHA256 { get; } = new AfdCustomizedCipherSuiteForTls13("TLS_AES_128_GCM_SHA256");
        public static AfdCustomizedCipherSuiteForTls13 TLS_AES_256_GCM_SHA384 { get; } = new AfdCustomizedCipherSuiteForTls13("TLS_AES_256_GCM_SHA384");

        public static bool operator ==(AfdCustomizedCipherSuiteForTls13 left, AfdCustomizedCipherSuiteForTls13 right) => left.Equals(right);
        public static bool operator !=(AfdCustomizedCipherSuiteForTls13 left, AfdCustomizedCipherSuiteForTls13 right) => !left.Equals(right);

        public static explicit operator string(AfdCustomizedCipherSuiteForTls13 value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdCustomizedCipherSuiteForTls13 other && Equals(other);
        public bool Equals(AfdCustomizedCipherSuiteForTls13 other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
    /// </summary>
    [EnumType]
    public readonly struct AfdMinimumTlsVersion : IEquatable<AfdMinimumTlsVersion>
    {
        private readonly string _value;

        private AfdMinimumTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdMinimumTlsVersion TLS10 { get; } = new AfdMinimumTlsVersion("TLS10");
        public static AfdMinimumTlsVersion TLS12 { get; } = new AfdMinimumTlsVersion("TLS12");
        public static AfdMinimumTlsVersion TLS13 { get; } = new AfdMinimumTlsVersion("TLS13");

        public static bool operator ==(AfdMinimumTlsVersion left, AfdMinimumTlsVersion right) => left.Equals(right);
        public static bool operator !=(AfdMinimumTlsVersion left, AfdMinimumTlsVersion right) => !left.Equals(right);

        public static explicit operator string(AfdMinimumTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdMinimumTlsVersion other && Equals(other);
        public bool Equals(AfdMinimumTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
    /// </summary>
    [EnumType]
    public readonly struct AfdQueryStringCachingBehavior : IEquatable<AfdQueryStringCachingBehavior>
    {
        private readonly string _value;

        private AfdQueryStringCachingBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdQueryStringCachingBehavior IgnoreQueryString { get; } = new AfdQueryStringCachingBehavior("IgnoreQueryString");
        public static AfdQueryStringCachingBehavior UseQueryString { get; } = new AfdQueryStringCachingBehavior("UseQueryString");
        public static AfdQueryStringCachingBehavior IgnoreSpecifiedQueryStrings { get; } = new AfdQueryStringCachingBehavior("IgnoreSpecifiedQueryStrings");
        public static AfdQueryStringCachingBehavior IncludeSpecifiedQueryStrings { get; } = new AfdQueryStringCachingBehavior("IncludeSpecifiedQueryStrings");

        public static bool operator ==(AfdQueryStringCachingBehavior left, AfdQueryStringCachingBehavior right) => left.Equals(right);
        public static bool operator !=(AfdQueryStringCachingBehavior left, AfdQueryStringCachingBehavior right) => !left.Equals(right);

        public static explicit operator string(AfdQueryStringCachingBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdQueryStringCachingBehavior other && Equals(other);
        public bool Equals(AfdQueryStringCachingBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct EnabledState : IEquatable<EnabledState>
    {
        private readonly string _value;

        private EnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnabledState Enabled { get; } = new EnabledState("Enabled");
        public static EnabledState Disabled { get; } = new EnabledState("Disabled");

        public static bool operator ==(EnabledState left, EnabledState right) => left.Equals(right);
        public static bool operator !=(EnabledState left, EnabledState right) => !left.Equals(right);

        public static explicit operator string(EnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnabledState other && Equals(other);
        public bool Equals(EnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol this rule will use when forwarding traffic to backends.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingProtocol : IEquatable<ForwardingProtocol>
    {
        private readonly string _value;

        private ForwardingProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingProtocol HttpOnly { get; } = new ForwardingProtocol("HttpOnly");
        public static ForwardingProtocol HttpsOnly { get; } = new ForwardingProtocol("HttpsOnly");
        public static ForwardingProtocol MatchRequest { get; } = new ForwardingProtocol("MatchRequest");

        public static bool operator ==(ForwardingProtocol left, ForwardingProtocol right) => left.Equals(right);
        public static bool operator !=(ForwardingProtocol left, ForwardingProtocol right) => !left.Equals(right);

        public static explicit operator string(ForwardingProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingProtocol other && Equals(other);
        public bool Equals(ForwardingProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
    /// </summary>
    [EnumType]
    public readonly struct HttpsRedirect : IEquatable<HttpsRedirect>
    {
        private readonly string _value;

        private HttpsRedirect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HttpsRedirect Enabled { get; } = new HttpsRedirect("Enabled");
        public static HttpsRedirect Disabled { get; } = new HttpsRedirect("Disabled");

        public static bool operator ==(HttpsRedirect left, HttpsRedirect right) => left.Equals(right);
        public static bool operator !=(HttpsRedirect left, HttpsRedirect right) => !left.Equals(right);

        public static explicit operator string(HttpsRedirect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpsRedirect other && Equals(other);
        public bool Equals(HttpsRedirect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// whether this route will be linked to the default endpoint domain.
    /// </summary>
    [EnumType]
    public readonly struct LinkToDefaultDomain : IEquatable<LinkToDefaultDomain>
    {
        private readonly string _value;

        private LinkToDefaultDomain(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinkToDefaultDomain Enabled { get; } = new LinkToDefaultDomain("Enabled");
        public static LinkToDefaultDomain Disabled { get; } = new LinkToDefaultDomain("Disabled");

        public static bool operator ==(LinkToDefaultDomain left, LinkToDefaultDomain right) => left.Equals(right);
        public static bool operator !=(LinkToDefaultDomain left, LinkToDefaultDomain right) => !left.Equals(right);

        public static explicit operator string(LinkToDefaultDomain value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinkToDefaultDomain other && Equals(other);
        public bool Equals(LinkToDefaultDomain other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol this tunnel will use for allowing traffic to backends.
    /// </summary>
    [EnumType]
    public readonly struct TunnelType : IEquatable<TunnelType>
    {
        private readonly string _value;

        private TunnelType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TunnelType HttpConnect { get; } = new TunnelType("HttpConnect");

        public static bool operator ==(TunnelType left, TunnelType right) => left.Equals(right);
        public static bool operator !=(TunnelType left, TunnelType right) => !left.Equals(right);

        public static explicit operator string(TunnelType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TunnelType other && Equals(other);
        public bool Equals(TunnelType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
