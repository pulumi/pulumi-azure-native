// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Cdn.V20200901
{
    /// <summary>
    /// Supported protocols for the customer's endpoint.
    /// </summary>
    [EnumType]
    public readonly struct AFDEndpointProtocols : IEquatable<AFDEndpointProtocols>
    {
        private readonly string _value;

        private AFDEndpointProtocols(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AFDEndpointProtocols Http { get; } = new AFDEndpointProtocols("Http");
        public static AFDEndpointProtocols Https { get; } = new AFDEndpointProtocols("Https");

        public static bool operator ==(AFDEndpointProtocols left, AFDEndpointProtocols right) => left.Equals(right);
        public static bool operator !=(AFDEndpointProtocols left, AFDEndpointProtocols right) => !left.Equals(right);

        public static explicit operator string(AFDEndpointProtocols value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AFDEndpointProtocols other && Equals(other);
        public bool Equals(AFDEndpointProtocols other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
    /// </summary>
    [EnumType]
    public readonly struct AfdQueryStringCachingBehavior : IEquatable<AfdQueryStringCachingBehavior>
    {
        private readonly string _value;

        private AfdQueryStringCachingBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AfdQueryStringCachingBehavior IgnoreQueryString { get; } = new AfdQueryStringCachingBehavior("IgnoreQueryString");
        public static AfdQueryStringCachingBehavior UseQueryString { get; } = new AfdQueryStringCachingBehavior("UseQueryString");
        public static AfdQueryStringCachingBehavior NotSet { get; } = new AfdQueryStringCachingBehavior("NotSet");

        public static bool operator ==(AfdQueryStringCachingBehavior left, AfdQueryStringCachingBehavior right) => left.Equals(right);
        public static bool operator !=(AfdQueryStringCachingBehavior left, AfdQueryStringCachingBehavior right) => !left.Equals(right);

        public static explicit operator string(AfdQueryStringCachingBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AfdQueryStringCachingBehavior other && Equals(other);
        public bool Equals(AfdQueryStringCachingBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct EnabledState : IEquatable<EnabledState>
    {
        private readonly string _value;

        private EnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnabledState Enabled { get; } = new EnabledState("Enabled");
        public static EnabledState Disabled { get; } = new EnabledState("Disabled");

        public static bool operator ==(EnabledState left, EnabledState right) => left.Equals(right);
        public static bool operator !=(EnabledState left, EnabledState right) => !left.Equals(right);

        public static explicit operator string(EnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnabledState other && Equals(other);
        public bool Equals(EnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol this rule will use when forwarding traffic to backends.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingProtocol : IEquatable<ForwardingProtocol>
    {
        private readonly string _value;

        private ForwardingProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingProtocol HttpOnly { get; } = new ForwardingProtocol("HttpOnly");
        public static ForwardingProtocol HttpsOnly { get; } = new ForwardingProtocol("HttpsOnly");
        public static ForwardingProtocol MatchRequest { get; } = new ForwardingProtocol("MatchRequest");

        public static bool operator ==(ForwardingProtocol left, ForwardingProtocol right) => left.Equals(right);
        public static bool operator !=(ForwardingProtocol left, ForwardingProtocol right) => !left.Equals(right);

        public static explicit operator string(ForwardingProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingProtocol other && Equals(other);
        public bool Equals(ForwardingProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of health probe request that is made.
    /// </summary>
    [EnumType]
    public readonly struct HealthProbeRequestType : IEquatable<HealthProbeRequestType>
    {
        private readonly string _value;

        private HealthProbeRequestType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HealthProbeRequestType NotSet { get; } = new HealthProbeRequestType("NotSet");
        public static HealthProbeRequestType GET { get; } = new HealthProbeRequestType("GET");
        public static HealthProbeRequestType HEAD { get; } = new HealthProbeRequestType("HEAD");

        public static bool operator ==(HealthProbeRequestType left, HealthProbeRequestType right) => left.Equals(right);
        public static bool operator !=(HealthProbeRequestType left, HealthProbeRequestType right) => !left.Equals(right);

        public static explicit operator string(HealthProbeRequestType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HealthProbeRequestType other && Equals(other);
        public bool Equals(HealthProbeRequestType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
    /// </summary>
    [EnumType]
    public readonly struct HttpsRedirect : IEquatable<HttpsRedirect>
    {
        private readonly string _value;

        private HttpsRedirect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HttpsRedirect Enabled { get; } = new HttpsRedirect("Enabled");
        public static HttpsRedirect Disabled { get; } = new HttpsRedirect("Disabled");

        public static bool operator ==(HttpsRedirect left, HttpsRedirect right) => left.Equals(right);
        public static bool operator !=(HttpsRedirect left, HttpsRedirect right) => !left.Equals(right);

        public static explicit operator string(HttpsRedirect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpsRedirect other && Equals(other);
        public bool Equals(HttpsRedirect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// whether this route will be linked to the default endpoint domain.
    /// </summary>
    [EnumType]
    public readonly struct LinkToDefaultDomain : IEquatable<LinkToDefaultDomain>
    {
        private readonly string _value;

        private LinkToDefaultDomain(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinkToDefaultDomain Enabled { get; } = new LinkToDefaultDomain("Enabled");
        public static LinkToDefaultDomain Disabled { get; } = new LinkToDefaultDomain("Disabled");

        public static bool operator ==(LinkToDefaultDomain left, LinkToDefaultDomain right) => left.Equals(right);
        public static bool operator !=(LinkToDefaultDomain left, LinkToDefaultDomain right) => !left.Equals(right);

        public static explicit operator string(LinkToDefaultDomain value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinkToDefaultDomain other && Equals(other);
        public bool Equals(LinkToDefaultDomain other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol to use for health probe.
    /// </summary>
    [EnumType]
    public readonly struct ProbeProtocol : IEquatable<ProbeProtocol>
    {
        private readonly string _value;

        private ProbeProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProbeProtocol NotSet { get; } = new ProbeProtocol("NotSet");
        public static ProbeProtocol Http { get; } = new ProbeProtocol("Http");
        public static ProbeProtocol Https { get; } = new ProbeProtocol("Https");

        public static bool operator ==(ProbeProtocol left, ProbeProtocol right) => left.Equals(right);
        public static bool operator !=(ProbeProtocol left, ProbeProtocol right) => !left.Equals(right);

        public static explicit operator string(ProbeProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProbeProtocol other && Equals(other);
        public bool Equals(ProbeProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of response errors for real user requests for which origin will be deemed unhealthy
    /// </summary>
    [EnumType]
    public readonly struct ResponseBasedDetectedErrorTypes : IEquatable<ResponseBasedDetectedErrorTypes>
    {
        private readonly string _value;

        private ResponseBasedDetectedErrorTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResponseBasedDetectedErrorTypes None { get; } = new ResponseBasedDetectedErrorTypes("None");
        public static ResponseBasedDetectedErrorTypes TcpErrorsOnly { get; } = new ResponseBasedDetectedErrorTypes("TcpErrorsOnly");
        public static ResponseBasedDetectedErrorTypes TcpAndHttpErrors { get; } = new ResponseBasedDetectedErrorTypes("TcpAndHttpErrors");

        public static bool operator ==(ResponseBasedDetectedErrorTypes left, ResponseBasedDetectedErrorTypes right) => left.Equals(right);
        public static bool operator !=(ResponseBasedDetectedErrorTypes left, ResponseBasedDetectedErrorTypes right) => !left.Equals(right);

        public static explicit operator string(ResponseBasedDetectedErrorTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResponseBasedDetectedErrorTypes other && Equals(other);
        public bool Equals(ResponseBasedDetectedErrorTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the pricing tier.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuName Standard_Verizon { get; } = new SkuName("Standard_Verizon");
        public static SkuName Premium_Verizon { get; } = new SkuName("Premium_Verizon");
        public static SkuName Custom_Verizon { get; } = new SkuName("Custom_Verizon");
        public static SkuName Standard_Akamai { get; } = new SkuName("Standard_Akamai");
        public static SkuName Standard_ChinaCdn { get; } = new SkuName("Standard_ChinaCdn");
        public static SkuName Standard_Microsoft { get; } = new SkuName("Standard_Microsoft");
        public static SkuName Premium_ChinaCdn { get; } = new SkuName("Premium_ChinaCdn");
        public static SkuName Standard_AzureFrontDoor { get; } = new SkuName("Standard_AzureFrontDoor");
        public static SkuName Premium_AzureFrontDoor { get; } = new SkuName("Premium_AzureFrontDoor");
        public static SkuName Standard_955BandWidth_ChinaCdn { get; } = new SkuName("Standard_955BandWidth_ChinaCdn");
        public static SkuName Standard_AvgBandWidth_ChinaCdn { get; } = new SkuName("Standard_AvgBandWidth_ChinaCdn");
        public static SkuName StandardPlus_ChinaCdn { get; } = new SkuName("StandardPlus_ChinaCdn");
        public static SkuName StandardPlus_955BandWidth_ChinaCdn { get; } = new SkuName("StandardPlus_955BandWidth_ChinaCdn");
        public static SkuName StandardPlus_AvgBandWidth_ChinaCdn { get; } = new SkuName("StandardPlus_AvgBandWidth_ChinaCdn");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
