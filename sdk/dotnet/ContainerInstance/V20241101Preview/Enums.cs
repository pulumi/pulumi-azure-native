// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ContainerInstance.V20241101Preview
{
    /// <summary>
    /// Access tier for specific share. GpV2 account can choose between TransactionOptimized (default), Hot, and Cool. FileStorage account can choose Premium. Learn more at: https://learn.microsoft.com/en-us/rest/api/storagerp/file-shares/create?tabs=HTTP#shareaccesstier
    /// </summary>
    [EnumType]
    public readonly struct AzureFileShareAccessTier : IEquatable<AzureFileShareAccessTier>
    {
        private readonly string _value;

        private AzureFileShareAccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AzureFileShareAccessTier Cool { get; } = new AzureFileShareAccessTier("Cool");
        public static AzureFileShareAccessTier Hot { get; } = new AzureFileShareAccessTier("Hot");
        public static AzureFileShareAccessTier Premium { get; } = new AzureFileShareAccessTier("Premium");
        public static AzureFileShareAccessTier TransactionOptimized { get; } = new AzureFileShareAccessTier("TransactionOptimized");

        public static bool operator ==(AzureFileShareAccessTier left, AzureFileShareAccessTier right) => left.Equals(right);
        public static bool operator !=(AzureFileShareAccessTier left, AzureFileShareAccessTier right) => !left.Equals(right);

        public static explicit operator string(AzureFileShareAccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AzureFileShareAccessTier other && Equals(other);
        public bool Equals(AzureFileShareAccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    ///  Specifies how Container Groups can access the Azure file share i.e. all CG will share same Azure file share or going to have exclusive file share.
    /// </summary>
    [EnumType]
    public readonly struct AzureFileShareAccessType : IEquatable<AzureFileShareAccessType>
    {
        private readonly string _value;

        private AzureFileShareAccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AzureFileShareAccessType Shared { get; } = new AzureFileShareAccessType("Shared");
        public static AzureFileShareAccessType Exclusive { get; } = new AzureFileShareAccessType("Exclusive");

        public static bool operator ==(AzureFileShareAccessType left, AzureFileShareAccessType right) => left.Equals(right);
        public static bool operator !=(AzureFileShareAccessType left, AzureFileShareAccessType right) => !left.Equals(right);

        public static explicit operator string(AzureFileShareAccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AzureFileShareAccessType other && Equals(other);
        public bool Equals(AzureFileShareAccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies if the IP is exposed to the public internet or private VNET.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupIpAddressType : IEquatable<ContainerGroupIpAddressType>
    {
        private readonly string _value;

        private ContainerGroupIpAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupIpAddressType Public { get; } = new ContainerGroupIpAddressType("Public");
        public static ContainerGroupIpAddressType Private { get; } = new ContainerGroupIpAddressType("Private");

        public static bool operator ==(ContainerGroupIpAddressType left, ContainerGroupIpAddressType right) => left.Equals(right);
        public static bool operator !=(ContainerGroupIpAddressType left, ContainerGroupIpAddressType right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupIpAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupIpAddressType other && Equals(other);
        public bool Equals(ContainerGroupIpAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol associated with the port.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupNetworkProtocol : IEquatable<ContainerGroupNetworkProtocol>
    {
        private readonly string _value;

        private ContainerGroupNetworkProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupNetworkProtocol TCP { get; } = new ContainerGroupNetworkProtocol("TCP");
        public static ContainerGroupNetworkProtocol UDP { get; } = new ContainerGroupNetworkProtocol("UDP");

        public static bool operator ==(ContainerGroupNetworkProtocol left, ContainerGroupNetworkProtocol right) => left.Equals(right);
        public static bool operator !=(ContainerGroupNetworkProtocol left, ContainerGroupNetworkProtocol right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupNetworkProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupNetworkProtocol other && Equals(other);
        public bool Equals(ContainerGroupNetworkProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The priority of the container group.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupPriority : IEquatable<ContainerGroupPriority>
    {
        private readonly string _value;

        private ContainerGroupPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupPriority Regular { get; } = new ContainerGroupPriority("Regular");
        public static ContainerGroupPriority Spot { get; } = new ContainerGroupPriority("Spot");

        public static bool operator ==(ContainerGroupPriority left, ContainerGroupPriority right) => left.Equals(right);
        public static bool operator !=(ContainerGroupPriority left, ContainerGroupPriority right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupPriority other && Equals(other);
        public bool Equals(ContainerGroupPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Restart policy for all containers within the container group. 
    /// - `Always` Always restart
    /// - `OnFailure` Restart on failure
    /// - `Never` Never restart
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupRestartPolicy : IEquatable<ContainerGroupRestartPolicy>
    {
        private readonly string _value;

        private ContainerGroupRestartPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupRestartPolicy Always { get; } = new ContainerGroupRestartPolicy("Always");
        public static ContainerGroupRestartPolicy OnFailure { get; } = new ContainerGroupRestartPolicy("OnFailure");
        public static ContainerGroupRestartPolicy Never { get; } = new ContainerGroupRestartPolicy("Never");

        public static bool operator ==(ContainerGroupRestartPolicy left, ContainerGroupRestartPolicy right) => left.Equals(right);
        public static bool operator !=(ContainerGroupRestartPolicy left, ContainerGroupRestartPolicy right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupRestartPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupRestartPolicy other && Equals(other);
        public bool Equals(ContainerGroupRestartPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU for a container group.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupSku : IEquatable<ContainerGroupSku>
    {
        private readonly string _value;

        private ContainerGroupSku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupSku NotSpecified { get; } = new ContainerGroupSku("NotSpecified");
        public static ContainerGroupSku Standard { get; } = new ContainerGroupSku("Standard");
        public static ContainerGroupSku Dedicated { get; } = new ContainerGroupSku("Dedicated");
        public static ContainerGroupSku Confidential { get; } = new ContainerGroupSku("Confidential");

        public static bool operator ==(ContainerGroupSku left, ContainerGroupSku right) => left.Equals(right);
        public static bool operator !=(ContainerGroupSku left, ContainerGroupSku right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupSku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupSku other && Equals(other);
        public bool Equals(ContainerGroupSku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol associated with the port.
    /// </summary>
    [EnumType]
    public readonly struct ContainerNetworkProtocol : IEquatable<ContainerNetworkProtocol>
    {
        private readonly string _value;

        private ContainerNetworkProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerNetworkProtocol TCP { get; } = new ContainerNetworkProtocol("TCP");
        public static ContainerNetworkProtocol UDP { get; } = new ContainerNetworkProtocol("UDP");

        public static bool operator ==(ContainerNetworkProtocol left, ContainerNetworkProtocol right) => left.Equals(right);
        public static bool operator !=(ContainerNetworkProtocol left, ContainerNetworkProtocol right) => !left.Equals(right);

        public static explicit operator string(ContainerNetworkProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerNetworkProtocol other && Equals(other);
        public bool Equals(ContainerNetworkProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The value representing the security enum. The 'Unsecure' value is the default value if not selected and means the object's domain name label is not secured against subdomain takeover. The 'TenantReuse' value is the default value if selected and means the object's domain name label can be reused within the same tenant. The 'SubscriptionReuse' value means the object's domain name label can be reused within the same subscription. The 'ResourceGroupReuse' value means the object's domain name label can be reused within the same resource group. The 'NoReuse' value means the object's domain name label cannot be reused within the same resource group, subscription, or tenant.
    /// </summary>
    [EnumType]
    public readonly struct DnsNameLabelReusePolicy : IEquatable<DnsNameLabelReusePolicy>
    {
        private readonly string _value;

        private DnsNameLabelReusePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DnsNameLabelReusePolicy Unsecure { get; } = new DnsNameLabelReusePolicy("Unsecure");
        public static DnsNameLabelReusePolicy TenantReuse { get; } = new DnsNameLabelReusePolicy("TenantReuse");
        public static DnsNameLabelReusePolicy SubscriptionReuse { get; } = new DnsNameLabelReusePolicy("SubscriptionReuse");
        public static DnsNameLabelReusePolicy ResourceGroupReuse { get; } = new DnsNameLabelReusePolicy("ResourceGroupReuse");
        public static DnsNameLabelReusePolicy Noreuse { get; } = new DnsNameLabelReusePolicy("Noreuse");

        public static bool operator ==(DnsNameLabelReusePolicy left, DnsNameLabelReusePolicy right) => left.Equals(right);
        public static bool operator !=(DnsNameLabelReusePolicy left, DnsNameLabelReusePolicy right) => !left.Equals(right);

        public static explicit operator string(DnsNameLabelReusePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DnsNameLabelReusePolicy other && Equals(other);
        public bool Equals(DnsNameLabelReusePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU of the GPU resource.
    /// </summary>
    [EnumType]
    public readonly struct GpuSku : IEquatable<GpuSku>
    {
        private readonly string _value;

        private GpuSku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GpuSku K80 { get; } = new GpuSku("K80");
        public static GpuSku P100 { get; } = new GpuSku("P100");
        public static GpuSku V100 { get; } = new GpuSku("V100");

        public static bool operator ==(GpuSku left, GpuSku right) => left.Equals(right);
        public static bool operator !=(GpuSku left, GpuSku right) => !left.Equals(right);

        public static explicit operator string(GpuSku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GpuSku other && Equals(other);
        public bool Equals(GpuSku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default access level.
    /// </summary>
    [EnumType]
    public readonly struct IdentityAccessLevel : IEquatable<IdentityAccessLevel>
    {
        private readonly string _value;

        private IdentityAccessLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityAccessLevel All { get; } = new IdentityAccessLevel("All");
        public static IdentityAccessLevel System { get; } = new IdentityAccessLevel("System");
        public static IdentityAccessLevel User { get; } = new IdentityAccessLevel("User");

        public static bool operator ==(IdentityAccessLevel left, IdentityAccessLevel right) => left.Equals(right);
        public static bool operator !=(IdentityAccessLevel left, IdentityAccessLevel right) => !left.Equals(right);

        public static explicit operator string(IdentityAccessLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityAccessLevel other && Equals(other);
        public bool Equals(IdentityAccessLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type to be used.
    /// </summary>
    [EnumType]
    public readonly struct LogAnalyticsLogType : IEquatable<LogAnalyticsLogType>
    {
        private readonly string _value;

        private LogAnalyticsLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogAnalyticsLogType ContainerInsights { get; } = new LogAnalyticsLogType("ContainerInsights");
        public static LogAnalyticsLogType ContainerInstanceLogs { get; } = new LogAnalyticsLogType("ContainerInstanceLogs");

        public static bool operator ==(LogAnalyticsLogType left, LogAnalyticsLogType right) => left.Equals(right);
        public static bool operator !=(LogAnalyticsLogType left, LogAnalyticsLogType right) => !left.Equals(right);

        public static explicit operator string(LogAnalyticsLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogAnalyticsLogType other && Equals(other);
        public bool Equals(LogAnalyticsLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NGroupUpdateMode : IEquatable<NGroupUpdateMode>
    {
        private readonly string _value;

        private NGroupUpdateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NGroupUpdateMode Manual { get; } = new NGroupUpdateMode("Manual");
        public static NGroupUpdateMode Rolling { get; } = new NGroupUpdateMode("Rolling");

        public static bool operator ==(NGroupUpdateMode left, NGroupUpdateMode right) => left.Equals(right);
        public static bool operator !=(NGroupUpdateMode left, NGroupUpdateMode right) => !left.Equals(right);

        public static explicit operator string(NGroupUpdateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NGroupUpdateMode other && Equals(other);
        public bool Equals(NGroupUpdateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operating system type required by the containers in the container group.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The priority of the container group.
    /// </summary>
    [EnumType]
    public readonly struct Priority : IEquatable<Priority>
    {
        private readonly string _value;

        private Priority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Priority Regular { get; } = new Priority("Regular");
        public static Priority Spot { get; } = new Priority("Spot");

        public static bool operator ==(Priority left, Priority right) => left.Equals(right);
        public static bool operator !=(Priority left, Priority right) => !left.Equals(right);

        public static explicit operator string(Priority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Priority other && Equals(other);
        public bool Equals(Priority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the NGroup. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the NGroup.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        public static ResourceIdentityType SystemAssigned_UserAssigned { get; } = new ResourceIdentityType("SystemAssigned, UserAssigned");
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scheme.
    /// </summary>
    [EnumType]
    public readonly struct Scheme : IEquatable<Scheme>
    {
        private readonly string _value;

        private Scheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Scheme Http { get; } = new Scheme("http");
        public static Scheme Https { get; } = new Scheme("https");

        public static bool operator ==(Scheme left, Scheme right) => left.Equals(right);
        public static bool operator !=(Scheme left, Scheme right) => !left.Equals(right);

        public static explicit operator string(Scheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Scheme other && Equals(other);
        public bool Equals(Scheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
