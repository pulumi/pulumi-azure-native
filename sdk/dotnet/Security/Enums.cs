// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Security
{
    /// <summary>
    /// The type of the action that will be triggered by the Automation
    /// </summary>
    [EnumType]
    public readonly struct ActionType : IEquatable<ActionType>
    {
        private readonly string _value;

        private ActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ActionType LogicApp { get; } = new ActionType("LogicApp");
        public static ActionType EventHub { get; } = new ActionType("EventHub");
        public static ActionType Workspace { get; } = new ActionType("Workspace");

        public static bool operator ==(ActionType left, ActionType right) => left.Equals(right);
        public static bool operator !=(ActionType left, ActionType right) => !left.Equals(right);

        public static explicit operator string(ActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ActionType other && Equals(other);
        public bool Equals(ActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data types sent to workspace.
    /// </summary>
    [EnumType]
    public readonly struct AdditionalWorkspaceDataType : IEquatable<AdditionalWorkspaceDataType>
    {
        private readonly string _value;

        private AdditionalWorkspaceDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdditionalWorkspaceDataType Alerts { get; } = new AdditionalWorkspaceDataType("Alerts");
        public static AdditionalWorkspaceDataType RawEvents { get; } = new AdditionalWorkspaceDataType("RawEvents");

        public static bool operator ==(AdditionalWorkspaceDataType left, AdditionalWorkspaceDataType right) => left.Equals(right);
        public static bool operator !=(AdditionalWorkspaceDataType left, AdditionalWorkspaceDataType right) => !left.Equals(right);

        public static explicit operator string(AdditionalWorkspaceDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdditionalWorkspaceDataType other && Equals(other);
        public bool Equals(AdditionalWorkspaceDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Workspace type.
    /// </summary>
    [EnumType]
    public readonly struct AdditionalWorkspaceType : IEquatable<AdditionalWorkspaceType>
    {
        private readonly string _value;

        private AdditionalWorkspaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdditionalWorkspaceType Sentinel { get; } = new AdditionalWorkspaceType("Sentinel");

        public static bool operator ==(AdditionalWorkspaceType left, AdditionalWorkspaceType right) => left.Equals(right);
        public static bool operator !=(AdditionalWorkspaceType left, AdditionalWorkspaceType right) => !left.Equals(right);

        public static explicit operator string(AdditionalWorkspaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdditionalWorkspaceType other && Equals(other);
        public bool Equals(AdditionalWorkspaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The application source, what it affects, e.g. Assessments
    /// </summary>
    [EnumType]
    public readonly struct ApplicationSourceResourceType : IEquatable<ApplicationSourceResourceType>
    {
        private readonly string _value;

        private ApplicationSourceResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The source of the application is assessments
        /// </summary>
        public static ApplicationSourceResourceType Assessments { get; } = new ApplicationSourceResourceType("Assessments");

        public static bool operator ==(ApplicationSourceResourceType left, ApplicationSourceResourceType right) => left.Equals(right);
        public static bool operator !=(ApplicationSourceResourceType left, ApplicationSourceResourceType right) => !left.Equals(right);

        public static explicit operator string(ApplicationSourceResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationSourceResourceType other && Equals(other);
        public bool Equals(ApplicationSourceResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Programmatic code for the status of the assessment
    /// </summary>
    [EnumType]
    public readonly struct AssessmentStatusCode : IEquatable<AssessmentStatusCode>
    {
        private readonly string _value;

        private AssessmentStatusCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The resource is healthy
        /// </summary>
        public static AssessmentStatusCode Healthy { get; } = new AssessmentStatusCode("Healthy");
        /// <summary>
        /// The resource has a security issue that needs to be addressed
        /// </summary>
        public static AssessmentStatusCode Unhealthy { get; } = new AssessmentStatusCode("Unhealthy");
        /// <summary>
        /// Assessment for this resource did not happen
        /// </summary>
        public static AssessmentStatusCode NotApplicable { get; } = new AssessmentStatusCode("NotApplicable");

        public static bool operator ==(AssessmentStatusCode left, AssessmentStatusCode right) => left.Equals(right);
        public static bool operator !=(AssessmentStatusCode left, AssessmentStatusCode right) => !left.Equals(right);

        public static explicit operator string(AssessmentStatusCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AssessmentStatusCode other && Equals(other);
        public bool Equals(AssessmentStatusCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// BuiltIn if the assessment based on built-in Azure Policy definition, Custom if the assessment based on custom Azure Policy definition
    /// </summary>
    [EnumType]
    public readonly struct AssessmentType : IEquatable<AssessmentType>
    {
        private readonly string _value;

        private AssessmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft Defender for Cloud managed assessments
        /// </summary>
        public static AssessmentType BuiltIn { get; } = new AssessmentType("BuiltIn");
        /// <summary>
        /// User defined policies that are automatically ingested from Azure Policy to Microsoft Defender for Cloud
        /// </summary>
        public static AssessmentType CustomPolicy { get; } = new AssessmentType("CustomPolicy");
        /// <summary>
        /// User assessments pushed directly by the user or other third party to Microsoft Defender for Cloud
        /// </summary>
        public static AssessmentType CustomerManaged { get; } = new AssessmentType("CustomerManaged");

        public static bool operator ==(AssessmentType left, AssessmentType right) => left.Equals(right);
        public static bool operator !=(AssessmentType left, AssessmentType right) => !left.Equals(right);

        public static explicit operator string(AssessmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AssessmentType other && Equals(other);
        public bool Equals(AssessmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attest category of this assignment
    /// </summary>
    [EnumType]
    public readonly struct AttestationComplianceState : IEquatable<AttestationComplianceState>
    {
        private readonly string _value;

        private AttestationComplianceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttestationComplianceState Unknown { get; } = new AttestationComplianceState("unknown");
        public static AttestationComplianceState Compliant { get; } = new AttestationComplianceState("compliant");
        public static AttestationComplianceState NonCompliant { get; } = new AttestationComplianceState("nonCompliant");

        public static bool operator ==(AttestationComplianceState left, AttestationComplianceState right) => left.Equals(right);
        public static bool operator !=(AttestationComplianceState left, AttestationComplianceState right) => !left.Equals(right);

        public static explicit operator string(AttestationComplianceState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttestationComplianceState other && Equals(other);
        public bool Equals(AttestationComplianceState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The authentication type
    /// </summary>
    [EnumType]
    public readonly struct AuthenticationType : IEquatable<AuthenticationType>
    {
        private readonly string _value;

        private AuthenticationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthenticationType AccessToken { get; } = new AuthenticationType("AccessToken");

        public static bool operator ==(AuthenticationType left, AuthenticationType right) => left.Equals(right);
        public static bool operator !=(AuthenticationType left, AuthenticationType right) => !left.Equals(right);

        public static explicit operator string(AuthenticationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthenticationType other && Equals(other);
        public bool Equals(AuthenticationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// AutoDiscovery states.
    /// </summary>
    [EnumType]
    public readonly struct AutoDiscovery : IEquatable<AutoDiscovery>
    {
        private readonly string _value;

        private AutoDiscovery(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoDiscovery Disabled { get; } = new AutoDiscovery("Disabled");
        public static AutoDiscovery Enabled { get; } = new AutoDiscovery("Enabled");
        public static AutoDiscovery NotApplicable { get; } = new AutoDiscovery("NotApplicable");

        public static bool operator ==(AutoDiscovery left, AutoDiscovery right) => left.Equals(right);
        public static bool operator !=(AutoDiscovery left, AutoDiscovery right) => !left.Equals(right);

        public static explicit operator string(AutoDiscovery value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoDiscovery other && Equals(other);
        public bool Equals(AutoDiscovery other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether or not to automatically install Azure Arc (hybrid compute) agents on machines
    /// </summary>
    [EnumType]
    public readonly struct AutoProvision : IEquatable<AutoProvision>
    {
        private readonly string _value;

        private AutoProvision(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Install missing Azure Arc agents on machines automatically
        /// </summary>
        public static AutoProvision On { get; } = new AutoProvision("On");
        /// <summary>
        /// Do not install Azure Arc agent on the machines automatically
        /// </summary>
        public static AutoProvision Off { get; } = new AutoProvision("Off");

        public static bool operator ==(AutoProvision left, AutoProvision right) => left.Equals(right);
        public static bool operator !=(AutoProvision left, AutoProvision right) => !left.Equals(right);

        public static explicit operator string(AutoProvision value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoProvision other && Equals(other);
        public bool Equals(AutoProvision other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The categories of resource that is at risk when the assessment is unhealthy
    /// </summary>
    [EnumType]
    public readonly struct Categories : IEquatable<Categories>
    {
        private readonly string _value;

        private Categories(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Categories Compute { get; } = new Categories("Compute");
        public static Categories Networking { get; } = new Categories("Networking");
        public static Categories Data { get; } = new Categories("Data");
        public static Categories IdentityAndAccess { get; } = new Categories("IdentityAndAccess");
        public static Categories IoT { get; } = new Categories("IoT");

        public static bool operator ==(Categories left, Categories right) => left.Equals(right);
        public static bool operator !=(Categories left, Categories right) => !left.Equals(right);

        public static explicit operator string(Categories value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Categories other && Equals(other);
        public bool Equals(Categories other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The multi cloud resource's cloud name.
    /// </summary>
    [EnumType]
    public readonly struct CloudName : IEquatable<CloudName>
    {
        private readonly string _value;

        private CloudName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudName Azure { get; } = new CloudName("Azure");
        public static CloudName AWS { get; } = new CloudName("AWS");
        public static CloudName GCP { get; } = new CloudName("GCP");
        public static CloudName Github { get; } = new CloudName("Github");
        public static CloudName AzureDevOps { get; } = new CloudName("AzureDevOps");
        public static CloudName GitLab { get; } = new CloudName("GitLab");
        public static CloudName DockerHub { get; } = new CloudName("DockerHub");
        public static CloudName JFrog { get; } = new CloudName("JFrog");

        public static bool operator ==(CloudName left, CloudName right) => left.Equals(right);
        public static bool operator !=(CloudName left, CloudName right) => !left.Equals(right);

        public static explicit operator string(CloudName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudName other && Equals(other);
        public bool Equals(CloudName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DataSource : IEquatable<DataSource>
    {
        private readonly string _value;

        private DataSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Devices twin data
        /// </summary>
        public static DataSource TwinData { get; } = new DataSource("TwinData");

        public static bool operator ==(DataSource left, DataSource right) => left.Equals(right);
        public static bool operator !=(DataSource left, DataSource right) => !left.Equals(right);

        public static explicit operator string(DataSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataSource other && Equals(other);
        public bool Equals(DataSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning state of the resource.
    /// 
    /// Pending - Provisioning pending.
    /// Failed - Provisioning failed.
    /// Succeeded - Successful provisioning.
    /// Canceled - Provisioning canceled.
    /// PendingDeletion - Deletion pending.
    /// DeletionSuccess - Deletion successful.
    /// DeletionFailure - Deletion failure.
    /// </summary>
    [EnumType]
    public readonly struct DevOpsProvisioningState : IEquatable<DevOpsProvisioningState>
    {
        private readonly string _value;

        private DevOpsProvisioningState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DevOpsProvisioningState Succeeded { get; } = new DevOpsProvisioningState("Succeeded");
        public static DevOpsProvisioningState Failed { get; } = new DevOpsProvisioningState("Failed");
        public static DevOpsProvisioningState Canceled { get; } = new DevOpsProvisioningState("Canceled");
        public static DevOpsProvisioningState Pending { get; } = new DevOpsProvisioningState("Pending");
        public static DevOpsProvisioningState PendingDeletion { get; } = new DevOpsProvisioningState("PendingDeletion");
        public static DevOpsProvisioningState DeletionSuccess { get; } = new DevOpsProvisioningState("DeletionSuccess");
        public static DevOpsProvisioningState DeletionFailure { get; } = new DevOpsProvisioningState("DeletionFailure");

        public static bool operator ==(DevOpsProvisioningState left, DevOpsProvisioningState right) => left.Equals(right);
        public static bool operator !=(DevOpsProvisioningState left, DevOpsProvisioningState right) => !left.Equals(right);

        public static explicit operator string(DevOpsProvisioningState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DevOpsProvisioningState other && Equals(other);
        public bool Equals(DevOpsProvisioningState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Expected effect of this assignment (Audit/Exempt/Attest)
    /// </summary>
    [EnumType]
    public readonly struct Effect : IEquatable<Effect>
    {
        private readonly string _value;

        private Effect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Effect Audit { get; } = new Effect("Audit");
        public static Effect Exempt { get; } = new Effect("Exempt");
        public static Effect Attest { get; } = new Effect("Attest");

        public static bool operator ==(Effect left, Effect right) => left.Equals(right);
        public static bool operator !=(Effect left, Effect right) => !left.Equals(right);

        public static explicit operator string(Effect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Effect other && Equals(other);
        public bool Equals(Effect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If set to "False", it allows the descendants of this scope to override the pricing configuration set on this scope (allows setting inherited="False"). If set to "True", it prevents overrides and forces this pricing configuration on all the descendants of this scope. This field is only available for subscription-level pricing.
    /// </summary>
    [EnumType]
    public readonly struct Enforce : IEquatable<Enforce>
    {
        private readonly string _value;

        private Enforce(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Allows the descendants of this scope to override the pricing configuration set on this scope (allows setting inherited="False")
        /// </summary>
        public static Enforce False { get; } = new Enforce("False");
        /// <summary>
        /// Prevents overrides and forces the current scope's pricing configuration to all descendants
        /// </summary>
        public static Enforce True { get; } = new Enforce("True");

        public static bool operator ==(Enforce left, Enforce right) => left.Equals(right);
        public static bool operator !=(Enforce left, Enforce right) => !left.Equals(right);

        public static explicit operator string(Enforce value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Enforce other && Equals(other);
        public bool Equals(Enforce other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the environment data.
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentType : IEquatable<EnvironmentType>
    {
        private readonly string _value;

        private EnvironmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnvironmentType AwsAccount { get; } = new EnvironmentType("AwsAccount");
        public static EnvironmentType GcpProject { get; } = new EnvironmentType("GcpProject");
        public static EnvironmentType GithubScope { get; } = new EnvironmentType("GithubScope");
        public static EnvironmentType AzureDevOpsScope { get; } = new EnvironmentType("AzureDevOpsScope");
        public static EnvironmentType GitlabScope { get; } = new EnvironmentType("GitlabScope");
        public static EnvironmentType DockerHubOrganization { get; } = new EnvironmentType("DockerHubOrganization");
        public static EnvironmentType JFrogArtifactory { get; } = new EnvironmentType("JFrogArtifactory");

        public static bool operator ==(EnvironmentType left, EnvironmentType right) => left.Equals(right);
        public static bool operator !=(EnvironmentType left, EnvironmentType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentType other && Equals(other);
        public bool Equals(EnvironmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A valid event source type.
    /// </summary>
    [EnumType]
    public readonly struct EventSource : IEquatable<EventSource>
    {
        private readonly string _value;

        private EventSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSource Assessments { get; } = new EventSource("Assessments");
        public static EventSource AssessmentsSnapshot { get; } = new EventSource("AssessmentsSnapshot");
        public static EventSource SubAssessments { get; } = new EventSource("SubAssessments");
        public static EventSource SubAssessmentsSnapshot { get; } = new EventSource("SubAssessmentsSnapshot");
        public static EventSource Alerts { get; } = new EventSource("Alerts");
        public static EventSource SecureScores { get; } = new EventSource("SecureScores");
        public static EventSource SecureScoresSnapshot { get; } = new EventSource("SecureScoresSnapshot");
        public static EventSource SecureScoreControls { get; } = new EventSource("SecureScoreControls");
        public static EventSource SecureScoreControlsSnapshot { get; } = new EventSource("SecureScoreControlsSnapshot");
        public static EventSource RegulatoryComplianceAssessment { get; } = new EventSource("RegulatoryComplianceAssessment");
        public static EventSource RegulatoryComplianceAssessmentSnapshot { get; } = new EventSource("RegulatoryComplianceAssessmentSnapshot");
        public static EventSource AttackPaths { get; } = new EventSource("AttackPaths");
        public static EventSource AttackPathsSnapshot { get; } = new EventSource("AttackPathsSnapshot");

        public static bool operator ==(EventSource left, EventSource right) => left.Equals(right);
        public static bool operator !=(EventSource left, EventSource right) => !left.Equals(right);

        public static explicit operator string(EventSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSource other && Equals(other);
        public bool Equals(EventSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Exemption category of this assignment
    /// </summary>
    [EnumType]
    public readonly struct ExemptionCategory : IEquatable<ExemptionCategory>
    {
        private readonly string _value;

        private ExemptionCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExemptionCategory Waiver { get; } = new ExemptionCategory("waiver");
        public static ExemptionCategory Mitigated { get; } = new ExemptionCategory("mitigated");

        public static bool operator ==(ExemptionCategory left, ExemptionCategory right) => left.Equals(right);
        public static bool operator !=(ExemptionCategory left, ExemptionCategory right) => !left.Equals(right);

        public static explicit operator string(ExemptionCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExemptionCategory other && Equals(other);
        public bool Equals(ExemptionCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ExportData : IEquatable<ExportData>
    {
        private readonly string _value;

        private ExportData(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Agent raw events
        /// </summary>
        public static ExportData RawEvents { get; } = new ExportData("RawEvents");

        public static bool operator ==(ExportData left, ExportData right) => left.Equals(right);
        public static bool operator !=(ExportData left, ExportData right) => !left.Equals(right);

        public static explicit operator string(ExportData value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExportData other && Equals(other);
        public bool Equals(ExportData other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The owner type for the governance rule owner source
    /// </summary>
    [EnumType]
    public readonly struct GovernanceRuleOwnerSourceType : IEquatable<GovernanceRuleOwnerSourceType>
    {
        private readonly string _value;

        private GovernanceRuleOwnerSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The rule source type defined using resource tag
        /// </summary>
        public static GovernanceRuleOwnerSourceType ByTag { get; } = new GovernanceRuleOwnerSourceType("ByTag");
        /// <summary>
        /// The rule source type defined manually
        /// </summary>
        public static GovernanceRuleOwnerSourceType Manually { get; } = new GovernanceRuleOwnerSourceType("Manually");

        public static bool operator ==(GovernanceRuleOwnerSourceType left, GovernanceRuleOwnerSourceType right) => left.Equals(right);
        public static bool operator !=(GovernanceRuleOwnerSourceType left, GovernanceRuleOwnerSourceType right) => !left.Equals(right);

        public static explicit operator string(GovernanceRuleOwnerSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GovernanceRuleOwnerSourceType other && Equals(other);
        public bool Equals(GovernanceRuleOwnerSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The governance rule source, what the rule affects, e.g. Assessments
    /// </summary>
    [EnumType]
    public readonly struct GovernanceRuleSourceResourceType : IEquatable<GovernanceRuleSourceResourceType>
    {
        private readonly string _value;

        private GovernanceRuleSourceResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The source of the governance rule is assessments
        /// </summary>
        public static GovernanceRuleSourceResourceType Assessments { get; } = new GovernanceRuleSourceResourceType("Assessments");

        public static bool operator ==(GovernanceRuleSourceResourceType left, GovernanceRuleSourceResourceType right) => left.Equals(right);
        public static bool operator !=(GovernanceRuleSourceResourceType left, GovernanceRuleSourceResourceType right) => !left.Equals(right);

        public static explicit operator string(GovernanceRuleSourceResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GovernanceRuleSourceResourceType other && Equals(other);
        public bool Equals(GovernanceRuleSourceResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The rule type of the governance rule, defines the source of the rule e.g. Integrated
    /// </summary>
    [EnumType]
    public readonly struct GovernanceRuleType : IEquatable<GovernanceRuleType>
    {
        private readonly string _value;

        private GovernanceRuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The source of the rule type definition is integrated
        /// </summary>
        public static GovernanceRuleType Integrated { get; } = new GovernanceRuleType("Integrated");
        /// <summary>
        /// The source of the rule type definition is ServiceNow
        /// </summary>
        public static GovernanceRuleType ServiceNow { get; } = new GovernanceRuleType("ServiceNow");

        public static bool operator ==(GovernanceRuleType left, GovernanceRuleType right) => left.Equals(right);
        public static bool operator !=(GovernanceRuleType left, GovernanceRuleType right) => !left.Equals(right);

        public static explicit operator string(GovernanceRuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GovernanceRuleType other && Equals(other);
        public bool Equals(GovernanceRuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The implementation effort required to remediate this assessment
    /// </summary>
    [EnumType]
    public readonly struct ImplementationEffort : IEquatable<ImplementationEffort>
    {
        private readonly string _value;

        private ImplementationEffort(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImplementationEffort Low { get; } = new ImplementationEffort("Low");
        public static ImplementationEffort Moderate { get; } = new ImplementationEffort("Moderate");
        public static ImplementationEffort High { get; } = new ImplementationEffort("High");

        public static bool operator ==(ImplementationEffort left, ImplementationEffort right) => left.Equals(right);
        public static bool operator !=(ImplementationEffort left, ImplementationEffort right) => !left.Equals(right);

        public static explicit operator string(ImplementationEffort value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImplementationEffort other && Equals(other);
        public bool Equals(ImplementationEffort other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the extension is enabled.
    /// </summary>
    [EnumType]
    public readonly struct IsEnabled : IEquatable<IsEnabled>
    {
        private readonly string _value;

        private IsEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the extension is enabled
        /// </summary>
        public static IsEnabled True { get; } = new IsEnabled("True");
        /// <summary>
        /// Indicates the extension is disabled
        /// </summary>
        public static IsEnabled False { get; } = new IsEnabled("False");

        public static bool operator ==(IsEnabled left, IsEnabled right) => left.Equals(right);
        public static bool operator !=(IsEnabled left, IsEnabled right) => !left.Equals(right);

        public static explicit operator string(IsEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IsEnabled other && Equals(other);
        public bool Equals(IsEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the minimal attach path risk level which will be sent as email notifications
    /// </summary>
    [EnumType]
    public readonly struct MinimalRiskLevel : IEquatable<MinimalRiskLevel>
    {
        private readonly string _value;

        private MinimalRiskLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Get notifications on new attack paths with Critical risk level
        /// </summary>
        public static MinimalRiskLevel Critical { get; } = new MinimalRiskLevel("Critical");
        /// <summary>
        /// Get notifications on new attack paths with High or Critical risk level
        /// </summary>
        public static MinimalRiskLevel High { get; } = new MinimalRiskLevel("High");
        /// <summary>
        /// Get notifications on new attach paths with Medium, High or Critical risk level
        /// </summary>
        public static MinimalRiskLevel Medium { get; } = new MinimalRiskLevel("Medium");
        /// <summary>
        /// Get notifications on new attach paths with Low, Medium, High or Critical risk level
        /// </summary>
        public static MinimalRiskLevel Low { get; } = new MinimalRiskLevel("Low");

        public static bool operator ==(MinimalRiskLevel left, MinimalRiskLevel right) => left.Equals(right);
        public static bool operator !=(MinimalRiskLevel left, MinimalRiskLevel right) => !left.Equals(right);

        public static explicit operator string(MinimalRiskLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimalRiskLevel other && Equals(other);
        public bool Equals(MinimalRiskLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the minimal alert severity which will be sent as email notifications
    /// </summary>
    [EnumType]
    public readonly struct MinimalSeverity : IEquatable<MinimalSeverity>
    {
        private readonly string _value;

        private MinimalSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Get notifications on new alerts with High severity
        /// </summary>
        public static MinimalSeverity High { get; } = new MinimalSeverity("High");
        /// <summary>
        /// Get notifications on new alerts with Medium or High severity
        /// </summary>
        public static MinimalSeverity Medium { get; } = new MinimalSeverity("Medium");
        /// <summary>
        /// Get notifications on new alerts with Low, Medium or High severity
        /// </summary>
        public static MinimalSeverity Low { get; } = new MinimalSeverity("Low");

        public static bool operator ==(MinimalSeverity left, MinimalSeverity right) => left.Equals(right);
        public static bool operator !=(MinimalSeverity left, MinimalSeverity right) => !left.Equals(right);

        public static explicit operator string(MinimalSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimalSeverity other && Equals(other);
        public bool Equals(MinimalSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the security offering.
    /// </summary>
    [EnumType]
    public readonly struct OfferingType : IEquatable<OfferingType>
    {
        private readonly string _value;

        private OfferingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OfferingType CspmMonitorAws { get; } = new OfferingType("CspmMonitorAws");
        public static OfferingType DefenderForContainersAws { get; } = new OfferingType("DefenderForContainersAws");
        public static OfferingType DefenderForServersAws { get; } = new OfferingType("DefenderForServersAws");
        public static OfferingType DefenderForDatabasesAws { get; } = new OfferingType("DefenderForDatabasesAws");
        public static OfferingType CspmMonitorGcp { get; } = new OfferingType("CspmMonitorGcp");
        public static OfferingType CspmMonitorGithub { get; } = new OfferingType("CspmMonitorGithub");
        public static OfferingType CspmMonitorAzureDevOps { get; } = new OfferingType("CspmMonitorAzureDevOps");
        public static OfferingType DefenderForServersGcp { get; } = new OfferingType("DefenderForServersGcp");
        public static OfferingType DefenderForContainersGcp { get; } = new OfferingType("DefenderForContainersGcp");
        public static OfferingType DefenderForDatabasesGcp { get; } = new OfferingType("DefenderForDatabasesGcp");
        public static OfferingType DefenderCspmAws { get; } = new OfferingType("DefenderCspmAws");
        public static OfferingType DefenderCspmGcp { get; } = new OfferingType("DefenderCspmGcp");
        public static OfferingType CspmMonitorGitLab { get; } = new OfferingType("CspmMonitorGitLab");
        public static OfferingType CspmMonitorDockerHub { get; } = new OfferingType("CspmMonitorDockerHub");
        public static OfferingType DefenderForContainersDockerHub { get; } = new OfferingType("DefenderForContainersDockerHub");
        public static OfferingType DefenderCspmDockerHub { get; } = new OfferingType("DefenderCspmDockerHub");
        public static OfferingType CspmMonitorJFrog { get; } = new OfferingType("CspmMonitorJFrog");
        public static OfferingType DefenderForContainersJFrog { get; } = new OfferingType("DefenderForContainersJFrog");
        public static OfferingType DefenderCspmJFrog { get; } = new OfferingType("DefenderCspmJFrog");

        public static bool operator ==(OfferingType left, OfferingType right) => left.Equals(right);
        public static bool operator !=(OfferingType left, OfferingType right) => !left.Equals(right);

        public static explicit operator string(OfferingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OfferingType other && Equals(other);
        public bool Equals(OfferingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A valid comparer operator to use. A case-insensitive comparison will be applied for String PropertyType.
    /// </summary>
    [EnumType]
    public readonly struct Operator : IEquatable<Operator>
    {
        private readonly string _value;

        private Operator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Applies for decimal and non-decimal operands
        /// </summary>
        public static Operator EqualsValue { get; } = new Operator("Equals");
        /// <summary>
        /// Applies only for decimal operands
        /// </summary>
        public static Operator GreaterThan { get; } = new Operator("GreaterThan");
        /// <summary>
        /// Applies only for decimal operands
        /// </summary>
        public static Operator GreaterThanOrEqualTo { get; } = new Operator("GreaterThanOrEqualTo");
        /// <summary>
        /// Applies only for decimal operands
        /// </summary>
        public static Operator LesserThan { get; } = new Operator("LesserThan");
        /// <summary>
        /// Applies only for decimal operands
        /// </summary>
        public static Operator LesserThanOrEqualTo { get; } = new Operator("LesserThanOrEqualTo");
        /// <summary>
        /// Applies  for decimal and non-decimal operands
        /// </summary>
        public static Operator NotEquals { get; } = new Operator("NotEquals");
        /// <summary>
        /// Applies only for non-decimal operands
        /// </summary>
        public static Operator Contains { get; } = new Operator("Contains");
        /// <summary>
        /// Applies only for non-decimal operands
        /// </summary>
        public static Operator StartsWith { get; } = new Operator("StartsWith");
        /// <summary>
        /// Applies only for non-decimal operands
        /// </summary>
        public static Operator EndsWith { get; } = new Operator("EndsWith");

        public static bool operator ==(Operator left, Operator right) => left.Equals(right);
        public static bool operator !=(Operator left, Operator right) => !left.Equals(right);

        public static explicit operator string(Operator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Operator other && Equals(other);
        public bool Equals(Operator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The multi cloud account's membership type in the organization
    /// </summary>
    [EnumType]
    public readonly struct OrganizationMembershipType : IEquatable<OrganizationMembershipType>
    {
        private readonly string _value;

        private OrganizationMembershipType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OrganizationMembershipType Member { get; } = new OrganizationMembershipType("Member");
        public static OrganizationMembershipType Organization { get; } = new OrganizationMembershipType("Organization");

        public static bool operator ==(OrganizationMembershipType left, OrganizationMembershipType right) => left.Equals(right);
        public static bool operator !=(OrganizationMembershipType left, OrganizationMembershipType right) => !left.Equals(right);

        public static explicit operator string(OrganizationMembershipType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationMembershipType other && Equals(other);
        public bool Equals(OrganizationMembershipType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the Defender plan is enabled on the selected scope. Microsoft Defender for Cloud is provided in two pricing tiers: free and standard. The standard tier offers advanced security capabilities, while the free tier offers basic security features.
    /// </summary>
    [EnumType]
    public readonly struct PricingTier : IEquatable<PricingTier>
    {
        private readonly string _value;

        private PricingTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Get free Microsoft Defender for Cloud experience with basic security features
        /// </summary>
        public static PricingTier Free { get; } = new PricingTier("Free");
        /// <summary>
        /// Get the standard Microsoft Defender for Cloud experience with advanced security features
        /// </summary>
        public static PricingTier Standard { get; } = new PricingTier("Standard");

        public static bool operator ==(PricingTier left, PricingTier right) => left.Equals(right);
        public static bool operator !=(PricingTier left, PricingTier right) => !left.Equals(right);

        public static explicit operator string(PricingTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PricingTier other && Equals(other);
        public bool Equals(PricingTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The data type of the compared operands (string, integer, floating point number or a boolean [true/false]]
    /// </summary>
    [EnumType]
    public readonly struct PropertyType : IEquatable<PropertyType>
    {
        private readonly string _value;

        private PropertyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PropertyType String { get; } = new PropertyType("String");
        public static PropertyType Integer { get; } = new PropertyType("Integer");
        public static PropertyType Number { get; } = new PropertyType("Number");
        public static PropertyType Boolean { get; } = new PropertyType("Boolean");

        public static bool operator ==(PropertyType left, PropertyType right) => left.Equals(right);
        public static bool operator !=(PropertyType left, PropertyType right) => !left.Equals(right);

        public static explicit operator string(PropertyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PropertyType other && Equals(other);
        public bool Equals(PropertyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Protocol TCP { get; } = new Protocol("TCP");
        public static Protocol UDP { get; } = new Protocol("UDP");
        public static Protocol All { get; } = new Protocol("*");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Recommendation status. When the recommendation status is disabled recommendations are not generated.
    /// </summary>
    [EnumType]
    public readonly struct RecommendationConfigStatus : IEquatable<RecommendationConfigStatus>
    {
        private readonly string _value;

        private RecommendationConfigStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecommendationConfigStatus Disabled { get; } = new RecommendationConfigStatus("Disabled");
        public static RecommendationConfigStatus Enabled { get; } = new RecommendationConfigStatus("Enabled");

        public static bool operator ==(RecommendationConfigStatus left, RecommendationConfigStatus right) => left.Equals(right);
        public static bool operator !=(RecommendationConfigStatus left, RecommendationConfigStatus right) => !left.Equals(right);

        public static explicit operator string(RecommendationConfigStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecommendationConfigStatus other && Equals(other);
        public bool Equals(RecommendationConfigStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The cloud that the recommendation is supported on.
    /// </summary>
    [EnumType]
    public readonly struct RecommendationSupportedClouds : IEquatable<RecommendationSupportedClouds>
    {
        private readonly string _value;

        private RecommendationSupportedClouds(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecommendationSupportedClouds Azure { get; } = new RecommendationSupportedClouds("Azure");
        public static RecommendationSupportedClouds AWS { get; } = new RecommendationSupportedClouds("AWS");
        public static RecommendationSupportedClouds GCP { get; } = new RecommendationSupportedClouds("GCP");

        public static bool operator ==(RecommendationSupportedClouds left, RecommendationSupportedClouds right) => left.Equals(right);
        public static bool operator !=(RecommendationSupportedClouds left, RecommendationSupportedClouds right) => !left.Equals(right);

        public static explicit operator string(RecommendationSupportedClouds value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecommendationSupportedClouds other && Equals(other);
        public bool Equals(RecommendationSupportedClouds other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of IoT Security recommendation.
    /// </summary>
    [EnumType]
    public readonly struct RecommendationType : IEquatable<RecommendationType>
    {
        private readonly string _value;

        private RecommendationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Authentication schema used for pull an edge module from an ACR repository does not use Service Principal Authentication.
        /// </summary>
        public static RecommendationType IoT_ACRAuthentication { get; } = new RecommendationType("IoT_ACRAuthentication");
        /// <summary>
        /// IoT agent message size capacity is currently underutilized, causing an increase in the number of sent messages. Adjust message intervals for better utilization.
        /// </summary>
        public static RecommendationType IoT_AgentSendsUnutilizedMessages { get; } = new RecommendationType("IoT_AgentSendsUnutilizedMessages");
        /// <summary>
        /// Identified security related system configuration issues.
        /// </summary>
        public static RecommendationType IoT_Baseline { get; } = new RecommendationType("IoT_Baseline");
        /// <summary>
        /// You can optimize Edge Hub memory usage by turning off protocol heads for any protocols not used by Edge modules in your solution.
        /// </summary>
        public static RecommendationType IoT_EdgeHubMemOptimize { get; } = new RecommendationType("IoT_EdgeHubMemOptimize");
        /// <summary>
        /// Logging is disabled for this edge module.
        /// </summary>
        public static RecommendationType IoT_EdgeLoggingOptions { get; } = new RecommendationType("IoT_EdgeLoggingOptions");
        /// <summary>
        /// A minority within a device security group has inconsistent Edge Module settings with the rest of their group.
        /// </summary>
        public static RecommendationType IoT_InconsistentModuleSettings { get; } = new RecommendationType("IoT_InconsistentModuleSettings");
        /// <summary>
        /// Install the Azure Security of Things Agent.
        /// </summary>
        public static RecommendationType IoT_InstallAgent { get; } = new RecommendationType("IoT_InstallAgent");
        /// <summary>
        /// IP Filter Configuration should have rules defined for allowed traffic and should deny all other traffic by default.
        /// </summary>
        public static RecommendationType IoT_IPFilter_DenyAll { get; } = new RecommendationType("IoT_IPFilter_DenyAll");
        /// <summary>
        /// An Allow IP Filter rules source IP range is too large. Overly permissive rules might expose your IoT hub to malicious intenders.
        /// </summary>
        public static RecommendationType IoT_IPFilter_PermissiveRule { get; } = new RecommendationType("IoT_IPFilter_PermissiveRule");
        /// <summary>
        /// A listening endpoint was found on the device.
        /// </summary>
        public static RecommendationType IoT_OpenPorts { get; } = new RecommendationType("IoT_OpenPorts");
        /// <summary>
        /// An Allowed firewall policy was found (INPUT/OUTPUT). The policy should Deny all traffic by default and define rules to allow necessary communication to/from the device.
        /// </summary>
        public static RecommendationType IoT_PermissiveFirewallPolicy { get; } = new RecommendationType("IoT_PermissiveFirewallPolicy");
        /// <summary>
        /// A rule in the firewall has been found that contains a permissive pattern for a wide range of IP addresses or Ports.
        /// </summary>
        public static RecommendationType IoT_PermissiveInputFirewallRules { get; } = new RecommendationType("IoT_PermissiveInputFirewallRules");
        /// <summary>
        /// A rule in the firewall has been found that contains a permissive pattern for a wide range of IP addresses or Ports.
        /// </summary>
        public static RecommendationType IoT_PermissiveOutputFirewallRules { get; } = new RecommendationType("IoT_PermissiveOutputFirewallRules");
        /// <summary>
        /// Edge module is configured to run in privileged mode, with extensive Linux capabilities or with host-level network access (send/receive data to host machine).
        /// </summary>
        public static RecommendationType IoT_PrivilegedDockerOptions { get; } = new RecommendationType("IoT_PrivilegedDockerOptions");
        /// <summary>
        /// Same authentication credentials to the IoT Hub used by multiple devices. This could indicate an illegitimate device impersonating a legitimate device. It also exposes the risk of device impersonation by an attacker.
        /// </summary>
        public static RecommendationType IoT_SharedCredentials { get; } = new RecommendationType("IoT_SharedCredentials");
        /// <summary>
        /// Insecure TLS configurations detected. Immediate upgrade recommended.
        /// </summary>
        public static RecommendationType IoT_VulnerableTLSCipherSuite { get; } = new RecommendationType("IoT_VulnerableTLSCipherSuite");

        public static bool operator ==(RecommendationType left, RecommendationType right) => left.Equals(right);
        public static bool operator !=(RecommendationType left, RecommendationType right) => !left.Equals(right);

        public static explicit operator string(RecommendationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecommendationType other && Equals(other);
        public bool Equals(RecommendationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Possible states of the rule
    /// </summary>
    [EnumType]
    public readonly struct RuleState : IEquatable<RuleState>
    {
        private readonly string _value;

        private RuleState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleState Enabled { get; } = new RuleState("Enabled");
        public static RuleState Disabled { get; } = new RuleState("Disabled");
        public static RuleState Expired { get; } = new RuleState("Expired");

        public static bool operator ==(RuleState left, RuleState right) => left.Equals(right);
        public static bool operator !=(RuleState left, RuleState right) => !left.Equals(right);

        public static explicit operator string(RuleState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleState other && Equals(other);
        public bool Equals(RuleState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scanning mode for the VM scan.
    /// </summary>
    [EnumType]
    public readonly struct ScanningMode : IEquatable<ScanningMode>
    {
        private readonly string _value;

        private ScanningMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScanningMode Default { get; } = new ScanningMode("Default");

        public static bool operator ==(ScanningMode left, ScanningMode right) => left.Equals(right);
        public static bool operator !=(ScanningMode left, ScanningMode right) => !left.Equals(right);

        public static explicit operator string(ScanningMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScanningMode other && Equals(other);
        public bool Equals(ScanningMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A possible role to configure sending security notification alerts to
    /// </summary>
    [EnumType]
    public readonly struct SecurityContactRole : IEquatable<SecurityContactRole>
    {
        private readonly string _value;

        private SecurityContactRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If enabled, send notification on new alerts to the account admins
        /// </summary>
        public static SecurityContactRole AccountAdmin { get; } = new SecurityContactRole("AccountAdmin");
        /// <summary>
        /// If enabled, send notification on new alerts to the service admins
        /// </summary>
        public static SecurityContactRole ServiceAdmin { get; } = new SecurityContactRole("ServiceAdmin");
        /// <summary>
        /// If enabled, send notification on new alerts to the subscription owners
        /// </summary>
        public static SecurityContactRole Owner { get; } = new SecurityContactRole("Owner");
        /// <summary>
        /// If enabled, send notification on new alerts to the subscription contributors
        /// </summary>
        public static SecurityContactRole Contributor { get; } = new SecurityContactRole("Contributor");

        public static bool operator ==(SecurityContactRole left, SecurityContactRole right) => left.Equals(right);
        public static bool operator !=(SecurityContactRole left, SecurityContactRole right) => !left.Equals(right);

        public static explicit operator string(SecurityContactRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityContactRole other && Equals(other);
        public bool Equals(SecurityContactRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity to relate to the assessments generated by this Recommendation.
    /// </summary>
    [EnumType]
    public readonly struct SecurityIssue : IEquatable<SecurityIssue>
    {
        private readonly string _value;

        private SecurityIssue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityIssue Vulnerability { get; } = new SecurityIssue("Vulnerability");
        public static SecurityIssue ExcessivePermissions { get; } = new SecurityIssue("ExcessivePermissions");
        public static SecurityIssue AnonymousAccess { get; } = new SecurityIssue("AnonymousAccess");
        public static SecurityIssue NetworkExposure { get; } = new SecurityIssue("NetworkExposure");
        public static SecurityIssue TrafficEncryption { get; } = new SecurityIssue("TrafficEncryption");
        public static SecurityIssue BestPractices { get; } = new SecurityIssue("BestPractices");

        public static bool operator ==(SecurityIssue left, SecurityIssue right) => left.Equals(right);
        public static bool operator !=(SecurityIssue left, SecurityIssue right) => !left.Equals(right);

        public static explicit operator string(SecurityIssue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityIssue other && Equals(other);
        public bool Equals(SecurityIssue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Status of the IoT Security solution.
    /// </summary>
    [EnumType]
    public readonly struct SecuritySolutionStatus : IEquatable<SecuritySolutionStatus>
    {
        private readonly string _value;

        private SecuritySolutionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecuritySolutionStatus Enabled { get; } = new SecuritySolutionStatus("Enabled");
        public static SecuritySolutionStatus Disabled { get; } = new SecuritySolutionStatus("Disabled");

        public static bool operator ==(SecuritySolutionStatus left, SecuritySolutionStatus right) => left.Equals(right);
        public static bool operator !=(SecuritySolutionStatus left, SecuritySolutionStatus right) => !left.Equals(right);

        public static explicit operator string(SecuritySolutionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecuritySolutionStatus other && Equals(other);
        public bool Equals(SecuritySolutionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The selected vulnerability assessments provider on Azure servers in the defined scope.
    /// </summary>
    [EnumType]
    public readonly struct ServerVulnerabilityAssessmentsAzureSettingSelectedProvider : IEquatable<ServerVulnerabilityAssessmentsAzureSettingSelectedProvider>
    {
        private readonly string _value;

        private ServerVulnerabilityAssessmentsAzureSettingSelectedProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Microsoft Defender for Endpoints threat and vulnerability management.
        /// </summary>
        public static ServerVulnerabilityAssessmentsAzureSettingSelectedProvider MdeTvm { get; } = new ServerVulnerabilityAssessmentsAzureSettingSelectedProvider("MdeTvm");

        public static bool operator ==(ServerVulnerabilityAssessmentsAzureSettingSelectedProvider left, ServerVulnerabilityAssessmentsAzureSettingSelectedProvider right) => left.Equals(right);
        public static bool operator !=(ServerVulnerabilityAssessmentsAzureSettingSelectedProvider left, ServerVulnerabilityAssessmentsAzureSettingSelectedProvider right) => !left.Equals(right);

        public static explicit operator string(ServerVulnerabilityAssessmentsAzureSettingSelectedProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerVulnerabilityAssessmentsAzureSettingSelectedProvider other && Equals(other);
        public bool Equals(ServerVulnerabilityAssessmentsAzureSettingSelectedProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of the server vulnerability assessments setting.
    /// </summary>
    [EnumType]
    public readonly struct ServerVulnerabilityAssessmentsSettingKind : IEquatable<ServerVulnerabilityAssessmentsSettingKind>
    {
        private readonly string _value;

        private ServerVulnerabilityAssessmentsSettingKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerVulnerabilityAssessmentsSettingKind AzureServersSetting { get; } = new ServerVulnerabilityAssessmentsSettingKind("AzureServersSetting");

        public static bool operator ==(ServerVulnerabilityAssessmentsSettingKind left, ServerVulnerabilityAssessmentsSettingKind right) => left.Equals(right);
        public static bool operator !=(ServerVulnerabilityAssessmentsSettingKind left, ServerVulnerabilityAssessmentsSettingKind right) => !left.Equals(right);

        public static explicit operator string(ServerVulnerabilityAssessmentsSettingKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerVulnerabilityAssessmentsSettingKind other && Equals(other);
        public bool Equals(ServerVulnerabilityAssessmentsSettingKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity level of the assessment
    /// </summary>
    [EnumType]
    public readonly struct Severity : IEquatable<Severity>
    {
        private readonly string _value;

        private Severity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Severity Low { get; } = new Severity("Low");
        public static Severity Medium { get; } = new Severity("Medium");
        public static Severity High { get; } = new Severity("High");

        public static bool operator ==(Severity left, Severity right) => left.Equals(right);
        public static bool operator !=(Severity left, Severity right) => !left.Equals(right);

        public static explicit operator string(Severity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Severity other && Equals(other);
        public bool Equals(Severity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity to relate to the assessments generated by this Recommendation.
    /// </summary>
    [EnumType]
    public readonly struct SeverityEnum : IEquatable<SeverityEnum>
    {
        private readonly string _value;

        private SeverityEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SeverityEnum High { get; } = new SeverityEnum("High");
        public static SeverityEnum Medium { get; } = new SeverityEnum("Medium");
        public static SeverityEnum Low { get; } = new SeverityEnum("Low");

        public static bool operator ==(SeverityEnum left, SeverityEnum right) => left.Equals(right);
        public static bool operator !=(SeverityEnum left, SeverityEnum right) => !left.Equals(right);

        public static explicit operator string(SeverityEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SeverityEnum other && Equals(other);
        public bool Equals(SeverityEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The platform where the assessed resource resides
    /// </summary>
    [EnumType]
    public readonly struct Source : IEquatable<Source>
    {
        private readonly string _value;

        private Source(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Resource is in Azure
        /// </summary>
        public static Source Azure { get; } = new Source("Azure");
        /// <summary>
        /// Resource in an on premise machine connected to Azure cloud
        /// </summary>
        public static Source OnPremise { get; } = new Source("OnPremise");
        /// <summary>
        /// SQL Resource in an on premise machine connected to Azure cloud
        /// </summary>
        public static Source OnPremiseSql { get; } = new Source("OnPremiseSql");

        public static bool operator ==(Source left, Source right) => left.Equals(right);
        public static bool operator !=(Source left, Source right) => !left.Equals(right);

        public static explicit operator string(Source value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Source other && Equals(other);
        public bool Equals(Source other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source type that will trigger the notification
    /// </summary>
    [EnumType]
    public readonly struct SourceType : IEquatable<SourceType>
    {
        private readonly string _value;

        private SourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SourceType Alert { get; } = new SourceType("Alert");
        public static SourceType AttackPath { get; } = new SourceType("AttackPath");

        public static bool operator ==(SourceType left, SourceType right) => left.Equals(right);
        public static bool operator !=(SourceType left, SourceType right) => !left.Equals(right);

        public static explicit operator string(SourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceType other && Equals(other);
        public bool Equals(SourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The cloud that the standard is supported on.
    /// </summary>
    [EnumType]
    public readonly struct StandardSupportedCloud : IEquatable<StandardSupportedCloud>
    {
        private readonly string _value;

        private StandardSupportedCloud(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StandardSupportedCloud Azure { get; } = new StandardSupportedCloud("Azure");
        public static StandardSupportedCloud AWS { get; } = new StandardSupportedCloud("AWS");
        public static StandardSupportedCloud GCP { get; } = new StandardSupportedCloud("GCP");

        public static bool operator ==(StandardSupportedCloud left, StandardSupportedCloud right) => left.Equals(right);
        public static bool operator !=(StandardSupportedCloud left, StandardSupportedCloud right) => !left.Equals(right);

        public static explicit operator string(StandardSupportedCloud value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StandardSupportedCloud other && Equals(other);
        public bool Equals(StandardSupportedCloud other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The cloud that the standard is supported on.
    /// </summary>
    [EnumType]
    public readonly struct StandardSupportedClouds : IEquatable<StandardSupportedClouds>
    {
        private readonly string _value;

        private StandardSupportedClouds(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StandardSupportedClouds AWS { get; } = new StandardSupportedClouds("AWS");
        public static StandardSupportedClouds GCP { get; } = new StandardSupportedClouds("GCP");

        public static bool operator ==(StandardSupportedClouds left, StandardSupportedClouds right) => left.Equals(right);
        public static bool operator !=(StandardSupportedClouds left, StandardSupportedClouds right) => !left.Equals(right);

        public static explicit operator string(StandardSupportedClouds value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StandardSupportedClouds other && Equals(other);
        public bool Equals(StandardSupportedClouds other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines whether to send email notifications from AMicrosoft Defender for Cloud to persons with specific RBAC roles on the subscription.
    /// </summary>
    [EnumType]
    public readonly struct State : IEquatable<State>
    {
        private readonly string _value;

        private State(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Send notification on new alerts to the subscription's admins
        /// </summary>
        public static State On { get; } = new State("On");
        /// <summary>
        /// Don't send notification on new alerts to the subscription's admins
        /// </summary>
        public static State Off { get; } = new State("Off");

        public static bool operator ==(State left, State right) => left.Equals(right);
        public static bool operator !=(State left, State right) => !left.Equals(right);

        public static explicit operator string(State value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is State other && Equals(other);
        public bool Equals(State other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the port
    /// </summary>
    [EnumType]
    public readonly struct Status : IEquatable<Status>
    {
        private readonly string _value;

        private Status(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Status Revoked { get; } = new Status("Revoked");
        public static Status Initiated { get; } = new Status("Initiated");

        public static bool operator ==(Status left, Status right) => left.Equals(right);
        public static bool operator !=(Status left, Status right) => !left.Equals(right);

        public static explicit operator string(Status value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Status other && Equals(other);
        public bool Equals(Status other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A description of why the `status` has its value
    /// </summary>
    [EnumType]
    public readonly struct StatusReason : IEquatable<StatusReason>
    {
        private readonly string _value;

        private StatusReason(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StatusReason Expired { get; } = new StatusReason("Expired");
        public static StatusReason UserRequested { get; } = new StatusReason("UserRequested");
        public static StatusReason NewerRequestInitiated { get; } = new StatusReason("NewerRequestInitiated");

        public static bool operator ==(StatusReason left, StatusReason right) => left.Equals(right);
        public static bool operator !=(StatusReason left, StatusReason right) => !left.Equals(right);

        public static explicit operator string(StatusReason value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusReason other && Equals(other);
        public bool Equals(StatusReason other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The available sub plans
    /// </summary>
    [EnumType]
    public readonly struct SubPlan : IEquatable<SubPlan>
    {
        private readonly string _value;

        private SubPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubPlan P1 { get; } = new SubPlan("P1");
        public static SubPlan P2 { get; } = new SubPlan("P2");

        public static bool operator ==(SubPlan left, SubPlan right) => left.Equals(right);
        public static bool operator !=(SubPlan left, SubPlan right) => !left.Equals(right);

        public static explicit operator string(SubPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubPlan other && Equals(other);
        public bool Equals(SubPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Relevant cloud for the custom assessment automation.
    /// </summary>
    [EnumType]
    public readonly struct SupportedCloudEnum : IEquatable<SupportedCloudEnum>
    {
        private readonly string _value;

        private SupportedCloudEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SupportedCloudEnum AWS { get; } = new SupportedCloudEnum("AWS");
        public static SupportedCloudEnum GCP { get; } = new SupportedCloudEnum("GCP");

        public static bool operator ==(SupportedCloudEnum left, SupportedCloudEnum right) => left.Equals(right);
        public static bool operator !=(SupportedCloudEnum left, SupportedCloudEnum right) => !left.Equals(right);

        public static explicit operator string(SupportedCloudEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SupportedCloudEnum other && Equals(other);
        public bool Equals(SupportedCloudEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Tactic of the assessment
    /// </summary>
    [EnumType]
    public readonly struct Tactics : IEquatable<Tactics>
    {
        private readonly string _value;

        private Tactics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Tactics Reconnaissance { get; } = new Tactics("Reconnaissance");
        public static Tactics Resource_Development { get; } = new Tactics("Resource Development");
        public static Tactics Initial_Access { get; } = new Tactics("Initial Access");
        public static Tactics Execution { get; } = new Tactics("Execution");
        public static Tactics Persistence { get; } = new Tactics("Persistence");
        public static Tactics Privilege_Escalation { get; } = new Tactics("Privilege Escalation");
        public static Tactics Defense_Evasion { get; } = new Tactics("Defense Evasion");
        public static Tactics Credential_Access { get; } = new Tactics("Credential Access");
        public static Tactics Discovery { get; } = new Tactics("Discovery");
        public static Tactics Lateral_Movement { get; } = new Tactics("Lateral Movement");
        public static Tactics Collection { get; } = new Tactics("Collection");
        public static Tactics Command_and_Control { get; } = new Tactics("Command and Control");
        public static Tactics Exfiltration { get; } = new Tactics("Exfiltration");
        public static Tactics Impact { get; } = new Tactics("Impact");

        public static bool operator ==(Tactics left, Tactics right) => left.Equals(right);
        public static bool operator !=(Tactics left, Tactics right) => !left.Equals(right);

        public static explicit operator string(Tactics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Tactics other && Equals(other);
        public bool Equals(Tactics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Techniques of the assessment
    /// </summary>
    [EnumType]
    public readonly struct Techniques : IEquatable<Techniques>
    {
        private readonly string _value;

        private Techniques(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Techniques Abuse_Elevation_Control_Mechanism { get; } = new Techniques("Abuse Elevation Control Mechanism");
        public static Techniques Access_Token_Manipulation { get; } = new Techniques("Access Token Manipulation");
        public static Techniques Account_Discovery { get; } = new Techniques("Account Discovery");
        public static Techniques Account_Manipulation { get; } = new Techniques("Account Manipulation");
        public static Techniques Active_Scanning { get; } = new Techniques("Active Scanning");
        public static Techniques Application_Layer_Protocol { get; } = new Techniques("Application Layer Protocol");
        public static Techniques Audio_Capture { get; } = new Techniques("Audio Capture");
        public static Techniques Boot_or_Logon_Autostart_Execution { get; } = new Techniques("Boot or Logon Autostart Execution");
        public static Techniques Boot_or_Logon_Initialization_Scripts { get; } = new Techniques("Boot or Logon Initialization Scripts");
        public static Techniques Brute_Force { get; } = new Techniques("Brute Force");
        public static Techniques Cloud_Infrastructure_Discovery { get; } = new Techniques("Cloud Infrastructure Discovery");
        public static Techniques Cloud_Service_Dashboard { get; } = new Techniques("Cloud Service Dashboard");
        public static Techniques Cloud_Service_Discovery { get; } = new Techniques("Cloud Service Discovery");
        public static Techniques Command_and_Scripting_Interpreter { get; } = new Techniques("Command and Scripting Interpreter");
        public static Techniques Compromise_Client_Software_Binary { get; } = new Techniques("Compromise Client Software Binary");
        public static Techniques Compromise_Infrastructure { get; } = new Techniques("Compromise Infrastructure");
        public static Techniques Container_and_Resource_Discovery { get; } = new Techniques("Container and Resource Discovery");
        public static Techniques Create_Account { get; } = new Techniques("Create Account");
        public static Techniques Create_or_Modify_System_Process { get; } = new Techniques("Create or Modify System Process");
        public static Techniques Credentials_from_Password_Stores { get; } = new Techniques("Credentials from Password Stores");
        public static Techniques Data_Destruction { get; } = new Techniques("Data Destruction");
        public static Techniques Data_Encrypted_for_Impact { get; } = new Techniques("Data Encrypted for Impact");
        public static Techniques Data_from_Cloud_Storage_Object { get; } = new Techniques("Data from Cloud Storage Object");
        public static Techniques Data_from_Configuration_Repository { get; } = new Techniques("Data from Configuration Repository");
        public static Techniques Data_from_Information_Repositories { get; } = new Techniques("Data from Information Repositories");
        public static Techniques Data_from_Local_System { get; } = new Techniques("Data from Local System");
        public static Techniques Data_Manipulation { get; } = new Techniques("Data Manipulation");
        public static Techniques Data_Staged { get; } = new Techniques("Data Staged");
        public static Techniques Defacement { get; } = new Techniques("Defacement");
        public static Techniques Deobfuscate_Decode_Files_or_Information { get; } = new Techniques("Deobfuscate/Decode Files or Information");
        public static Techniques Disk_Wipe { get; } = new Techniques("Disk Wipe");
        public static Techniques Domain_Trust_Discovery { get; } = new Techniques("Domain Trust Discovery");
        public static Techniques Drive_by_Compromise { get; } = new Techniques("Drive-by Compromise");
        public static Techniques Dynamic_Resolution { get; } = new Techniques("Dynamic Resolution");
        public static Techniques Endpoint_Denial_of_Service { get; } = new Techniques("Endpoint Denial of Service");
        public static Techniques Event_Triggered_Execution { get; } = new Techniques("Event Triggered Execution");
        public static Techniques Exfiltration_Over_Alternative_Protocol { get; } = new Techniques("Exfiltration Over Alternative Protocol");
        public static Techniques Exploit_Public_Facing_Application { get; } = new Techniques("Exploit Public-Facing Application");
        public static Techniques Exploitation_for_Client_Execution { get; } = new Techniques("Exploitation for Client Execution");
        public static Techniques Exploitation_for_Credential_Access { get; } = new Techniques("Exploitation for Credential Access");
        public static Techniques Exploitation_for_Defense_Evasion { get; } = new Techniques("Exploitation for Defense Evasion");
        public static Techniques Exploitation_for_Privilege_Escalation { get; } = new Techniques("Exploitation for Privilege Escalation");
        public static Techniques Exploitation_of_Remote_Services { get; } = new Techniques("Exploitation of Remote Services");
        public static Techniques External_Remote_Services { get; } = new Techniques("External Remote Services");
        public static Techniques Fallback_Channels { get; } = new Techniques("Fallback Channels");
        public static Techniques File_and_Directory_Discovery { get; } = new Techniques("File and Directory Discovery");
        public static Techniques Gather_Victim_Network_Information { get; } = new Techniques("Gather Victim Network Information");
        public static Techniques Hide_Artifacts { get; } = new Techniques("Hide Artifacts");
        public static Techniques Hijack_Execution_Flow { get; } = new Techniques("Hijack Execution Flow");
        public static Techniques Impair_Defenses { get; } = new Techniques("Impair Defenses");
        public static Techniques Implant_Container_Image { get; } = new Techniques("Implant Container Image");
        public static Techniques Indicator_Removal_on_Host { get; } = new Techniques("Indicator Removal on Host");
        public static Techniques Indirect_Command_Execution { get; } = new Techniques("Indirect Command Execution");
        public static Techniques Ingress_Tool_Transfer { get; } = new Techniques("Ingress Tool Transfer");
        public static Techniques Input_Capture { get; } = new Techniques("Input Capture");
        public static Techniques Inter_Process_Communication { get; } = new Techniques("Inter-Process Communication");
        public static Techniques Lateral_Tool_Transfer { get; } = new Techniques("Lateral Tool Transfer");
        public static Techniques Man_in_the_Middle { get; } = new Techniques("Man-in-the-Middle");
        public static Techniques Masquerading { get; } = new Techniques("Masquerading");
        public static Techniques Modify_Authentication_Process { get; } = new Techniques("Modify Authentication Process");
        public static Techniques Modify_Registry { get; } = new Techniques("Modify Registry");
        public static Techniques Network_Denial_of_Service { get; } = new Techniques("Network Denial of Service");
        public static Techniques Network_Service_Scanning { get; } = new Techniques("Network Service Scanning");
        public static Techniques Network_Sniffing { get; } = new Techniques("Network Sniffing");
        public static Techniques Non_Application_Layer_Protocol { get; } = new Techniques("Non-Application Layer Protocol");
        public static Techniques Non_Standard_Port { get; } = new Techniques("Non-Standard Port");
        public static Techniques Obtain_Capabilities { get; } = new Techniques("Obtain Capabilities");
        public static Techniques Obfuscated_Files_or_Information { get; } = new Techniques("Obfuscated Files or Information");
        public static Techniques Office_Application_Startup { get; } = new Techniques("Office Application Startup");
        public static Techniques OS_Credential_Dumping { get; } = new Techniques("OS Credential Dumping");
        public static Techniques Permission_Groups_Discovery { get; } = new Techniques("Permission Groups Discovery");
        public static Techniques Phishing { get; } = new Techniques("Phishing");
        public static Techniques Pre_OS_Boot { get; } = new Techniques("Pre-OS Boot");
        public static Techniques Process_Discovery { get; } = new Techniques("Process Discovery");
        public static Techniques Process_Injection { get; } = new Techniques("Process Injection");
        public static Techniques Protocol_Tunneling { get; } = new Techniques("Protocol Tunneling");
        public static Techniques Proxy { get; } = new Techniques("Proxy");
        public static Techniques Query_Registry { get; } = new Techniques("Query Registry");
        public static Techniques Remote_Access_Software { get; } = new Techniques("Remote Access Software");
        public static Techniques Remote_Service_Session_Hijacking { get; } = new Techniques("Remote Service Session Hijacking");
        public static Techniques Remote_Services { get; } = new Techniques("Remote Services");
        public static Techniques Remote_System_Discovery { get; } = new Techniques("Remote System Discovery");
        public static Techniques Resource_Hijacking { get; } = new Techniques("Resource Hijacking");
        public static Techniques Scheduled_Task_Job { get; } = new Techniques("Scheduled Task/Job");
        public static Techniques Screen_Capture { get; } = new Techniques("Screen Capture");
        public static Techniques Search_Victim_Owned_Websites { get; } = new Techniques("Search Victim-Owned Websites");
        public static Techniques Server_Software_Component { get; } = new Techniques("Server Software Component");
        public static Techniques Service_Stop { get; } = new Techniques("Service Stop");
        public static Techniques Signed_Binary_Proxy_Execution { get; } = new Techniques("Signed Binary Proxy Execution");
        public static Techniques Software_Deployment_Tools { get; } = new Techniques("Software Deployment Tools");
        public static Techniques SQL_Stored_Procedures { get; } = new Techniques("SQL Stored Procedures");
        public static Techniques Steal_or_Forge_Kerberos_Tickets { get; } = new Techniques("Steal or Forge Kerberos Tickets");
        public static Techniques Subvert_Trust_Controls { get; } = new Techniques("Subvert Trust Controls");
        public static Techniques Supply_Chain_Compromise { get; } = new Techniques("Supply Chain Compromise");
        public static Techniques System_Information_Discovery { get; } = new Techniques("System Information Discovery");
        public static Techniques Taint_Shared_Content { get; } = new Techniques("Taint Shared Content");
        public static Techniques Traffic_Signaling { get; } = new Techniques("Traffic Signaling");
        public static Techniques Transfer_Data_to_Cloud_Account { get; } = new Techniques("Transfer Data to Cloud Account");
        public static Techniques Trusted_Relationship { get; } = new Techniques("Trusted Relationship");
        public static Techniques Unsecured_Credentials { get; } = new Techniques("Unsecured Credentials");
        public static Techniques User_Execution { get; } = new Techniques("User Execution");
        public static Techniques Valid_Accounts { get; } = new Techniques("Valid Accounts");
        public static Techniques Windows_Management_Instrumentation { get; } = new Techniques("Windows Management Instrumentation");
        public static Techniques File_and_Directory_Permissions_Modification { get; } = new Techniques("File and Directory Permissions Modification");

        public static bool operator ==(Techniques left, Techniques right) => left.Equals(right);
        public static bool operator !=(Techniques left, Techniques right) => !left.Equals(right);

        public static explicit operator string(Techniques value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Techniques other && Equals(other);
        public bool Equals(Techniques other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Threats impact of the assessment
    /// </summary>
    [EnumType]
    public readonly struct Threats : IEquatable<Threats>
    {
        private readonly string _value;

        private Threats(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Threats AccountBreach { get; } = new Threats("accountBreach");
        public static Threats DataExfiltration { get; } = new Threats("dataExfiltration");
        public static Threats DataSpillage { get; } = new Threats("dataSpillage");
        public static Threats MaliciousInsider { get; } = new Threats("maliciousInsider");
        public static Threats ElevationOfPrivilege { get; } = new Threats("elevationOfPrivilege");
        public static Threats ThreatResistance { get; } = new Threats("threatResistance");
        public static Threats MissingCoverage { get; } = new Threats("missingCoverage");
        public static Threats DenialOfService { get; } = new Threats("denialOfService");

        public static bool operator ==(Threats left, Threats right) => left.Equals(right);
        public static bool operator !=(Threats left, Threats right) => !left.Equals(right);

        public static explicit operator string(Threats value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Threats other && Equals(other);
        public bool Equals(Threats other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Vulnerability Assessment solution to be provisioned. Can be either 'TVM' or 'Qualys'
    /// </summary>
    [EnumType]
    public readonly struct Type : IEquatable<Type>
    {
        private readonly string _value;

        private Type(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Type Qualys { get; } = new Type("Qualys");
        public static Type TVM { get; } = new Type("TVM");

        public static bool operator ==(Type left, Type right) => left.Equals(right);
        public static bool operator !=(Type left, Type right) => !left.Equals(right);

        public static explicit operator string(Type value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Type other && Equals(other);
        public bool Equals(Type other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Unmasked IP address logging status
    /// </summary>
    [EnumType]
    public readonly struct UnmaskedIpLoggingStatus : IEquatable<UnmaskedIpLoggingStatus>
    {
        private readonly string _value;

        private UnmaskedIpLoggingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unmasked IP logging is disabled
        /// </summary>
        public static UnmaskedIpLoggingStatus Disabled { get; } = new UnmaskedIpLoggingStatus("Disabled");
        /// <summary>
        /// Unmasked IP logging is enabled
        /// </summary>
        public static UnmaskedIpLoggingStatus Enabled { get; } = new UnmaskedIpLoggingStatus("Enabled");

        public static bool operator ==(UnmaskedIpLoggingStatus left, UnmaskedIpLoggingStatus right) => left.Equals(right);
        public static bool operator !=(UnmaskedIpLoggingStatus left, UnmaskedIpLoggingStatus right) => !left.Equals(right);

        public static explicit operator string(UnmaskedIpLoggingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UnmaskedIpLoggingStatus other && Equals(other);
        public bool Equals(UnmaskedIpLoggingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The user impact of the assessment
    /// </summary>
    [EnumType]
    public readonly struct UserImpact : IEquatable<UserImpact>
    {
        private readonly string _value;

        private UserImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UserImpact Low { get; } = new UserImpact("Low");
        public static UserImpact Moderate { get; } = new UserImpact("Moderate");
        public static UserImpact High { get; } = new UserImpact("High");

        public static bool operator ==(UserImpact left, UserImpact right) => left.Equals(right);
        public static bool operator !=(UserImpact left, UserImpact right) => !left.Equals(right);

        public static explicit operator string(UserImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UserImpact other && Equals(other);
        public bool Equals(UserImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
