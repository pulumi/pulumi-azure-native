// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Web.V20231201
{
    /// <summary>
    /// ActiveRevisionsMode controls how active revisions are handled for the Container app:
    /// &lt;list&gt;&lt;item&gt;Multiple: multiple revisions can be active. If no value if provided, this is the default&lt;/item&gt;&lt;item&gt;Single: Only one revision can be active at a time. Revision weights can not be used in this mode&lt;/item&gt;&lt;/list&gt;
    /// </summary>
    [EnumType]
    public readonly struct ActiveRevisionsMode : IEquatable<ActiveRevisionsMode>
    {
        private readonly string _value;

        private ActiveRevisionsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ActiveRevisionsMode Multiple { get; } = new ActiveRevisionsMode("multiple");
        public static ActiveRevisionsMode Single { get; } = new ActiveRevisionsMode("single");

        public static bool operator ==(ActiveRevisionsMode left, ActiveRevisionsMode right) => left.Equals(right);
        public static bool operator !=(ActiveRevisionsMode left, ActiveRevisionsMode right) => !left.Equals(right);

        public static explicit operator string(ActiveRevisionsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ActiveRevisionsMode other && Equals(other);
        public bool Equals(ActiveRevisionsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Auth Type
    /// </summary>
    [EnumType]
    public readonly struct AuthType : IEquatable<AuthType>
    {
        private readonly string _value;

        private AuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthType Anonymous { get; } = new AuthType("Anonymous");
        public static AuthType UserCredentials { get; } = new AuthType("UserCredentials");
        public static AuthType SystemIdentity { get; } = new AuthType("SystemIdentity");
        public static AuthType UserAssigned { get; } = new AuthType("UserAssigned");

        public static bool operator ==(AuthType left, AuthType right) => left.Equals(right);
        public static bool operator !=(AuthType left, AuthType right) => !left.Equals(right);

        public static explicit operator string(AuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthType other && Equals(other);
        public bool Equals(AuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
    /// </summary>
    [EnumType]
    public readonly struct AuthenticationType : IEquatable<AuthenticationType>
    {
        private readonly string _value;

        private AuthenticationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthenticationType SystemAssignedIdentity { get; } = new AuthenticationType("SystemAssignedIdentity");
        public static AuthenticationType UserAssignedIdentity { get; } = new AuthenticationType("UserAssignedIdentity");
        public static AuthenticationType StorageAccountConnectionString { get; } = new AuthenticationType("StorageAccountConnectionString");

        public static bool operator ==(AuthenticationType left, AuthenticationType right) => left.Equals(right);
        public static bool operator !=(AuthenticationType left, AuthenticationType right) => !left.Equals(right);

        public static explicit operator string(AuthenticationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthenticationType other && Equals(other);
        public bool Equals(AuthenticationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Predefined action to be taken.
    /// </summary>
    [EnumType]
    public readonly struct AutoHealActionType : IEquatable<AutoHealActionType>
    {
        private readonly string _value;

        private AutoHealActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoHealActionType Recycle { get; } = new AutoHealActionType("Recycle");
        public static AutoHealActionType LogEvent { get; } = new AutoHealActionType("LogEvent");
        public static AutoHealActionType CustomAction { get; } = new AutoHealActionType("CustomAction");

        public static bool operator ==(AutoHealActionType left, AutoHealActionType right) => left.Equals(right);
        public static bool operator !=(AutoHealActionType left, AutoHealActionType right) => !left.Equals(right);

        public static explicit operator string(AutoHealActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoHealActionType other && Equals(other);
        public bool Equals(AutoHealActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Azure resource type.
    /// </summary>
    [EnumType]
    public readonly struct AzureResourceType : IEquatable<AzureResourceType>
    {
        private readonly string _value;

        private AzureResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AzureResourceType Website { get; } = new AzureResourceType("Website");
        public static AzureResourceType TrafficManager { get; } = new AzureResourceType("TrafficManager");

        public static bool operator ==(AzureResourceType left, AzureResourceType right) => left.Equals(right);
        public static bool operator !=(AzureResourceType left, AzureResourceType right) => !left.Equals(right);

        public static explicit operator string(AzureResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AzureResourceType other && Equals(other);
        public bool Equals(AzureResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mounting protocol to use for the storage account.
    /// </summary>
    [EnumType]
    public readonly struct AzureStorageProtocol : IEquatable<AzureStorageProtocol>
    {
        private readonly string _value;

        private AzureStorageProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AzureStorageProtocol Smb { get; } = new AzureStorageProtocol("Smb");
        public static AzureStorageProtocol Http { get; } = new AzureStorageProtocol("Http");
        public static AzureStorageProtocol Nfs { get; } = new AzureStorageProtocol("Nfs");

        public static bool operator ==(AzureStorageProtocol left, AzureStorageProtocol right) => left.Equals(right);
        public static bool operator !=(AzureStorageProtocol left, AzureStorageProtocol right) => !left.Equals(right);

        public static explicit operator string(AzureStorageProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AzureStorageProtocol other && Equals(other);
        public bool Equals(AzureStorageProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of storage.
    /// </summary>
    [EnumType]
    public readonly struct AzureStorageType : IEquatable<AzureStorageType>
    {
        private readonly string _value;

        private AzureStorageType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AzureStorageType AzureFiles { get; } = new AzureStorageType("AzureFiles");
        public static AzureStorageType AzureBlob { get; } = new AzureStorageType("AzureBlob");

        public static bool operator ==(AzureStorageType left, AzureStorageType right) => left.Equals(right);
        public static bool operator !=(AzureStorageType left, AzureStorageType right) => !left.Equals(right);

        public static explicit operator string(AzureStorageType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AzureStorageType other && Equals(other);
        public bool Equals(AzureStorageType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default authentication provider to use when multiple providers are configured.
    /// This setting is only needed if multiple providers are configured and the unauthenticated client
    /// action is set to "RedirectToLoginPage".
    /// </summary>
    [EnumType]
    public readonly struct BuiltInAuthenticationProvider : IEquatable<BuiltInAuthenticationProvider>
    {
        private readonly string _value;

        private BuiltInAuthenticationProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BuiltInAuthenticationProvider AzureActiveDirectory { get; } = new BuiltInAuthenticationProvider("AzureActiveDirectory");
        public static BuiltInAuthenticationProvider Facebook { get; } = new BuiltInAuthenticationProvider("Facebook");
        public static BuiltInAuthenticationProvider Google { get; } = new BuiltInAuthenticationProvider("Google");
        public static BuiltInAuthenticationProvider MicrosoftAccount { get; } = new BuiltInAuthenticationProvider("MicrosoftAccount");
        public static BuiltInAuthenticationProvider Twitter { get; } = new BuiltInAuthenticationProvider("Twitter");
        public static BuiltInAuthenticationProvider Github { get; } = new BuiltInAuthenticationProvider("Github");

        public static bool operator ==(BuiltInAuthenticationProvider left, BuiltInAuthenticationProvider right) => left.Equals(right);
        public static bool operator !=(BuiltInAuthenticationProvider left, BuiltInAuthenticationProvider right) => !left.Equals(right);

        public static explicit operator string(BuiltInAuthenticationProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuiltInAuthenticationProvider other && Equals(other);
        public bool Equals(BuiltInAuthenticationProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This composes with ClientCertEnabled setting.
    /// - ClientCertEnabled: false means ClientCert is ignored.
    /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
    /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
    /// </summary>
    [EnumType]
    public readonly struct ClientCertMode : IEquatable<ClientCertMode>
    {
        private readonly string _value;

        private ClientCertMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClientCertMode Required { get; } = new ClientCertMode("Required");
        public static ClientCertMode Optional { get; } = new ClientCertMode("Optional");
        public static ClientCertMode OptionalInteractiveUser { get; } = new ClientCertMode("OptionalInteractiveUser");

        public static bool operator ==(ClientCertMode left, ClientCertMode right) => left.Equals(right);
        public static bool operator !=(ClientCertMode left, ClientCertMode right) => !left.Equals(right);

        public static explicit operator string(ClientCertMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClientCertMode other && Equals(other);
        public bool Equals(ClientCertMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of database.
    /// </summary>
    [EnumType]
    public readonly struct ConnectionStringType : IEquatable<ConnectionStringType>
    {
        private readonly string _value;

        private ConnectionStringType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionStringType MySql { get; } = new ConnectionStringType("MySql");
        public static ConnectionStringType SQLServer { get; } = new ConnectionStringType("SQLServer");
        public static ConnectionStringType SQLAzure { get; } = new ConnectionStringType("SQLAzure");
        public static ConnectionStringType Custom { get; } = new ConnectionStringType("Custom");
        public static ConnectionStringType NotificationHub { get; } = new ConnectionStringType("NotificationHub");
        public static ConnectionStringType ServiceBus { get; } = new ConnectionStringType("ServiceBus");
        public static ConnectionStringType EventHub { get; } = new ConnectionStringType("EventHub");
        public static ConnectionStringType ApiHub { get; } = new ConnectionStringType("ApiHub");
        public static ConnectionStringType DocDb { get; } = new ConnectionStringType("DocDb");
        public static ConnectionStringType RedisCache { get; } = new ConnectionStringType("RedisCache");
        public static ConnectionStringType PostgreSQL { get; } = new ConnectionStringType("PostgreSQL");

        public static bool operator ==(ConnectionStringType left, ConnectionStringType right) => left.Equals(right);
        public static bool operator !=(ConnectionStringType left, ConnectionStringType right) => !left.Equals(right);

        public static explicit operator string(ConnectionStringType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionStringType other && Equals(other);
        public bool Equals(ConnectionStringType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Custom DNS record type.
    /// </summary>
    [EnumType]
    public readonly struct CustomHostNameDnsRecordType : IEquatable<CustomHostNameDnsRecordType>
    {
        private readonly string _value;

        private CustomHostNameDnsRecordType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CustomHostNameDnsRecordType CName { get; } = new CustomHostNameDnsRecordType("CName");
        public static CustomHostNameDnsRecordType A { get; } = new CustomHostNameDnsRecordType("A");

        public static bool operator ==(CustomHostNameDnsRecordType left, CustomHostNameDnsRecordType right) => left.Equals(right);
        public static bool operator !=(CustomHostNameDnsRecordType left, CustomHostNameDnsRecordType right) => !left.Equals(right);

        public static explicit operator string(CustomHostNameDnsRecordType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CustomHostNameDnsRecordType other && Equals(other);
        public bool Equals(CustomHostNameDnsRecordType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
    /// </summary>
    [EnumType]
    public readonly struct DaprLogLevel : IEquatable<DaprLogLevel>
    {
        private readonly string _value;

        private DaprLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DaprLogLevel Info { get; } = new DaprLogLevel("info");
        public static DaprLogLevel Debug { get; } = new DaprLogLevel("debug");
        public static DaprLogLevel Warn { get; } = new DaprLogLevel("warn");
        public static DaprLogLevel Error { get; } = new DaprLogLevel("error");

        public static bool operator ==(DaprLogLevel left, DaprLogLevel right) => left.Equals(right);
        public static bool operator !=(DaprLogLevel left, DaprLogLevel right) => !left.Equals(right);

        public static explicit operator string(DaprLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DaprLogLevel other && Equals(other);
        public bool Equals(DaprLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Database type (e.g. SqlAzure / MySql).
    /// </summary>
    [EnumType]
    public readonly struct DatabaseType : IEquatable<DatabaseType>
    {
        private readonly string _value;

        private DatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatabaseType SqlAzure { get; } = new DatabaseType("SqlAzure");
        public static DatabaseType MySql { get; } = new DatabaseType("MySql");
        public static DatabaseType LocalMySql { get; } = new DatabaseType("LocalMySql");
        public static DatabaseType PostgreSql { get; } = new DatabaseType("PostgreSql");

        public static bool operator ==(DatabaseType left, DatabaseType right) => left.Equals(right);
        public static bool operator !=(DatabaseType left, DatabaseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseType other && Equals(other);
        public bool Equals(DatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default action for scm access restriction if no rules are matched.
    /// </summary>
    [EnumType]
    public readonly struct DefaultAction : IEquatable<DefaultAction>
    {
        private readonly string _value;

        private DefaultAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultAction Allow { get; } = new DefaultAction("Allow");
        public static DefaultAction Deny { get; } = new DefaultAction("Deny");

        public static bool operator ==(DefaultAction left, DefaultAction right) => left.Equals(right);
        public static bool operator !=(DefaultAction left, DefaultAction right) => !left.Equals(right);

        public static explicit operator string(DefaultAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultAction other && Equals(other);
        public bool Equals(DefaultAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State indicating the status of the enterprise grade CDN serving traffic to the static web app.
    /// </summary>
    [EnumType]
    public readonly struct EnterpriseGradeCdnStatus : IEquatable<EnterpriseGradeCdnStatus>
    {
        private readonly string _value;

        private EnterpriseGradeCdnStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnterpriseGradeCdnStatus Enabled { get; } = new EnterpriseGradeCdnStatus("Enabled");
        public static EnterpriseGradeCdnStatus Enabling { get; } = new EnterpriseGradeCdnStatus("Enabling");
        public static EnterpriseGradeCdnStatus Disabled { get; } = new EnterpriseGradeCdnStatus("Disabled");
        public static EnterpriseGradeCdnStatus Disabling { get; } = new EnterpriseGradeCdnStatus("Disabling");

        public static bool operator ==(EnterpriseGradeCdnStatus left, EnterpriseGradeCdnStatus right) => left.Equals(right);
        public static bool operator !=(EnterpriseGradeCdnStatus left, EnterpriseGradeCdnStatus right) => !left.Equals(right);

        public static explicit operator string(EnterpriseGradeCdnStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnterpriseGradeCdnStatus other && Equals(other);
        public bool Equals(EnterpriseGradeCdnStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
    /// </summary>
    [EnumType]
    public readonly struct FrequencyUnit : IEquatable<FrequencyUnit>
    {
        private readonly string _value;

        private FrequencyUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrequencyUnit Day { get; } = new FrequencyUnit("Day");
        public static FrequencyUnit Hour { get; } = new FrequencyUnit("Hour");

        public static bool operator ==(FrequencyUnit left, FrequencyUnit right) => left.Equals(right);
        public static bool operator !=(FrequencyUnit left, FrequencyUnit right) => !left.Equals(right);

        public static explicit operator string(FrequencyUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrequencyUnit other && Equals(other);
        public bool Equals(FrequencyUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FrontEndServiceType : IEquatable<FrontEndServiceType>
    {
        private readonly string _value;

        private FrontEndServiceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontEndServiceType NodePort { get; } = new FrontEndServiceType("NodePort");
        public static FrontEndServiceType LoadBalancer { get; } = new FrontEndServiceType("LoadBalancer");

        public static bool operator ==(FrontEndServiceType left, FrontEndServiceType right) => left.Equals(right);
        public static bool operator !=(FrontEndServiceType left, FrontEndServiceType right) => !left.Equals(right);

        public static explicit operator string(FrontEndServiceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontEndServiceType other && Equals(other);
        public bool Equals(FrontEndServiceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of FTP / FTPS service
    /// </summary>
    [EnumType]
    public readonly struct FtpsState : IEquatable<FtpsState>
    {
        private readonly string _value;

        private FtpsState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FtpsState AllAllowed { get; } = new FtpsState("AllAllowed");
        public static FtpsState FtpsOnly { get; } = new FtpsState("FtpsOnly");
        public static FtpsState Disabled { get; } = new FtpsState("Disabled");

        public static bool operator ==(FtpsState left, FtpsState right) => left.Equals(right);
        public static bool operator !=(FtpsState left, FtpsState right) => !left.Equals(right);

        public static explicit operator string(FtpsState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FtpsState other && Equals(other);
        public bool Equals(FtpsState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Hostname type.
    /// </summary>
    [EnumType]
    public readonly struct HostNameType : IEquatable<HostNameType>
    {
        private readonly string _value;

        private HostNameType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostNameType Verified { get; } = new HostNameType("Verified");
        public static HostNameType Managed { get; } = new HostNameType("Managed");

        public static bool operator ==(HostNameType left, HostNameType right) => left.Equals(right);
        public static bool operator !=(HostNameType left, HostNameType right) => !left.Equals(right);

        public static explicit operator string(HostNameType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostNameType other && Equals(other);
        public bool Equals(HostNameType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the hostname is a standard or repository hostname.
    /// </summary>
    [EnumType]
    public readonly struct HostType : IEquatable<HostType>
    {
        private readonly string _value;

        private HostType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostType Standard { get; } = new HostType("Standard");
        public static HostType Repository { get; } = new HostType("Repository");

        public static bool operator ==(HostType left, HostType right) => left.Equals(right);
        public static bool operator !=(HostType left, HostType right) => !left.Equals(right);

        public static explicit operator string(HostType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostType other && Equals(other);
        public bool Equals(HostType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ingress transport protocol
    /// </summary>
    [EnumType]
    public readonly struct IngressTransportMethod : IEquatable<IngressTransportMethod>
    {
        private readonly string _value;

        private IngressTransportMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IngressTransportMethod Auto { get; } = new IngressTransportMethod("auto");
        public static IngressTransportMethod Http { get; } = new IngressTransportMethod("http");
        public static IngressTransportMethod Http2 { get; } = new IngressTransportMethod("http2");

        public static bool operator ==(IngressTransportMethod left, IngressTransportMethod right) => left.Equals(right);
        public static bool operator !=(IngressTransportMethod left, IngressTransportMethod right) => !left.Equals(right);

        public static explicit operator string(IngressTransportMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IngressTransportMethod other && Equals(other);
        public bool Equals(IngressTransportMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines what this IP filter will be used for. This is to support IP filtering on proxies.
    /// </summary>
    [EnumType]
    public readonly struct IpFilterTag : IEquatable<IpFilterTag>
    {
        private readonly string _value;

        private IpFilterTag(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpFilterTag Default { get; } = new IpFilterTag("Default");
        public static IpFilterTag XffProxy { get; } = new IpFilterTag("XffProxy");
        public static IpFilterTag ServiceTag { get; } = new IpFilterTag("ServiceTag");

        public static bool operator ==(IpFilterTag left, IpFilterTag right) => left.Equals(right);
        public static bool operator !=(IpFilterTag left, IpFilterTag right) => !left.Equals(right);

        public static explicit operator string(IpFilterTag value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpFilterTag other && Equals(other);
        public bool Equals(IpFilterTag other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment.
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancingMode : IEquatable<LoadBalancingMode>
    {
        private readonly string _value;

        private LoadBalancingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancingMode None { get; } = new LoadBalancingMode("None");
        public static LoadBalancingMode Web { get; } = new LoadBalancingMode("Web");
        public static LoadBalancingMode Publishing { get; } = new LoadBalancingMode("Publishing");
        public static LoadBalancingMode Web_Publishing { get; } = new LoadBalancingMode("Web, Publishing");

        public static bool operator ==(LoadBalancingMode left, LoadBalancingMode right) => left.Equals(right);
        public static bool operator !=(LoadBalancingMode left, LoadBalancingMode right) => !left.Equals(right);

        public static explicit operator string(LoadBalancingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancingMode other && Equals(other);
        public bool Equals(LoadBalancingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Log level.
    /// </summary>
    [EnumType]
    public readonly struct LogLevel : IEquatable<LogLevel>
    {
        private readonly string _value;

        private LogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogLevel Off { get; } = new LogLevel("Off");
        public static LogLevel Verbose { get; } = new LogLevel("Verbose");
        public static LogLevel Information { get; } = new LogLevel("Information");
        public static LogLevel Warning { get; } = new LogLevel("Warning");
        public static LogLevel Error { get; } = new LogLevel("Error");

        public static bool operator ==(LogLevel left, LogLevel right) => left.Equals(right);
        public static bool operator !=(LogLevel left, LogLevel right) => !left.Equals(right);

        public static explicit operator string(LogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogLevel other && Equals(other);
        public bool Equals(LogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Managed pipeline mode.
    /// </summary>
    [EnumType]
    public readonly struct ManagedPipelineMode : IEquatable<ManagedPipelineMode>
    {
        private readonly string _value;

        private ManagedPipelineMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedPipelineMode Integrated { get; } = new ManagedPipelineMode("Integrated");
        public static ManagedPipelineMode Classic { get; } = new ManagedPipelineMode("Classic");

        public static bool operator ==(ManagedPipelineMode left, ManagedPipelineMode right) => left.Equals(right);
        public static bool operator !=(ManagedPipelineMode left, ManagedPipelineMode right) => !left.Equals(right);

        public static explicit operator string(ManagedPipelineMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedPipelineMode other && Equals(other);
        public bool Equals(ManagedPipelineMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity.
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned, UserAssigned");
        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Public Certificate Location
    /// </summary>
    [EnumType]
    public readonly struct PublicCertificateLocation : IEquatable<PublicCertificateLocation>
    {
        private readonly string _value;

        private PublicCertificateLocation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicCertificateLocation CurrentUserMy { get; } = new PublicCertificateLocation("CurrentUserMy");
        public static PublicCertificateLocation LocalMachineMy { get; } = new PublicCertificateLocation("LocalMachineMy");
        public static PublicCertificateLocation Unknown { get; } = new PublicCertificateLocation("Unknown");

        public static bool operator ==(PublicCertificateLocation left, PublicCertificateLocation right) => left.Equals(right);
        public static bool operator !=(PublicCertificateLocation left, PublicCertificateLocation right) => !left.Equals(right);

        public static explicit operator string(PublicCertificateLocation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicCertificateLocation other && Equals(other);
        public bool Equals(PublicCertificateLocation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Site redundancy mode
    /// </summary>
    [EnumType]
    public readonly struct RedundancyMode : IEquatable<RedundancyMode>
    {
        private readonly string _value;

        private RedundancyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RedundancyMode None { get; } = new RedundancyMode("None");
        public static RedundancyMode Manual { get; } = new RedundancyMode("Manual");
        public static RedundancyMode Failover { get; } = new RedundancyMode("Failover");
        public static RedundancyMode ActiveActive { get; } = new RedundancyMode("ActiveActive");
        public static RedundancyMode GeoRedundant { get; } = new RedundancyMode("GeoRedundant");

        public static bool operator ==(RedundancyMode left, RedundancyMode right) => left.Equals(right);
        public static bool operator !=(RedundancyMode left, RedundancyMode right) => !left.Equals(right);

        public static explicit operator string(RedundancyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedundancyMode other && Equals(other);
        public bool Equals(RedundancyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of route this is:
    /// DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
    /// INHERITED - Routes inherited from the real Virtual Network routes
    /// STATIC - Static route set on the app only
    /// 
    /// These values will be used for syncing an app's routes with those from a Virtual Network.
    /// </summary>
    [EnumType]
    public readonly struct RouteType : IEquatable<RouteType>
    {
        private readonly string _value;

        private RouteType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteType DEFAULT { get; } = new RouteType("DEFAULT");
        public static RouteType INHERITED { get; } = new RouteType("INHERITED");
        public static RouteType STATIC { get; } = new RouteType("STATIC");

        public static bool operator ==(RouteType left, RouteType right) => left.Equals(right);
        public static bool operator !=(RouteType left, RouteType right) => !left.Equals(right);

        public static explicit operator string(RouteType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteType other && Equals(other);
        public bool Equals(RouteType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
    /// </summary>
    [EnumType]
    public readonly struct RuntimeName : IEquatable<RuntimeName>
    {
        private readonly string _value;

        private RuntimeName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuntimeName Dotnet_isolated { get; } = new RuntimeName("dotnet-isolated");
        public static RuntimeName Node { get; } = new RuntimeName("node");
        public static RuntimeName Java { get; } = new RuntimeName("java");
        public static RuntimeName Powershell { get; } = new RuntimeName("powershell");
        public static RuntimeName Python { get; } = new RuntimeName("python");
        public static RuntimeName Custom { get; } = new RuntimeName("custom");

        public static bool operator ==(RuntimeName left, RuntimeName right) => left.Equals(right);
        public static bool operator !=(RuntimeName left, RuntimeName right) => !left.Equals(right);

        public static explicit operator string(RuntimeName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuntimeName other && Equals(other);
        public bool Equals(RuntimeName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// SCM type.
    /// </summary>
    [EnumType]
    public readonly struct ScmType : IEquatable<ScmType>
    {
        private readonly string _value;

        private ScmType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScmType None { get; } = new ScmType("None");
        public static ScmType Dropbox { get; } = new ScmType("Dropbox");
        public static ScmType Tfs { get; } = new ScmType("Tfs");
        public static ScmType LocalGit { get; } = new ScmType("LocalGit");
        public static ScmType GitHub { get; } = new ScmType("GitHub");
        public static ScmType CodePlexGit { get; } = new ScmType("CodePlexGit");
        public static ScmType CodePlexHg { get; } = new ScmType("CodePlexHg");
        public static ScmType BitbucketGit { get; } = new ScmType("BitbucketGit");
        public static ScmType BitbucketHg { get; } = new ScmType("BitbucketHg");
        public static ScmType ExternalGit { get; } = new ScmType("ExternalGit");
        public static ScmType ExternalHg { get; } = new ScmType("ExternalHg");
        public static ScmType OneDrive { get; } = new ScmType("OneDrive");
        public static ScmType VSO { get; } = new ScmType("VSO");
        public static ScmType VSTSRM { get; } = new ScmType("VSTSRM");

        public static bool operator ==(ScmType left, ScmType right) => left.Equals(right);
        public static bool operator !=(ScmType left, ScmType right) => !left.Equals(right);

        public static explicit operator string(ScmType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScmType other && Equals(other);
        public bool Equals(ScmType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Site load balancing.
    /// </summary>
    [EnumType]
    public readonly struct SiteLoadBalancing : IEquatable<SiteLoadBalancing>
    {
        private readonly string _value;

        private SiteLoadBalancing(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SiteLoadBalancing WeightedRoundRobin { get; } = new SiteLoadBalancing("WeightedRoundRobin");
        public static SiteLoadBalancing LeastRequests { get; } = new SiteLoadBalancing("LeastRequests");
        public static SiteLoadBalancing LeastResponseTime { get; } = new SiteLoadBalancing("LeastResponseTime");
        public static SiteLoadBalancing WeightedTotalTraffic { get; } = new SiteLoadBalancing("WeightedTotalTraffic");
        public static SiteLoadBalancing RequestHash { get; } = new SiteLoadBalancing("RequestHash");
        public static SiteLoadBalancing PerSiteRoundRobin { get; } = new SiteLoadBalancing("PerSiteRoundRobin");

        public static bool operator ==(SiteLoadBalancing left, SiteLoadBalancing right) => left.Equals(right);
        public static bool operator !=(SiteLoadBalancing left, SiteLoadBalancing right) => !left.Equals(right);

        public static explicit operator string(SiteLoadBalancing value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SiteLoadBalancing other && Equals(other);
        public bool Equals(SiteLoadBalancing other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// SSL type.
    /// </summary>
    [EnumType]
    public readonly struct SslState : IEquatable<SslState>
    {
        private readonly string _value;

        private SslState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslState Disabled { get; } = new SslState("Disabled");
        public static SslState SniEnabled { get; } = new SslState("SniEnabled");
        public static SslState IpBasedEnabled { get; } = new SslState("IpBasedEnabled");

        public static bool operator ==(SslState left, SslState right) => left.Equals(right);
        public static bool operator !=(SslState left, SslState right) => !left.Equals(right);

        public static explicit operator string(SslState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslState other && Equals(other);
        public bool Equals(SslState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State indicating whether staging environments are allowed or not allowed for a static web app.
    /// </summary>
    [EnumType]
    public readonly struct StagingEnvironmentPolicy : IEquatable<StagingEnvironmentPolicy>
    {
        private readonly string _value;

        private StagingEnvironmentPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StagingEnvironmentPolicy Enabled { get; } = new StagingEnvironmentPolicy("Enabled");
        public static StagingEnvironmentPolicy Disabled { get; } = new StagingEnvironmentPolicy("Disabled");

        public static bool operator ==(StagingEnvironmentPolicy left, StagingEnvironmentPolicy right) => left.Equals(right);
        public static bool operator !=(StagingEnvironmentPolicy left, StagingEnvironmentPolicy right) => !left.Equals(right);

        public static explicit operator string(StagingEnvironmentPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StagingEnvironmentPolicy other && Equals(other);
        public bool Equals(StagingEnvironmentPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property to select Azure Storage type. Available options: blobContainer.
    /// </summary>
    [EnumType]
    public readonly struct StorageType : IEquatable<StorageType>
    {
        private readonly string _value;

        private StorageType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageType BlobContainer { get; } = new StorageType("blobContainer");

        public static bool operator ==(StorageType left, StorageType right) => left.Equals(right);
        public static bool operator !=(StorageType left, StorageType right) => !left.Equals(right);

        public static explicit operator string(StorageType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageType other && Equals(other);
        public bool Equals(StorageType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
    /// </summary>
    [EnumType]
    public readonly struct SupportedTlsVersions : IEquatable<SupportedTlsVersions>
    {
        private readonly string _value;

        private SupportedTlsVersions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SupportedTlsVersions SupportedTlsVersions_1_0 { get; } = new SupportedTlsVersions("1.0");
        public static SupportedTlsVersions SupportedTlsVersions_1_1 { get; } = new SupportedTlsVersions("1.1");
        public static SupportedTlsVersions SupportedTlsVersions_1_2 { get; } = new SupportedTlsVersions("1.2");
        public static SupportedTlsVersions SupportedTlsVersions_1_3 { get; } = new SupportedTlsVersions("1.3");

        public static bool operator ==(SupportedTlsVersions left, SupportedTlsVersions right) => left.Equals(right);
        public static bool operator !=(SupportedTlsVersions left, SupportedTlsVersions right) => !left.Equals(right);

        public static explicit operator string(SupportedTlsVersions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SupportedTlsVersions other && Equals(other);
        public bool Equals(SupportedTlsVersions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The minimum strength TLS cipher suite allowed for an application
    /// </summary>
    [EnumType]
    public readonly struct TlsCipherSuites : IEquatable<TlsCipherSuites>
    {
        private readonly string _value;

        private TlsCipherSuites(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TlsCipherSuites TLS_AES_256_GCM_SHA384 { get; } = new TlsCipherSuites("TLS_AES_256_GCM_SHA384");
        public static TlsCipherSuites TLS_AES_128_GCM_SHA256 { get; } = new TlsCipherSuites("TLS_AES_128_GCM_SHA256");
        public static TlsCipherSuites TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 { get; } = new TlsCipherSuites("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384");
        public static TlsCipherSuites TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 { get; } = new TlsCipherSuites("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256");
        public static TlsCipherSuites TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 { get; } = new TlsCipherSuites("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA");
        public static TlsCipherSuites TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA { get; } = new TlsCipherSuites("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA");
        public static TlsCipherSuites TLS_RSA_WITH_AES_256_GCM_SHA384 { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_256_GCM_SHA384");
        public static TlsCipherSuites TLS_RSA_WITH_AES_128_GCM_SHA256 { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_128_GCM_SHA256");
        public static TlsCipherSuites TLS_RSA_WITH_AES_256_CBC_SHA256 { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_256_CBC_SHA256");
        public static TlsCipherSuites TLS_RSA_WITH_AES_128_CBC_SHA256 { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_128_CBC_SHA256");
        public static TlsCipherSuites TLS_RSA_WITH_AES_256_CBC_SHA { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_256_CBC_SHA");
        public static TlsCipherSuites TLS_RSA_WITH_AES_128_CBC_SHA { get; } = new TlsCipherSuites("TLS_RSA_WITH_AES_128_CBC_SHA");

        public static bool operator ==(TlsCipherSuites left, TlsCipherSuites right) => left.Equals(right);
        public static bool operator !=(TlsCipherSuites left, TlsCipherSuites right) => !left.Equals(right);

        public static explicit operator string(TlsCipherSuites value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsCipherSuites other && Equals(other);
        public bool Equals(TlsCipherSuites other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to take when an unauthenticated client attempts to access the app.
    /// </summary>
    [EnumType]
    public readonly struct UnauthenticatedClientAction : IEquatable<UnauthenticatedClientAction>
    {
        private readonly string _value;

        private UnauthenticatedClientAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UnauthenticatedClientAction RedirectToLoginPage { get; } = new UnauthenticatedClientAction("RedirectToLoginPage");
        public static UnauthenticatedClientAction AllowAnonymous { get; } = new UnauthenticatedClientAction("AllowAnonymous");

        public static bool operator ==(UnauthenticatedClientAction left, UnauthenticatedClientAction right) => left.Equals(right);
        public static bool operator !=(UnauthenticatedClientAction left, UnauthenticatedClientAction right) => !left.Equals(right);

        public static explicit operator string(UnauthenticatedClientAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UnauthenticatedClientAction other && Equals(other);
        public bool Equals(UnauthenticatedClientAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Upgrade Preference
    /// </summary>
    [EnumType]
    public readonly struct UpgradePreference : IEquatable<UpgradePreference>
    {
        private readonly string _value;

        private UpgradePreference(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No preference on when this App Service Environment will be upgraded
        /// </summary>
        public static UpgradePreference None { get; } = new UpgradePreference("None");
        /// <summary>
        /// This App Service Environment will be upgraded before others in the same region that have Upgrade Preference 'Late'
        /// </summary>
        public static UpgradePreference Early { get; } = new UpgradePreference("Early");
        /// <summary>
        /// This App Service Environment will be upgraded after others in the same region that have Upgrade Preference 'Early'
        /// </summary>
        public static UpgradePreference Late { get; } = new UpgradePreference("Late");
        /// <summary>
        /// ASEv3 only. Once an upgrade is available, this App Service Environment will wait 10 days for the upgrade to be manually initiated. After 10 days the upgrade will begin automatically
        /// </summary>
        public static UpgradePreference Manual { get; } = new UpgradePreference("Manual");

        public static bool operator ==(UpgradePreference left, UpgradePreference right) => left.Equals(right);
        public static bool operator !=(UpgradePreference left, UpgradePreference right) => !left.Equals(right);

        public static explicit operator string(UpgradePreference value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradePreference other && Equals(other);
        public bool Equals(UpgradePreference other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
