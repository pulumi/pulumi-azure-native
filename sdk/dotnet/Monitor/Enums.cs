// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Monitor
{
    /// <summary>
    /// Specifies the default access mode of queries through associated private endpoints in scope. If not specified default value is 'Open'. You can override this default setting for a specific private endpoint connection by adding an exclusion in the 'exclusions' array.
    /// </summary>
    [EnumType]
    public readonly struct AccessMode : IEquatable<AccessMode>
    {
        private readonly string _value;

        private AccessMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessMode Open { get; } = new AccessMode("Open");
        public static AccessMode PrivateOnly { get; } = new AccessMode("PrivateOnly");

        public static bool operator ==(AccessMode left, AccessMode right) => left.Equals(right);
        public static bool operator !=(AccessMode left, AccessMode right) => !left.Equals(right);

        public static explicit operator string(AccessMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessMode other && Equals(other);
        public bool Equals(AccessMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the operator that is used to compare the metric data and the threshold.
    /// </summary>
    [EnumType]
    public readonly struct ComparisonOperationType : IEquatable<ComparisonOperationType>
    {
        private readonly string _value;

        private ComparisonOperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComparisonOperationType EqualsValue { get; } = new ComparisonOperationType("Equals");
        public static ComparisonOperationType NotEquals { get; } = new ComparisonOperationType("NotEquals");
        public static ComparisonOperationType GreaterThan { get; } = new ComparisonOperationType("GreaterThan");
        public static ComparisonOperationType GreaterThanOrEqual { get; } = new ComparisonOperationType("GreaterThanOrEqual");
        public static ComparisonOperationType LessThan { get; } = new ComparisonOperationType("LessThan");
        public static ComparisonOperationType LessThanOrEqual { get; } = new ComparisonOperationType("LessThanOrEqual");

        public static bool operator ==(ComparisonOperationType left, ComparisonOperationType right) => left.Equals(right);
        public static bool operator !=(ComparisonOperationType left, ComparisonOperationType right) => !left.Equals(right);

        public static explicit operator string(ComparisonOperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComparisonOperationType other && Equals(other);
        public bool Equals(ComparisonOperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The criteria operator. Relevant and required only for rules of the kind LogAlert.
    /// </summary>
    [EnumType]
    public readonly struct ConditionOperator : IEquatable<ConditionOperator>
    {
        private readonly string _value;

        private ConditionOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConditionOperator EqualsValue { get; } = new ConditionOperator("Equals");
        public static ConditionOperator GreaterThan { get; } = new ConditionOperator("GreaterThan");
        public static ConditionOperator GreaterThanOrEqual { get; } = new ConditionOperator("GreaterThanOrEqual");
        public static ConditionOperator LessThan { get; } = new ConditionOperator("LessThan");
        public static ConditionOperator LessThanOrEqual { get; } = new ConditionOperator("LessThanOrEqual");
        public static ConditionOperator GreaterOrLessThan { get; } = new ConditionOperator("GreaterOrLessThan");

        public static bool operator ==(ConditionOperator left, ConditionOperator right) => left.Equals(right);
        public static bool operator !=(ConditionOperator left, ConditionOperator right) => !left.Equals(right);

        public static explicit operator string(ConditionOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionOperator other && Equals(other);
        public bool Equals(ConditionOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of threshold criteria
    /// </summary>
    [EnumType]
    public readonly struct CriterionType : IEquatable<CriterionType>
    {
        private readonly string _value;

        private CriterionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CriterionType StaticThresholdCriterion { get; } = new CriterionType("StaticThresholdCriterion");
        public static CriterionType DynamicThresholdCriterion { get; } = new CriterionType("DynamicThresholdCriterion");

        public static bool operator ==(CriterionType left, CriterionType right) => left.Equals(right);
        public static bool operator !=(CriterionType left, CriterionType right) => !left.Equals(right);

        public static explicit operator string(CriterionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CriterionType other && Equals(other);
        public bool Equals(CriterionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Operator for dimension values
    /// </summary>
    [EnumType]
    public readonly struct DimensionOperator : IEquatable<DimensionOperator>
    {
        private readonly string _value;

        private DimensionOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DimensionOperator Include { get; } = new DimensionOperator("Include");
        public static DimensionOperator Exclude { get; } = new DimensionOperator("Exclude");

        public static bool operator ==(DimensionOperator left, DimensionOperator right) => left.Equals(right);
        public static bool operator !=(DimensionOperator left, DimensionOperator right) => !left.Equals(right);

        public static explicit operator string(DimensionOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DimensionOperator other && Equals(other);
        public bool Equals(DimensionOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of exporter.
    /// </summary>
    [EnumType]
    public readonly struct ExporterType : IEquatable<ExporterType>
    {
        private readonly string _value;

        private ExporterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Export logs to Azure Monitor Workspace.
        /// </summary>
        public static ExporterType AzureMonitorWorkspaceLogs { get; } = new ExporterType("AzureMonitorWorkspaceLogs");
        /// <summary>
        /// Export data to another pipeline group instance.
        /// </summary>
        public static ExporterType PipelineGroup { get; } = new ExporterType("PipelineGroup");

        public static bool operator ==(ExporterType left, ExporterType right) => left.Equals(right);
        public static bool operator !=(ExporterType left, ExporterType right) => !left.Equals(right);

        public static explicit operator string(ExporterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExporterType other && Equals(other);
        public bool Equals(ExporterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationType : IEquatable<ExtendedLocationType>
    {
        private readonly string _value;

        private ExtendedLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Azure Edge Zones location type
        /// </summary>
        public static ExtendedLocationType EdgeZone { get; } = new ExtendedLocationType("EdgeZone");
        /// <summary>
        /// Azure Custom Locations type
        /// </summary>
        public static ExtendedLocationType CustomLocation { get; } = new ExtendedLocationType("CustomLocation");

        public static bool operator ==(ExtendedLocationType left, ExtendedLocationType right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationType left, ExtendedLocationType right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationType other && Equals(other);
        public bool Equals(ExtendedLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// External networking mode.
    /// </summary>
    [EnumType]
    public readonly struct ExternalNetworkingMode : IEquatable<ExternalNetworkingMode>
    {
        private readonly string _value;

        private ExternalNetworkingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Load balancer only.
        /// </summary>
        public static ExternalNetworkingMode LoadBalancerOnly { get; } = new ExternalNetworkingMode("LoadBalancerOnly");

        public static bool operator ==(ExternalNetworkingMode left, ExternalNetworkingMode right) => left.Equals(right);
        public static bool operator !=(ExternalNetworkingMode left, ExternalNetworkingMode right) => !left.Equals(right);

        public static explicit operator string(ExternalNetworkingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalNetworkingMode other && Equals(other);
        public bool Equals(ExternalNetworkingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType None { get; } = new IdentityType("None");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The incident management service type
    /// </summary>
    [EnumType]
    public readonly struct IncidentManagementService : IEquatable<IncidentManagementService>
    {
        private readonly string _value;

        private IncidentManagementService(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IncidentManagementService Icm { get; } = new IncidentManagementService("Icm");

        public static bool operator ==(IncidentManagementService left, IncidentManagementService right) => left.Equals(right);
        public static bool operator !=(IncidentManagementService left, IncidentManagementService right) => !left.Equals(right);

        public static explicit operator string(IncidentManagementService value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IncidentManagementService other && Equals(other);
        public bool Equals(IncidentManagementService other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
    /// </summary>
    [EnumType]
    public readonly struct JsonMapperElement : IEquatable<JsonMapperElement>
    {
        private readonly string _value;

        private JsonMapperElement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Read or write the json array from or to the body of the message.
        /// </summary>
        public static JsonMapperElement Body { get; } = new JsonMapperElement("body");
        /// <summary>
        /// Read or write the json array from or to the attributes of the message.
        /// </summary>
        public static JsonMapperElement Attributes { get; } = new JsonMapperElement("attributes");

        public static bool operator ==(JsonMapperElement left, JsonMapperElement right) => left.Equals(right);
        public static bool operator !=(JsonMapperElement left, JsonMapperElement right) => !left.Equals(right);

        public static explicit operator string(JsonMapperElement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JsonMapperElement other && Equals(other);
        public bool Equals(JsonMapperElement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the type of scheduled query rule. The default is LogAlert.
    /// </summary>
    [EnumType]
    public readonly struct Kind : IEquatable<Kind>
    {
        private readonly string _value;

        private Kind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Kind LogAlert { get; } = new Kind("LogAlert");
        public static Kind EventLogAlert { get; } = new Kind("EventLogAlert");
        public static Kind LogToMetric { get; } = new Kind("LogToMetric");

        public static bool operator ==(Kind left, Kind right) => left.Equals(right);
        public static bool operator !=(Kind left, Kind right) => !left.Equals(right);

        public static explicit operator string(Kind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Kind other && Equals(other);
        public bool Equals(Kind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the metric statistic type. How the metrics from multiple instances are combined.
    /// </summary>
    [EnumType]
    public readonly struct MetricStatisticType : IEquatable<MetricStatisticType>
    {
        private readonly string _value;

        private MetricStatisticType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetricStatisticType Average { get; } = new MetricStatisticType("Average");
        public static MetricStatisticType Min { get; } = new MetricStatisticType("Min");
        public static MetricStatisticType Max { get; } = new MetricStatisticType("Max");
        public static MetricStatisticType Sum { get; } = new MetricStatisticType("Sum");
        public static MetricStatisticType Count { get; } = new MetricStatisticType("Count");

        public static bool operator ==(MetricStatisticType left, MetricStatisticType right) => left.Equals(right);
        public static bool operator !=(MetricStatisticType left, MetricStatisticType right) => !left.Equals(right);

        public static explicit operator string(MetricStatisticType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricStatisticType other && Equals(other);
        public bool Equals(MetricStatisticType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the operation associated with the notification and its value must be "scale"
    /// </summary>
    [EnumType]
    public readonly struct OperationType : IEquatable<OperationType>
    {
        private readonly string _value;

        private OperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperationType Scale { get; } = new OperationType("Scale");

        public static bool operator ==(OperationType left, OperationType right) => left.Equals(right);
        public static bool operator !=(OperationType left, OperationType right) => !left.Equals(right);

        public static explicit operator string(OperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationType other && Equals(other);
        public bool Equals(OperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of pipeline
    /// </summary>
    [EnumType]
    public readonly struct PipelineType : IEquatable<PipelineType>
    {
        private readonly string _value;

        private PipelineType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Pipeline for logs telemetry.
        /// </summary>
        public static PipelineType Logs { get; } = new PipelineType("Logs");

        public static bool operator ==(PipelineType left, PipelineType right) => left.Equals(right);
        public static bool operator !=(PipelineType left, PipelineType right) => !left.Equals(right);

        public static explicit operator string(PipelineType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PipelineType other && Equals(other);
        public bool Equals(PipelineType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the predictive autoscale mode
    /// </summary>
    [EnumType]
    public readonly struct PredictiveAutoscalePolicyScaleMode : IEquatable<PredictiveAutoscalePolicyScaleMode>
    {
        private readonly string _value;

        private PredictiveAutoscalePolicyScaleMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PredictiveAutoscalePolicyScaleMode Disabled { get; } = new PredictiveAutoscalePolicyScaleMode("Disabled");
        public static PredictiveAutoscalePolicyScaleMode ForecastOnly { get; } = new PredictiveAutoscalePolicyScaleMode("ForecastOnly");
        public static PredictiveAutoscalePolicyScaleMode Enabled { get; } = new PredictiveAutoscalePolicyScaleMode("Enabled");

        public static bool operator ==(PredictiveAutoscalePolicyScaleMode left, PredictiveAutoscalePolicyScaleMode right) => left.Equals(right);
        public static bool operator !=(PredictiveAutoscalePolicyScaleMode left, PredictiveAutoscalePolicyScaleMode right) => !left.Equals(right);

        public static explicit operator string(PredictiveAutoscalePolicyScaleMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PredictiveAutoscalePolicyScaleMode other && Equals(other);
        public bool Equals(PredictiveAutoscalePolicyScaleMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of processor.
    /// </summary>
    [EnumType]
    public readonly struct ProcessorType : IEquatable<ProcessorType>
    {
        private readonly string _value;

        private ProcessorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Batch processor.
        /// </summary>
        public static ProcessorType Batch { get; } = new ProcessorType("Batch");

        public static bool operator ==(ProcessorType left, ProcessorType right) => left.Equals(right);
        public static bool operator !=(ProcessorType left, ProcessorType right) => !left.Equals(right);

        public static explicit operator string(ProcessorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProcessorType other && Equals(other);
        public bool Equals(ProcessorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of receiver.
    /// </summary>
    [EnumType]
    public readonly struct ReceiverType : IEquatable<ReceiverType>
    {
        private readonly string _value;

        private ReceiverType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Linux syslog.
        /// </summary>
        public static ReceiverType Syslog { get; } = new ReceiverType("Syslog");
        /// <summary>
        /// Receives data from azure monitor agent receiver.
        /// </summary>
        public static ReceiverType Ama { get; } = new ReceiverType("Ama");
        /// <summary>
        /// Receives data from another pipeline group.
        /// </summary>
        public static ReceiverType PipelineGroup { get; } = new ReceiverType("PipelineGroup");
        /// <summary>
        /// Receives data from a OTLP collector.
        /// </summary>
        public static ReceiverType OTLP { get; } = new ReceiverType("OTLP");
        /// <summary>
        /// Receives data from an UDP collector.
        /// </summary>
        public static ReceiverType UDP { get; } = new ReceiverType("UDP");

        public static bool operator ==(ReceiverType left, ReceiverType right) => left.Equals(right);
        public static bool operator !=(ReceiverType left, ReceiverType right) => !left.Equals(right);

        public static explicit operator string(ReceiverType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReceiverType other && Equals(other);
        public bool Equals(ReceiverType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
    /// </summary>
    [EnumType]
    public readonly struct RecurrenceFrequency : IEquatable<RecurrenceFrequency>
    {
        private readonly string _value;

        private RecurrenceFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecurrenceFrequency None { get; } = new RecurrenceFrequency("None");
        public static RecurrenceFrequency Second { get; } = new RecurrenceFrequency("Second");
        public static RecurrenceFrequency Minute { get; } = new RecurrenceFrequency("Minute");
        public static RecurrenceFrequency Hour { get; } = new RecurrenceFrequency("Hour");
        public static RecurrenceFrequency Day { get; } = new RecurrenceFrequency("Day");
        public static RecurrenceFrequency Week { get; } = new RecurrenceFrequency("Week");
        public static RecurrenceFrequency Month { get; } = new RecurrenceFrequency("Month");
        public static RecurrenceFrequency Year { get; } = new RecurrenceFrequency("Year");

        public static bool operator ==(RecurrenceFrequency left, RecurrenceFrequency right) => left.Equals(right);
        public static bool operator !=(RecurrenceFrequency left, RecurrenceFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurrenceFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurrenceFrequency other && Equals(other);
        public bool Equals(RecurrenceFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the scale direction. Whether the scaling action increases or decreases the number of instances.
    /// </summary>
    [EnumType]
    public readonly struct ScaleDirection : IEquatable<ScaleDirection>
    {
        private readonly string _value;

        private ScaleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleDirection None { get; } = new ScaleDirection("None");
        public static ScaleDirection Increase { get; } = new ScaleDirection("Increase");
        public static ScaleDirection Decrease { get; } = new ScaleDirection("Decrease");

        public static bool operator ==(ScaleDirection left, ScaleDirection right) => left.Equals(right);
        public static bool operator !=(ScaleDirection left, ScaleDirection right) => !left.Equals(right);

        public static explicit operator string(ScaleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleDirection other && Equals(other);
        public bool Equals(ScaleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
    /// </summary>
    [EnumType]
    public readonly struct ScaleRuleMetricDimensionOperationType : IEquatable<ScaleRuleMetricDimensionOperationType>
    {
        private readonly string _value;

        private ScaleRuleMetricDimensionOperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleRuleMetricDimensionOperationType EqualsValue { get; } = new ScaleRuleMetricDimensionOperationType("Equals");
        public static ScaleRuleMetricDimensionOperationType NotEquals { get; } = new ScaleRuleMetricDimensionOperationType("NotEquals");

        public static bool operator ==(ScaleRuleMetricDimensionOperationType left, ScaleRuleMetricDimensionOperationType right) => left.Equals(right);
        public static bool operator !=(ScaleRuleMetricDimensionOperationType left, ScaleRuleMetricDimensionOperationType right) => !left.Equals(right);

        public static explicit operator string(ScaleRuleMetricDimensionOperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleRuleMetricDimensionOperationType other && Equals(other);
        public bool Equals(ScaleRuleMetricDimensionOperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the type of action that should occur when the scale rule fires.
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType ChangeCount { get; } = new ScaleType("ChangeCount");
        public static ScaleType PercentChangeCount { get; } = new ScaleType("PercentChangeCount");
        public static ScaleType ExactCount { get; } = new ScaleType("ExactCount");
        public static ScaleType ServiceAllowedNextValue { get; } = new ScaleType("ServiceAllowedNextValue");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of scoped Azure monitor resource.
    /// </summary>
    [EnumType]
    public readonly struct ScopedResourceKind : IEquatable<ScopedResourceKind>
    {
        private readonly string _value;

        private ScopedResourceKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScopedResourceKind Resource { get; } = new ScopedResourceKind("Resource");
        public static ScopedResourceKind Metrics { get; } = new ScopedResourceKind("Metrics");

        public static bool operator ==(ScopedResourceKind left, ScopedResourceKind right) => left.Equals(right);
        public static bool operator !=(ScopedResourceKind left, ScopedResourceKind right) => !left.Equals(right);

        public static explicit operator string(ScopedResourceKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScopedResourceKind other && Equals(other);
        public bool Equals(ScopedResourceKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encoding of the stream being received.
    /// </summary>
    [EnumType]
    public readonly struct StreamEncodingType : IEquatable<StreamEncodingType>
    {
        private readonly string _value;

        private StreamEncodingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No encoding validation. Treats the file as a stream of raw bytes.
        /// </summary>
        public static StreamEncodingType Nop { get; } = new StreamEncodingType("nop");
        /// <summary>
        /// UTF-8 encoding.
        /// </summary>
        public static StreamEncodingType Utf_8 { get; } = new StreamEncodingType("utf-8");
        /// <summary>
        /// UTF-16 encoding with little-endian byte order.
        /// </summary>
        public static StreamEncodingType Utf_16le { get; } = new StreamEncodingType("utf-16le");
        /// <summary>
        /// UTF-16 encoding with little-endian byte order.
        /// </summary>
        public static StreamEncodingType Utf_16be { get; } = new StreamEncodingType("utf-16be");
        /// <summary>
        /// ASCII encoding.
        /// </summary>
        public static StreamEncodingType Ascii { get; } = new StreamEncodingType("ascii");
        /// <summary>
        /// The Big5 Chinese character encoding.
        /// </summary>
        public static StreamEncodingType Big5 { get; } = new StreamEncodingType("big5");

        public static bool operator ==(StreamEncodingType left, StreamEncodingType right) => left.Equals(right);
        public static bool operator !=(StreamEncodingType left, StreamEncodingType right) => !left.Equals(right);

        public static explicit operator string(StreamEncodingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StreamEncodingType other && Equals(other);
        public bool Equals(StreamEncodingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol to parse syslog messages. Default rfc3164
    /// </summary>
    [EnumType]
    public readonly struct SyslogProtocol : IEquatable<SyslogProtocol>
    {
        private readonly string _value;

        private SyslogProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// rfc3164 protocol.
        /// </summary>
        public static SyslogProtocol Rfc3164 { get; } = new SyslogProtocol("rfc3164");
        /// <summary>
        /// rfc5424 protocol.
        /// </summary>
        public static SyslogProtocol Rfc5424 { get; } = new SyslogProtocol("rfc5424");

        public static bool operator ==(SyslogProtocol left, SyslogProtocol right) => left.Equals(right);
        public static bool operator !=(SyslogProtocol left, SyslogProtocol right) => !left.Equals(right);

        public static explicit operator string(SyslogProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SyslogProtocol other && Equals(other);
        public bool Equals(SyslogProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Aggregation type. Relevant and required only for rules of the kind LogAlert.
    /// </summary>
    [EnumType]
    public readonly struct TimeAggregation : IEquatable<TimeAggregation>
    {
        private readonly string _value;

        private TimeAggregation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TimeAggregation Count { get; } = new TimeAggregation("Count");
        public static TimeAggregation Average { get; } = new TimeAggregation("Average");
        public static TimeAggregation Minimum { get; } = new TimeAggregation("Minimum");
        public static TimeAggregation Maximum { get; } = new TimeAggregation("Maximum");
        public static TimeAggregation Total { get; } = new TimeAggregation("Total");

        public static bool operator ==(TimeAggregation left, TimeAggregation right) => left.Equals(right);
        public static bool operator !=(TimeAggregation left, TimeAggregation right) => !left.Equals(right);

        public static explicit operator string(TimeAggregation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeAggregation other && Equals(other);
        public bool Equals(TimeAggregation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
    /// </summary>
    [EnumType]
    public readonly struct TimeAggregationType : IEquatable<TimeAggregationType>
    {
        private readonly string _value;

        private TimeAggregationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TimeAggregationType Average { get; } = new TimeAggregationType("Average");
        public static TimeAggregationType Minimum { get; } = new TimeAggregationType("Minimum");
        public static TimeAggregationType Maximum { get; } = new TimeAggregationType("Maximum");
        public static TimeAggregationType Total { get; } = new TimeAggregationType("Total");
        public static TimeAggregationType Count { get; } = new TimeAggregationType("Count");
        public static TimeAggregationType Last { get; } = new TimeAggregationType("Last");

        public static bool operator ==(TimeAggregationType left, TimeAggregationType right) => left.Equals(right);
        public static bool operator !=(TimeAggregationType left, TimeAggregationType right) => !left.Equals(right);

        public static explicit operator string(TimeAggregationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeAggregationType other && Equals(other);
        public bool Equals(TimeAggregationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
