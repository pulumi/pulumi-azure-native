// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.Network.V20200101
{
    /// <summary>
    /// Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct BackendEnabledState : IEquatable<BackendEnabledState>
    {
        private readonly string _value;

        private BackendEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendEnabledState Enabled { get; } = new BackendEnabledState("Enabled");
        public static BackendEnabledState Disabled { get; } = new BackendEnabledState("Disabled");

        public static bool operator ==(BackendEnabledState left, BackendEnabledState right) => left.Equals(right);
        public static bool operator !=(BackendEnabledState left, BackendEnabledState right) => !left.Equals(right);

        public static explicit operator string(BackendEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendEnabledState other && Equals(other);
        public bool Equals(BackendEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to use dynamic compression for cached content
    /// </summary>
    [EnumType]
    public readonly struct DynamicCompressionEnabled : IEquatable<DynamicCompressionEnabled>
    {
        private readonly string _value;

        private DynamicCompressionEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DynamicCompressionEnabled Enabled { get; } = new DynamicCompressionEnabled("Enabled");
        public static DynamicCompressionEnabled Disabled { get; } = new DynamicCompressionEnabled("Disabled");

        public static bool operator ==(DynamicCompressionEnabled left, DynamicCompressionEnabled right) => left.Equals(right);
        public static bool operator !=(DynamicCompressionEnabled left, DynamicCompressionEnabled right) => !left.Equals(right);

        public static explicit operator string(DynamicCompressionEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DynamicCompressionEnabled other && Equals(other);
        public bool Equals(DynamicCompressionEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
    /// </summary>
    [EnumType]
    public readonly struct EnforceCertificateNameCheckEnabledState : IEquatable<EnforceCertificateNameCheckEnabledState>
    {
        private readonly string _value;

        private EnforceCertificateNameCheckEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnforceCertificateNameCheckEnabledState Enabled { get; } = new EnforceCertificateNameCheckEnabledState("Enabled");
        public static EnforceCertificateNameCheckEnabledState Disabled { get; } = new EnforceCertificateNameCheckEnabledState("Disabled");

        public static bool operator ==(EnforceCertificateNameCheckEnabledState left, EnforceCertificateNameCheckEnabledState right) => left.Equals(right);
        public static bool operator !=(EnforceCertificateNameCheckEnabledState left, EnforceCertificateNameCheckEnabledState right) => !left.Equals(right);

        public static explicit operator string(EnforceCertificateNameCheckEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnforceCertificateNameCheckEnabledState other && Equals(other);
        public bool Equals(EnforceCertificateNameCheckEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorEnabledState : IEquatable<FrontDoorEnabledState>
    {
        private readonly string _value;

        private FrontDoorEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorEnabledState Enabled { get; } = new FrontDoorEnabledState("Enabled");
        public static FrontDoorEnabledState Disabled { get; } = new FrontDoorEnabledState("Disabled");

        public static bool operator ==(FrontDoorEnabledState left, FrontDoorEnabledState right) => left.Equals(right);
        public static bool operator !=(FrontDoorEnabledState left, FrontDoorEnabledState right) => !left.Equals(right);

        public static explicit operator string(FrontDoorEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorEnabledState other && Equals(other);
        public bool Equals(FrontDoorEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol this rule will use when forwarding traffic to backends.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorForwardingProtocol : IEquatable<FrontDoorForwardingProtocol>
    {
        private readonly string _value;

        private FrontDoorForwardingProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorForwardingProtocol HttpOnly { get; } = new FrontDoorForwardingProtocol("HttpOnly");
        public static FrontDoorForwardingProtocol HttpsOnly { get; } = new FrontDoorForwardingProtocol("HttpsOnly");
        public static FrontDoorForwardingProtocol MatchRequest { get; } = new FrontDoorForwardingProtocol("MatchRequest");

        public static bool operator ==(FrontDoorForwardingProtocol left, FrontDoorForwardingProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorForwardingProtocol left, FrontDoorForwardingProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorForwardingProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorForwardingProtocol other && Equals(other);
        public bool Equals(FrontDoorForwardingProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configures which HTTP method to use to probe the backends defined under backendPools.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorHealthProbeMethod : IEquatable<FrontDoorHealthProbeMethod>
    {
        private readonly string _value;

        private FrontDoorHealthProbeMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorHealthProbeMethod GET { get; } = new FrontDoorHealthProbeMethod("GET");
        public static FrontDoorHealthProbeMethod HEAD { get; } = new FrontDoorHealthProbeMethod("HEAD");

        public static bool operator ==(FrontDoorHealthProbeMethod left, FrontDoorHealthProbeMethod right) => left.Equals(right);
        public static bool operator !=(FrontDoorHealthProbeMethod left, FrontDoorHealthProbeMethod right) => !left.Equals(right);

        public static explicit operator string(FrontDoorHealthProbeMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorHealthProbeMethod other && Equals(other);
        public bool Equals(FrontDoorHealthProbeMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Accepted protocol schemes.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorProtocol : IEquatable<FrontDoorProtocol>
    {
        private readonly string _value;

        private FrontDoorProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorProtocol Http { get; } = new FrontDoorProtocol("Http");
        public static FrontDoorProtocol Https { get; } = new FrontDoorProtocol("Https");

        public static bool operator ==(FrontDoorProtocol left, FrontDoorProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorProtocol left, FrontDoorProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorProtocol other && Equals(other);
        public bool Equals(FrontDoorProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Treatment of URL query terms when forming the cache key.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorQuery : IEquatable<FrontDoorQuery>
    {
        private readonly string _value;

        private FrontDoorQuery(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorQuery StripNone { get; } = new FrontDoorQuery("StripNone");
        public static FrontDoorQuery StripAll { get; } = new FrontDoorQuery("StripAll");
        public static FrontDoorQuery StripOnly { get; } = new FrontDoorQuery("StripOnly");
        public static FrontDoorQuery StripAllExcept { get; } = new FrontDoorQuery("StripAllExcept");

        public static bool operator ==(FrontDoorQuery left, FrontDoorQuery right) => left.Equals(right);
        public static bool operator !=(FrontDoorQuery left, FrontDoorQuery right) => !left.Equals(right);

        public static explicit operator string(FrontDoorQuery value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorQuery other && Equals(other);
        public bool Equals(FrontDoorQuery other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol of the destination to where the traffic is redirected
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorRedirectProtocol : IEquatable<FrontDoorRedirectProtocol>
    {
        private readonly string _value;

        private FrontDoorRedirectProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorRedirectProtocol HttpOnly { get; } = new FrontDoorRedirectProtocol("HttpOnly");
        public static FrontDoorRedirectProtocol HttpsOnly { get; } = new FrontDoorRedirectProtocol("HttpsOnly");
        public static FrontDoorRedirectProtocol MatchRequest { get; } = new FrontDoorRedirectProtocol("MatchRequest");

        public static bool operator ==(FrontDoorRedirectProtocol left, FrontDoorRedirectProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorRedirectProtocol left, FrontDoorRedirectProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorRedirectProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorRedirectProtocol other && Equals(other);
        public bool Equals(FrontDoorRedirectProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The redirect type the rule will use when redirecting traffic.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorRedirectType : IEquatable<FrontDoorRedirectType>
    {
        private readonly string _value;

        private FrontDoorRedirectType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorRedirectType Moved { get; } = new FrontDoorRedirectType("Moved");
        public static FrontDoorRedirectType Found { get; } = new FrontDoorRedirectType("Found");
        public static FrontDoorRedirectType TemporaryRedirect { get; } = new FrontDoorRedirectType("TemporaryRedirect");
        public static FrontDoorRedirectType PermanentRedirect { get; } = new FrontDoorRedirectType("PermanentRedirect");

        public static bool operator ==(FrontDoorRedirectType left, FrontDoorRedirectType right) => left.Equals(right);
        public static bool operator !=(FrontDoorRedirectType left, FrontDoorRedirectType right) => !left.Equals(right);

        public static explicit operator string(FrontDoorRedirectType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorRedirectType other && Equals(other);
        public bool Equals(FrontDoorRedirectType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which type of manipulation to apply to the header.
    /// </summary>
    [EnumType]
    public readonly struct HeaderActionType : IEquatable<HeaderActionType>
    {
        private readonly string _value;

        private HeaderActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HeaderActionType Append { get; } = new HeaderActionType("Append");
        public static HeaderActionType Delete { get; } = new HeaderActionType("Delete");
        public static HeaderActionType Overwrite { get; } = new HeaderActionType("Overwrite");

        public static bool operator ==(HeaderActionType left, HeaderActionType right) => left.Equals(right);
        public static bool operator !=(HeaderActionType left, HeaderActionType right) => !left.Equals(right);

        public static explicit operator string(HeaderActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HeaderActionType other && Equals(other);
        public bool Equals(HeaderActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
    /// </summary>
    [EnumType]
    public readonly struct HealthProbeEnabled : IEquatable<HealthProbeEnabled>
    {
        private readonly string _value;

        private HealthProbeEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HealthProbeEnabled Enabled { get; } = new HealthProbeEnabled("Enabled");
        public static HealthProbeEnabled Disabled { get; } = new HealthProbeEnabled("Disabled");

        public static bool operator ==(HealthProbeEnabled left, HealthProbeEnabled right) => left.Equals(right);
        public static bool operator !=(HealthProbeEnabled left, HealthProbeEnabled right) => !left.Equals(right);

        public static explicit operator string(HealthProbeEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HealthProbeEnabled other && Equals(other);
        public bool Equals(HealthProbeEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
    /// </summary>
    [EnumType]
    public readonly struct MatchProcessingBehavior : IEquatable<MatchProcessingBehavior>
    {
        private readonly string _value;

        private MatchProcessingBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchProcessingBehavior Continue { get; } = new MatchProcessingBehavior("Continue");
        public static MatchProcessingBehavior Stop { get; } = new MatchProcessingBehavior("Stop");

        public static bool operator ==(MatchProcessingBehavior left, MatchProcessingBehavior right) => left.Equals(right);
        public static bool operator !=(MatchProcessingBehavior left, MatchProcessingBehavior right) => !left.Equals(right);

        public static explicit operator string(MatchProcessingBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchProcessingBehavior other && Equals(other);
        public bool Equals(MatchProcessingBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct RoutingRuleEnabledState : IEquatable<RoutingRuleEnabledState>
    {
        private readonly string _value;

        private RoutingRuleEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutingRuleEnabledState Enabled { get; } = new RoutingRuleEnabledState("Enabled");
        public static RoutingRuleEnabledState Disabled { get; } = new RoutingRuleEnabledState("Disabled");

        public static bool operator ==(RoutingRuleEnabledState left, RoutingRuleEnabledState right) => left.Equals(right);
        public static bool operator !=(RoutingRuleEnabledState left, RoutingRuleEnabledState right) => !left.Equals(right);

        public static explicit operator string(RoutingRuleEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutingRuleEnabledState other && Equals(other);
        public bool Equals(RoutingRuleEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Match Variable
    /// </summary>
    [EnumType]
    public readonly struct RulesEngineMatchVariable : IEquatable<RulesEngineMatchVariable>
    {
        private readonly string _value;

        private RulesEngineMatchVariable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RulesEngineMatchVariable IsMobile { get; } = new RulesEngineMatchVariable("IsMobile");
        public static RulesEngineMatchVariable RemoteAddr { get; } = new RulesEngineMatchVariable("RemoteAddr");
        public static RulesEngineMatchVariable RequestMethod { get; } = new RulesEngineMatchVariable("RequestMethod");
        public static RulesEngineMatchVariable QueryString { get; } = new RulesEngineMatchVariable("QueryString");
        public static RulesEngineMatchVariable PostArgs { get; } = new RulesEngineMatchVariable("PostArgs");
        public static RulesEngineMatchVariable RequestUri { get; } = new RulesEngineMatchVariable("RequestUri");
        public static RulesEngineMatchVariable RequestPath { get; } = new RulesEngineMatchVariable("RequestPath");
        public static RulesEngineMatchVariable RequestFilename { get; } = new RulesEngineMatchVariable("RequestFilename");
        public static RulesEngineMatchVariable RequestFilenameExtension { get; } = new RulesEngineMatchVariable("RequestFilenameExtension");
        public static RulesEngineMatchVariable RequestHeader { get; } = new RulesEngineMatchVariable("RequestHeader");
        public static RulesEngineMatchVariable RequestBody { get; } = new RulesEngineMatchVariable("RequestBody");
        public static RulesEngineMatchVariable RequestScheme { get; } = new RulesEngineMatchVariable("RequestScheme");

        public static bool operator ==(RulesEngineMatchVariable left, RulesEngineMatchVariable right) => left.Equals(right);
        public static bool operator !=(RulesEngineMatchVariable left, RulesEngineMatchVariable right) => !left.Equals(right);

        public static explicit operator string(RulesEngineMatchVariable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RulesEngineMatchVariable other && Equals(other);
        public bool Equals(RulesEngineMatchVariable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes operator to apply to the match condition.
    /// </summary>
    [EnumType]
    public readonly struct RulesEngineOperator : IEquatable<RulesEngineOperator>
    {
        private readonly string _value;

        private RulesEngineOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RulesEngineOperator Any { get; } = new RulesEngineOperator("Any");
        public static RulesEngineOperator IPMatch { get; } = new RulesEngineOperator("IPMatch");
        public static RulesEngineOperator GeoMatch { get; } = new RulesEngineOperator("GeoMatch");
        public static RulesEngineOperator Equal { get; } = new RulesEngineOperator("Equal");
        public static RulesEngineOperator Contains { get; } = new RulesEngineOperator("Contains");
        public static RulesEngineOperator LessThan { get; } = new RulesEngineOperator("LessThan");
        public static RulesEngineOperator GreaterThan { get; } = new RulesEngineOperator("GreaterThan");
        public static RulesEngineOperator LessThanOrEqual { get; } = new RulesEngineOperator("LessThanOrEqual");
        public static RulesEngineOperator GreaterThanOrEqual { get; } = new RulesEngineOperator("GreaterThanOrEqual");
        public static RulesEngineOperator BeginsWith { get; } = new RulesEngineOperator("BeginsWith");
        public static RulesEngineOperator EndsWith { get; } = new RulesEngineOperator("EndsWith");

        public static bool operator ==(RulesEngineOperator left, RulesEngineOperator right) => left.Equals(right);
        public static bool operator !=(RulesEngineOperator left, RulesEngineOperator right) => !left.Equals(right);

        public static explicit operator string(RulesEngineOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RulesEngineOperator other && Equals(other);
        public bool Equals(RulesEngineOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct SessionAffinityEnabledState : IEquatable<SessionAffinityEnabledState>
    {
        private readonly string _value;

        private SessionAffinityEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SessionAffinityEnabledState Enabled { get; } = new SessionAffinityEnabledState("Enabled");
        public static SessionAffinityEnabledState Disabled { get; } = new SessionAffinityEnabledState("Disabled");

        public static bool operator ==(SessionAffinityEnabledState left, SessionAffinityEnabledState right) => left.Equals(right);
        public static bool operator !=(SessionAffinityEnabledState left, SessionAffinityEnabledState right) => !left.Equals(right);

        public static explicit operator string(SessionAffinityEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionAffinityEnabledState other && Equals(other);
        public bool Equals(SessionAffinityEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes what transforms are applied before matching
    /// </summary>
    [EnumType]
    public readonly struct Transform : IEquatable<Transform>
    {
        private readonly string _value;

        private Transform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Transform Lowercase { get; } = new Transform("Lowercase");
        public static Transform Uppercase { get; } = new Transform("Uppercase");
        public static Transform Trim { get; } = new Transform("Trim");
        public static Transform UrlDecode { get; } = new Transform("UrlDecode");
        public static Transform UrlEncode { get; } = new Transform("UrlEncode");
        public static Transform RemoveNulls { get; } = new Transform("RemoveNulls");

        public static bool operator ==(Transform left, Transform right) => left.Equals(right);
        public static bool operator !=(Transform left, Transform right) => !left.Equals(right);

        public static explicit operator string(Transform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Transform other && Equals(other);
        public bool Equals(Transform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
