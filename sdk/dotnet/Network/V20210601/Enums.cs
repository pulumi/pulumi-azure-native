// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Network.V20210601
{
    /// <summary>
    /// Describes the override action to be applied when rule matches.
    /// </summary>
    [EnumType]
    public readonly struct ActionType : IEquatable<ActionType>
    {
        private readonly string _value;

        private ActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ActionType Allow { get; } = new ActionType("Allow");
        public static ActionType Block { get; } = new ActionType("Block");
        public static ActionType Log { get; } = new ActionType("Log");
        public static ActionType Redirect { get; } = new ActionType("Redirect");

        public static bool operator ==(ActionType left, ActionType right) => left.Equals(right);
        public static bool operator !=(ActionType left, ActionType right) => !left.Equals(right);

        public static explicit operator string(ActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ActionType other && Equals(other);
        public bool Equals(ActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct BackendEnabledState : IEquatable<BackendEnabledState>
    {
        private readonly string _value;

        private BackendEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendEnabledState Enabled { get; } = new BackendEnabledState("Enabled");
        public static BackendEnabledState Disabled { get; } = new BackendEnabledState("Disabled");

        public static bool operator ==(BackendEnabledState left, BackendEnabledState right) => left.Equals(right);
        public static bool operator !=(BackendEnabledState left, BackendEnabledState right) => !left.Equals(right);

        public static explicit operator string(BackendEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendEnabledState other && Equals(other);
        public bool Equals(BackendEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
    /// </summary>
    [EnumType]
    public readonly struct CustomRuleEnabledState : IEquatable<CustomRuleEnabledState>
    {
        private readonly string _value;

        private CustomRuleEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CustomRuleEnabledState Disabled { get; } = new CustomRuleEnabledState("Disabled");
        public static CustomRuleEnabledState Enabled { get; } = new CustomRuleEnabledState("Enabled");

        public static bool operator ==(CustomRuleEnabledState left, CustomRuleEnabledState right) => left.Equals(right);
        public static bool operator !=(CustomRuleEnabledState left, CustomRuleEnabledState right) => !left.Equals(right);

        public static explicit operator string(CustomRuleEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CustomRuleEnabledState other && Equals(other);
        public bool Equals(CustomRuleEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to use dynamic compression for cached content
    /// </summary>
    [EnumType]
    public readonly struct DynamicCompressionEnabled : IEquatable<DynamicCompressionEnabled>
    {
        private readonly string _value;

        private DynamicCompressionEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DynamicCompressionEnabled Enabled { get; } = new DynamicCompressionEnabled("Enabled");
        public static DynamicCompressionEnabled Disabled { get; } = new DynamicCompressionEnabled("Disabled");

        public static bool operator ==(DynamicCompressionEnabled left, DynamicCompressionEnabled right) => left.Equals(right);
        public static bool operator !=(DynamicCompressionEnabled left, DynamicCompressionEnabled right) => !left.Equals(right);

        public static explicit operator string(DynamicCompressionEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DynamicCompressionEnabled other && Equals(other);
        public bool Equals(DynamicCompressionEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
    /// </summary>
    [EnumType]
    public readonly struct EnforceCertificateNameCheckEnabledState : IEquatable<EnforceCertificateNameCheckEnabledState>
    {
        private readonly string _value;

        private EnforceCertificateNameCheckEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnforceCertificateNameCheckEnabledState Enabled { get; } = new EnforceCertificateNameCheckEnabledState("Enabled");
        public static EnforceCertificateNameCheckEnabledState Disabled { get; } = new EnforceCertificateNameCheckEnabledState("Disabled");

        public static bool operator ==(EnforceCertificateNameCheckEnabledState left, EnforceCertificateNameCheckEnabledState right) => left.Equals(right);
        public static bool operator !=(EnforceCertificateNameCheckEnabledState left, EnforceCertificateNameCheckEnabledState right) => !left.Equals(right);

        public static explicit operator string(EnforceCertificateNameCheckEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnforceCertificateNameCheckEnabledState other && Equals(other);
        public bool Equals(EnforceCertificateNameCheckEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorEnabledState : IEquatable<FrontDoorEnabledState>
    {
        private readonly string _value;

        private FrontDoorEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorEnabledState Enabled { get; } = new FrontDoorEnabledState("Enabled");
        public static FrontDoorEnabledState Disabled { get; } = new FrontDoorEnabledState("Disabled");

        public static bool operator ==(FrontDoorEnabledState left, FrontDoorEnabledState right) => left.Equals(right);
        public static bool operator !=(FrontDoorEnabledState left, FrontDoorEnabledState right) => !left.Equals(right);

        public static explicit operator string(FrontDoorEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorEnabledState other && Equals(other);
        public bool Equals(FrontDoorEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol this rule will use when forwarding traffic to backends.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorForwardingProtocol : IEquatable<FrontDoorForwardingProtocol>
    {
        private readonly string _value;

        private FrontDoorForwardingProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorForwardingProtocol HttpOnly { get; } = new FrontDoorForwardingProtocol("HttpOnly");
        public static FrontDoorForwardingProtocol HttpsOnly { get; } = new FrontDoorForwardingProtocol("HttpsOnly");
        public static FrontDoorForwardingProtocol MatchRequest { get; } = new FrontDoorForwardingProtocol("MatchRequest");

        public static bool operator ==(FrontDoorForwardingProtocol left, FrontDoorForwardingProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorForwardingProtocol left, FrontDoorForwardingProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorForwardingProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorForwardingProtocol other && Equals(other);
        public bool Equals(FrontDoorForwardingProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configures which HTTP method to use to probe the backends defined under backendPools.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorHealthProbeMethod : IEquatable<FrontDoorHealthProbeMethod>
    {
        private readonly string _value;

        private FrontDoorHealthProbeMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorHealthProbeMethod GET { get; } = new FrontDoorHealthProbeMethod("GET");
        public static FrontDoorHealthProbeMethod HEAD { get; } = new FrontDoorHealthProbeMethod("HEAD");

        public static bool operator ==(FrontDoorHealthProbeMethod left, FrontDoorHealthProbeMethod right) => left.Equals(right);
        public static bool operator !=(FrontDoorHealthProbeMethod left, FrontDoorHealthProbeMethod right) => !left.Equals(right);

        public static explicit operator string(FrontDoorHealthProbeMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorHealthProbeMethod other && Equals(other);
        public bool Equals(FrontDoorHealthProbeMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Request variable to compare with.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorMatchVariable : IEquatable<FrontDoorMatchVariable>
    {
        private readonly string _value;

        private FrontDoorMatchVariable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorMatchVariable RemoteAddr { get; } = new FrontDoorMatchVariable("RemoteAddr");
        public static FrontDoorMatchVariable RequestMethod { get; } = new FrontDoorMatchVariable("RequestMethod");
        public static FrontDoorMatchVariable QueryString { get; } = new FrontDoorMatchVariable("QueryString");
        public static FrontDoorMatchVariable PostArgs { get; } = new FrontDoorMatchVariable("PostArgs");
        public static FrontDoorMatchVariable RequestUri { get; } = new FrontDoorMatchVariable("RequestUri");
        public static FrontDoorMatchVariable RequestHeader { get; } = new FrontDoorMatchVariable("RequestHeader");
        public static FrontDoorMatchVariable RequestBody { get; } = new FrontDoorMatchVariable("RequestBody");
        public static FrontDoorMatchVariable Cookies { get; } = new FrontDoorMatchVariable("Cookies");
        public static FrontDoorMatchVariable SocketAddr { get; } = new FrontDoorMatchVariable("SocketAddr");

        public static bool operator ==(FrontDoorMatchVariable left, FrontDoorMatchVariable right) => left.Equals(right);
        public static bool operator !=(FrontDoorMatchVariable left, FrontDoorMatchVariable right) => !left.Equals(right);

        public static explicit operator string(FrontDoorMatchVariable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorMatchVariable other && Equals(other);
        public bool Equals(FrontDoorMatchVariable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Accepted protocol schemes.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorProtocol : IEquatable<FrontDoorProtocol>
    {
        private readonly string _value;

        private FrontDoorProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorProtocol Http { get; } = new FrontDoorProtocol("Http");
        public static FrontDoorProtocol Https { get; } = new FrontDoorProtocol("Https");

        public static bool operator ==(FrontDoorProtocol left, FrontDoorProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorProtocol left, FrontDoorProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorProtocol other && Equals(other);
        public bool Equals(FrontDoorProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Treatment of URL query terms when forming the cache key.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorQuery : IEquatable<FrontDoorQuery>
    {
        private readonly string _value;

        private FrontDoorQuery(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorQuery StripNone { get; } = new FrontDoorQuery("StripNone");
        public static FrontDoorQuery StripAll { get; } = new FrontDoorQuery("StripAll");
        public static FrontDoorQuery StripOnly { get; } = new FrontDoorQuery("StripOnly");
        public static FrontDoorQuery StripAllExcept { get; } = new FrontDoorQuery("StripAllExcept");

        public static bool operator ==(FrontDoorQuery left, FrontDoorQuery right) => left.Equals(right);
        public static bool operator !=(FrontDoorQuery left, FrontDoorQuery right) => !left.Equals(right);

        public static explicit operator string(FrontDoorQuery value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorQuery other && Equals(other);
        public bool Equals(FrontDoorQuery other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol of the destination to where the traffic is redirected
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorRedirectProtocol : IEquatable<FrontDoorRedirectProtocol>
    {
        private readonly string _value;

        private FrontDoorRedirectProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorRedirectProtocol HttpOnly { get; } = new FrontDoorRedirectProtocol("HttpOnly");
        public static FrontDoorRedirectProtocol HttpsOnly { get; } = new FrontDoorRedirectProtocol("HttpsOnly");
        public static FrontDoorRedirectProtocol MatchRequest { get; } = new FrontDoorRedirectProtocol("MatchRequest");

        public static bool operator ==(FrontDoorRedirectProtocol left, FrontDoorRedirectProtocol right) => left.Equals(right);
        public static bool operator !=(FrontDoorRedirectProtocol left, FrontDoorRedirectProtocol right) => !left.Equals(right);

        public static explicit operator string(FrontDoorRedirectProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorRedirectProtocol other && Equals(other);
        public bool Equals(FrontDoorRedirectProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The redirect type the rule will use when redirecting traffic.
    /// </summary>
    [EnumType]
    public readonly struct FrontDoorRedirectType : IEquatable<FrontDoorRedirectType>
    {
        private readonly string _value;

        private FrontDoorRedirectType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FrontDoorRedirectType Moved { get; } = new FrontDoorRedirectType("Moved");
        public static FrontDoorRedirectType Found { get; } = new FrontDoorRedirectType("Found");
        public static FrontDoorRedirectType TemporaryRedirect { get; } = new FrontDoorRedirectType("TemporaryRedirect");
        public static FrontDoorRedirectType PermanentRedirect { get; } = new FrontDoorRedirectType("PermanentRedirect");

        public static bool operator ==(FrontDoorRedirectType left, FrontDoorRedirectType right) => left.Equals(right);
        public static bool operator !=(FrontDoorRedirectType left, FrontDoorRedirectType right) => !left.Equals(right);

        public static explicit operator string(FrontDoorRedirectType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FrontDoorRedirectType other && Equals(other);
        public bool Equals(FrontDoorRedirectType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which type of manipulation to apply to the header.
    /// </summary>
    [EnumType]
    public readonly struct HeaderActionType : IEquatable<HeaderActionType>
    {
        private readonly string _value;

        private HeaderActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HeaderActionType Append { get; } = new HeaderActionType("Append");
        public static HeaderActionType Delete { get; } = new HeaderActionType("Delete");
        public static HeaderActionType Overwrite { get; } = new HeaderActionType("Overwrite");

        public static bool operator ==(HeaderActionType left, HeaderActionType right) => left.Equals(right);
        public static bool operator !=(HeaderActionType left, HeaderActionType right) => !left.Equals(right);

        public static explicit operator string(HeaderActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HeaderActionType other && Equals(other);
        public bool Equals(HeaderActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
    /// </summary>
    [EnumType]
    public readonly struct HealthProbeEnabled : IEquatable<HealthProbeEnabled>
    {
        private readonly string _value;

        private HealthProbeEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HealthProbeEnabled Enabled { get; } = new HealthProbeEnabled("Enabled");
        public static HealthProbeEnabled Disabled { get; } = new HealthProbeEnabled("Disabled");

        public static bool operator ==(HealthProbeEnabled left, HealthProbeEnabled right) => left.Equals(right);
        public static bool operator !=(HealthProbeEnabled left, HealthProbeEnabled right) => !left.Equals(right);

        public static explicit operator string(HealthProbeEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HealthProbeEnabled other && Equals(other);
        public bool Equals(HealthProbeEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
    /// </summary>
    [EnumType]
    public readonly struct ManagedRuleEnabledState : IEquatable<ManagedRuleEnabledState>
    {
        private readonly string _value;

        private ManagedRuleEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedRuleEnabledState Disabled { get; } = new ManagedRuleEnabledState("Disabled");
        public static ManagedRuleEnabledState Enabled { get; } = new ManagedRuleEnabledState("Enabled");

        public static bool operator ==(ManagedRuleEnabledState left, ManagedRuleEnabledState right) => left.Equals(right);
        public static bool operator !=(ManagedRuleEnabledState left, ManagedRuleEnabledState right) => !left.Equals(right);

        public static explicit operator string(ManagedRuleEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedRuleEnabledState other && Equals(other);
        public bool Equals(ManagedRuleEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The variable type to be excluded.
    /// </summary>
    [EnumType]
    public readonly struct ManagedRuleExclusionMatchVariable : IEquatable<ManagedRuleExclusionMatchVariable>
    {
        private readonly string _value;

        private ManagedRuleExclusionMatchVariable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedRuleExclusionMatchVariable RequestHeaderNames { get; } = new ManagedRuleExclusionMatchVariable("RequestHeaderNames");
        public static ManagedRuleExclusionMatchVariable RequestCookieNames { get; } = new ManagedRuleExclusionMatchVariable("RequestCookieNames");
        public static ManagedRuleExclusionMatchVariable QueryStringArgNames { get; } = new ManagedRuleExclusionMatchVariable("QueryStringArgNames");
        public static ManagedRuleExclusionMatchVariable RequestBodyPostArgNames { get; } = new ManagedRuleExclusionMatchVariable("RequestBodyPostArgNames");
        public static ManagedRuleExclusionMatchVariable RequestBodyJsonArgNames { get; } = new ManagedRuleExclusionMatchVariable("RequestBodyJsonArgNames");

        public static bool operator ==(ManagedRuleExclusionMatchVariable left, ManagedRuleExclusionMatchVariable right) => left.Equals(right);
        public static bool operator !=(ManagedRuleExclusionMatchVariable left, ManagedRuleExclusionMatchVariable right) => !left.Equals(right);

        public static explicit operator string(ManagedRuleExclusionMatchVariable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedRuleExclusionMatchVariable other && Equals(other);
        public bool Equals(ManagedRuleExclusionMatchVariable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
    /// </summary>
    [EnumType]
    public readonly struct ManagedRuleExclusionSelectorMatchOperator : IEquatable<ManagedRuleExclusionSelectorMatchOperator>
    {
        private readonly string _value;

        private ManagedRuleExclusionSelectorMatchOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedRuleExclusionSelectorMatchOperator EqualsValue { get; } = new ManagedRuleExclusionSelectorMatchOperator("Equals");
        public static ManagedRuleExclusionSelectorMatchOperator Contains { get; } = new ManagedRuleExclusionSelectorMatchOperator("Contains");
        public static ManagedRuleExclusionSelectorMatchOperator StartsWith { get; } = new ManagedRuleExclusionSelectorMatchOperator("StartsWith");
        public static ManagedRuleExclusionSelectorMatchOperator EndsWith { get; } = new ManagedRuleExclusionSelectorMatchOperator("EndsWith");
        public static ManagedRuleExclusionSelectorMatchOperator EqualsAny { get; } = new ManagedRuleExclusionSelectorMatchOperator("EqualsAny");

        public static bool operator ==(ManagedRuleExclusionSelectorMatchOperator left, ManagedRuleExclusionSelectorMatchOperator right) => left.Equals(right);
        public static bool operator !=(ManagedRuleExclusionSelectorMatchOperator left, ManagedRuleExclusionSelectorMatchOperator right) => !left.Equals(right);

        public static explicit operator string(ManagedRuleExclusionSelectorMatchOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedRuleExclusionSelectorMatchOperator other && Equals(other);
        public bool Equals(ManagedRuleExclusionSelectorMatchOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the action to take when a managed rule set score threshold is met.
    /// </summary>
    [EnumType]
    public readonly struct ManagedRuleSetActionType : IEquatable<ManagedRuleSetActionType>
    {
        private readonly string _value;

        private ManagedRuleSetActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedRuleSetActionType Block { get; } = new ManagedRuleSetActionType("Block");
        public static ManagedRuleSetActionType Log { get; } = new ManagedRuleSetActionType("Log");
        public static ManagedRuleSetActionType Redirect { get; } = new ManagedRuleSetActionType("Redirect");

        public static bool operator ==(ManagedRuleSetActionType left, ManagedRuleSetActionType right) => left.Equals(right);
        public static bool operator !=(ManagedRuleSetActionType left, ManagedRuleSetActionType right) => !left.Equals(right);

        public static explicit operator string(ManagedRuleSetActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedRuleSetActionType other && Equals(other);
        public bool Equals(ManagedRuleSetActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
    /// </summary>
    [EnumType]
    public readonly struct MatchProcessingBehavior : IEquatable<MatchProcessingBehavior>
    {
        private readonly string _value;

        private MatchProcessingBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchProcessingBehavior Continue { get; } = new MatchProcessingBehavior("Continue");
        public static MatchProcessingBehavior Stop { get; } = new MatchProcessingBehavior("Stop");

        public static bool operator ==(MatchProcessingBehavior left, MatchProcessingBehavior right) => left.Equals(right);
        public static bool operator !=(MatchProcessingBehavior left, MatchProcessingBehavior right) => !left.Equals(right);

        public static explicit operator string(MatchProcessingBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchProcessingBehavior other && Equals(other);
        public bool Equals(MatchProcessingBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Comparison type to use for matching with the variable value.
    /// </summary>
    [EnumType]
    public readonly struct Operator : IEquatable<Operator>
    {
        private readonly string _value;

        private Operator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Operator Any { get; } = new Operator("Any");
        public static Operator IPMatch { get; } = new Operator("IPMatch");
        public static Operator GeoMatch { get; } = new Operator("GeoMatch");
        public static Operator Equal { get; } = new Operator("Equal");
        public static Operator Contains { get; } = new Operator("Contains");
        public static Operator LessThan { get; } = new Operator("LessThan");
        public static Operator GreaterThan { get; } = new Operator("GreaterThan");
        public static Operator LessThanOrEqual { get; } = new Operator("LessThanOrEqual");
        public static Operator GreaterThanOrEqual { get; } = new Operator("GreaterThanOrEqual");
        public static Operator BeginsWith { get; } = new Operator("BeginsWith");
        public static Operator EndsWith { get; } = new Operator("EndsWith");
        public static Operator RegEx { get; } = new Operator("RegEx");

        public static bool operator ==(Operator left, Operator right) => left.Equals(right);
        public static bool operator !=(Operator left, Operator right) => !left.Equals(right);

        public static explicit operator string(Operator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Operator other && Equals(other);
        public bool Equals(Operator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
    /// </summary>
    [EnumType]
    public readonly struct PolicyEnabledState : IEquatable<PolicyEnabledState>
    {
        private readonly string _value;

        private PolicyEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PolicyEnabledState Disabled { get; } = new PolicyEnabledState("Disabled");
        public static PolicyEnabledState Enabled { get; } = new PolicyEnabledState("Enabled");

        public static bool operator ==(PolicyEnabledState left, PolicyEnabledState right) => left.Equals(right);
        public static bool operator !=(PolicyEnabledState left, PolicyEnabledState right) => !left.Equals(right);

        public static explicit operator string(PolicyEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyEnabledState other && Equals(other);
        public bool Equals(PolicyEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes if it is in detection mode or prevention mode at policy level.
    /// </summary>
    [EnumType]
    public readonly struct PolicyMode : IEquatable<PolicyMode>
    {
        private readonly string _value;

        private PolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PolicyMode Prevention { get; } = new PolicyMode("Prevention");
        public static PolicyMode Detection { get; } = new PolicyMode("Detection");

        public static bool operator ==(PolicyMode left, PolicyMode right) => left.Equals(right);
        public static bool operator !=(PolicyMode left, PolicyMode right) => !left.Equals(right);

        public static explicit operator string(PolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyMode other && Equals(other);
        public bool Equals(PolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes if policy managed rules will inspect the request body content.
    /// </summary>
    [EnumType]
    public readonly struct PolicyRequestBodyCheck : IEquatable<PolicyRequestBodyCheck>
    {
        private readonly string _value;

        private PolicyRequestBodyCheck(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PolicyRequestBodyCheck Disabled { get; } = new PolicyRequestBodyCheck("Disabled");
        public static PolicyRequestBodyCheck Enabled { get; } = new PolicyRequestBodyCheck("Enabled");

        public static bool operator ==(PolicyRequestBodyCheck left, PolicyRequestBodyCheck right) => left.Equals(right);
        public static bool operator !=(PolicyRequestBodyCheck left, PolicyRequestBodyCheck right) => !left.Equals(right);

        public static explicit operator string(PolicyRequestBodyCheck value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyRequestBodyCheck other && Equals(other);
        public bool Equals(PolicyRequestBodyCheck other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct RoutingRuleEnabledState : IEquatable<RoutingRuleEnabledState>
    {
        private readonly string _value;

        private RoutingRuleEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutingRuleEnabledState Enabled { get; } = new RoutingRuleEnabledState("Enabled");
        public static RoutingRuleEnabledState Disabled { get; } = new RoutingRuleEnabledState("Disabled");

        public static bool operator ==(RoutingRuleEnabledState left, RoutingRuleEnabledState right) => left.Equals(right);
        public static bool operator !=(RoutingRuleEnabledState left, RoutingRuleEnabledState right) => !left.Equals(right);

        public static explicit operator string(RoutingRuleEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutingRuleEnabledState other && Equals(other);
        public bool Equals(RoutingRuleEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes type of rule.
    /// </summary>
    [EnumType]
    public readonly struct RuleType : IEquatable<RuleType>
    {
        private readonly string _value;

        private RuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleType MatchRule { get; } = new RuleType("MatchRule");
        public static RuleType RateLimitRule { get; } = new RuleType("RateLimitRule");

        public static bool operator ==(RuleType left, RuleType right) => left.Equals(right);
        public static bool operator !=(RuleType left, RuleType right) => !left.Equals(right);

        public static explicit operator string(RuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleType other && Equals(other);
        public bool Equals(RuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Match Variable
    /// </summary>
    [EnumType]
    public readonly struct RulesEngineMatchVariable : IEquatable<RulesEngineMatchVariable>
    {
        private readonly string _value;

        private RulesEngineMatchVariable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RulesEngineMatchVariable IsMobile { get; } = new RulesEngineMatchVariable("IsMobile");
        public static RulesEngineMatchVariable RemoteAddr { get; } = new RulesEngineMatchVariable("RemoteAddr");
        public static RulesEngineMatchVariable RequestMethod { get; } = new RulesEngineMatchVariable("RequestMethod");
        public static RulesEngineMatchVariable QueryString { get; } = new RulesEngineMatchVariable("QueryString");
        public static RulesEngineMatchVariable PostArgs { get; } = new RulesEngineMatchVariable("PostArgs");
        public static RulesEngineMatchVariable RequestUri { get; } = new RulesEngineMatchVariable("RequestUri");
        public static RulesEngineMatchVariable RequestPath { get; } = new RulesEngineMatchVariable("RequestPath");
        public static RulesEngineMatchVariable RequestFilename { get; } = new RulesEngineMatchVariable("RequestFilename");
        public static RulesEngineMatchVariable RequestFilenameExtension { get; } = new RulesEngineMatchVariable("RequestFilenameExtension");
        public static RulesEngineMatchVariable RequestHeader { get; } = new RulesEngineMatchVariable("RequestHeader");
        public static RulesEngineMatchVariable RequestBody { get; } = new RulesEngineMatchVariable("RequestBody");
        public static RulesEngineMatchVariable RequestScheme { get; } = new RulesEngineMatchVariable("RequestScheme");

        public static bool operator ==(RulesEngineMatchVariable left, RulesEngineMatchVariable right) => left.Equals(right);
        public static bool operator !=(RulesEngineMatchVariable left, RulesEngineMatchVariable right) => !left.Equals(right);

        public static explicit operator string(RulesEngineMatchVariable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RulesEngineMatchVariable other && Equals(other);
        public bool Equals(RulesEngineMatchVariable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes operator to apply to the match condition.
    /// </summary>
    [EnumType]
    public readonly struct RulesEngineOperator : IEquatable<RulesEngineOperator>
    {
        private readonly string _value;

        private RulesEngineOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RulesEngineOperator Any { get; } = new RulesEngineOperator("Any");
        public static RulesEngineOperator IPMatch { get; } = new RulesEngineOperator("IPMatch");
        public static RulesEngineOperator GeoMatch { get; } = new RulesEngineOperator("GeoMatch");
        public static RulesEngineOperator Equal { get; } = new RulesEngineOperator("Equal");
        public static RulesEngineOperator Contains { get; } = new RulesEngineOperator("Contains");
        public static RulesEngineOperator LessThan { get; } = new RulesEngineOperator("LessThan");
        public static RulesEngineOperator GreaterThan { get; } = new RulesEngineOperator("GreaterThan");
        public static RulesEngineOperator LessThanOrEqual { get; } = new RulesEngineOperator("LessThanOrEqual");
        public static RulesEngineOperator GreaterThanOrEqual { get; } = new RulesEngineOperator("GreaterThanOrEqual");
        public static RulesEngineOperator BeginsWith { get; } = new RulesEngineOperator("BeginsWith");
        public static RulesEngineOperator EndsWith { get; } = new RulesEngineOperator("EndsWith");

        public static bool operator ==(RulesEngineOperator left, RulesEngineOperator right) => left.Equals(right);
        public static bool operator !=(RulesEngineOperator left, RulesEngineOperator right) => !left.Equals(right);

        public static explicit operator string(RulesEngineOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RulesEngineOperator other && Equals(other);
        public bool Equals(RulesEngineOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
    /// </summary>
    [EnumType]
    public readonly struct SessionAffinityEnabledState : IEquatable<SessionAffinityEnabledState>
    {
        private readonly string _value;

        private SessionAffinityEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SessionAffinityEnabledState Enabled { get; } = new SessionAffinityEnabledState("Enabled");
        public static SessionAffinityEnabledState Disabled { get; } = new SessionAffinityEnabledState("Disabled");

        public static bool operator ==(SessionAffinityEnabledState left, SessionAffinityEnabledState right) => left.Equals(right);
        public static bool operator !=(SessionAffinityEnabledState left, SessionAffinityEnabledState right) => !left.Equals(right);

        public static explicit operator string(SessionAffinityEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionAffinityEnabledState other && Equals(other);
        public bool Equals(SessionAffinityEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the pricing tier.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuName Classic_AzureFrontDoor { get; } = new SkuName("Classic_AzureFrontDoor");
        public static SkuName Standard_AzureFrontDoor { get; } = new SkuName("Standard_AzureFrontDoor");
        public static SkuName Premium_AzureFrontDoor { get; } = new SkuName("Premium_AzureFrontDoor");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes what transforms are applied before matching
    /// </summary>
    [EnumType]
    public readonly struct Transform : IEquatable<Transform>
    {
        private readonly string _value;

        private Transform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Transform Lowercase { get; } = new Transform("Lowercase");
        public static Transform Uppercase { get; } = new Transform("Uppercase");
        public static Transform Trim { get; } = new Transform("Trim");
        public static Transform UrlDecode { get; } = new Transform("UrlDecode");
        public static Transform UrlEncode { get; } = new Transform("UrlEncode");
        public static Transform RemoveNulls { get; } = new Transform("RemoveNulls");

        public static bool operator ==(Transform left, Transform right) => left.Equals(right);
        public static bool operator !=(Transform left, Transform right) => !left.Equals(right);

        public static explicit operator string(Transform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Transform other && Equals(other);
        public bool Equals(Transform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes what transforms applied before matching.
    /// </summary>
    [EnumType]
    public readonly struct TransformType : IEquatable<TransformType>
    {
        private readonly string _value;

        private TransformType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TransformType Lowercase { get; } = new TransformType("Lowercase");
        public static TransformType Uppercase { get; } = new TransformType("Uppercase");
        public static TransformType Trim { get; } = new TransformType("Trim");
        public static TransformType UrlDecode { get; } = new TransformType("UrlDecode");
        public static TransformType UrlEncode { get; } = new TransformType("UrlEncode");
        public static TransformType RemoveNulls { get; } = new TransformType("RemoveNulls");

        public static bool operator ==(TransformType left, TransformType right) => left.Equals(right);
        public static bool operator !=(TransformType left, TransformType right) => !left.Equals(right);

        public static explicit operator string(TransformType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransformType other && Equals(other);
        public bool Equals(TransformType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
