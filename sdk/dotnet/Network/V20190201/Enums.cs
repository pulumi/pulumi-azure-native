// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Network.V20190201
{
    /// <summary>
    /// The access type of the rule.
    /// </summary>
    [EnumType]
    public readonly struct Access : IEquatable<Access>
    {
        private readonly string _value;

        private Access(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Access Allow { get; } = new Access("Allow");
        public static Access Deny { get; } = new Access("Deny");

        public static bool operator ==(Access left, Access right) => left.Equals(right);
        public static bool operator !=(Access left, Access right) => !left.Equals(right);

        public static explicit operator string(Access value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Access other && Equals(other);
        public bool Equals(Access other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
    /// </summary>
    [EnumType]
    public readonly struct DdosSettingsProtectionCoverage : IEquatable<DdosSettingsProtectionCoverage>
    {
        private readonly string _value;

        private DdosSettingsProtectionCoverage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DdosSettingsProtectionCoverage Basic { get; } = new DdosSettingsProtectionCoverage("Basic");
        public static DdosSettingsProtectionCoverage Standard { get; } = new DdosSettingsProtectionCoverage("Standard");

        public static bool operator ==(DdosSettingsProtectionCoverage left, DdosSettingsProtectionCoverage right) => left.Equals(right);
        public static bool operator !=(DdosSettingsProtectionCoverage left, DdosSettingsProtectionCoverage right) => !left.Equals(right);

        public static explicit operator string(DdosSettingsProtectionCoverage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DdosSettingsProtectionCoverage other && Equals(other);
        public bool Equals(DdosSettingsProtectionCoverage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// AdvertisedPublicPrefixState of the Peering resource. Possible values are 'NotConfigured', 'Configuring', 'Configured', and 'ValidationNeeded'.
    /// </summary>
    [EnumType]
    public readonly struct ExpressRouteCircuitPeeringAdvertisedPublicPrefixState : IEquatable<ExpressRouteCircuitPeeringAdvertisedPublicPrefixState>
    {
        private readonly string _value;

        private ExpressRouteCircuitPeeringAdvertisedPublicPrefixState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpressRouteCircuitPeeringAdvertisedPublicPrefixState NotConfigured { get; } = new ExpressRouteCircuitPeeringAdvertisedPublicPrefixState("NotConfigured");
        public static ExpressRouteCircuitPeeringAdvertisedPublicPrefixState Configuring { get; } = new ExpressRouteCircuitPeeringAdvertisedPublicPrefixState("Configuring");
        public static ExpressRouteCircuitPeeringAdvertisedPublicPrefixState Configured { get; } = new ExpressRouteCircuitPeeringAdvertisedPublicPrefixState("Configured");
        public static ExpressRouteCircuitPeeringAdvertisedPublicPrefixState ValidationNeeded { get; } = new ExpressRouteCircuitPeeringAdvertisedPublicPrefixState("ValidationNeeded");

        public static bool operator ==(ExpressRouteCircuitPeeringAdvertisedPublicPrefixState left, ExpressRouteCircuitPeeringAdvertisedPublicPrefixState right) => left.Equals(right);
        public static bool operator !=(ExpressRouteCircuitPeeringAdvertisedPublicPrefixState left, ExpressRouteCircuitPeeringAdvertisedPublicPrefixState right) => !left.Equals(right);

        public static explicit operator string(ExpressRouteCircuitPeeringAdvertisedPublicPrefixState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpressRouteCircuitPeeringAdvertisedPublicPrefixState other && Equals(other);
        public bool Equals(ExpressRouteCircuitPeeringAdvertisedPublicPrefixState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of peering. Possible values are: 'Disabled' and 'Enabled'
    /// </summary>
    [EnumType]
    public readonly struct ExpressRouteCircuitPeeringState : IEquatable<ExpressRouteCircuitPeeringState>
    {
        private readonly string _value;

        private ExpressRouteCircuitPeeringState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpressRouteCircuitPeeringState Disabled { get; } = new ExpressRouteCircuitPeeringState("Disabled");
        public static ExpressRouteCircuitPeeringState Enabled { get; } = new ExpressRouteCircuitPeeringState("Enabled");

        public static bool operator ==(ExpressRouteCircuitPeeringState left, ExpressRouteCircuitPeeringState right) => left.Equals(right);
        public static bool operator !=(ExpressRouteCircuitPeeringState left, ExpressRouteCircuitPeeringState right) => !left.Equals(right);

        public static explicit operator string(ExpressRouteCircuitPeeringState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpressRouteCircuitPeeringState other && Equals(other);
        public bool Equals(ExpressRouteCircuitPeeringState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The peering state.
    /// </summary>
    [EnumType]
    public readonly struct ExpressRoutePeeringState : IEquatable<ExpressRoutePeeringState>
    {
        private readonly string _value;

        private ExpressRoutePeeringState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpressRoutePeeringState Disabled { get; } = new ExpressRoutePeeringState("Disabled");
        public static ExpressRoutePeeringState Enabled { get; } = new ExpressRoutePeeringState("Enabled");

        public static bool operator ==(ExpressRoutePeeringState left, ExpressRoutePeeringState right) => left.Equals(right);
        public static bool operator !=(ExpressRoutePeeringState left, ExpressRoutePeeringState right) => !left.Equals(right);

        public static explicit operator string(ExpressRoutePeeringState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpressRoutePeeringState other && Equals(other);
        public bool Equals(ExpressRoutePeeringState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The peering type.
    /// </summary>
    [EnumType]
    public readonly struct ExpressRoutePeeringType : IEquatable<ExpressRoutePeeringType>
    {
        private readonly string _value;

        private ExpressRoutePeeringType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpressRoutePeeringType AzurePublicPeering { get; } = new ExpressRoutePeeringType("AzurePublicPeering");
        public static ExpressRoutePeeringType AzurePrivatePeering { get; } = new ExpressRoutePeeringType("AzurePrivatePeering");
        public static ExpressRoutePeeringType MicrosoftPeering { get; } = new ExpressRoutePeeringType("MicrosoftPeering");

        public static bool operator ==(ExpressRoutePeeringType left, ExpressRoutePeeringType right) => left.Equals(right);
        public static bool operator !=(ExpressRoutePeeringType left, ExpressRoutePeeringType right) => !left.Equals(right);

        public static explicit operator string(ExpressRoutePeeringType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpressRoutePeeringType other && Equals(other);
        public bool Equals(ExpressRoutePeeringType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Private IP allocation method.
    /// </summary>
    [EnumType]
    public readonly struct IPAllocationMethod : IEquatable<IPAllocationMethod>
    {
        private readonly string _value;

        private IPAllocationMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPAllocationMethod Static { get; } = new IPAllocationMethod("Static");
        public static IPAllocationMethod Dynamic { get; } = new IPAllocationMethod("Dynamic");

        public static bool operator ==(IPAllocationMethod left, IPAllocationMethod right) => left.Equals(right);
        public static bool operator !=(IPAllocationMethod left, IPAllocationMethod right) => !left.Equals(right);

        public static explicit operator string(IPAllocationMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAllocationMethod other && Equals(other);
        public bool Equals(IPAllocationMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The public IP address version.
    /// </summary>
    [EnumType]
    public readonly struct IPVersion : IEquatable<IPVersion>
    {
        private readonly string _value;

        private IPVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPVersion IPv4 { get; } = new IPVersion("IPv4");
        public static IPVersion IPv6 { get; } = new IPVersion("IPv6");

        public static bool operator ==(IPVersion left, IPVersion right) => left.Equals(right);
        public static bool operator !=(IPVersion left, IPVersion right) => !left.Equals(right);

        public static explicit operator string(IPVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPVersion other && Equals(other);
        public bool Equals(IPVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of a public IP address SKU.
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAddressSkuName : IEquatable<PublicIPAddressSkuName>
    {
        private readonly string _value;

        private PublicIPAddressSkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicIPAddressSkuName Basic { get; } = new PublicIPAddressSkuName("Basic");
        public static PublicIPAddressSkuName Standard { get; } = new PublicIPAddressSkuName("Standard");

        public static bool operator ==(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => left.Equals(right);
        public static bool operator !=(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => !left.Equals(right);

        public static explicit operator string(PublicIPAddressSkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAddressSkuName other && Equals(other);
        public bool Equals(PublicIPAddressSkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The rule type of the rule. Valid value is: 'Community'
    /// </summary>
    [EnumType]
    public readonly struct RouteFilterRuleType : IEquatable<RouteFilterRuleType>
    {
        private readonly string _value;

        private RouteFilterRuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteFilterRuleType Community { get; } = new RouteFilterRuleType("Community");

        public static bool operator ==(RouteFilterRuleType left, RouteFilterRuleType right) => left.Equals(right);
        public static bool operator !=(RouteFilterRuleType left, RouteFilterRuleType right) => !left.Equals(right);

        public static explicit operator string(RouteFilterRuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteFilterRuleType other && Equals(other);
        public bool Equals(RouteFilterRuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Azure hop the packet should be sent to.
    /// </summary>
    [EnumType]
    public readonly struct RouteNextHopType : IEquatable<RouteNextHopType>
    {
        private readonly string _value;

        private RouteNextHopType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteNextHopType VirtualNetworkGateway { get; } = new RouteNextHopType("VirtualNetworkGateway");
        public static RouteNextHopType VnetLocal { get; } = new RouteNextHopType("VnetLocal");
        public static RouteNextHopType Internet { get; } = new RouteNextHopType("Internet");
        public static RouteNextHopType VirtualAppliance { get; } = new RouteNextHopType("VirtualAppliance");
        public static RouteNextHopType None { get; } = new RouteNextHopType("None");

        public static bool operator ==(RouteNextHopType left, RouteNextHopType right) => left.Equals(right);
        public static bool operator !=(RouteNextHopType left, RouteNextHopType right) => !left.Equals(right);

        public static explicit operator string(RouteNextHopType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteNextHopType other && Equals(other);
        public bool Equals(RouteNextHopType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network traffic is allowed or denied.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleAccess : IEquatable<SecurityRuleAccess>
    {
        private readonly string _value;

        private SecurityRuleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityRuleAccess Allow { get; } = new SecurityRuleAccess("Allow");
        public static SecurityRuleAccess Deny { get; } = new SecurityRuleAccess("Deny");

        public static bool operator ==(SecurityRuleAccess left, SecurityRuleAccess right) => left.Equals(right);
        public static bool operator !=(SecurityRuleAccess left, SecurityRuleAccess right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleAccess other && Equals(other);
        public bool Equals(SecurityRuleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleDirection : IEquatable<SecurityRuleDirection>
    {
        private readonly string _value;

        private SecurityRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityRuleDirection Inbound { get; } = new SecurityRuleDirection("Inbound");
        public static SecurityRuleDirection Outbound { get; } = new SecurityRuleDirection("Outbound");

        public static bool operator ==(SecurityRuleDirection left, SecurityRuleDirection right) => left.Equals(right);
        public static bool operator !=(SecurityRuleDirection left, SecurityRuleDirection right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleDirection other && Equals(other);
        public bool Equals(SecurityRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network protocol this rule applies to. Possible values are 'Tcp', 'Udp', 'Icmp', 'Esp', and '*'.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleProtocol : IEquatable<SecurityRuleProtocol>
    {
        private readonly string _value;

        private SecurityRuleProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityRuleProtocol Tcp { get; } = new SecurityRuleProtocol("Tcp");
        public static SecurityRuleProtocol Udp { get; } = new SecurityRuleProtocol("Udp");
        public static SecurityRuleProtocol Icmp { get; } = new SecurityRuleProtocol("Icmp");
        public static SecurityRuleProtocol Esp { get; } = new SecurityRuleProtocol("Esp");
        public static SecurityRuleProtocol Asterisk { get; } = new SecurityRuleProtocol("*");

        public static bool operator ==(SecurityRuleProtocol left, SecurityRuleProtocol right) => left.Equals(right);
        public static bool operator !=(SecurityRuleProtocol left, SecurityRuleProtocol right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleProtocol other && Equals(other);
        public bool Equals(SecurityRuleProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The reference to the transport protocol used by the load balancing rule.
    /// </summary>
    [EnumType]
    public readonly struct TransportProtocol : IEquatable<TransportProtocol>
    {
        private readonly string _value;

        private TransportProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TransportProtocol Udp { get; } = new TransportProtocol("Udp");
        public static TransportProtocol Tcp { get; } = new TransportProtocol("Tcp");
        public static TransportProtocol All { get; } = new TransportProtocol("All");

        public static bool operator ==(TransportProtocol left, TransportProtocol right) => left.Equals(right);
        public static bool operator !=(TransportProtocol left, TransportProtocol right) => !left.Equals(right);

        public static explicit operator string(TransportProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransportProtocol other && Equals(other);
        public bool Equals(TransportProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
