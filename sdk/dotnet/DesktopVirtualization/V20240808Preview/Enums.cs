// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.DesktopVirtualization.V20240808Preview
{
    /// <summary>
    /// Resource Type of ApplicationGroup.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationGroupType : IEquatable<ApplicationGroupType>
    {
        private readonly string _value;

        private ApplicationGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Application group is Remote and can launch individual applications without a Desktop.
        /// </summary>
        public static ApplicationGroupType RemoteApp { get; } = new ApplicationGroupType("RemoteApp");
        /// <summary>
        /// Application Group delivers a full expected Desktop experience
        /// </summary>
        public static ApplicationGroupType Desktop { get; } = new ApplicationGroupType("Desktop");

        public static bool operator ==(ApplicationGroupType left, ApplicationGroupType right) => left.Equals(right);
        public static bool operator !=(ApplicationGroupType left, ApplicationGroupType right) => !left.Equals(right);

        public static explicit operator string(ApplicationGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationGroupType other && Equals(other);
        public bool Equals(ApplicationGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
    /// </summary>
    [EnumType]
    public readonly struct CommandLineSetting : IEquatable<CommandLineSetting>
    {
        private readonly string _value;

        private CommandLineSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cannot be launched with command line arguments.
        /// </summary>
        public static CommandLineSetting DoNotAllow { get; } = new CommandLineSetting("DoNotAllow");
        /// <summary>
        /// Can optionally be launched with command line arguments.
        /// </summary>
        public static CommandLineSetting Allow { get; } = new CommandLineSetting("Allow");
        /// <summary>
        /// Required to be launched with command line arguments.
        /// </summary>
        public static CommandLineSetting Require { get; } = new CommandLineSetting("Require");

        public static bool operator ==(CommandLineSetting left, CommandLineSetting right) => left.Equals(right);
        public static bool operator !=(CommandLineSetting left, CommandLineSetting right) => !left.Equals(right);

        public static explicit operator string(CommandLineSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CommandLineSetting other && Equals(other);
        public bool Equals(CommandLineSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Day of the week. Modeled as string
    /// </summary>
    [EnumType]
    public readonly struct DayOfWeek : IEquatable<DayOfWeek>
    {
        private readonly string _value;

        private DayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DayOfWeek Monday { get; } = new DayOfWeek("Monday");
        public static DayOfWeek Tuesday { get; } = new DayOfWeek("Tuesday");
        public static DayOfWeek Wednesday { get; } = new DayOfWeek("Wednesday");
        public static DayOfWeek Thursday { get; } = new DayOfWeek("Thursday");
        public static DayOfWeek Friday { get; } = new DayOfWeek("Friday");
        public static DayOfWeek Saturday { get; } = new DayOfWeek("Saturday");
        public static DayOfWeek Sunday { get; } = new DayOfWeek("Sunday");

        public static bool operator ==(DayOfWeek left, DayOfWeek right) => left.Equals(right);
        public static bool operator !=(DayOfWeek left, DayOfWeek right) => !left.Equals(right);

        public static explicit operator string(DayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DayOfWeek other && Equals(other);
        public bool Equals(DayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct DirectUDP : IEquatable<DirectUDP>
    {
        private readonly string _value;

        private DirectUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AVD-wide settings are used to determine connection availability
        /// </summary>
        public static DirectUDP Default { get; } = new DirectUDP("Default");
        /// <summary>
        /// UDP will attempt this connection type when making connections.
        /// </summary>
        public static DirectUDP Enabled { get; } = new DirectUDP("Enabled");
        /// <summary>
        /// UDP will not attempt this connection type when making connections
        /// </summary>
        public static DirectUDP Disabled { get; } = new DirectUDP("Disabled");

        public static bool operator ==(DirectUDP left, DirectUDP right) => left.Equals(right);
        public static bool operator !=(DirectUDP left, DirectUDP right) => !left.Equals(right);

        public static explicit operator string(DirectUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DirectUDP other && Equals(other);
        public bool Equals(DirectUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Parameter indicating how the health check should behave if this package fails staging
    /// </summary>
    [EnumType]
    public readonly struct FailHealthCheckOnStagingFailure : IEquatable<FailHealthCheckOnStagingFailure>
    {
        private readonly string _value;

        private FailHealthCheckOnStagingFailure(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Health Check will report unhealthy
        /// </summary>
        public static FailHealthCheckOnStagingFailure Unhealthy { get; } = new FailHealthCheckOnStagingFailure("Unhealthy");
        /// <summary>
        /// Health Check will report NeedsAssistance
        /// </summary>
        public static FailHealthCheckOnStagingFailure NeedsAssistance { get; } = new FailHealthCheckOnStagingFailure("NeedsAssistance");
        /// <summary>
        /// Health Check will not report failure
        /// </summary>
        public static FailHealthCheckOnStagingFailure DoNotFail { get; } = new FailHealthCheckOnStagingFailure("DoNotFail");

        public static bool operator ==(FailHealthCheckOnStagingFailure left, FailHealthCheckOnStagingFailure right) => left.Equals(right);
        public static bool operator !=(FailHealthCheckOnStagingFailure left, FailHealthCheckOnStagingFailure right) => !left.Equals(right);

        public static explicit operator string(FailHealthCheckOnStagingFailure value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FailHealthCheckOnStagingFailure other && Equals(other);
        public bool Equals(FailHealthCheckOnStagingFailure other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct HostPoolType : IEquatable<HostPoolType>
    {
        private readonly string _value;

        private HostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
        /// </summary>
        public static HostPoolType Personal { get; } = new HostPoolType("Personal");
        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static HostPoolType Pooled { get; } = new HostPoolType("Pooled");
        /// <summary>
        /// Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct.
        /// </summary>
        public static HostPoolType BYODesktop { get; } = new HostPoolType("BYODesktop");

        public static bool operator ==(HostPoolType left, HostPoolType right) => left.Equals(right);
        public static bool operator !=(HostPoolType left, HostPoolType right) => !left.Equals(right);

        public static explicit operator string(HostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostPoolType other && Equals(other);
        public bool Equals(HostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct HostpoolPublicNetworkAccess : IEquatable<HostpoolPublicNetworkAccess>
    {
        private readonly string _value;

        private HostpoolPublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Allows this resource to be accessed from the public network
        /// </summary>
        public static HostpoolPublicNetworkAccess Enabled { get; } = new HostpoolPublicNetworkAccess("Enabled");
        /// <summary>
        /// Prevents this resource from being accessed from the public network
        /// </summary>
        public static HostpoolPublicNetworkAccess Disabled { get; } = new HostpoolPublicNetworkAccess("Disabled");
        /// <summary>
        /// Allows SessionHosts to be accessed from the public network
        /// </summary>
        public static HostpoolPublicNetworkAccess EnabledForSessionHostsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForSessionHostsOnly");
        /// <summary>
        /// Allows Clients to be accessed from the public network
        /// </summary>
        public static HostpoolPublicNetworkAccess EnabledForClientsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForClientsOnly");

        public static bool operator ==(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(HostpoolPublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostpoolPublicNetworkAccess other && Equals(other);
        public bool Equals(HostpoolPublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the load balancer.
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Uses BreadthFirst algorithm for load balancing.
        /// </summary>
        public static LoadBalancerType BreadthFirst { get; } = new LoadBalancerType("BreadthFirst");
        /// <summary>
        /// Uses DepthFirst algorithm for load balancing.
        /// </summary>
        public static LoadBalancerType DepthFirst { get; } = new LoadBalancerType("DepthFirst");
        /// <summary>
        /// Maintains persistent connections.
        /// </summary>
        public static LoadBalancerType Persistent { get; } = new LoadBalancerType("Persistent");
        /// <summary>
        /// Maintains multiple persistents connections.
        /// </summary>
        public static LoadBalancerType MultiplePersistent { get; } = new LoadBalancerType("MultiplePersistent");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct ManagedPrivateUDP : IEquatable<ManagedPrivateUDP>
    {
        private readonly string _value;

        private ManagedPrivateUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AVD-wide settings are used to determine connection availability
        /// </summary>
        public static ManagedPrivateUDP Default { get; } = new ManagedPrivateUDP("Default");
        /// <summary>
        /// UDP will attempt this connection type when making connections.
        /// </summary>
        public static ManagedPrivateUDP Enabled { get; } = new ManagedPrivateUDP("Enabled");
        /// <summary>
        /// UDP will not attempt this connection type when making connections
        /// </summary>
        public static ManagedPrivateUDP Disabled { get; } = new ManagedPrivateUDP("Disabled");

        public static bool operator ==(ManagedPrivateUDP left, ManagedPrivateUDP right) => left.Equals(right);
        public static bool operator !=(ManagedPrivateUDP left, ManagedPrivateUDP right) => !left.Equals(right);

        public static explicit operator string(ManagedPrivateUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedPrivateUDP other && Equals(other);
        public bool Equals(ManagedPrivateUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of management for this hostpool, Automated or Standard. The default value is Automated.
    /// </summary>
    [EnumType]
    public readonly struct ManagementType : IEquatable<ManagementType>
    {
        private readonly string _value;

        private ManagementType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automated management of the hostpool
        /// </summary>
        public static ManagementType Automated { get; } = new ManagementType("Automated");
        /// <summary>
        /// Standard management of the hostpool
        /// </summary>
        public static ManagementType Standard { get; } = new ManagementType("Standard");

        public static bool operator ==(ManagementType left, ManagementType right) => left.Equals(right);
        public static bool operator !=(ManagementType left, ManagementType right) => !left.Equals(right);

        public static explicit operator string(ManagementType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagementType other && Equals(other);
        public bool Equals(ManagementType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Is package timestamped so it can ignore the certificate expiry date
    /// </summary>
    [EnumType]
    public readonly struct PackageTimestamped : IEquatable<PackageTimestamped>
    {
        private readonly string _value;

        private PackageTimestamped(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Package is timestamped
        /// </summary>
        public static PackageTimestamped Timestamped { get; } = new PackageTimestamped("Timestamped");
        /// <summary>
        /// Package is not timestamped, use certificate expiry date
        /// </summary>
        public static PackageTimestamped NotTimestamped { get; } = new PackageTimestamped("NotTimestamped");

        public static bool operator ==(PackageTimestamped left, PackageTimestamped right) => left.Equals(right);
        public static bool operator !=(PackageTimestamped left, PackageTimestamped right) => !left.Equals(right);

        public static explicit operator string(PackageTimestamped value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageTimestamped other && Equals(other);
        public bool Equals(PackageTimestamped other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PersonalDesktopAssignment type for HostPool.
    /// </summary>
    [EnumType]
    public readonly struct PersonalDesktopAssignmentType : IEquatable<PersonalDesktopAssignmentType>
    {
        private readonly string _value;

        private PersonalDesktopAssignmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically assigns an available personal desktop to the user.
        /// </summary>
        public static PersonalDesktopAssignmentType Automatic { get; } = new PersonalDesktopAssignmentType("Automatic");
        /// <summary>
        /// Manually assigns a specific personal desktop to the user.
        /// </summary>
        public static PersonalDesktopAssignmentType Direct { get; } = new PersonalDesktopAssignmentType("Direct");

        public static bool operator ==(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => left.Equals(right);
        public static bool operator !=(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => !left.Equals(right);

        public static explicit operator string(PersonalDesktopAssignmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PersonalDesktopAssignmentType other && Equals(other);
        public bool Equals(PersonalDesktopAssignmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of preferred application group type, default to Desktop Application Group
    /// </summary>
    [EnumType]
    public readonly struct PreferredAppGroupType : IEquatable<PreferredAppGroupType>
    {
        private readonly string _value;

        private PreferredAppGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Internal Use Only
        /// </summary>
        public static PreferredAppGroupType None { get; } = new PreferredAppGroupType("None");
        /// <summary>
        /// Use Desktop Application Group
        /// </summary>
        public static PreferredAppGroupType Desktop { get; } = new PreferredAppGroupType("Desktop");
        /// <summary>
        /// Use RailApplications (RemoteApp)
        /// </summary>
        public static PreferredAppGroupType RailApplications { get; } = new PreferredAppGroupType("RailApplications");

        public static bool operator ==(PreferredAppGroupType left, PreferredAppGroupType right) => left.Equals(right);
        public static bool operator !=(PreferredAppGroupType left, PreferredAppGroupType right) => !left.Equals(right);

        public static explicit operator string(PreferredAppGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PreferredAppGroupType other && Equals(other);
        public bool Equals(PreferredAppGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Connection is Pending
        /// </summary>
        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        /// <summary>
        /// Connection was Approved
        /// </summary>
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        /// <summary>
        /// Connection was rejected
        /// </summary>
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This resource is accessible from the public network.
        /// </summary>
        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        /// <summary>
        /// This resource is not accessible from the public network.
        /// </summary>
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct PublicUDP : IEquatable<PublicUDP>
    {
        private readonly string _value;

        private PublicUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AVD-wide settings are used to determine connection availability
        /// </summary>
        public static PublicUDP Default { get; } = new PublicUDP("Default");
        /// <summary>
        /// UDP will attempt this connection type when making connections.
        /// </summary>
        public static PublicUDP Enabled { get; } = new PublicUDP("Enabled");
        /// <summary>
        /// UDP will not attempt this connection type when making connections
        /// </summary>
        public static PublicUDP Disabled { get; } = new PublicUDP("Disabled");

        public static bool operator ==(PublicUDP left, PublicUDP right) => left.Equals(right);
        public static bool operator !=(PublicUDP left, PublicUDP right) => !left.Equals(right);

        public static explicit operator string(PublicUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicUDP other && Equals(other);
        public bool Equals(PublicUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resetting the token.
    /// </summary>
    [EnumType]
    public readonly struct RegistrationTokenOperation : IEquatable<RegistrationTokenOperation>
    {
        private readonly string _value;

        private RegistrationTokenOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Delete operation
        /// </summary>
        public static RegistrationTokenOperation Delete { get; } = new RegistrationTokenOperation("Delete");
        /// <summary>
        /// No Operation
        /// </summary>
        public static RegistrationTokenOperation None { get; } = new RegistrationTokenOperation("None");
        /// <summary>
        /// Update Operation
        /// </summary>
        public static RegistrationTokenOperation Update { get; } = new RegistrationTokenOperation("Update");

        public static bool operator ==(RegistrationTokenOperation left, RegistrationTokenOperation right) => left.Equals(right);
        public static bool operator !=(RegistrationTokenOperation left, RegistrationTokenOperation right) => !left.Equals(right);

        public static explicit operator string(RegistrationTokenOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegistrationTokenOperation other && Equals(other);
        public bool Equals(RegistrationTokenOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct RelayUDP : IEquatable<RelayUDP>
    {
        private readonly string _value;

        private RelayUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AVD-wide settings are used to determine connection availability
        /// </summary>
        public static RelayUDP Default { get; } = new RelayUDP("Default");
        /// <summary>
        /// UDP will attempt this connection type when making connections.
        /// </summary>
        public static RelayUDP Enabled { get; } = new RelayUDP("Enabled");
        /// <summary>
        /// UDP will not attempt this connection type when making connections
        /// </summary>
        public static RelayUDP Disabled { get; } = new RelayUDP("Disabled");

        public static bool operator ==(RelayUDP left, RelayUDP right) => left.Equals(right);
        public static bool operator !=(RelayUDP left, RelayUDP right) => !left.Equals(right);

        public static explicit operator string(RelayUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RelayUDP other && Equals(other);
        public bool Equals(RelayUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resource Type of Application.
    /// </summary>
    [EnumType]
    public readonly struct RemoteApplicationType : IEquatable<RemoteApplicationType>
    {
        private readonly string _value;

        private RemoteApplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Built-in applications
        /// </summary>
        public static RemoteApplicationType InBuilt { get; } = new RemoteApplicationType("InBuilt");
        /// <summary>
        /// Imported MSIX application packages
        /// </summary>
        public static RemoteApplicationType MsixApplication { get; } = new RemoteApplicationType("MsixApplication");

        public static bool operator ==(RemoteApplicationType left, RemoteApplicationType right) => left.Equals(right);
        public static bool operator !=(RemoteApplicationType left, RemoteApplicationType right) => !left.Equals(right);

        public static explicit operator string(RemoteApplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteApplicationType other && Equals(other);
        public bool Equals(RemoteApplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of single sign on Secret Type.
    /// </summary>
    [EnumType]
    public readonly struct SSOSecretType : IEquatable<SSOSecretType>
    {
        private readonly string _value;

        private SSOSecretType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The SSO Secret is a Shared Key.
        /// </summary>
        public static SSOSecretType SharedKey { get; } = new SSOSecretType("SharedKey");
        /// <summary>
        /// The SSO Secret is a Certificate.
        /// </summary>
        public static SSOSecretType Certificate { get; } = new SSOSecretType("Certificate");
        /// <summary>
        /// The SSO Secret is a SharedKey that is stored in KeyVault.
        /// </summary>
        public static SSOSecretType SharedKeyInKeyVault { get; } = new SSOSecretType("SharedKeyInKeyVault");
        /// <summary>
        /// The SSO Secret is a Certificate that is stored in KeyVault.
        /// </summary>
        public static SSOSecretType CertificateInKeyVault { get; } = new SSOSecretType("CertificateInKeyVault");

        public static bool operator ==(SSOSecretType left, SSOSecretType right) => left.Equals(right);
        public static bool operator !=(SSOSecretType left, SSOSecretType right) => !left.Equals(right);

        public static explicit operator string(SSOSecretType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSOSecretType other && Equals(other);
        public bool Equals(SSOSecretType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct ScalingHostPoolType : IEquatable<ScalingHostPoolType>
    {
        private readonly string _value;

        private ScalingHostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static ScalingHostPoolType Pooled { get; } = new ScalingHostPoolType("Pooled");
        /// <summary>
        /// Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
        /// </summary>
        public static ScalingHostPoolType Personal { get; } = new ScalingHostPoolType("Personal");

        public static bool operator ==(ScalingHostPoolType left, ScalingHostPoolType right) => left.Equals(right);
        public static bool operator !=(ScalingHostPoolType left, ScalingHostPoolType right) => !left.Equals(right);

        public static explicit operator string(ScalingHostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScalingHostPoolType other && Equals(other);
        public bool Equals(ScalingHostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Action to be taken after a logoff during the ramp up period.
    /// </summary>
    [EnumType]
    public readonly struct SessionHandlingOperation : IEquatable<SessionHandlingOperation>
    {
        private readonly string _value;

        private SessionHandlingOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No action will be taken after disconnect
        /// </summary>
        public static SessionHandlingOperation None { get; } = new SessionHandlingOperation("None");
        /// <summary>
        /// Session Host will be deallocated after disconnect
        /// </summary>
        public static SessionHandlingOperation Deallocate { get; } = new SessionHandlingOperation("Deallocate");
        /// <summary>
        /// Session Host will hibernate after disconnect
        /// </summary>
        public static SessionHandlingOperation Hibernate { get; } = new SessionHandlingOperation("Hibernate");

        public static bool operator ==(SessionHandlingOperation left, SessionHandlingOperation right) => left.Equals(right);
        public static bool operator !=(SessionHandlingOperation left, SessionHandlingOperation right) => !left.Equals(right);

        public static explicit operator string(SessionHandlingOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHandlingOperation other && Equals(other);
        public bool Equals(SessionHandlingOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of maintenance for session host components.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostComponentUpdateType : IEquatable<SessionHostComponentUpdateType>
    {
        private readonly string _value;

        private SessionHostComponentUpdateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Agent and other agent side components are delivery schedule is controlled by WVD Infra.
        /// </summary>
        public static SessionHostComponentUpdateType Default { get; } = new SessionHostComponentUpdateType("Default");
        /// <summary>
        /// TenantAdmin have opted in for Scheduled Component Update feature.
        /// </summary>
        public static SessionHostComponentUpdateType Scheduled { get; } = new SessionHostComponentUpdateType("Scheduled");

        public static bool operator ==(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => left.Equals(right);
        public static bool operator !=(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => !left.Equals(right);

        public static explicit operator string(SessionHostComponentUpdateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostComponentUpdateType other && Equals(other);
        public bool Equals(SessionHostComponentUpdateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load balancing algorithm for ramp up period.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostLoadBalancingAlgorithm : IEquatable<SessionHostLoadBalancingAlgorithm>
    {
        private readonly string _value;

        private SessionHostLoadBalancingAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Breadth First Algorithm for Load Balancing
        /// </summary>
        public static SessionHostLoadBalancingAlgorithm BreadthFirst { get; } = new SessionHostLoadBalancingAlgorithm("BreadthFirst");
        /// <summary>
        /// Depth First Algorithm for Load Balancing
        /// </summary>
        public static SessionHostLoadBalancingAlgorithm DepthFirst { get; } = new SessionHostLoadBalancingAlgorithm("DepthFirst");

        public static bool operator ==(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => left.Equals(right);
        public static bool operator !=(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => !left.Equals(right);

        public static explicit operator string(SessionHostLoadBalancingAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostLoadBalancingAlgorithm other && Equals(other);
        public bool Equals(SessionHostLoadBalancingAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired configuration of Start VM On Connect for the hostpool during the ramp up phase. If this is disabled, session hosts must be turned on using rampUpAutoStartHosts or by turning them on manually.
    /// </summary>
    [EnumType]
    public readonly struct SetStartVMOnConnect : IEquatable<SetStartVMOnConnect>
    {
        private readonly string _value;

        private SetStartVMOnConnect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Start VM on Connect is enabled
        /// </summary>
        public static SetStartVMOnConnect Enable { get; } = new SetStartVMOnConnect("Enable");
        /// <summary>
        /// Start VM on Connect is disabled, must use rampUpAutoStartHosts or turn on manually
        /// </summary>
        public static SetStartVMOnConnect Disable { get; } = new SetStartVMOnConnect("Disable");

        public static bool operator ==(SetStartVMOnConnect left, SetStartVMOnConnect right) => left.Equals(right);
        public static bool operator !=(SetStartVMOnConnect left, SetStartVMOnConnect right) => !left.Equals(right);

        public static explicit operator string(SetStartVMOnConnect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SetStartVMOnConnect other && Equals(other);
        public bool Equals(SetStartVMOnConnect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
    /// </summary>
    [EnumType]
    public readonly struct SkuTier : IEquatable<SkuTier>
    {
        private readonly string _value;

        private SkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuTier Free { get; } = new SkuTier("Free");
        public static SkuTier Basic { get; } = new SkuTier("Basic");
        public static SkuTier Standard { get; } = new SkuTier("Standard");
        public static SkuTier Premium { get; } = new SkuTier("Premium");

        public static bool operator ==(SkuTier left, SkuTier right) => left.Equals(right);
        public static bool operator !=(SkuTier left, SkuTier right) => !left.Equals(right);

        public static explicit operator string(SkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuTier other && Equals(other);
        public bool Equals(SkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired startup behavior during the ramp up period for personal vms in the hostpool.
    /// </summary>
    [EnumType]
    public readonly struct StartupBehavior : IEquatable<StartupBehavior>
    {
        private readonly string _value;

        private StartupBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Session hosts will not be started by the service. This setting depends on Start VM on Connect to be enabled to start the session hosts.
        /// </summary>
        public static StartupBehavior None { get; } = new StartupBehavior("None");
        /// <summary>
        /// Session hosts with an assigned user will be started during Ramp Up
        /// </summary>
        public static StartupBehavior WithAssignedUser { get; } = new StartupBehavior("WithAssignedUser");
        /// <summary>
        /// All personal session hosts in the hostpool will be started during ramp up.
        /// </summary>
        public static StartupBehavior All { get; } = new StartupBehavior("All");

        public static bool operator ==(StartupBehavior left, StartupBehavior right) => left.Equals(right);
        public static bool operator !=(StartupBehavior left, StartupBehavior right) => !left.Equals(right);

        public static explicit operator string(StartupBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StartupBehavior other && Equals(other);
        public bool Equals(StartupBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies when to stop hosts during ramp down period.
    /// </summary>
    [EnumType]
    public readonly struct StopHostsWhen : IEquatable<StopHostsWhen>
    {
        private readonly string _value;

        private StopHostsWhen(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Zero Total Sessions
        /// </summary>
        public static StopHostsWhen ZeroSessions { get; } = new StopHostsWhen("ZeroSessions");
        /// <summary>
        /// Zero Active Sessions
        /// </summary>
        public static StopHostsWhen ZeroActiveSessions { get; } = new StopHostsWhen("ZeroActiveSessions");

        public static bool operator ==(StopHostsWhen left, StopHostsWhen right) => left.Equals(right);
        public static bool operator !=(StopHostsWhen left, StopHostsWhen right) => !left.Equals(right);

        public static explicit operator string(StopHostsWhen value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StopHostsWhen other && Equals(other);
        public bool Equals(StopHostsWhen other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
