// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.DesktopVirtualization.V20240808Preview
{
    /// <summary>
    /// Resource Type of ApplicationGroup.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationGroupType : IEquatable<ApplicationGroupType>
    {
        private readonly string _value;

        private ApplicationGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationGroupType RemoteApp { get; } = new ApplicationGroupType("RemoteApp");
        public static ApplicationGroupType Desktop { get; } = new ApplicationGroupType("Desktop");

        public static bool operator ==(ApplicationGroupType left, ApplicationGroupType right) => left.Equals(right);
        public static bool operator !=(ApplicationGroupType left, ApplicationGroupType right) => !left.Equals(right);

        public static explicit operator string(ApplicationGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationGroupType other && Equals(other);
        public bool Equals(ApplicationGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
    /// </summary>
    [EnumType]
    public readonly struct CommandLineSetting : IEquatable<CommandLineSetting>
    {
        private readonly string _value;

        private CommandLineSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CommandLineSetting DoNotAllow { get; } = new CommandLineSetting("DoNotAllow");
        public static CommandLineSetting Allow { get; } = new CommandLineSetting("Allow");
        public static CommandLineSetting Require { get; } = new CommandLineSetting("Require");

        public static bool operator ==(CommandLineSetting left, CommandLineSetting right) => left.Equals(right);
        public static bool operator !=(CommandLineSetting left, CommandLineSetting right) => !left.Equals(right);

        public static explicit operator string(CommandLineSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CommandLineSetting other && Equals(other);
        public bool Equals(CommandLineSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Day of the week.
    /// </summary>
    [EnumType]
    public readonly struct DayOfWeek : IEquatable<DayOfWeek>
    {
        private readonly string _value;

        private DayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DayOfWeek Sunday { get; } = new DayOfWeek("Sunday");
        public static DayOfWeek Monday { get; } = new DayOfWeek("Monday");
        public static DayOfWeek Tuesday { get; } = new DayOfWeek("Tuesday");
        public static DayOfWeek Wednesday { get; } = new DayOfWeek("Wednesday");
        public static DayOfWeek Thursday { get; } = new DayOfWeek("Thursday");
        public static DayOfWeek Friday { get; } = new DayOfWeek("Friday");
        public static DayOfWeek Saturday { get; } = new DayOfWeek("Saturday");

        public static bool operator ==(DayOfWeek left, DayOfWeek right) => left.Equals(right);
        public static bool operator !=(DayOfWeek left, DayOfWeek right) => !left.Equals(right);

        public static explicit operator string(DayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DayOfWeek other && Equals(other);
        public bool Equals(DayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct DirectUDP : IEquatable<DirectUDP>
    {
        private readonly string _value;

        private DirectUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DirectUDP Default { get; } = new DirectUDP("Default");
        public static DirectUDP Enabled { get; } = new DirectUDP("Enabled");
        public static DirectUDP Disabled { get; } = new DirectUDP("Disabled");

        public static bool operator ==(DirectUDP left, DirectUDP right) => left.Equals(right);
        public static bool operator !=(DirectUDP left, DirectUDP right) => !left.Equals(right);

        public static explicit operator string(DirectUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DirectUDP other && Equals(other);
        public bool Equals(DirectUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Parameter indicating how the health check should behave if this package fails staging
    /// </summary>
    [EnumType]
    public readonly struct FailHealthCheckOnStagingFailure : IEquatable<FailHealthCheckOnStagingFailure>
    {
        private readonly string _value;

        private FailHealthCheckOnStagingFailure(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FailHealthCheckOnStagingFailure Unhealthy { get; } = new FailHealthCheckOnStagingFailure("Unhealthy");
        public static FailHealthCheckOnStagingFailure NeedsAssistance { get; } = new FailHealthCheckOnStagingFailure("NeedsAssistance");
        public static FailHealthCheckOnStagingFailure DoNotFail { get; } = new FailHealthCheckOnStagingFailure("DoNotFail");

        public static bool operator ==(FailHealthCheckOnStagingFailure left, FailHealthCheckOnStagingFailure right) => left.Equals(right);
        public static bool operator !=(FailHealthCheckOnStagingFailure left, FailHealthCheckOnStagingFailure right) => !left.Equals(right);

        public static explicit operator string(FailHealthCheckOnStagingFailure value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FailHealthCheckOnStagingFailure other && Equals(other);
        public bool Equals(FailHealthCheckOnStagingFailure other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct HostPoolType : IEquatable<HostPoolType>
    {
        private readonly string _value;

        private HostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
        /// </summary>
        public static HostPoolType Personal { get; } = new HostPoolType("Personal");
        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static HostPoolType Pooled { get; } = new HostPoolType("Pooled");
        /// <summary>
        /// Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct.
        /// </summary>
        public static HostPoolType BYODesktop { get; } = new HostPoolType("BYODesktop");

        public static bool operator ==(HostPoolType left, HostPoolType right) => left.Equals(right);
        public static bool operator !=(HostPoolType left, HostPoolType right) => !left.Equals(right);

        public static explicit operator string(HostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostPoolType other && Equals(other);
        public bool Equals(HostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct HostpoolPublicNetworkAccess : IEquatable<HostpoolPublicNetworkAccess>
    {
        private readonly string _value;

        private HostpoolPublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostpoolPublicNetworkAccess Enabled { get; } = new HostpoolPublicNetworkAccess("Enabled");
        public static HostpoolPublicNetworkAccess Disabled { get; } = new HostpoolPublicNetworkAccess("Disabled");
        public static HostpoolPublicNetworkAccess EnabledForSessionHostsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForSessionHostsOnly");
        public static HostpoolPublicNetworkAccess EnabledForClientsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForClientsOnly");

        public static bool operator ==(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(HostpoolPublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostpoolPublicNetworkAccess other && Equals(other);
        public bool Equals(HostpoolPublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the load balancer.
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancerType BreadthFirst { get; } = new LoadBalancerType("BreadthFirst");
        public static LoadBalancerType DepthFirst { get; } = new LoadBalancerType("DepthFirst");
        public static LoadBalancerType Persistent { get; } = new LoadBalancerType("Persistent");
        public static LoadBalancerType MultiplePersistent { get; } = new LoadBalancerType("MultiplePersistent");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct ManagedPrivateUDP : IEquatable<ManagedPrivateUDP>
    {
        private readonly string _value;

        private ManagedPrivateUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedPrivateUDP Default { get; } = new ManagedPrivateUDP("Default");
        public static ManagedPrivateUDP Enabled { get; } = new ManagedPrivateUDP("Enabled");
        public static ManagedPrivateUDP Disabled { get; } = new ManagedPrivateUDP("Disabled");

        public static bool operator ==(ManagedPrivateUDP left, ManagedPrivateUDP right) => left.Equals(right);
        public static bool operator !=(ManagedPrivateUDP left, ManagedPrivateUDP right) => !left.Equals(right);

        public static explicit operator string(ManagedPrivateUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedPrivateUDP other && Equals(other);
        public bool Equals(ManagedPrivateUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of management for this hostpool, Automated or Standard. The default value is Automated.
    /// </summary>
    [EnumType]
    public readonly struct ManagementType : IEquatable<ManagementType>
    {
        private readonly string _value;

        private ManagementType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagementType Automated { get; } = new ManagementType("Automated");
        public static ManagementType Standard { get; } = new ManagementType("Standard");

        public static bool operator ==(ManagementType left, ManagementType right) => left.Equals(right);
        public static bool operator !=(ManagementType left, ManagementType right) => !left.Equals(right);

        public static explicit operator string(ManagementType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagementType other && Equals(other);
        public bool Equals(ManagementType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Is package timestamped so it can ignore the certificate expiry date
    /// </summary>
    [EnumType]
    public readonly struct PackageTimestamped : IEquatable<PackageTimestamped>
    {
        private readonly string _value;

        private PackageTimestamped(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PackageTimestamped Timestamped { get; } = new PackageTimestamped("Timestamped");
        public static PackageTimestamped NotTimestamped { get; } = new PackageTimestamped("NotTimestamped");

        public static bool operator ==(PackageTimestamped left, PackageTimestamped right) => left.Equals(right);
        public static bool operator !=(PackageTimestamped left, PackageTimestamped right) => !left.Equals(right);

        public static explicit operator string(PackageTimestamped value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageTimestamped other && Equals(other);
        public bool Equals(PackageTimestamped other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PersonalDesktopAssignment type for HostPool.
    /// </summary>
    [EnumType]
    public readonly struct PersonalDesktopAssignmentType : IEquatable<PersonalDesktopAssignmentType>
    {
        private readonly string _value;

        private PersonalDesktopAssignmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PersonalDesktopAssignmentType Automatic { get; } = new PersonalDesktopAssignmentType("Automatic");
        public static PersonalDesktopAssignmentType Direct { get; } = new PersonalDesktopAssignmentType("Direct");

        public static bool operator ==(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => left.Equals(right);
        public static bool operator !=(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => !left.Equals(right);

        public static explicit operator string(PersonalDesktopAssignmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PersonalDesktopAssignmentType other && Equals(other);
        public bool Equals(PersonalDesktopAssignmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of preferred application group type, default to Desktop Application Group
    /// </summary>
    [EnumType]
    public readonly struct PreferredAppGroupType : IEquatable<PreferredAppGroupType>
    {
        private readonly string _value;

        private PreferredAppGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This value is read only, it is not accepted on input.
        /// </summary>
        public static PreferredAppGroupType None { get; } = new PreferredAppGroupType("None");
        /// <summary>
        /// Users access the full Windows desktop from a session host. Available with pooled or personal host pools.
        /// </summary>
        public static PreferredAppGroupType Desktop { get; } = new PreferredAppGroupType("Desktop");
        /// <summary>
        /// Users access individual applications you select and publish to the application group. Available with pooled host pools only.
        /// </summary>
        public static PreferredAppGroupType RailApplications { get; } = new PreferredAppGroupType("RailApplications");

        public static bool operator ==(PreferredAppGroupType left, PreferredAppGroupType right) => left.Equals(right);
        public static bool operator !=(PreferredAppGroupType left, PreferredAppGroupType right) => !left.Equals(right);

        public static explicit operator string(PreferredAppGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PreferredAppGroupType other && Equals(other);
        public bool Equals(PreferredAppGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct PublicUDP : IEquatable<PublicUDP>
    {
        private readonly string _value;

        private PublicUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicUDP Default { get; } = new PublicUDP("Default");
        public static PublicUDP Enabled { get; } = new PublicUDP("Enabled");
        public static PublicUDP Disabled { get; } = new PublicUDP("Disabled");

        public static bool operator ==(PublicUDP left, PublicUDP right) => left.Equals(right);
        public static bool operator !=(PublicUDP left, PublicUDP right) => !left.Equals(right);

        public static explicit operator string(PublicUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicUDP other && Equals(other);
        public bool Equals(PublicUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resetting the token.
    /// </summary>
    [EnumType]
    public readonly struct RegistrationTokenOperation : IEquatable<RegistrationTokenOperation>
    {
        private readonly string _value;

        private RegistrationTokenOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegistrationTokenOperation Delete { get; } = new RegistrationTokenOperation("Delete");
        public static RegistrationTokenOperation None { get; } = new RegistrationTokenOperation("None");
        public static RegistrationTokenOperation Update { get; } = new RegistrationTokenOperation("Update");

        public static bool operator ==(RegistrationTokenOperation left, RegistrationTokenOperation right) => left.Equals(right);
        public static bool operator !=(RegistrationTokenOperation left, RegistrationTokenOperation right) => !left.Equals(right);

        public static explicit operator string(RegistrationTokenOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegistrationTokenOperation other && Equals(other);
        public bool Equals(RegistrationTokenOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
    /// </summary>
    [EnumType]
    public readonly struct RelayUDP : IEquatable<RelayUDP>
    {
        private readonly string _value;

        private RelayUDP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RelayUDP Default { get; } = new RelayUDP("Default");
        public static RelayUDP Enabled { get; } = new RelayUDP("Enabled");
        public static RelayUDP Disabled { get; } = new RelayUDP("Disabled");

        public static bool operator ==(RelayUDP left, RelayUDP right) => left.Equals(right);
        public static bool operator !=(RelayUDP left, RelayUDP right) => !left.Equals(right);

        public static explicit operator string(RelayUDP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RelayUDP other && Equals(other);
        public bool Equals(RelayUDP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resource Type of Application.
    /// </summary>
    [EnumType]
    public readonly struct RemoteApplicationType : IEquatable<RemoteApplicationType>
    {
        private readonly string _value;

        private RemoteApplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteApplicationType InBuilt { get; } = new RemoteApplicationType("InBuilt");
        public static RemoteApplicationType MsixApplication { get; } = new RemoteApplicationType("MsixApplication");

        public static bool operator ==(RemoteApplicationType left, RemoteApplicationType right) => left.Equals(right);
        public static bool operator !=(RemoteApplicationType left, RemoteApplicationType right) => !left.Equals(right);

        public static explicit operator string(RemoteApplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteApplicationType other && Equals(other);
        public bool Equals(RemoteApplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of single sign on Secret Type.
    /// </summary>
    [EnumType]
    public readonly struct SSOSecretType : IEquatable<SSOSecretType>
    {
        private readonly string _value;

        private SSOSecretType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SSOSecretType SharedKey { get; } = new SSOSecretType("SharedKey");
        public static SSOSecretType Certificate { get; } = new SSOSecretType("Certificate");
        public static SSOSecretType SharedKeyInKeyVault { get; } = new SSOSecretType("SharedKeyInKeyVault");
        public static SSOSecretType CertificateInKeyVault { get; } = new SSOSecretType("CertificateInKeyVault");

        public static bool operator ==(SSOSecretType left, SSOSecretType right) => left.Equals(right);
        public static bool operator !=(SSOSecretType left, SSOSecretType right) => !left.Equals(right);

        public static explicit operator string(SSOSecretType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSOSecretType other && Equals(other);
        public bool Equals(SSOSecretType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct ScalingHostPoolType : IEquatable<ScalingHostPoolType>
    {
        private readonly string _value;

        private ScalingHostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static ScalingHostPoolType Pooled { get; } = new ScalingHostPoolType("Pooled");
        /// <summary>
        /// Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
        /// </summary>
        public static ScalingHostPoolType Personal { get; } = new ScalingHostPoolType("Personal");

        public static bool operator ==(ScalingHostPoolType left, ScalingHostPoolType right) => left.Equals(right);
        public static bool operator !=(ScalingHostPoolType left, ScalingHostPoolType right) => !left.Equals(right);

        public static explicit operator string(ScalingHostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScalingHostPoolType other && Equals(other);
        public bool Equals(ScalingHostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Action to be taken after a logoff during the ramp up period.
    /// </summary>
    [EnumType]
    public readonly struct SessionHandlingOperation : IEquatable<SessionHandlingOperation>
    {
        private readonly string _value;

        private SessionHandlingOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SessionHandlingOperation None { get; } = new SessionHandlingOperation("None");
        public static SessionHandlingOperation Deallocate { get; } = new SessionHandlingOperation("Deallocate");
        public static SessionHandlingOperation Hibernate { get; } = new SessionHandlingOperation("Hibernate");

        public static bool operator ==(SessionHandlingOperation left, SessionHandlingOperation right) => left.Equals(right);
        public static bool operator !=(SessionHandlingOperation left, SessionHandlingOperation right) => !left.Equals(right);

        public static explicit operator string(SessionHandlingOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHandlingOperation other && Equals(other);
        public bool Equals(SessionHandlingOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of maintenance for session host components.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostComponentUpdateType : IEquatable<SessionHostComponentUpdateType>
    {
        private readonly string _value;

        private SessionHostComponentUpdateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Agent and other agent side components are delivery schedule is controlled by WVD Infra.
        /// </summary>
        public static SessionHostComponentUpdateType Default { get; } = new SessionHostComponentUpdateType("Default");
        /// <summary>
        /// TenantAdmin have opted in for Scheduled Component Update feature.
        /// </summary>
        public static SessionHostComponentUpdateType Scheduled { get; } = new SessionHostComponentUpdateType("Scheduled");

        public static bool operator ==(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => left.Equals(right);
        public static bool operator !=(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => !left.Equals(right);

        public static explicit operator string(SessionHostComponentUpdateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostComponentUpdateType other && Equals(other);
        public bool Equals(SessionHostComponentUpdateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load balancing algorithm for ramp up period.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostLoadBalancingAlgorithm : IEquatable<SessionHostLoadBalancingAlgorithm>
    {
        private readonly string _value;

        private SessionHostLoadBalancingAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SessionHostLoadBalancingAlgorithm BreadthFirst { get; } = new SessionHostLoadBalancingAlgorithm("BreadthFirst");
        public static SessionHostLoadBalancingAlgorithm DepthFirst { get; } = new SessionHostLoadBalancingAlgorithm("DepthFirst");

        public static bool operator ==(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => left.Equals(right);
        public static bool operator !=(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => !left.Equals(right);

        public static explicit operator string(SessionHostLoadBalancingAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostLoadBalancingAlgorithm other && Equals(other);
        public bool Equals(SessionHostLoadBalancingAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired configuration of Start VM On Connect for the hostpool during the ramp up phase. If this is disabled, session hosts must be turned on using rampUpAutoStartHosts or by turning them on manually.
    /// </summary>
    [EnumType]
    public readonly struct SetStartVMOnConnect : IEquatable<SetStartVMOnConnect>
    {
        private readonly string _value;

        private SetStartVMOnConnect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SetStartVMOnConnect Enable { get; } = new SetStartVMOnConnect("Enable");
        public static SetStartVMOnConnect Disable { get; } = new SetStartVMOnConnect("Disable");

        public static bool operator ==(SetStartVMOnConnect left, SetStartVMOnConnect right) => left.Equals(right);
        public static bool operator !=(SetStartVMOnConnect left, SetStartVMOnConnect right) => !left.Equals(right);

        public static explicit operator string(SetStartVMOnConnect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SetStartVMOnConnect other && Equals(other);
        public bool Equals(SetStartVMOnConnect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
    /// </summary>
    [EnumType]
    public readonly struct SkuTier : IEquatable<SkuTier>
    {
        private readonly string _value;

        private SkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuTier Free { get; } = new SkuTier("Free");
        public static SkuTier Basic { get; } = new SkuTier("Basic");
        public static SkuTier Standard { get; } = new SkuTier("Standard");
        public static SkuTier Premium { get; } = new SkuTier("Premium");

        public static bool operator ==(SkuTier left, SkuTier right) => left.Equals(right);
        public static bool operator !=(SkuTier left, SkuTier right) => !left.Equals(right);

        public static explicit operator string(SkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuTier other && Equals(other);
        public bool Equals(SkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired startup behavior during the ramp up period for personal vms in the hostpool.
    /// </summary>
    [EnumType]
    public readonly struct StartupBehavior : IEquatable<StartupBehavior>
    {
        private readonly string _value;

        private StartupBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Session hosts will not be started by the service. This setting depends on Start VM on Connect to be enabled to start the session hosts.
        /// </summary>
        public static StartupBehavior None { get; } = new StartupBehavior("None");
        /// <summary>
        /// Session hosts with an assigned user will be started during Ramp Up
        /// </summary>
        public static StartupBehavior WithAssignedUser { get; } = new StartupBehavior("WithAssignedUser");
        /// <summary>
        /// All personal session hosts in the hostpool will be started during ramp up.
        /// </summary>
        public static StartupBehavior All { get; } = new StartupBehavior("All");

        public static bool operator ==(StartupBehavior left, StartupBehavior right) => left.Equals(right);
        public static bool operator !=(StartupBehavior left, StartupBehavior right) => !left.Equals(right);

        public static explicit operator string(StartupBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StartupBehavior other && Equals(other);
        public bool Equals(StartupBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies when to stop hosts during ramp down period.
    /// </summary>
    [EnumType]
    public readonly struct StopHostsWhen : IEquatable<StopHostsWhen>
    {
        private readonly string _value;

        private StopHostsWhen(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StopHostsWhen ZeroSessions { get; } = new StopHostsWhen("ZeroSessions");
        public static StopHostsWhen ZeroActiveSessions { get; } = new StopHostsWhen("ZeroActiveSessions");

        public static bool operator ==(StopHostsWhen left, StopHostsWhen right) => left.Equals(right);
        public static bool operator !=(StopHostsWhen left, StopHostsWhen right) => !left.Equals(right);

        public static explicit operator string(StopHostsWhen value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StopHostsWhen other && Equals(other);
        public bool Equals(StopHostsWhen other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
