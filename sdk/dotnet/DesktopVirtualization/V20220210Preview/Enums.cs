// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.DesktopVirtualization.V20220210Preview
{
    /// <summary>
    /// Resource Type of ApplicationGroup.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationGroupType : IEquatable<ApplicationGroupType>
    {
        private readonly string _value;

        private ApplicationGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationGroupType RemoteApp { get; } = new ApplicationGroupType("RemoteApp");
        public static ApplicationGroupType Desktop { get; } = new ApplicationGroupType("Desktop");

        public static bool operator ==(ApplicationGroupType left, ApplicationGroupType right) => left.Equals(right);
        public static bool operator !=(ApplicationGroupType left, ApplicationGroupType right) => !left.Equals(right);

        public static explicit operator string(ApplicationGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationGroupType other && Equals(other);
        public bool Equals(ApplicationGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
    /// </summary>
    [EnumType]
    public readonly struct CommandLineSetting : IEquatable<CommandLineSetting>
    {
        private readonly string _value;

        private CommandLineSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CommandLineSetting DoNotAllow { get; } = new CommandLineSetting("DoNotAllow");
        public static CommandLineSetting Allow { get; } = new CommandLineSetting("Allow");
        public static CommandLineSetting Require { get; } = new CommandLineSetting("Require");

        public static bool operator ==(CommandLineSetting left, CommandLineSetting right) => left.Equals(right);
        public static bool operator !=(CommandLineSetting left, CommandLineSetting right) => !left.Equals(right);

        public static explicit operator string(CommandLineSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CommandLineSetting other && Equals(other);
        public bool Equals(CommandLineSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day of the week (Monday-Sunday).
    /// </summary>
    [EnumType]
    public readonly struct DayOfWeek : IEquatable<DayOfWeek>
    {
        private readonly string _value;

        private DayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DayOfWeek Monday { get; } = new DayOfWeek("Monday");
        public static DayOfWeek Tuesday { get; } = new DayOfWeek("Tuesday");
        public static DayOfWeek Wednesday { get; } = new DayOfWeek("Wednesday");
        public static DayOfWeek Thursday { get; } = new DayOfWeek("Thursday");
        public static DayOfWeek Friday { get; } = new DayOfWeek("Friday");
        public static DayOfWeek Saturday { get; } = new DayOfWeek("Saturday");
        public static DayOfWeek Sunday { get; } = new DayOfWeek("Sunday");

        public static bool operator ==(DayOfWeek left, DayOfWeek right) => left.Equals(right);
        public static bool operator !=(DayOfWeek left, DayOfWeek right) => !left.Equals(right);

        public static explicit operator string(DayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DayOfWeek other && Equals(other);
        public bool Equals(DayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct HostPoolType : IEquatable<HostPoolType>
    {
        private readonly string _value;

        private HostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
        /// </summary>
        public static HostPoolType Personal { get; } = new HostPoolType("Personal");
        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static HostPoolType Pooled { get; } = new HostPoolType("Pooled");
        /// <summary>
        /// Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct.
        /// </summary>
        public static HostPoolType BYODesktop { get; } = new HostPoolType("BYODesktop");

        public static bool operator ==(HostPoolType left, HostPoolType right) => left.Equals(right);
        public static bool operator !=(HostPoolType left, HostPoolType right) => !left.Equals(right);

        public static explicit operator string(HostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostPoolType other && Equals(other);
        public bool Equals(HostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct HostpoolPublicNetworkAccess : IEquatable<HostpoolPublicNetworkAccess>
    {
        private readonly string _value;

        private HostpoolPublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HostpoolPublicNetworkAccess Enabled { get; } = new HostpoolPublicNetworkAccess("Enabled");
        public static HostpoolPublicNetworkAccess Disabled { get; } = new HostpoolPublicNetworkAccess("Disabled");
        public static HostpoolPublicNetworkAccess EnabledForSessionHostsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForSessionHostsOnly");
        public static HostpoolPublicNetworkAccess EnabledForClientsOnly { get; } = new HostpoolPublicNetworkAccess("EnabledForClientsOnly");

        public static bool operator ==(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(HostpoolPublicNetworkAccess left, HostpoolPublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(HostpoolPublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostpoolPublicNetworkAccess other && Equals(other);
        public bool Equals(HostpoolPublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the load balancer.
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancerType BreadthFirst { get; } = new LoadBalancerType("BreadthFirst");
        public static LoadBalancerType DepthFirst { get; } = new LoadBalancerType("DepthFirst");
        public static LoadBalancerType Persistent { get; } = new LoadBalancerType("Persistent");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of operation for migration.
    /// </summary>
    [EnumType]
    public readonly struct Operation : IEquatable<Operation>
    {
        private readonly string _value;

        private Operation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Start the migration.
        /// </summary>
        public static Operation Start { get; } = new Operation("Start");
        /// <summary>
        /// Revoke the migration.
        /// </summary>
        public static Operation Revoke { get; } = new Operation("Revoke");
        /// <summary>
        /// Complete the migration.
        /// </summary>
        public static Operation Complete { get; } = new Operation("Complete");
        /// <summary>
        /// Hide the hostpool.
        /// </summary>
        public static Operation Hide { get; } = new Operation("Hide");
        /// <summary>
        /// Unhide the hostpool.
        /// </summary>
        public static Operation Unhide { get; } = new Operation("Unhide");

        public static bool operator ==(Operation left, Operation right) => left.Equals(right);
        public static bool operator !=(Operation left, Operation right) => !left.Equals(right);

        public static explicit operator string(Operation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Operation other && Equals(other);
        public bool Equals(Operation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PersonalDesktopAssignment type for HostPool.
    /// </summary>
    [EnumType]
    public readonly struct PersonalDesktopAssignmentType : IEquatable<PersonalDesktopAssignmentType>
    {
        private readonly string _value;

        private PersonalDesktopAssignmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PersonalDesktopAssignmentType Automatic { get; } = new PersonalDesktopAssignmentType("Automatic");
        public static PersonalDesktopAssignmentType Direct { get; } = new PersonalDesktopAssignmentType("Direct");

        public static bool operator ==(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => left.Equals(right);
        public static bool operator !=(PersonalDesktopAssignmentType left, PersonalDesktopAssignmentType right) => !left.Equals(right);

        public static explicit operator string(PersonalDesktopAssignmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PersonalDesktopAssignmentType other && Equals(other);
        public bool Equals(PersonalDesktopAssignmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of preferred application group type, default to Desktop Application Group
    /// </summary>
    [EnumType]
    public readonly struct PreferredAppGroupType : IEquatable<PreferredAppGroupType>
    {
        private readonly string _value;

        private PreferredAppGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PreferredAppGroupType None { get; } = new PreferredAppGroupType("None");
        public static PreferredAppGroupType Desktop { get; } = new PreferredAppGroupType("Desktop");
        public static PreferredAppGroupType RailApplications { get; } = new PreferredAppGroupType("RailApplications");

        public static bool operator ==(PreferredAppGroupType left, PreferredAppGroupType right) => left.Equals(right);
        public static bool operator !=(PreferredAppGroupType left, PreferredAppGroupType right) => !left.Equals(right);

        public static explicit operator string(PreferredAppGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PreferredAppGroupType other && Equals(other);
        public bool Equals(PreferredAppGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resetting the token.
    /// </summary>
    [EnumType]
    public readonly struct RegistrationTokenOperation : IEquatable<RegistrationTokenOperation>
    {
        private readonly string _value;

        private RegistrationTokenOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegistrationTokenOperation Delete { get; } = new RegistrationTokenOperation("Delete");
        public static RegistrationTokenOperation None { get; } = new RegistrationTokenOperation("None");
        public static RegistrationTokenOperation Update { get; } = new RegistrationTokenOperation("Update");

        public static bool operator ==(RegistrationTokenOperation left, RegistrationTokenOperation right) => left.Equals(right);
        public static bool operator !=(RegistrationTokenOperation left, RegistrationTokenOperation right) => !left.Equals(right);

        public static explicit operator string(RegistrationTokenOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegistrationTokenOperation other && Equals(other);
        public bool Equals(RegistrationTokenOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resource Type of Application.
    /// </summary>
    [EnumType]
    public readonly struct RemoteApplicationType : IEquatable<RemoteApplicationType>
    {
        private readonly string _value;

        private RemoteApplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteApplicationType InBuilt { get; } = new RemoteApplicationType("InBuilt");
        public static RemoteApplicationType MsixApplication { get; } = new RemoteApplicationType("MsixApplication");

        public static bool operator ==(RemoteApplicationType left, RemoteApplicationType right) => left.Equals(right);
        public static bool operator !=(RemoteApplicationType left, RemoteApplicationType right) => !left.Equals(right);

        public static explicit operator string(RemoteApplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteApplicationType other && Equals(other);
        public bool Equals(RemoteApplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of single sign on Secret Type.
    /// </summary>
    [EnumType]
    public readonly struct SSOSecretType : IEquatable<SSOSecretType>
    {
        private readonly string _value;

        private SSOSecretType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SSOSecretType SharedKey { get; } = new SSOSecretType("SharedKey");
        public static SSOSecretType Certificate { get; } = new SSOSecretType("Certificate");
        public static SSOSecretType SharedKeyInKeyVault { get; } = new SSOSecretType("SharedKeyInKeyVault");
        public static SSOSecretType CertificateInKeyVault { get; } = new SSOSecretType("CertificateInKeyVault");

        public static bool operator ==(SSOSecretType left, SSOSecretType right) => left.Equals(right);
        public static bool operator !=(SSOSecretType left, SSOSecretType right) => !left.Equals(right);

        public static explicit operator string(SSOSecretType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSOSecretType other && Equals(other);
        public bool Equals(SSOSecretType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// HostPool type for desktop.
    /// </summary>
    [EnumType]
    public readonly struct ScalingHostPoolType : IEquatable<ScalingHostPoolType>
    {
        private readonly string _value;

        private ScalingHostPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users get a new (random) SessionHost every time it connects to the HostPool.
        /// </summary>
        public static ScalingHostPoolType Pooled { get; } = new ScalingHostPoolType("Pooled");

        public static bool operator ==(ScalingHostPoolType left, ScalingHostPoolType right) => left.Equals(right);
        public static bool operator !=(ScalingHostPoolType left, ScalingHostPoolType right) => !left.Equals(right);

        public static explicit operator string(ScalingHostPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScalingHostPoolType other && Equals(other);
        public bool Equals(ScalingHostPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The preferred mechanism for updating the agent components. This is either Scheduled or Default.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostComponentUpdateType : IEquatable<SessionHostComponentUpdateType>
    {
        private readonly string _value;

        private SessionHostComponentUpdateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The agent components are updated according to the AVD infrastructure flighting. For more information, see https://aka.ms/avdagent.
        /// </summary>
        public static SessionHostComponentUpdateType Default { get; } = new SessionHostComponentUpdateType("Default");
        /// <summary>
        /// This enables the Scheduled Agent Updates feature which allows the agent components to get updated according to the schedule that the admin define. For more information, see https://aka.ms/avdsau.
        /// </summary>
        public static SessionHostComponentUpdateType Scheduled { get; } = new SessionHostComponentUpdateType("Scheduled");

        public static bool operator ==(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => left.Equals(right);
        public static bool operator !=(SessionHostComponentUpdateType left, SessionHostComponentUpdateType right) => !left.Equals(right);

        public static explicit operator string(SessionHostComponentUpdateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostComponentUpdateType other && Equals(other);
        public bool Equals(SessionHostComponentUpdateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load balancing algorithm for ramp up period.
    /// </summary>
    [EnumType]
    public readonly struct SessionHostLoadBalancingAlgorithm : IEquatable<SessionHostLoadBalancingAlgorithm>
    {
        private readonly string _value;

        private SessionHostLoadBalancingAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SessionHostLoadBalancingAlgorithm BreadthFirst { get; } = new SessionHostLoadBalancingAlgorithm("BreadthFirst");
        public static SessionHostLoadBalancingAlgorithm DepthFirst { get; } = new SessionHostLoadBalancingAlgorithm("DepthFirst");

        public static bool operator ==(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => left.Equals(right);
        public static bool operator !=(SessionHostLoadBalancingAlgorithm left, SessionHostLoadBalancingAlgorithm right) => !left.Equals(right);

        public static explicit operator string(SessionHostLoadBalancingAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SessionHostLoadBalancingAlgorithm other && Equals(other);
        public bool Equals(SessionHostLoadBalancingAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
    /// </summary>
    [EnumType]
    public readonly struct SkuTier : IEquatable<SkuTier>
    {
        private readonly string _value;

        private SkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuTier Free { get; } = new SkuTier("Free");
        public static SkuTier Basic { get; } = new SkuTier("Basic");
        public static SkuTier Standard { get; } = new SkuTier("Standard");
        public static SkuTier Premium { get; } = new SkuTier("Premium");

        public static bool operator ==(SkuTier left, SkuTier right) => left.Equals(right);
        public static bool operator !=(SkuTier left, SkuTier right) => !left.Equals(right);

        public static explicit operator string(SkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuTier other && Equals(other);
        public bool Equals(SkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies when to stop hosts during ramp down period.
    /// </summary>
    [EnumType]
    public readonly struct StopHostsWhen : IEquatable<StopHostsWhen>
    {
        private readonly string _value;

        private StopHostsWhen(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StopHostsWhen ZeroSessions { get; } = new StopHostsWhen("ZeroSessions");
        public static StopHostsWhen ZeroActiveSessions { get; } = new StopHostsWhen("ZeroActiveSessions");

        public static bool operator ==(StopHostsWhen left, StopHostsWhen right) => left.Equals(right);
        public static bool operator !=(StopHostsWhen left, StopHostsWhen right) => !left.Equals(right);

        public static explicit operator string(StopHostsWhen value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StopHostsWhen other && Equals(other);
        public bool Equals(StopHostsWhen other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
