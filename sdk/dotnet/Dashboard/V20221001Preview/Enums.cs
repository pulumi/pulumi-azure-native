// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Dashboard.V20221001Preview
{
    /// <summary>
    /// The api key setting of the Grafana instance.
    /// </summary>
    [EnumType]
    public readonly struct ApiKey : IEquatable<ApiKey>
    {
        private readonly string _value;

        private ApiKey(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApiKey Disabled { get; } = new ApiKey("Disabled");
        public static ApiKey Enabled { get; } = new ApiKey("Enabled");

        public static bool operator ==(ApiKey left, ApiKey right) => left.Equals(right);
        public static bool operator !=(ApiKey left, ApiKey right) => !left.Equals(right);

        public static explicit operator string(ApiKey value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiKey other && Equals(other);
        public bool Equals(ApiKey other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope for dns deterministic name hash calculation.
    /// </summary>
    [EnumType]
    public readonly struct AutoGeneratedDomainNameLabelScope : IEquatable<AutoGeneratedDomainNameLabelScope>
    {
        private readonly string _value;

        private AutoGeneratedDomainNameLabelScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoGeneratedDomainNameLabelScope TenantReuse { get; } = new AutoGeneratedDomainNameLabelScope("TenantReuse");

        public static bool operator ==(AutoGeneratedDomainNameLabelScope left, AutoGeneratedDomainNameLabelScope right) => left.Equals(right);
        public static bool operator !=(AutoGeneratedDomainNameLabelScope left, AutoGeneratedDomainNameLabelScope right) => !left.Equals(right);

        public static explicit operator string(AutoGeneratedDomainNameLabelScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoGeneratedDomainNameLabelScope other && Equals(other);
        public bool Equals(AutoGeneratedDomainNameLabelScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether a Grafana instance uses deterministic outbound IPs.
    /// </summary>
    [EnumType]
    public readonly struct DeterministicOutboundIP : IEquatable<DeterministicOutboundIP>
    {
        private readonly string _value;

        private DeterministicOutboundIP(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeterministicOutboundIP Disabled { get; } = new DeterministicOutboundIP("Disabled");
        public static DeterministicOutboundIP Enabled { get; } = new DeterministicOutboundIP("Enabled");

        public static bool operator ==(DeterministicOutboundIP left, DeterministicOutboundIP right) => left.Equals(right);
        public static bool operator !=(DeterministicOutboundIP left, DeterministicOutboundIP right) => !left.Equals(right);

        public static explicit operator string(DeterministicOutboundIP value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeterministicOutboundIP other && Equals(other);
        public bool Equals(DeterministicOutboundIP other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The AutoRenew setting of the Enterprise subscription
    /// </summary>
    [EnumType]
    public readonly struct MarketplaceAutoRenew : IEquatable<MarketplaceAutoRenew>
    {
        private readonly string _value;

        private MarketplaceAutoRenew(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MarketplaceAutoRenew Disabled { get; } = new MarketplaceAutoRenew("Disabled");
        public static MarketplaceAutoRenew Enabled { get; } = new MarketplaceAutoRenew("Enabled");

        public static bool operator ==(MarketplaceAutoRenew left, MarketplaceAutoRenew right) => left.Equals(right);
        public static bool operator !=(MarketplaceAutoRenew left, MarketplaceAutoRenew right) => !left.Equals(right);

        public static explicit operator string(MarketplaceAutoRenew value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MarketplaceAutoRenew other && Equals(other);
        public bool Equals(MarketplaceAutoRenew other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicate the state for enable or disable traffic over the public interface.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The StartTLSPolicy setting of the SMTP configuration
    /// https://pkg.go.dev/github.com/go-mail/mail#StartTLSPolicy
    /// </summary>
    [EnumType]
    public readonly struct StartTLSPolicy : IEquatable<StartTLSPolicy>
    {
        private readonly string _value;

        private StartTLSPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StartTLSPolicy OpportunisticStartTLS { get; } = new StartTLSPolicy("OpportunisticStartTLS");
        public static StartTLSPolicy MandatoryStartTLS { get; } = new StartTLSPolicy("MandatoryStartTLS");
        public static StartTLSPolicy NoStartTLS { get; } = new StartTLSPolicy("NoStartTLS");

        public static bool operator ==(StartTLSPolicy left, StartTLSPolicy right) => left.Equals(right);
        public static bool operator !=(StartTLSPolicy left, StartTLSPolicy right) => !left.Equals(right);

        public static explicit operator string(StartTLSPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StartTLSPolicy other && Equals(other);
        public bool Equals(StartTLSPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The zone redundancy setting of the Grafana instance.
    /// </summary>
    [EnumType]
    public readonly struct ZoneRedundancy : IEquatable<ZoneRedundancy>
    {
        private readonly string _value;

        private ZoneRedundancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ZoneRedundancy Disabled { get; } = new ZoneRedundancy("Disabled");
        public static ZoneRedundancy Enabled { get; } = new ZoneRedundancy("Enabled");

        public static bool operator ==(ZoneRedundancy left, ZoneRedundancy right) => left.Equals(right);
        public static bool operator !=(ZoneRedundancy left, ZoneRedundancy right) => !left.Equals(right);

        public static explicit operator string(ZoneRedundancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZoneRedundancy other && Equals(other);
        public bool Equals(ZoneRedundancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
