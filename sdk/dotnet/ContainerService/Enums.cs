// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ContainerService
{
    /// <summary>
    /// Action if Kubernetes namespace with same name already exists.
    /// </summary>
    [EnumType]
    public readonly struct AdoptionPolicy : IEquatable<AdoptionPolicy>
    {
        private readonly string _value;

        private AdoptionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If the namespace already exists in Kubernetes, attempts to create that same namespace in ARM will fail.
        /// </summary>
        public static AdoptionPolicy Never { get; } = new AdoptionPolicy("Never");
        /// <summary>
        /// Take over the existing namespace to be managed by ARM, if there is no difference.
        /// </summary>
        public static AdoptionPolicy IfIdentical { get; } = new AdoptionPolicy("IfIdentical");
        /// <summary>
        /// Always take over the existing namespace to be managed by ARM, some fields might be overwritten.
        /// </summary>
        public static AdoptionPolicy Always { get; } = new AdoptionPolicy("Always");

        public static bool operator ==(AdoptionPolicy left, AdoptionPolicy right) => left.Equals(right);
        public static bool operator !=(AdoptionPolicy left, AdoptionPolicy right) => !left.Equals(right);

        public static explicit operator string(AdoptionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdoptionPolicy other && Equals(other);
        public bool Equals(AdoptionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not specified, the default value is FQDN if security.enabled is set to true.
    /// </summary>
    [EnumType]
    public readonly struct AdvancedNetworkPolicies : IEquatable<AdvancedNetworkPolicies>
    {
        private readonly string _value;

        private AdvancedNetworkPolicies(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Enable Layer7 network policies (FQDN, HTTP/S, Kafka). This option is a superset of the FQDN option.
        /// </summary>
        public static AdvancedNetworkPolicies L7 { get; } = new AdvancedNetworkPolicies("L7");
        /// <summary>
        /// Enable FQDN based network policies
        /// </summary>
        public static AdvancedNetworkPolicies FQDN { get; } = new AdvancedNetworkPolicies("FQDN");
        /// <summary>
        /// Disable Layer 7 network policies (FQDN, HTTP/S, Kafka)
        /// </summary>
        public static AdvancedNetworkPolicies None { get; } = new AdvancedNetworkPolicies("None");

        public static bool operator ==(AdvancedNetworkPolicies left, AdvancedNetworkPolicies right) => left.Equals(right);
        public static bool operator !=(AdvancedNetworkPolicies left, AdvancedNetworkPolicies right) => !left.Equals(right);

        public static explicit operator string(AdvancedNetworkPolicies value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdvancedNetworkPolicies other && Equals(other);
        public bool Equals(AdvancedNetworkPolicies other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolMode : IEquatable<AgentPoolMode>
    {
        private readonly string _value;

        private AgentPoolMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// System agent pools are primarily for hosting critical system pods such as CoreDNS and metrics-server. System agent pools osType must be Linux. System agent pools VM SKU must have at least 2vCPUs and 4GB of memory.
        /// </summary>
        public static AgentPoolMode System { get; } = new AgentPoolMode("System");
        /// <summary>
        /// User agent pools are primarily for hosting your application pods.
        /// </summary>
        public static AgentPoolMode User { get; } = new AgentPoolMode("User");
        /// <summary>
        /// Gateway agent pools are dedicated to providing static egress IPs to pods. For more details, see https://aka.ms/aks/static-egress-gateway.
        /// </summary>
        public static AgentPoolMode Gateway { get; } = new AgentPoolMode("Gateway");

        public static bool operator ==(AgentPoolMode left, AgentPoolMode right) => left.Equals(right);
        public static bool operator !=(AgentPoolMode left, AgentPoolMode right) => !left.Equals(right);

        public static explicit operator string(AgentPoolMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolMode other && Equals(other);
        public bool Equals(AgentPoolMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// SSH access method of an agent pool.
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolSSHAccess : IEquatable<AgentPoolSSHAccess>
    {
        private readonly string _value;

        private AgentPoolSSHAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Can SSH onto the node as a local user using private key.
        /// </summary>
        public static AgentPoolSSHAccess LocalUser { get; } = new AgentPoolSSHAccess("LocalUser");
        /// <summary>
        /// SSH service will be turned off on the node.
        /// </summary>
        public static AgentPoolSSHAccess Disabled { get; } = new AgentPoolSSHAccess("Disabled");

        public static bool operator ==(AgentPoolSSHAccess left, AgentPoolSSHAccess right) => left.Equals(right);
        public static bool operator !=(AgentPoolSSHAccess left, AgentPoolSSHAccess right) => !left.Equals(right);

        public static explicit operator string(AgentPoolSSHAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolSSHAccess other && Equals(other);
        public bool Equals(AgentPoolSSHAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Agent Pool.
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolType : IEquatable<AgentPoolType>
    {
        private readonly string _value;

        private AgentPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create an Agent Pool backed by a Virtual Machine Scale Set.
        /// </summary>
        public static AgentPoolType VirtualMachineScaleSets { get; } = new AgentPoolType("VirtualMachineScaleSets");
        /// <summary>
        /// Use of this is strongly discouraged.
        /// </summary>
        public static AgentPoolType AvailabilitySet { get; } = new AgentPoolType("AvailabilitySet");
        /// <summary>
        /// Create an Agent Pool backed by a Single Instance VM orchestration mode.
        /// </summary>
        public static AgentPoolType VirtualMachines { get; } = new AgentPoolType("VirtualMachines");

        public static bool operator ==(AgentPoolType left, AgentPoolType right) => left.Equals(right);
        public static bool operator !=(AgentPoolType left, AgentPoolType right) => !left.Equals(right);

        public static explicit operator string(AgentPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolType other && Equals(other);
        public bool Equals(AgentPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The artifact source. The source where the artifacts are downloaded from.
    /// </summary>
    [EnumType]
    public readonly struct ArtifactSource : IEquatable<ArtifactSource>
    {
        private readonly string _value;

        private ArtifactSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// pull images from Azure Container Registry with cache
        /// </summary>
        public static ArtifactSource Cache { get; } = new ArtifactSource("Cache");
        /// <summary>
        /// pull images from Microsoft Artifact Registry
        /// </summary>
        public static ArtifactSource Direct { get; } = new ArtifactSource("Direct");

        public static bool operator ==(ArtifactSource left, ArtifactSource right) => left.Equals(right);
        public static bool operator !=(ArtifactSource left, ArtifactSource right) => !left.Equals(right);

        public static explicit operator string(ArtifactSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArtifactSource other && Equals(other);
        public bool Equals(ArtifactSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The node image upgrade type.
    /// </summary>
    [EnumType]
    public readonly struct AutoUpgradeNodeImageSelectionType : IEquatable<AutoUpgradeNodeImageSelectionType>
    {
        private readonly string _value;

        private AutoUpgradeNodeImageSelectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use the latest image version when upgrading nodes. Clusters may use different image versions (e.g., 'AKSUbuntu-1804gen2containerd-2021.10.12' and 'AKSUbuntu-1804gen2containerd-2021.10.19') because, for example, the latest available version is different in different regions.
        /// </summary>
        public static AutoUpgradeNodeImageSelectionType Latest { get; } = new AutoUpgradeNodeImageSelectionType("Latest");
        /// <summary>
        /// The image versions to upgrade nodes to are selected as described below: for each node pool in managed clusters affected by the update run, the system selects the latest image version such that it is available across all other node pools (in all other clusters) of the same image type. As a result, all node pools of the same image type will be upgraded to the same image version. For example, if the latest image version for image type 'AKSUbuntu-1804gen2containerd' is 'AKSUbuntu-1804gen2containerd-2021.10.12' for a node pool in cluster A in region X, and is 'AKSUbuntu-1804gen2containerd-2021.10.17' for a node pool in cluster B in region Y, the system will upgrade both node pools to image version 'AKSUbuntu-1804gen2containerd-2021.10.12'.
        /// </summary>
        public static AutoUpgradeNodeImageSelectionType Consistent { get; } = new AutoUpgradeNodeImageSelectionType("Consistent");

        public static bool operator ==(AutoUpgradeNodeImageSelectionType left, AutoUpgradeNodeImageSelectionType right) => left.Equals(right);
        public static bool operator !=(AutoUpgradeNodeImageSelectionType left, AutoUpgradeNodeImageSelectionType right) => !left.Equals(right);

        public static explicit operator string(AutoUpgradeNodeImageSelectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoUpgradeNodeImageSelectionType other && Equals(other);
        public bool Equals(AutoUpgradeNodeImageSelectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the managed inbound Load Balancer BackendPool.
    /// </summary>
    [EnumType]
    public readonly struct BackendPoolType : IEquatable<BackendPoolType>
    {
        private readonly string _value;

        private BackendPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the managed inbound Load Balancer BackendPool. https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#configure-load-balancer-backend.
        /// </summary>
        public static BackendPoolType NodeIPConfiguration { get; } = new BackendPoolType("NodeIPConfiguration");
        /// <summary>
        /// The type of the managed inbound Load Balancer BackendPool. https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#configure-load-balancer-backend.
        /// </summary>
        public static BackendPoolType NodeIP { get; } = new BackendPoolType("NodeIP");

        public static bool operator ==(BackendPoolType left, BackendPoolType right) => left.Equals(right);
        public static bool operator !=(BackendPoolType left, BackendPoolType right) => !left.Equals(right);

        public static explicit operator string(BackendPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendPoolType other && Equals(other);
        public bool Equals(BackendPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Tells whether the cluster is Running or Stopped
    /// </summary>
    [EnumType]
    public readonly struct Code : IEquatable<Code>
    {
        private readonly string _value;

        private Code(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The cluster is running.
        /// </summary>
        public static Code Running { get; } = new Code("Running");
        /// <summary>
        /// The cluster is stopped.
        /// </summary>
        public static Code Stopped { get; } = new Code("Stopped");

        public static bool operator ==(Code left, Code right) => left.Equals(right);
        public static bool operator !=(Code left, Code right) => !left.Equals(right);

        public static explicit operator string(Code value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Code other && Equals(other);
        public bool Equals(Code other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private link service connection status.
    /// </summary>
    [EnumType]
    public readonly struct ConnectionStatus : IEquatable<ConnectionStatus>
    {
        private readonly string _value;

        private ConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionStatus Pending { get; } = new ConnectionStatus("Pending");
        public static ConnectionStatus Approved { get; } = new ConnectionStatus("Approved");
        public static ConnectionStatus Rejected { get; } = new ConnectionStatus("Rejected");
        public static ConnectionStatus Disconnected { get; } = new ConnectionStatus("Disconnected");

        public static bool operator ==(ConnectionStatus left, ConnectionStatus right) => left.Equals(right);
        public static bool operator !=(ConnectionStatus left, ConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(ConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionStatus other && Equals(other);
        public bool Equals(ConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Delete options of a namespace.
    /// </summary>
    [EnumType]
    public readonly struct DeletePolicy : IEquatable<DeletePolicy>
    {
        private readonly string _value;

        private DeletePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Only delete the ARM resource, keep the Kubernetes namespace. Also delete the ManagedByARM label.
        /// </summary>
        public static DeletePolicy Keep { get; } = new DeletePolicy("Keep");
        /// <summary>
        /// Delete both the ARM resource and the Kubernetes namespace together.
        /// </summary>
        public static DeletePolicy Delete { get; } = new DeletePolicy("Delete");

        public static bool operator ==(DeletePolicy left, DeletePolicy right) => left.Equals(right);
        public static bool operator !=(DeletePolicy left, DeletePolicy right) => !left.Equals(right);

        public static explicit operator string(DeletePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeletePolicy other && Equals(other);
        public bool Equals(DeletePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deployment safeguards level. Possible values are Warn and Enforce
    /// </summary>
    [EnumType]
    public readonly struct DeploymentSafeguardsLevel : IEquatable<DeploymentSafeguardsLevel>
    {
        private readonly string _value;

        private DeploymentSafeguardsLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Best practice violations will only show warnings
        /// </summary>
        public static DeploymentSafeguardsLevel Warn { get; } = new DeploymentSafeguardsLevel("Warn");
        /// <summary>
        /// Best practice violations will be denied
        /// </summary>
        public static DeploymentSafeguardsLevel Enforce { get; } = new DeploymentSafeguardsLevel("Enforce");

        public static bool operator ==(DeploymentSafeguardsLevel left, DeploymentSafeguardsLevel right) => left.Equals(right);
        public static bool operator !=(DeploymentSafeguardsLevel left, DeploymentSafeguardsLevel right) => !left.Equals(right);

        public static explicit operator string(DeploymentSafeguardsLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentSafeguardsLevel other && Equals(other);
        public bool Equals(DeploymentSafeguardsLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stage at which the script is executed.
    /// Specifying `NodeImageBuildTime` will ensure changes are persisted into the node image.
    /// </summary>
    [EnumType]
    public readonly struct ExecutionPoint : IEquatable<ExecutionPoint>
    {
        private readonly string _value;

        private ExecutionPoint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Execute during node image build time.
        /// </summary>
        public static ExecutionPoint NodeImageBuildTime { get; } = new ExecutionPoint("NodeImageBuildTime");
        /// <summary>
        /// Execute during node provisioning time.
        /// </summary>
        public static ExecutionPoint NodeProvisionTime { get; } = new ExecutionPoint("NodeProvisionTime");

        public static bool operator ==(ExecutionPoint left, ExecutionPoint right) => left.Equals(right);
        public static bool operator !=(ExecutionPoint left, ExecutionPoint right) => !left.Equals(right);

        public static explicit operator string(ExecutionPoint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExecutionPoint other && Equals(other);
        public bool Equals(ExecutionPoint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The expander to use when scaling up. If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.
    /// </summary>
    [EnumType]
    public readonly struct Expander : IEquatable<Expander>
    {
        private readonly string _value;

        private Expander(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Selects the node group that will have the least idle CPU (if tied, unused memory) after scale-up. This is useful when you have different classes of nodes, for example, high CPU or high memory nodes, and only want to expand those when there are pending pods that need a lot of those resources.
        /// </summary>
        public static Expander Least_waste { get; } = new Expander("least-waste");
        /// <summary>
        /// Selects the node group that would be able to schedule the most pods when scaling up. This is useful when you are using nodeSelector to make sure certain pods land on certain nodes. Note that this won't cause the autoscaler to select bigger nodes vs. smaller, as it can add multiple smaller nodes at once.
        /// </summary>
        public static Expander Most_pods { get; } = new Expander("most-pods");
        /// <summary>
        /// Selects the node group that has the highest priority assigned by the user. It's configuration is described in more details [here](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md).
        /// </summary>
        public static Expander Priority { get; } = new Expander("priority");
        /// <summary>
        /// Used when you don't have a particular need for the node groups to scale differently.
        /// </summary>
        public static Expander Random { get; } = new Expander("random");

        public static bool operator ==(Expander left, Expander right) => left.Equals(right);
        public static bool operator !=(Expander left, Expander right) => !left.Equals(right);

        public static explicit operator string(Expander value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Expander other && Equals(other);
        public bool Equals(Expander other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to install GPU drivers. When it's not specified, default is Install.
    /// </summary>
    [EnumType]
    public readonly struct GPUDriver : IEquatable<GPUDriver>
    {
        private readonly string _value;

        private GPUDriver(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Install driver.
        /// </summary>
        public static GPUDriver Install { get; } = new GPUDriver("Install");
        /// <summary>
        /// Skip driver install.
        /// </summary>
        public static GPUDriver None { get; } = new GPUDriver("None");

        public static bool operator ==(GPUDriver left, GPUDriver right) => left.Equals(right);
        public static bool operator !=(GPUDriver left, GPUDriver right) => !left.Equals(right);

        public static explicit operator string(GPUDriver value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUDriver other && Equals(other);
        public bool Equals(GPUDriver other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
    /// </summary>
    [EnumType]
    public readonly struct GPUInstanceProfile : IEquatable<GPUInstanceProfile>
    {
        private readonly string _value;

        private GPUInstanceProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GPUInstanceProfile MIG1g { get; } = new GPUInstanceProfile("MIG1g");
        public static GPUInstanceProfile MIG2g { get; } = new GPUInstanceProfile("MIG2g");
        public static GPUInstanceProfile MIG3g { get; } = new GPUInstanceProfile("MIG3g");
        public static GPUInstanceProfile MIG4g { get; } = new GPUInstanceProfile("MIG4g");
        public static GPUInstanceProfile MIG7g { get; } = new GPUInstanceProfile("MIG7g");

        public static bool operator ==(GPUInstanceProfile left, GPUInstanceProfile right) => left.Equals(right);
        public static bool operator !=(GPUInstanceProfile left, GPUInstanceProfile right) => !left.Equals(right);

        public static explicit operator string(GPUInstanceProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUInstanceProfile other && Equals(other);
        public bool Equals(GPUInstanceProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP version to use for cluster networking and IP assignment.
    /// </summary>
    [EnumType]
    public readonly struct IpFamily : IEquatable<IpFamily>
    {
        private readonly string _value;

        private IpFamily(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpFamily IPv4 { get; } = new IpFamily("IPv4");
        public static IpFamily IPv6 { get; } = new IpFamily("IPv6");

        public static bool operator ==(IpFamily left, IpFamily right) => left.Equals(right);
        public static bool operator !=(IpFamily left, IpFamily right) => !left.Equals(right);

        public static explicit operator string(IpFamily value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpFamily other && Equals(other);
        public bool Equals(IpFamily other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode of an ingress gateway.
    /// </summary>
    [EnumType]
    public readonly struct IstioIngressGatewayMode : IEquatable<IstioIngressGatewayMode>
    {
        private readonly string _value;

        private IstioIngressGatewayMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The ingress gateway is assigned a public IP address and is publicly accessible.
        /// </summary>
        public static IstioIngressGatewayMode External { get; } = new IstioIngressGatewayMode("External");
        /// <summary>
        /// The ingress gateway is assigned an internal IP address and cannot is accessed publicly.
        /// </summary>
        public static IstioIngressGatewayMode Internal { get; } = new IstioIngressGatewayMode("Internal");

        public static bool operator ==(IstioIngressGatewayMode left, IstioIngressGatewayMode right) => left.Equals(right);
        public static bool operator !=(IstioIngressGatewayMode left, IstioIngressGatewayMode right) => !left.Equals(right);

        public static explicit operator string(IstioIngressGatewayMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IstioIngressGatewayMode other && Equals(other);
        public bool Equals(IstioIngressGatewayMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network access of the key vault. Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
    /// </summary>
    [EnumType]
    public readonly struct KeyVaultNetworkAccessTypes : IEquatable<KeyVaultNetworkAccessTypes>
    {
        private readonly string _value;

        private KeyVaultNetworkAccessTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyVaultNetworkAccessTypes Public { get; } = new KeyVaultNetworkAccessTypes("Public");
        public static KeyVaultNetworkAccessTypes Private { get; } = new KeyVaultNetworkAccessTypes("Private");

        public static bool operator ==(KeyVaultNetworkAccessTypes left, KeyVaultNetworkAccessTypes right) => left.Equals(right);
        public static bool operator !=(KeyVaultNetworkAccessTypes left, KeyVaultNetworkAccessTypes right) => !left.Equals(right);

        public static explicit operator string(KeyVaultNetworkAccessTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyVaultNetworkAccessTypes other && Equals(other);
        public bool Equals(KeyVaultNetworkAccessTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
    /// </summary>
    [EnumType]
    public readonly struct KubeletDiskType : IEquatable<KubeletDiskType>
    {
        private readonly string _value;

        private KubeletDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Kubelet will use the OS disk for its data.
        /// </summary>
        public static KubeletDiskType OS { get; } = new KubeletDiskType("OS");
        /// <summary>
        /// Kubelet will use the temporary disk for its data.
        /// </summary>
        public static KubeletDiskType Temporary { get; } = new KubeletDiskType("Temporary");

        public static bool operator ==(KubeletDiskType left, KubeletDiskType right) => left.Equals(right);
        public static bool operator !=(KubeletDiskType left, KubeletDiskType right) => !left.Equals(right);

        public static explicit operator string(KubeletDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KubeletDiskType other && Equals(other);
        public bool Equals(KubeletDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
    /// </summary>
    [EnumType]
    public readonly struct KubernetesSupportPlan : IEquatable<KubernetesSupportPlan>
    {
        private readonly string _value;

        private KubernetesSupportPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Support for the version is the same as for the open source Kubernetes offering. Official Kubernetes open source community support versions for 1 year after release.
        /// </summary>
        public static KubernetesSupportPlan KubernetesOfficial { get; } = new KubernetesSupportPlan("KubernetesOfficial");
        /// <summary>
        /// Support for the version extended past the KubernetesOfficial support of 1 year. AKS continues to patch CVEs for another 1 year, for a total of 2 years of support.
        /// </summary>
        public static KubernetesSupportPlan AKSLongTermSupport { get; } = new KubernetesSupportPlan("AKSLongTermSupport");

        public static bool operator ==(KubernetesSupportPlan left, KubernetesSupportPlan right) => left.Equals(right);
        public static bool operator !=(KubernetesSupportPlan left, KubernetesSupportPlan right) => !left.Equals(right);

        public static explicit operator string(KubernetesSupportPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KubernetesSupportPlan other && Equals(other);
        public bool Equals(KubernetesSupportPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
    /// </summary>
    [EnumType]
    public readonly struct LicenseType : IEquatable<LicenseType>
    {
        private readonly string _value;

        private LicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No additional licensing is applied.
        /// </summary>
        public static LicenseType None { get; } = new LicenseType("None");
        /// <summary>
        /// Enables Azure Hybrid User Benefits for Windows VMs.
        /// </summary>
        public static LicenseType Windows_Server { get; } = new LicenseType("Windows_Server");

        public static bool operator ==(LicenseType left, LicenseType right) => left.Equals(right);
        public static bool operator !=(LicenseType left, LicenseType right) => !left.Equals(right);

        public static explicit operator string(LicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LicenseType other && Equals(other);
        public bool Equals(LicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load balancer SKUs.
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerSku : IEquatable<LoadBalancerSku>
    {
        private readonly string _value;

        private LoadBalancerSku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use a a standard Load Balancer. This is the recommended Load Balancer SKU. For more information about on working with the load balancer in the managed cluster, see the [standard Load Balancer](https://docs.microsoft.com/azure/aks/load-balancer-standard) article.
        /// </summary>
        public static LoadBalancerSku Standard { get; } = new LoadBalancerSku("standard");
        /// <summary>
        /// Use a basic Load Balancer with limited functionality.
        /// </summary>
        public static LoadBalancerSku Basic { get; } = new LoadBalancerSku("basic");

        public static bool operator ==(LoadBalancerSku left, LoadBalancerSku right) => left.Equals(right);
        public static bool operator !=(LoadBalancerSku left, LoadBalancerSku right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerSku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerSku other && Equals(other);
        public bool Equals(LoadBalancerSku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of a managed cluster SKU.
    /// </summary>
    [EnumType]
    public readonly struct ManagedClusterSKUName : IEquatable<ManagedClusterSKUName>
    {
        private readonly string _value;

        private ManagedClusterSKUName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Base option for the AKS control plane.
        /// </summary>
        public static ManagedClusterSKUName Base { get; } = new ManagedClusterSKUName("Base");
        /// <summary>
        /// Automatic clusters are optimized to run most production workloads with configuration that follows AKS best practices and recommendations for cluster and workload setup, scalability, and security. For more details about Automatic clusters see aka.ms/aks/automatic.
        /// </summary>
        public static ManagedClusterSKUName Automatic { get; } = new ManagedClusterSKUName("Automatic");

        public static bool operator ==(ManagedClusterSKUName left, ManagedClusterSKUName right) => left.Equals(right);
        public static bool operator !=(ManagedClusterSKUName left, ManagedClusterSKUName right) => !left.Equals(right);

        public static explicit operator string(ManagedClusterSKUName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedClusterSKUName other && Equals(other);
        public bool Equals(ManagedClusterSKUName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
    /// </summary>
    [EnumType]
    public readonly struct ManagedClusterSKUTier : IEquatable<ManagedClusterSKUTier>
    {
        private readonly string _value;

        private ManagedClusterSKUTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cluster has premium capabilities in addition to all of the capabilities included in 'Standard'. Premium enables selection of LongTermSupport (aka.ms/aks/lts) for certain Kubernetes versions.
        /// </summary>
        public static ManagedClusterSKUTier Premium { get; } = new ManagedClusterSKUTier("Premium");
        /// <summary>
        /// Recommended for mission-critical and production workloads. Includes Kubernetes control plane autoscaling, workload-intensive testing, and up to 5,000 nodes per cluster. Guarantees 99.95% availability of the Kubernetes API server endpoint for clusters that use Availability Zones and 99.9% of availability for clusters that don't use Availability Zones.
        /// </summary>
        public static ManagedClusterSKUTier Standard { get; } = new ManagedClusterSKUTier("Standard");
        /// <summary>
        /// The cluster management is free, but charged for VM, storage, and networking usage. Best for experimenting, learning, simple testing, or workloads with fewer than 10 nodes. Not recommended for production use cases.
        /// </summary>
        public static ManagedClusterSKUTier Free { get; } = new ManagedClusterSKUTier("Free");

        public static bool operator ==(ManagedClusterSKUTier left, ManagedClusterSKUTier right) => left.Equals(right);
        public static bool operator !=(ManagedClusterSKUTier left, ManagedClusterSKUTier right) => !left.Equals(right);

        public static explicit operator string(ManagedClusterSKUTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedClusterSKUTier other && Equals(other);
        public bool Equals(ManagedClusterSKUTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ManagedClusterUpgradeType is the type of upgrade to be applied.
    /// </summary>
    [EnumType]
    public readonly struct ManagedClusterUpgradeType : IEquatable<ManagedClusterUpgradeType>
    {
        private readonly string _value;

        private ManagedClusterUpgradeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Full upgrades the control plane and all agent pools of the target ManagedClusters. Requires the ManagedClusterUpgradeSpec.KubernetesVersion property to be set.
        /// </summary>
        public static ManagedClusterUpgradeType Full { get; } = new ManagedClusterUpgradeType("Full");
        /// <summary>
        /// NodeImageOnly upgrades only the node images of the target ManagedClusters. Requires the ManagedClusterUpgradeSpec.KubernetesVersion property to NOT be set.
        /// </summary>
        public static ManagedClusterUpgradeType NodeImageOnly { get; } = new ManagedClusterUpgradeType("NodeImageOnly");
        /// <summary>
        /// ControlPlaneOnly upgrades only targets the KubernetesVersion of the ManagedClusters and will not be applied to the AgentPool. Requires the ManagedClusterUpgradeSpec.KubernetesVersion property to be set.
        /// </summary>
        public static ManagedClusterUpgradeType ControlPlaneOnly { get; } = new ManagedClusterUpgradeType("ControlPlaneOnly");

        public static bool operator ==(ManagedClusterUpgradeType left, ManagedClusterUpgradeType right) => left.Equals(right);
        public static bool operator !=(ManagedClusterUpgradeType left, ManagedClusterUpgradeType right) => !left.Equals(right);

        public static explicit operator string(ManagedClusterUpgradeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedClusterUpgradeType other && Equals(other);
        public bool Equals(ManagedClusterUpgradeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned, UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network dataplane used in the Kubernetes cluster.
    /// </summary>
    [EnumType]
    public readonly struct NetworkDataplane : IEquatable<NetworkDataplane>
    {
        private readonly string _value;

        private NetworkDataplane(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use Azure network dataplane.
        /// </summary>
        public static NetworkDataplane Azure { get; } = new NetworkDataplane("azure");
        /// <summary>
        /// Use Cilium network dataplane. See [Azure CNI Powered by Cilium](https://learn.microsoft.com/azure/aks/azure-cni-powered-by-cilium) for more information.
        /// </summary>
        public static NetworkDataplane Cilium { get; } = new NetworkDataplane("cilium");

        public static bool operator ==(NetworkDataplane left, NetworkDataplane right) => left.Equals(right);
        public static bool operator !=(NetworkDataplane left, NetworkDataplane right) => !left.Equals(right);

        public static explicit operator string(NetworkDataplane value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkDataplane other && Equals(other);
        public bool Equals(NetworkDataplane other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
    /// </summary>
    [EnumType]
    public readonly struct NetworkMode : IEquatable<NetworkMode>
    {
        private readonly string _value;

        private NetworkMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No bridge is created. Intra-VM Pod to Pod communication is through IP routes created by Azure CNI. See [Transparent Mode](https://docs.microsoft.com/azure/aks/faq#transparent-mode) for more information.
        /// </summary>
        public static NetworkMode Transparent { get; } = new NetworkMode("transparent");
        /// <summary>
        /// This is no longer supported
        /// </summary>
        public static NetworkMode Bridge { get; } = new NetworkMode("bridge");

        public static bool operator ==(NetworkMode left, NetworkMode right) => left.Equals(right);
        public static bool operator !=(NetworkMode left, NetworkMode right) => !left.Equals(right);

        public static explicit operator string(NetworkMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkMode other && Equals(other);
        public bool Equals(NetworkMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network plugin used for building the Kubernetes network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPlugin : IEquatable<NetworkPlugin>
    {
        private readonly string _value;

        private NetworkPlugin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use the Azure CNI network plugin. See [Azure CNI (advanced) networking](https://docs.microsoft.com/azure/aks/concepts-network#azure-cni-advanced-networking) for more information.
        /// </summary>
        public static NetworkPlugin Azure { get; } = new NetworkPlugin("azure");
        /// <summary>
        /// Use the Kubenet network plugin. See [Kubenet (basic) networking](https://docs.microsoft.com/azure/aks/concepts-network#kubenet-basic-networking) for more information.
        /// </summary>
        public static NetworkPlugin Kubenet { get; } = new NetworkPlugin("kubenet");
        /// <summary>
        /// No CNI plugin is pre-installed. See [BYO CNI](https://docs.microsoft.com/en-us/azure/aks/use-byo-cni) for more information.
        /// </summary>
        public static NetworkPlugin None { get; } = new NetworkPlugin("none");

        public static bool operator ==(NetworkPlugin left, NetworkPlugin right) => left.Equals(right);
        public static bool operator !=(NetworkPlugin left, NetworkPlugin right) => !left.Equals(right);

        public static explicit operator string(NetworkPlugin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPlugin other && Equals(other);
        public bool Equals(NetworkPlugin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode the network plugin should use.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPluginMode : IEquatable<NetworkPluginMode>
    {
        private readonly string _value;

        private NetworkPluginMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Used with networkPlugin=azure, pods are given IPs from the PodCIDR address space but use Azure Routing Domains rather than Kubenet's method of route tables. For more information visit https://aka.ms/aks/azure-cni-overlay.
        /// </summary>
        public static NetworkPluginMode Overlay { get; } = new NetworkPluginMode("overlay");

        public static bool operator ==(NetworkPluginMode left, NetworkPluginMode right) => left.Equals(right);
        public static bool operator !=(NetworkPluginMode left, NetworkPluginMode right) => !left.Equals(right);

        public static explicit operator string(NetworkPluginMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPluginMode other && Equals(other);
        public bool Equals(NetworkPluginMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network policy used for building the Kubernetes network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPolicy : IEquatable<NetworkPolicy>
    {
        private readonly string _value;

        private NetworkPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Network policies will not be enforced. This is the default value when NetworkPolicy is not specified.
        /// </summary>
        public static NetworkPolicy None { get; } = new NetworkPolicy("none");
        /// <summary>
        /// Use Calico network policies. See [differences between Azure and Calico policies](https://docs.microsoft.com/azure/aks/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information.
        /// </summary>
        public static NetworkPolicy Calico { get; } = new NetworkPolicy("calico");
        /// <summary>
        /// Use Azure network policies. See [differences between Azure and Calico policies](https://docs.microsoft.com/azure/aks/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information.
        /// </summary>
        public static NetworkPolicy Azure { get; } = new NetworkPolicy("azure");
        /// <summary>
        /// Use Cilium to enforce network policies. This requires networkDataplane to be 'cilium'.
        /// </summary>
        public static NetworkPolicy Cilium { get; } = new NetworkPolicy("cilium");

        public static bool operator ==(NetworkPolicy left, NetworkPolicy right) => left.Equals(right);
        public static bool operator !=(NetworkPolicy left, NetworkPolicy right) => !left.Equals(right);

        public static explicit operator string(NetworkPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPolicy other && Equals(other);
        public bool Equals(NetworkPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ingress type for the default NginxIngressController custom resource
    /// </summary>
    [EnumType]
    public readonly struct NginxIngressControllerType : IEquatable<NginxIngressControllerType>
    {
        private readonly string _value;

        private NginxIngressControllerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default NginxIngressController will be created. Users can edit the default NginxIngressController Custom Resource to configure load balancer annotations.
        /// </summary>
        public static NginxIngressControllerType AnnotationControlled { get; } = new NginxIngressControllerType("AnnotationControlled");
        /// <summary>
        /// The default NginxIngressController will be created and the operator will provision an external loadbalancer with it. Any annotation to make the default loadbalancer internal will be overwritten.
        /// </summary>
        public static NginxIngressControllerType External { get; } = new NginxIngressControllerType("External");
        /// <summary>
        /// The default NginxIngressController will be created and the operator will provision an internal loadbalancer with it. Any annotation to make the default loadbalancer external will be overwritten.
        /// </summary>
        public static NginxIngressControllerType Internal { get; } = new NginxIngressControllerType("Internal");
        /// <summary>
        /// The default Ingress Controller will not be created. It will not be deleted by the system if it exists. Users should delete the default NginxIngressController Custom Resource manually if desired.
        /// </summary>
        public static NginxIngressControllerType None { get; } = new NginxIngressControllerType("None");

        public static bool operator ==(NginxIngressControllerType left, NginxIngressControllerType right) => left.Equals(right);
        public static bool operator !=(NginxIngressControllerType left, NginxIngressControllerType right) => !left.Equals(right);

        public static explicit operator string(NginxIngressControllerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NginxIngressControllerType other && Equals(other);
        public bool Equals(NginxIngressControllerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The node image upgrade type.
    /// </summary>
    [EnumType]
    public readonly struct NodeImageSelectionType : IEquatable<NodeImageSelectionType>
    {
        private readonly string _value;

        private NodeImageSelectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use the latest image version when upgrading nodes. Clusters may use different image versions (e.g., 'AKSUbuntu-1804gen2containerd-2021.10.12' and 'AKSUbuntu-1804gen2containerd-2021.10.19') because, for example, the latest available version is different in different regions.
        /// </summary>
        public static NodeImageSelectionType Latest { get; } = new NodeImageSelectionType("Latest");
        /// <summary>
        /// The image versions to upgrade nodes to are selected as described below: for each node pool in managed clusters affected by the update run, the system selects the latest image version such that it is available across all other node pools (in all other clusters) of the same image type. As a result, all node pools of the same image type will be upgraded to the same image version. For example, if the latest image version for image type 'AKSUbuntu-1804gen2containerd' is 'AKSUbuntu-1804gen2containerd-2021.10.12' for a node pool in cluster A in region X, and is 'AKSUbuntu-1804gen2containerd-2021.10.17' for a node pool in cluster B in region Y, the system will upgrade both node pools to image version 'AKSUbuntu-1804gen2containerd-2021.10.12'.
        /// </summary>
        public static NodeImageSelectionType Consistent { get; } = new NodeImageSelectionType("Consistent");
        /// <summary>
        /// Upgrade the nodes to the custom image versions. When set, update run will use node image versions provided in customNodeImageVersions to upgrade the nodes. If set, customNodeImageVersions must not be empty.
        /// </summary>
        public static NodeImageSelectionType Custom { get; } = new NodeImageSelectionType("Custom");

        public static bool operator ==(NodeImageSelectionType left, NodeImageSelectionType right) => left.Equals(right);
        public static bool operator !=(NodeImageSelectionType left, NodeImageSelectionType right) => !left.Equals(right);

        public static explicit operator string(NodeImageSelectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeImageSelectionType other && Equals(other);
        public bool Equals(NodeImageSelectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
    /// </summary>
    [EnumType]
    public readonly struct NodeOSUpgradeChannel : IEquatable<NodeOSUpgradeChannel>
    {
        private readonly string _value;

        private NodeOSUpgradeChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No attempt to update your machines OS will be made either by OS or by rolling VHDs. This means you are responsible for your security updates
        /// </summary>
        public static NodeOSUpgradeChannel None { get; } = new NodeOSUpgradeChannel("None");
        /// <summary>
        /// OS updates will be applied automatically through the OS built-in patching infrastructure. Newly scaled in machines will be unpatched initially and will be patched at some point by the OS's infrastructure. Behavior of this option depends on the OS in question. Ubuntu and Mariner apply security patches through unattended upgrade roughly once a day around 06:00 UTC. Windows does not apply security patches automatically and so for them this option is equivalent to None till further notice
        /// </summary>
        public static NodeOSUpgradeChannel Unmanaged { get; } = new NodeOSUpgradeChannel("Unmanaged");
        /// <summary>
        /// AKS will update the nodes with a newly patched VHD containing security fixes and bugfixes on a weekly cadence. With the VHD update machines will be rolling reimaged to that VHD following maintenance windows and surge settings. No extra VHD cost is incurred when choosing this option as AKS hosts the images.
        /// </summary>
        public static NodeOSUpgradeChannel NodeImage { get; } = new NodeOSUpgradeChannel("NodeImage");
        /// <summary>
        /// AKS downloads and updates the nodes with tested security updates. These updates honor the maintenance window settings and produce a new VHD that is used on new nodes. On some occasions it's not possible to apply the updates in place, in such cases the existing nodes will also be re-imaged to the newly produced VHD in order to apply the changes. This option incurs an extra cost of hosting the new Security Patch VHDs in your resource group for just in time consumption.
        /// </summary>
        public static NodeOSUpgradeChannel SecurityPatch { get; } = new NodeOSUpgradeChannel("SecurityPatch");

        public static bool operator ==(NodeOSUpgradeChannel left, NodeOSUpgradeChannel right) => left.Equals(right);
        public static bool operator !=(NodeOSUpgradeChannel left, NodeOSUpgradeChannel right) => !left.Equals(right);

        public static explicit operator string(NodeOSUpgradeChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeOSUpgradeChannel other && Equals(other);
        public bool Equals(NodeOSUpgradeChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified, the default is Auto. For more information see aka.ms/aks/nap#node-pools.
    /// </summary>
    [EnumType]
    public readonly struct NodeProvisioningDefaultNodePools : IEquatable<NodeProvisioningDefaultNodePools>
    {
        private readonly string _value;

        private NodeProvisioningDefaultNodePools(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No Karpenter NodePools are provisioned automatically. Automatic scaling will not happen unless the user creates one or more NodePool CRD instances.
        /// </summary>
        public static NodeProvisioningDefaultNodePools None { get; } = new NodeProvisioningDefaultNodePools("None");
        /// <summary>
        /// A standard set of Karpenter NodePools are provisioned
        /// </summary>
        public static NodeProvisioningDefaultNodePools Auto { get; } = new NodeProvisioningDefaultNodePools("Auto");

        public static bool operator ==(NodeProvisioningDefaultNodePools left, NodeProvisioningDefaultNodePools right) => left.Equals(right);
        public static bool operator !=(NodeProvisioningDefaultNodePools left, NodeProvisioningDefaultNodePools right) => !left.Equals(right);

        public static explicit operator string(NodeProvisioningDefaultNodePools value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeProvisioningDefaultNodePools other && Equals(other);
        public bool Equals(NodeProvisioningDefaultNodePools other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The node provisioning mode. If not specified, the default is Manual.
    /// </summary>
    [EnumType]
    public readonly struct NodeProvisioningMode : IEquatable<NodeProvisioningMode>
    {
        private readonly string _value;

        private NodeProvisioningMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nodes are provisioned manually by the user
        /// </summary>
        public static NodeProvisioningMode Manual { get; } = new NodeProvisioningMode("Manual");
        /// <summary>
        /// Nodes are provisioned automatically by AKS using Karpenter (See aka.ms/aks/nap for more details). Fixed size Node Pools can still be created, but autoscaling Node Pools cannot be. (See aka.ms/aks/nap for more details).
        /// </summary>
        public static NodeProvisioningMode Auto { get; } = new NodeProvisioningMode("Auto");

        public static bool operator ==(NodeProvisioningMode left, NodeProvisioningMode right) => left.Equals(right);
        public static bool operator !=(NodeProvisioningMode left, NodeProvisioningMode right) => !left.Equals(right);

        public static explicit operator string(NodeProvisioningMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeProvisioningMode other && Equals(other);
        public bool Equals(NodeProvisioningMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
    /// </summary>
    [EnumType]
    public readonly struct OSDiskType : IEquatable<OSDiskType>
    {
        private readonly string _value;

        private OSDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Azure replicates the operating system disk for a virtual machine to Azure storage to avoid data loss should the VM need to be relocated to another host. Since containers aren't designed to have local state persisted, this behavior offers limited value while providing some drawbacks, including slower node provisioning and higher read/write latency.
        /// </summary>
        public static OSDiskType Managed { get; } = new OSDiskType("Managed");
        /// <summary>
        /// Ephemeral OS disks are stored only on the host machine, just like a temporary disk. This provides lower read/write latency, along with faster node scaling and cluster upgrades.
        /// </summary>
        public static OSDiskType Ephemeral { get; } = new OSDiskType("Ephemeral");

        public static bool operator ==(OSDiskType left, OSDiskType right) => left.Equals(right);
        public static bool operator !=(OSDiskType left, OSDiskType right) => !left.Equals(right);

        public static explicit operator string(OSDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSDiskType other && Equals(other);
        public bool Equals(OSDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when Kubernetes &lt;= 1.24 or Windows2022 when Kubernetes &gt;= 1.25 if OSType is Windows.
    /// </summary>
    [EnumType]
    public readonly struct OSSKU : IEquatable<OSSKU>
    {
        private readonly string _value;

        private OSSKU(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use Ubuntu as the OS for node images.
        /// </summary>
        public static OSSKU Ubuntu { get; } = new OSSKU("Ubuntu");
        /// <summary>
        /// Use AzureLinux as the OS for node images. Azure Linux is a container-optimized Linux distro built by Microsoft, visit https://aka.ms/azurelinux for more information.
        /// </summary>
        public static OSSKU AzureLinux { get; } = new OSSKU("AzureLinux");
        /// <summary>
        /// Use AzureLinux3 as the OS for node images. Azure Linux is a container-optimized Linux distro built by Microsoft, visit https://aka.ms/azurelinux for more information. For limitations, visit https://aka.ms/aks/node-images. For OS migration guidance, see https://aka.ms/aks/upgrade-os-version.
        /// </summary>
        public static OSSKU AzureLinux3 { get; } = new OSSKU("AzureLinux3");
        /// <summary>
        /// Deprecated OSSKU. Microsoft recommends that new deployments choose 'AzureLinux' instead.
        /// </summary>
        public static OSSKU CBLMariner { get; } = new OSSKU("CBLMariner");
        /// <summary>
        /// Use Windows2019 as the OS for node images. Unsupported for system node pools. Windows2019 only supports Windows2019 containers; it cannot run Windows2022 containers and vice versa.
        /// </summary>
        public static OSSKU Windows2019 { get; } = new OSSKU("Windows2019");
        /// <summary>
        /// Use Windows2022 as the OS for node images. Unsupported for system node pools. Windows2022 only supports Windows2022 containers; it cannot run Windows2019 containers and vice versa.
        /// </summary>
        public static OSSKU Windows2022 { get; } = new OSSKU("Windows2022");
        /// <summary>
        /// Use Ubuntu2204 as the OS for node images, however, Ubuntu 22.04 may not be supported for all nodepools. For limitations and supported kubernetes versions, see https://aka.ms/aks/supported-ubuntu-versions
        /// </summary>
        public static OSSKU Ubuntu2204 { get; } = new OSSKU("Ubuntu2204");

        public static bool operator ==(OSSKU left, OSSKU right) => left.Equals(right);
        public static bool operator !=(OSSKU left, OSSKU right) => !left.Equals(right);

        public static explicit operator string(OSSKU value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSSKU other && Equals(other);
        public bool Equals(OSSKU other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operating system type. The default is Linux.
    /// </summary>
    [EnumType]
    public readonly struct OSType : IEquatable<OSType>
    {
        private readonly string _value;

        private OSType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use Linux.
        /// </summary>
        public static OSType Linux { get; } = new OSType("Linux");
        /// <summary>
        /// Use Windows.
        /// </summary>
        public static OSType Windows { get; } = new OSType("Windows");

        public static bool operator ==(OSType left, OSType right) => left.Equals(right);
        public static bool operator !=(OSType left, OSType right) => !left.Equals(right);

        public static explicit operator string(OSType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSType other && Equals(other);
        public bool Equals(OSType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// operator represents a key's relationship to a set of values. Valid operators are In and NotIn
    /// </summary>
    [EnumType]
    public readonly struct Operator : IEquatable<Operator>
    {
        private readonly string _value;

        private Operator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The value of the key should be in the given list.
        /// </summary>
        public static Operator In { get; } = new Operator("In");
        /// <summary>
        /// The value of the key should not be in the given list.
        /// </summary>
        public static Operator NotIn { get; } = new Operator("NotIn");
        /// <summary>
        /// The value of the key should exist.
        /// </summary>
        public static Operator Exists { get; } = new Operator("Exists");
        /// <summary>
        /// The value of the key should not exist.
        /// </summary>
        public static Operator DoesNotExist { get; } = new Operator("DoesNotExist");

        public static bool operator ==(Operator left, Operator right) => left.Equals(right);
        public static bool operator !=(Operator left, Operator right) => !left.Equals(right);

        public static explicit operator string(Operator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Operator other && Equals(other);
        public bool Equals(Operator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
    /// </summary>
    [EnumType]
    public readonly struct OutboundType : IEquatable<OutboundType>
    {
        private readonly string _value;

        private OutboundType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The load balancer is used for egress through an AKS assigned public IP. This supports Kubernetes services of type 'loadBalancer'. For more information see [outbound type loadbalancer](https://docs.microsoft.com/azure/aks/egress-outboundtype#outbound-type-of-loadbalancer).
        /// </summary>
        public static OutboundType LoadBalancer { get; } = new OutboundType("loadBalancer");
        /// <summary>
        /// Egress paths must be defined by the user. This is an advanced scenario and requires proper network configuration. For more information see [outbound type userDefinedRouting](https://docs.microsoft.com/azure/aks/egress-outboundtype#outbound-type-of-userdefinedrouting).
        /// </summary>
        public static OutboundType UserDefinedRouting { get; } = new OutboundType("userDefinedRouting");
        /// <summary>
        /// The AKS-managed NAT gateway is used for egress.
        /// </summary>
        public static OutboundType ManagedNATGateway { get; } = new OutboundType("managedNATGateway");
        /// <summary>
        /// The user-assigned NAT gateway associated to the cluster subnet is used for egress. This is an advanced scenario and requires proper network configuration.
        /// </summary>
        public static OutboundType UserAssignedNATGateway { get; } = new OutboundType("userAssignedNATGateway");
        /// <summary>
        /// The AKS cluster is not set with any outbound-type. All AKS nodes follows Azure VM default outbound behavior. Please refer to https://azure.microsoft.com/en-us/updates/default-outbound-access-for-vms-in-azure-will-be-retired-transition-to-a-new-method-of-internet-access/
        /// </summary>
        public static OutboundType None { get; } = new OutboundType("none");

        public static bool operator ==(OutboundType left, OutboundType right) => left.Equals(right);
        public static bool operator !=(OutboundType left, OutboundType right) => !left.Equals(right);

        public static explicit operator string(OutboundType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OutboundType other && Equals(other);
        public bool Equals(OutboundType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with podSubnetId. The default is 'DynamicIndividual'.
    /// </summary>
    [EnumType]
    public readonly struct PodIPAllocationMode : IEquatable<PodIPAllocationMode>
    {
        private readonly string _value;

        private PodIPAllocationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Each node gets allocated with a non-contiguous list of IP addresses assignable to pods. This is better for maximizing a small to medium subnet of size /16 or smaller. The Azure CNI cluster with dynamic IP allocation defaults to this mode if the customer does not explicitly specify a podIPAllocationMode
        /// </summary>
        public static PodIPAllocationMode DynamicIndividual { get; } = new PodIPAllocationMode("DynamicIndividual");
        /// <summary>
        /// Each node is statically allocated CIDR block(s) of size /28 = 16 IPs per block to satisfy the maxPods per node. Number of CIDR blocks &gt;= (maxPods / 16). The block, rather than a single IP, counts against the Azure Vnet Private IP limit of 65K. Therefore block mode is suitable for running larger workloads with more than the current limit of 65K pods in a cluster. This mode is better suited to scale with larger subnets of /15 or bigger
        /// </summary>
        public static PodIPAllocationMode StaticBlock { get; } = new PodIPAllocationMode("StaticBlock");

        public static bool operator ==(PodIPAllocationMode left, PodIPAllocationMode right) => left.Equals(right);
        public static bool operator !=(PodIPAllocationMode left, PodIPAllocationMode right) => !left.Equals(right);

        public static explicit operator string(PodIPAllocationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PodIPAllocationMode other && Equals(other);
        public bool Equals(PodIPAllocationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ingress policy for the network.
    /// </summary>
    [EnumType]
    public readonly struct PolicyRule : IEquatable<PolicyRule>
    {
        private readonly string _value;

        private PolicyRule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Deny all network traffic.
        /// </summary>
        public static PolicyRule DenyAll { get; } = new PolicyRule("DenyAll");
        /// <summary>
        /// Allow all network traffic.
        /// </summary>
        public static PolicyRule AllowAll { get; } = new PolicyRule("AllowAll");
        /// <summary>
        /// Allow traffic within the same namespace.
        /// </summary>
        public static PolicyRule AllowSameNamespace { get; } = new PolicyRule("AllowSameNamespace");

        public static bool operator ==(PolicyRule left, PolicyRule right) => left.Equals(right);
        public static bool operator !=(PolicyRule left, PolicyRule right) => !left.Equals(right);

        public static explicit operator string(PolicyRule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyRule other && Equals(other);
        public bool Equals(PolicyRule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network protocol of the port.
    /// </summary>
    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TCP protocol.
        /// </summary>
        public static Protocol TCP { get; } = new Protocol("TCP");
        /// <summary>
        /// UDP protocol.
        /// </summary>
        public static Protocol UDP { get; } = new Protocol("UDP");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the managed cluster. For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use an implicitly created system assigned managed identity to manage cluster resources. Master components in the control plane such as kube-controller-manager will use the system assigned managed identity to manipulate Azure resources.
        /// </summary>
        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        /// <summary>
        /// Use a user-specified identity to manage cluster resources. Master components in the control plane such as kube-controller-manager will use the specified user assigned managed identity to manipulate Azure resources.
        /// </summary>
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        /// <summary>
        /// Do not use a managed identity for the Managed Cluster, service principal will be used instead.
        /// </summary>
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
    /// </summary>
    [EnumType]
    public readonly struct RestrictionLevel : IEquatable<RestrictionLevel>
    {
        private readonly string _value;

        private RestrictionLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// All RBAC permissions are allowed on the managed node resource group
        /// </summary>
        public static RestrictionLevel Unrestricted { get; } = new RestrictionLevel("Unrestricted");
        /// <summary>
        /// Only */read RBAC permissions allowed on the managed node resource group
        /// </summary>
        public static RestrictionLevel ReadOnly { get; } = new RestrictionLevel("ReadOnly");

        public static bool operator ==(RestrictionLevel left, RestrictionLevel right) => left.Equals(right);
        public static bool operator !=(RestrictionLevel left, RestrictionLevel right) => !left.Equals(right);

        public static explicit operator string(RestrictionLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RestrictionLevel other && Equals(other);
        public bool Equals(RestrictionLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
    /// </summary>
    [EnumType]
    public readonly struct ScaleDownMode : IEquatable<ScaleDownMode>
    {
        private readonly string _value;

        private ScaleDownMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create new instances during scale up and remove instances during scale down.
        /// </summary>
        public static ScaleDownMode Delete { get; } = new ScaleDownMode("Delete");
        /// <summary>
        /// Attempt to start deallocated instances (if they exist) during scale up and deallocate instances during scale down.
        /// </summary>
        public static ScaleDownMode Deallocate { get; } = new ScaleDownMode("Deallocate");

        public static bool operator ==(ScaleDownMode left, ScaleDownMode right) => left.Equals(right);
        public static bool operator !=(ScaleDownMode left, ScaleDownMode right) => !left.Equals(right);

        public static explicit operator string(ScaleDownMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleDownMode other && Equals(other);
        public bool Equals(ScaleDownMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Virtual Machine Scale Set eviction policy to use. This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.
    /// </summary>
    [EnumType]
    public readonly struct ScaleSetEvictionPolicy : IEquatable<ScaleSetEvictionPolicy>
    {
        private readonly string _value;

        private ScaleSetEvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nodes in the underlying Scale Set of the node pool are deleted when they're evicted.
        /// </summary>
        public static ScaleSetEvictionPolicy Delete { get; } = new ScaleSetEvictionPolicy("Delete");
        /// <summary>
        /// Nodes in the underlying Scale Set of the node pool are set to the stopped-deallocated state upon eviction. Nodes in the stopped-deallocated state count against your compute quota and can cause issues with cluster scaling or upgrading.
        /// </summary>
        public static ScaleSetEvictionPolicy Deallocate { get; } = new ScaleSetEvictionPolicy("Deallocate");

        public static bool operator ==(ScaleSetEvictionPolicy left, ScaleSetEvictionPolicy right) => left.Equals(right);
        public static bool operator !=(ScaleSetEvictionPolicy left, ScaleSetEvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(ScaleSetEvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleSetEvictionPolicy other && Equals(other);
        public bool Equals(ScaleSetEvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
    /// </summary>
    [EnumType]
    public readonly struct ScaleSetPriority : IEquatable<ScaleSetPriority>
    {
        private readonly string _value;

        private ScaleSetPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Spot priority VMs will be used. There is no SLA for spot nodes. See [spot on AKS](https://docs.microsoft.com/azure/aks/spot-node-pool) for more information.
        /// </summary>
        public static ScaleSetPriority Spot { get; } = new ScaleSetPriority("Spot");
        /// <summary>
        /// Regular VMs will be used.
        /// </summary>
        public static ScaleSetPriority Regular { get; } = new ScaleSetPriority("Regular");

        public static bool operator ==(ScaleSetPriority left, ScaleSetPriority right) => left.Equals(right);
        public static bool operator !=(ScaleSetPriority left, ScaleSetPriority right) => !left.Equals(right);

        public static explicit operator string(ScaleSetPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleSetPriority other && Equals(other);
        public bool Equals(ScaleSetPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The runtime environment for the script (e.g. Bash).
    /// </summary>
    [EnumType]
    public readonly struct ScriptType : IEquatable<ScriptType>
    {
        private readonly string _value;

        private ScriptType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Bash script.
        /// </summary>
        public static ScriptType Bash { get; } = new ScriptType("Bash");
        /// <summary>
        /// PowerShell script.
        /// </summary>
        public static ScriptType PowerShell { get; } = new ScriptType("PowerShell");

        public static bool operator ==(ScriptType left, ScriptType right) => left.Equals(right);
        public static bool operator !=(ScriptType left, ScriptType right) => !left.Equals(right);

        public static explicit operator string(ScriptType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScriptType other && Equals(other);
        public bool Equals(ScriptType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode of the service mesh.
    /// </summary>
    [EnumType]
    public readonly struct ServiceMeshMode : IEquatable<ServiceMeshMode>
    {
        private readonly string _value;

        private ServiceMeshMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Istio deployed as an AKS addon.
        /// </summary>
        public static ServiceMeshMode Istio { get; } = new ServiceMeshMode("Istio");
        /// <summary>
        /// Mesh is disabled.
        /// </summary>
        public static ServiceMeshMode Disabled { get; } = new ServiceMeshMode("Disabled");

        public static bool operator ==(ServiceMeshMode left, ServiceMeshMode right) => left.Equals(right);
        public static bool operator !=(ServiceMeshMode left, ServiceMeshMode right) => !left.Equals(right);

        public static explicit operator string(ServiceMeshMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceMeshMode other && Equals(other);
        public bool Equals(ServiceMeshMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of a snapshot. The default is NodePool.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotType : IEquatable<SnapshotType>
    {
        private readonly string _value;

        private SnapshotType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The snapshot is a snapshot of a node pool.
        /// </summary>
        public static SnapshotType NodePool { get; } = new SnapshotType("NodePool");

        public static bool operator ==(SnapshotType left, SnapshotType right) => left.Equals(right);
        public static bool operator !=(SnapshotType left, SnapshotType right) => !left.Equals(right);

        public static explicit operator string(SnapshotType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotType other && Equals(other);
        public bool Equals(SnapshotType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The week index. Specifies on which week of the month the dayOfWeek applies.
    /// </summary>
    [EnumType]
    public readonly struct Type : IEquatable<Type>
    {
        private readonly string _value;

        private Type(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// First week of the month.
        /// </summary>
        public static Type First { get; } = new Type("First");
        /// <summary>
        /// Second week of the month.
        /// </summary>
        public static Type Second { get; } = new Type("Second");
        /// <summary>
        /// Third week of the month.
        /// </summary>
        public static Type Third { get; } = new Type("Third");
        /// <summary>
        /// Fourth week of the month.
        /// </summary>
        public static Type Fourth { get; } = new Type("Fourth");
        /// <summary>
        /// Last week of the month.
        /// </summary>
        public static Type Last { get; } = new Type("Last");

        public static bool operator ==(Type left, Type right) => left.Equals(right);
        public static bool operator !=(Type left, Type right) => !left.Equals(right);

        public static explicit operator string(Type value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Type other && Equals(other);
        public bool Equals(Type other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period is exceeding the remaining per-node drain timeout or pod is still being in a running state, can also cause undrainable nodes.
    /// </summary>
    [EnumType]
    public readonly struct UndrainableNodeBehavior : IEquatable<UndrainableNodeBehavior>
    {
        private readonly string _value;

        private UndrainableNodeBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AKS will cordon the blocked nodes and replace them with surge nodes during upgrade. The blocked nodes will be cordoned and replaced by surge nodes. The blocked nodes will have label 'kubernetes.azure.com/upgrade-status:Quarantined'. A surge node will be retained for each blocked node. A best-effort attempt will be made to delete all other surge nodes. If there are enough surge nodes to replace blocked nodes, then the upgrade operation and the managed cluster will be in failed state. Otherwise, the upgrade operation and the managed cluster will be in canceled state.
        /// </summary>
        public static UndrainableNodeBehavior Cordon { get; } = new UndrainableNodeBehavior("Cordon");
        /// <summary>
        /// AKS will mark the blocked nodes schedulable, but the blocked nodes are not upgraded. A best-effort attempt will be made to delete all surge nodes. The upgrade operation and the managed cluster will be in failed state if there are any blocked nodes.
        /// </summary>
        public static UndrainableNodeBehavior Schedule { get; } = new UndrainableNodeBehavior("Schedule");

        public static bool operator ==(UndrainableNodeBehavior left, UndrainableNodeBehavior right) => left.Equals(right);
        public static bool operator !=(UndrainableNodeBehavior left, UndrainableNodeBehavior right) => !left.Equals(right);

        public static explicit operator string(UndrainableNodeBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UndrainableNodeBehavior other && Equals(other);
        public bool Equals(UndrainableNodeBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
    /// </summary>
    [EnumType]
    public readonly struct UpgradeChannel : IEquatable<UpgradeChannel>
    {
        private readonly string _value;

        private UpgradeChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically upgrade the cluster to the latest supported patch release on the latest supported minor version. In cases where the cluster is at a version of Kubernetes that is at an N-2 minor version where N is the latest supported minor version, the cluster first upgrades to the latest supported patch version on N-1 minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster first is upgraded to 1.18.6, then is upgraded to 1.19.1.
        /// </summary>
        public static UpgradeChannel Rapid { get; } = new UpgradeChannel("rapid");
        /// <summary>
        /// Automatically upgrade the cluster to the latest supported patch release on minor version N-1, where N is the latest supported minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.18.6.
        /// </summary>
        public static UpgradeChannel Stable { get; } = new UpgradeChannel("stable");
        /// <summary>
        /// Automatically upgrade the cluster to the latest supported patch version when it becomes available while keeping the minor version the same. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.17.9.
        /// </summary>
        public static UpgradeChannel Patch { get; } = new UpgradeChannel("patch");
        /// <summary>
        /// Automatically upgrade the node image to the latest version available. Consider using nodeOSUpgradeChannel instead as that allows you to configure node OS patching separate from Kubernetes version patching
        /// </summary>
        public static UpgradeChannel Node_image { get; } = new UpgradeChannel("node-image");
        /// <summary>
        /// Disables auto-upgrades and keeps the cluster at its current version of Kubernetes.
        /// </summary>
        public static UpgradeChannel None { get; } = new UpgradeChannel("none");

        public static bool operator ==(UpgradeChannel left, UpgradeChannel right) => left.Equals(right);
        public static bool operator !=(UpgradeChannel left, UpgradeChannel right) => !left.Equals(right);

        public static explicit operator string(UpgradeChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradeChannel other && Equals(other);
        public bool Equals(UpgradeChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day of the week.
    /// </summary>
    [EnumType]
    public readonly struct WeekDay : IEquatable<WeekDay>
    {
        private readonly string _value;

        private WeekDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WeekDay Sunday { get; } = new WeekDay("Sunday");
        public static WeekDay Monday { get; } = new WeekDay("Monday");
        public static WeekDay Tuesday { get; } = new WeekDay("Tuesday");
        public static WeekDay Wednesday { get; } = new WeekDay("Wednesday");
        public static WeekDay Thursday { get; } = new WeekDay("Thursday");
        public static WeekDay Friday { get; } = new WeekDay("Friday");
        public static WeekDay Saturday { get; } = new WeekDay("Saturday");

        public static bool operator ==(WeekDay left, WeekDay right) => left.Equals(right);
        public static bool operator !=(WeekDay left, WeekDay right) => !left.Equals(right);

        public static explicit operator string(WeekDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeekDay other && Equals(other);
        public bool Equals(WeekDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the type of workload a node can run.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadRuntime : IEquatable<WorkloadRuntime>
    {
        private readonly string _value;

        private WorkloadRuntime(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nodes will use Kubelet to run standard OCI container workloads.
        /// </summary>
        public static WorkloadRuntime OCIContainer { get; } = new WorkloadRuntime("OCIContainer");
        /// <summary>
        /// Nodes will use Krustlet to run WASM workloads using the WASI provider (Preview).
        /// </summary>
        public static WorkloadRuntime WasmWasi { get; } = new WorkloadRuntime("WasmWasi");

        public static bool operator ==(WorkloadRuntime left, WorkloadRuntime right) => left.Equals(right);
        public static bool operator !=(WorkloadRuntime left, WorkloadRuntime right) => !left.Equals(right);

        public static explicit operator string(WorkloadRuntime value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadRuntime other && Equals(other);
        public bool Equals(WorkloadRuntime other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
