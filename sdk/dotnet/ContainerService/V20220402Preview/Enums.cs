// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ContainerService.V20220402Preview
{
    /// <summary>
    /// A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolMode : IEquatable<AgentPoolMode>
    {
        private readonly string _value;

        private AgentPoolMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// System agent pools are primarily for hosting critical system pods such as CoreDNS and metrics-server. System agent pools osType must be Linux. System agent pools VM SKU must have at least 2vCPUs and 4GB of memory.
        /// </summary>
        public static AgentPoolMode System { get; } = new AgentPoolMode("System");
        /// <summary>
        /// User agent pools are primarily for hosting your application pods.
        /// </summary>
        public static AgentPoolMode User { get; } = new AgentPoolMode("User");

        public static bool operator ==(AgentPoolMode left, AgentPoolMode right) => left.Equals(right);
        public static bool operator !=(AgentPoolMode left, AgentPoolMode right) => !left.Equals(right);

        public static explicit operator string(AgentPoolMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolMode other && Equals(other);
        public bool Equals(AgentPoolMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of Agent Pool.
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolType : IEquatable<AgentPoolType>
    {
        private readonly string _value;

        private AgentPoolType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create an Agent Pool backed by a Virtual Machine Scale Set.
        /// </summary>
        public static AgentPoolType VirtualMachineScaleSets { get; } = new AgentPoolType("VirtualMachineScaleSets");
        /// <summary>
        /// Use of this is strongly discouraged.
        /// </summary>
        public static AgentPoolType AvailabilitySet { get; } = new AgentPoolType("AvailabilitySet");

        public static bool operator ==(AgentPoolType left, AgentPoolType right) => left.Equals(right);
        public static bool operator !=(AgentPoolType left, AgentPoolType right) => !left.Equals(right);

        public static explicit operator string(AgentPoolType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolType other && Equals(other);
        public bool Equals(AgentPoolType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Tells whether the cluster is Running or Stopped
    /// </summary>
    [EnumType]
    public readonly struct Code : IEquatable<Code>
    {
        private readonly string _value;

        private Code(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The cluster is running.
        /// </summary>
        public static Code Running { get; } = new Code("Running");
        /// <summary>
        /// The cluster is stopped.
        /// </summary>
        public static Code Stopped { get; } = new Code("Stopped");

        public static bool operator ==(Code left, Code right) => left.Equals(right);
        public static bool operator !=(Code left, Code right) => !left.Equals(right);

        public static explicit operator string(Code value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Code other && Equals(other);
        public bool Equals(Code other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
    /// </summary>
    [EnumType]
    public readonly struct GPUInstanceProfile : IEquatable<GPUInstanceProfile>
    {
        private readonly string _value;

        private GPUInstanceProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GPUInstanceProfile MIG1g { get; } = new GPUInstanceProfile("MIG1g");
        public static GPUInstanceProfile MIG2g { get; } = new GPUInstanceProfile("MIG2g");
        public static GPUInstanceProfile MIG3g { get; } = new GPUInstanceProfile("MIG3g");
        public static GPUInstanceProfile MIG4g { get; } = new GPUInstanceProfile("MIG4g");
        public static GPUInstanceProfile MIG7g { get; } = new GPUInstanceProfile("MIG7g");

        public static bool operator ==(GPUInstanceProfile left, GPUInstanceProfile right) => left.Equals(right);
        public static bool operator !=(GPUInstanceProfile left, GPUInstanceProfile right) => !left.Equals(right);

        public static explicit operator string(GPUInstanceProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUInstanceProfile other && Equals(other);
        public bool Equals(GPUInstanceProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
    /// </summary>
    [EnumType]
    public readonly struct KubeletDiskType : IEquatable<KubeletDiskType>
    {
        private readonly string _value;

        private KubeletDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Kubelet will use the OS disk for its data.
        /// </summary>
        public static KubeletDiskType OS { get; } = new KubeletDiskType("OS");
        /// <summary>
        /// Kubelet will use the temporary disk for its data.
        /// </summary>
        public static KubeletDiskType Temporary { get; } = new KubeletDiskType("Temporary");

        public static bool operator ==(KubeletDiskType left, KubeletDiskType right) => left.Equals(right);
        public static bool operator !=(KubeletDiskType left, KubeletDiskType right) => !left.Equals(right);

        public static explicit operator string(KubeletDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KubeletDiskType other && Equals(other);
        public bool Equals(KubeletDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
    /// </summary>
    [EnumType]
    public readonly struct OSDiskType : IEquatable<OSDiskType>
    {
        private readonly string _value;

        private OSDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Azure replicates the operating system disk for a virtual machine to Azure storage to avoid data loss should the VM need to be relocated to another host. Since containers aren't designed to have local state persisted, this behavior offers limited value while providing some drawbacks, including slower node provisioning and higher read/write latency.
        /// </summary>
        public static OSDiskType Managed { get; } = new OSDiskType("Managed");
        /// <summary>
        /// Ephemeral OS disks are stored only on the host machine, just like a temporary disk. This provides lower read/write latency, along with faster node scaling and cluster upgrades.
        /// </summary>
        public static OSDiskType Ephemeral { get; } = new OSDiskType("Ephemeral");

        public static bool operator ==(OSDiskType left, OSDiskType right) => left.Equals(right);
        public static bool operator !=(OSDiskType left, OSDiskType right) => !left.Equals(right);

        public static explicit operator string(OSDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSDiskType other && Equals(other);
        public bool Equals(OSDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the OS SKU used by the agent pool. If not specified, the default is Ubuntu if OSType=Linux or Windows2019 if OSType=Windows. And the default Windows OSSKU will be changed to Windows2022 after Windows2019 is deprecated.
    /// </summary>
    [EnumType]
    public readonly struct OSSKU : IEquatable<OSSKU>
    {
        private readonly string _value;

        private OSSKU(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OSSKU Ubuntu { get; } = new OSSKU("Ubuntu");
        public static OSSKU CBLMariner { get; } = new OSSKU("CBLMariner");
        public static OSSKU Windows2019 { get; } = new OSSKU("Windows2019");
        public static OSSKU Windows2022 { get; } = new OSSKU("Windows2022");

        public static bool operator ==(OSSKU left, OSSKU right) => left.Equals(right);
        public static bool operator !=(OSSKU left, OSSKU right) => !left.Equals(right);

        public static explicit operator string(OSSKU value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSSKU other && Equals(other);
        public bool Equals(OSSKU other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operating system type. The default is Linux.
    /// </summary>
    [EnumType]
    public readonly struct OSType : IEquatable<OSType>
    {
        private readonly string _value;

        private OSType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Use Linux.
        /// </summary>
        public static OSType Linux { get; } = new OSType("Linux");
        /// <summary>
        /// Use Windows.
        /// </summary>
        public static OSType Windows { get; } = new OSType("Windows");

        public static bool operator ==(OSType left, OSType right) => left.Equals(right);
        public static bool operator !=(OSType left, OSType right) => !left.Equals(right);

        public static explicit operator string(OSType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSType other && Equals(other);
        public bool Equals(OSType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
    /// </summary>
    [EnumType]
    public readonly struct ScaleDownMode : IEquatable<ScaleDownMode>
    {
        private readonly string _value;

        private ScaleDownMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Create new instances during scale up and remove instances during scale down.
        /// </summary>
        public static ScaleDownMode Delete { get; } = new ScaleDownMode("Delete");
        /// <summary>
        /// Attempt to start deallocated instances (if they exist) during scale up and deallocate instances during scale down.
        /// </summary>
        public static ScaleDownMode Deallocate { get; } = new ScaleDownMode("Deallocate");

        public static bool operator ==(ScaleDownMode left, ScaleDownMode right) => left.Equals(right);
        public static bool operator !=(ScaleDownMode left, ScaleDownMode right) => !left.Equals(right);

        public static explicit operator string(ScaleDownMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleDownMode other && Equals(other);
        public bool Equals(ScaleDownMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.
    /// </summary>
    [EnumType]
    public readonly struct ScaleSetEvictionPolicy : IEquatable<ScaleSetEvictionPolicy>
    {
        private readonly string _value;

        private ScaleSetEvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nodes in the underlying Scale Set of the node pool are deleted when they're evicted.
        /// </summary>
        public static ScaleSetEvictionPolicy Delete { get; } = new ScaleSetEvictionPolicy("Delete");
        /// <summary>
        /// Nodes in the underlying Scale Set of the node pool are set to the stopped-deallocated state upon eviction. Nodes in the stopped-deallocated state count against your compute quota and can cause issues with cluster scaling or upgrading.
        /// </summary>
        public static ScaleSetEvictionPolicy Deallocate { get; } = new ScaleSetEvictionPolicy("Deallocate");

        public static bool operator ==(ScaleSetEvictionPolicy left, ScaleSetEvictionPolicy right) => left.Equals(right);
        public static bool operator !=(ScaleSetEvictionPolicy left, ScaleSetEvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(ScaleSetEvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleSetEvictionPolicy other && Equals(other);
        public bool Equals(ScaleSetEvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
    /// </summary>
    [EnumType]
    public readonly struct ScaleSetPriority : IEquatable<ScaleSetPriority>
    {
        private readonly string _value;

        private ScaleSetPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Spot priority VMs will be used. There is no SLA for spot nodes. See [spot on AKS](https://docs.microsoft.com/azure/aks/spot-node-pool) for more information.
        /// </summary>
        public static ScaleSetPriority Spot { get; } = new ScaleSetPriority("Spot");
        /// <summary>
        /// Regular VMs will be used.
        /// </summary>
        public static ScaleSetPriority Regular { get; } = new ScaleSetPriority("Regular");

        public static bool operator ==(ScaleSetPriority left, ScaleSetPriority right) => left.Equals(right);
        public static bool operator !=(ScaleSetPriority left, ScaleSetPriority right) => !left.Equals(right);

        public static explicit operator string(ScaleSetPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleSetPriority other && Equals(other);
        public bool Equals(ScaleSetPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the type of workload a node can run.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadRuntime : IEquatable<WorkloadRuntime>
    {
        private readonly string _value;

        private WorkloadRuntime(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nodes will use Kubelet to run standard OCI container workloads.
        /// </summary>
        public static WorkloadRuntime OCIContainer { get; } = new WorkloadRuntime("OCIContainer");
        /// <summary>
        /// Nodes will use Krustlet to run WASM workloads using the WASI provider (Preview).
        /// </summary>
        public static WorkloadRuntime WasmWasi { get; } = new WorkloadRuntime("WasmWasi");

        public static bool operator ==(WorkloadRuntime left, WorkloadRuntime right) => left.Equals(right);
        public static bool operator !=(WorkloadRuntime left, WorkloadRuntime right) => !left.Equals(right);

        public static explicit operator string(WorkloadRuntime value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadRuntime other && Equals(other);
        public bool Equals(WorkloadRuntime other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
