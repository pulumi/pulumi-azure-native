// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.NetworkCloud.V20231001Preview
{
    /// <summary>
    /// The indicator of if this advertisement is also made to the network fabric associated with the Network Cloud Cluster. This field is ignored if fabricPeeringEnabled is set to False.
    /// </summary>
    [EnumType]
    public readonly struct AdvertiseToFabric : IEquatable<AdvertiseToFabric>
    {
        private readonly string _value;

        private AdvertiseToFabric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AdvertiseToFabric True { get; } = new AdvertiseToFabric("True");
        public static AdvertiseToFabric False { get; } = new AdvertiseToFabric("False");

        public static bool operator ==(AdvertiseToFabric left, AdvertiseToFabric right) => left.Equals(right);
        public static bool operator !=(AdvertiseToFabric left, AdvertiseToFabric right) => !left.Equals(right);

        public static explicit operator string(AdvertiseToFabric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdvertiseToFabric other && Equals(other);
        public bool Equals(AdvertiseToFabric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The selection of how this agent pool is utilized, either as a system pool or a user pool. System pools run the features and critical services for the Kubernetes Cluster, while user pools are dedicated to user workloads. Every Kubernetes cluster must contain at least one system node pool with at least one node.
    /// </summary>
    [EnumType]
    public readonly struct AgentPoolMode : IEquatable<AgentPoolMode>
    {
        private readonly string _value;

        private AgentPoolMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AgentPoolMode System { get; } = new AgentPoolMode("System");
        public static AgentPoolMode User { get; } = new AgentPoolMode("User");
        public static AgentPoolMode NotApplicable { get; } = new AgentPoolMode("NotApplicable");

        public static bool operator ==(AgentPoolMode left, AgentPoolMode right) => left.Equals(right);
        public static bool operator !=(AgentPoolMode left, AgentPoolMode right) => !left.Equals(right);

        public static explicit operator string(AgentPoolMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AgentPoolMode other && Equals(other);
        public bool Equals(AgentPoolMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access level allowed for the users in this key set.
    /// </summary>
    [EnumType]
    public readonly struct BareMetalMachineKeySetPrivilegeLevel : IEquatable<BareMetalMachineKeySetPrivilegeLevel>
    {
        private readonly string _value;

        private BareMetalMachineKeySetPrivilegeLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BareMetalMachineKeySetPrivilegeLevel Standard { get; } = new BareMetalMachineKeySetPrivilegeLevel("Standard");
        public static BareMetalMachineKeySetPrivilegeLevel Superuser { get; } = new BareMetalMachineKeySetPrivilegeLevel("Superuser");

        public static bool operator ==(BareMetalMachineKeySetPrivilegeLevel left, BareMetalMachineKeySetPrivilegeLevel right) => left.Equals(right);
        public static bool operator !=(BareMetalMachineKeySetPrivilegeLevel left, BareMetalMachineKeySetPrivilegeLevel right) => !left.Equals(right);

        public static explicit operator string(BareMetalMachineKeySetPrivilegeLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BareMetalMachineKeySetPrivilegeLevel other && Equals(other);
        public bool Equals(BareMetalMachineKeySetPrivilegeLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator to prevent the use of IP addresses ending with .0 and .255 for this pool. Enabling this option will only use IP addresses between .1 and .254 inclusive.
    /// </summary>
    [EnumType]
    public readonly struct BfdEnabled : IEquatable<BfdEnabled>
    {
        private readonly string _value;

        private BfdEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BfdEnabled True { get; } = new BfdEnabled("True");
        public static BfdEnabled False { get; } = new BfdEnabled("False");

        public static bool operator ==(BfdEnabled left, BfdEnabled right) => left.Equals(right);
        public static bool operator !=(BfdEnabled left, BfdEnabled right) => !left.Equals(right);

        public static explicit operator string(BfdEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BfdEnabled other && Equals(other);
        public bool Equals(BfdEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator to enable multi-hop peering support.
    /// </summary>
    [EnumType]
    public readonly struct BgpMultiHop : IEquatable<BgpMultiHop>
    {
        private readonly string _value;

        private BgpMultiHop(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BgpMultiHop True { get; } = new BgpMultiHop("True");
        public static BgpMultiHop False { get; } = new BgpMultiHop("False");

        public static bool operator ==(BgpMultiHop left, BgpMultiHop right) => left.Equals(right);
        public static bool operator !=(BgpMultiHop left, BgpMultiHop right) => !left.Equals(right);

        public static explicit operator string(BgpMultiHop value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BgpMultiHop other && Equals(other);
        public bool Equals(BgpMultiHop other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access level allowed for the users in this key set.
    /// </summary>
    [EnumType]
    public readonly struct BmcKeySetPrivilegeLevel : IEquatable<BmcKeySetPrivilegeLevel>
    {
        private readonly string _value;

        private BmcKeySetPrivilegeLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BmcKeySetPrivilegeLevel ReadOnly { get; } = new BmcKeySetPrivilegeLevel("ReadOnly");
        public static BmcKeySetPrivilegeLevel Administrator { get; } = new BmcKeySetPrivilegeLevel("Administrator");

        public static bool operator ==(BmcKeySetPrivilegeLevel left, BmcKeySetPrivilegeLevel right) => left.Equals(right);
        public static bool operator !=(BmcKeySetPrivilegeLevel left, BmcKeySetPrivilegeLevel right) => !left.Equals(right);

        public static explicit operator string(BmcKeySetPrivilegeLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BmcKeySetPrivilegeLevel other && Equals(other);
        public bool Equals(BmcKeySetPrivilegeLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the platform default endpoints are allowed for the egress traffic.
    /// </summary>
    [EnumType]
    public readonly struct CloudServicesNetworkEnableDefaultEgressEndpoints : IEquatable<CloudServicesNetworkEnableDefaultEgressEndpoints>
    {
        private readonly string _value;

        private CloudServicesNetworkEnableDefaultEgressEndpoints(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudServicesNetworkEnableDefaultEgressEndpoints True { get; } = new CloudServicesNetworkEnableDefaultEgressEndpoints("True");
        public static CloudServicesNetworkEnableDefaultEgressEndpoints False { get; } = new CloudServicesNetworkEnableDefaultEgressEndpoints("False");

        public static bool operator ==(CloudServicesNetworkEnableDefaultEgressEndpoints left, CloudServicesNetworkEnableDefaultEgressEndpoints right) => left.Equals(right);
        public static bool operator !=(CloudServicesNetworkEnableDefaultEgressEndpoints left, CloudServicesNetworkEnableDefaultEgressEndpoints right) => !left.Equals(right);

        public static explicit operator string(CloudServicesNetworkEnableDefaultEgressEndpoints value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudServicesNetworkEnableDefaultEgressEndpoints other && Equals(other);
        public bool Equals(CloudServicesNetworkEnableDefaultEgressEndpoints other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator if the specified key vault should be used to archive the secrets of the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterSecretArchiveEnabled : IEquatable<ClusterSecretArchiveEnabled>
    {
        private readonly string _value;

        private ClusterSecretArchiveEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterSecretArchiveEnabled True { get; } = new ClusterSecretArchiveEnabled("True");
        public static ClusterSecretArchiveEnabled False { get; } = new ClusterSecretArchiveEnabled("False");

        public static bool operator ==(ClusterSecretArchiveEnabled left, ClusterSecretArchiveEnabled right) => left.Equals(right);
        public static bool operator !=(ClusterSecretArchiveEnabled left, ClusterSecretArchiveEnabled right) => !left.Equals(right);

        public static explicit operator string(ClusterSecretArchiveEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterSecretArchiveEnabled other && Equals(other);
        public bool Equals(ClusterSecretArchiveEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of rack configuration for the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterType : IEquatable<ClusterType>
    {
        private readonly string _value;

        private ClusterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterType SingleRack { get; } = new ClusterType("SingleRack");
        public static ClusterType MultiRack { get; } = new ClusterType("MultiRack");

        public static bool operator ==(ClusterType left, ClusterType right) => left.Equals(right);
        public static bool operator !=(ClusterType left, ClusterType right) => !left.Equals(right);

        public static explicit operator string(ClusterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterType other && Equals(other);
        public bool Equals(ClusterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode of operation for runtime protection.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateStrategyType : IEquatable<ClusterUpdateStrategyType>
    {
        private readonly string _value;

        private ClusterUpdateStrategyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterUpdateStrategyType Rack { get; } = new ClusterUpdateStrategyType("Rack");

        public static bool operator ==(ClusterUpdateStrategyType left, ClusterUpdateStrategyType right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateStrategyType left, ClusterUpdateStrategyType right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateStrategyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateStrategyType other && Equals(other);
        public bool Equals(ClusterUpdateStrategyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the console access is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ConsoleEnabled : IEquatable<ConsoleEnabled>
    {
        private readonly string _value;

        private ConsoleEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConsoleEnabled True { get; } = new ConsoleEnabled("True");
        public static ConsoleEnabled False { get; } = new ConsoleEnabled("False");

        public static bool operator ==(ConsoleEnabled left, ConsoleEnabled right) => left.Equals(right);
        public static bool operator !=(ConsoleEnabled left, ConsoleEnabled right) => !left.Equals(right);

        public static explicit operator string(ConsoleEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsoleEnabled other && Equals(other);
        public bool Equals(ConsoleEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether this is the default gateway.
    /// Only one of the attached networks (including the CloudServicesNetwork attachment) for a single machine may be specified as True.
    /// </summary>
    [EnumType]
    public readonly struct DefaultGateway : IEquatable<DefaultGateway>
    {
        private readonly string _value;

        private DefaultGateway(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultGateway True { get; } = new DefaultGateway("True");
        public static DefaultGateway False { get; } = new DefaultGateway("False");

        public static bool operator ==(DefaultGateway left, DefaultGateway right) => left.Equals(right);
        public static bool operator !=(DefaultGateway left, DefaultGateway right) => !left.Equals(right);

        public static explicit operator string(DefaultGateway value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultGateway other && Equals(other);
        public bool Equals(DefaultGateway other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator to specify if the load balancer peers with the network fabric.
    /// </summary>
    [EnumType]
    public readonly struct FabricPeeringEnabled : IEquatable<FabricPeeringEnabled>
    {
        private readonly string _value;

        private FabricPeeringEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FabricPeeringEnabled True { get; } = new FabricPeeringEnabled("True");
        public static FabricPeeringEnabled False { get; } = new FabricPeeringEnabled("False");

        public static bool operator ==(FabricPeeringEnabled left, FabricPeeringEnabled right) => left.Equals(right);
        public static bool operator !=(FabricPeeringEnabled left, FabricPeeringEnabled right) => !left.Equals(right);

        public static explicit operator string(FabricPeeringEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FabricPeeringEnabled other && Equals(other);
        public bool Equals(FabricPeeringEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The size of the hugepages to allocate.
    /// </summary>
    [EnumType]
    public readonly struct HugepagesSize : IEquatable<HugepagesSize>
    {
        private readonly string _value;

        private HugepagesSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HugepagesSize HugepagesSize_2M { get; } = new HugepagesSize("2M");
        public static HugepagesSize HugepagesSize_1G { get; } = new HugepagesSize("1G");

        public static bool operator ==(HugepagesSize left, HugepagesSize right) => left.Equals(right);
        public static bool operator !=(HugepagesSize left, HugepagesSize right) => !left.Equals(right);

        public static explicit operator string(HugepagesSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HugepagesSize other && Equals(other);
        public bool Equals(HugepagesSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The indicator of whether or not to disable IPAM allocation on the network attachment definition injected into the Hybrid AKS Cluster.
    /// </summary>
    [EnumType]
    public readonly struct HybridAksIpamEnabled : IEquatable<HybridAksIpamEnabled>
    {
        private readonly string _value;

        private HybridAksIpamEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HybridAksIpamEnabled True { get; } = new HybridAksIpamEnabled("True");
        public static HybridAksIpamEnabled False { get; } = new HybridAksIpamEnabled("False");

        public static bool operator ==(HybridAksIpamEnabled left, HybridAksIpamEnabled right) => left.Equals(right);
        public static bool operator !=(HybridAksIpamEnabled left, HybridAksIpamEnabled right) => !left.Equals(right);

        public static explicit operator string(HybridAksIpamEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HybridAksIpamEnabled other && Equals(other);
        public bool Equals(HybridAksIpamEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The network plugin type for Hybrid AKS.
    /// </summary>
    [EnumType]
    public readonly struct HybridAksPluginType : IEquatable<HybridAksPluginType>
    {
        private readonly string _value;

        private HybridAksPluginType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HybridAksPluginType DPDK { get; } = new HybridAksPluginType("DPDK");
        public static HybridAksPluginType SRIOV { get; } = new HybridAksPluginType("SRIOV");
        public static HybridAksPluginType OSDevice { get; } = new HybridAksPluginType("OSDevice");

        public static bool operator ==(HybridAksPluginType left, HybridAksPluginType right) => left.Equals(right);
        public static bool operator !=(HybridAksPluginType left, HybridAksPluginType right) => !left.Equals(right);

        public static explicit operator string(HybridAksPluginType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HybridAksPluginType other && Equals(other);
        public bool Equals(HybridAksPluginType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the IP address allocation, defaulted to "DualStack".
    /// </summary>
    [EnumType]
    public readonly struct IpAllocationType : IEquatable<IpAllocationType>
    {
        private readonly string _value;

        private IpAllocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpAllocationType IPV4 { get; } = new IpAllocationType("IPV4");
        public static IpAllocationType IPV6 { get; } = new IpAllocationType("IPV6");
        public static IpAllocationType DualStack { get; } = new IpAllocationType("DualStack");

        public static bool operator ==(IpAllocationType left, IpAllocationType right) => left.Equals(right);
        public static bool operator !=(IpAllocationType left, IpAllocationType right) => !left.Equals(right);

        public static explicit operator string(IpAllocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpAllocationType other && Equals(other);
        public bool Equals(IpAllocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of how this network will be utilized by the Kubernetes cluster.
    /// </summary>
    [EnumType]
    public readonly struct KubernetesPluginType : IEquatable<KubernetesPluginType>
    {
        private readonly string _value;

        private KubernetesPluginType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KubernetesPluginType DPDK { get; } = new KubernetesPluginType("DPDK");
        public static KubernetesPluginType SRIOV { get; } = new KubernetesPluginType("SRIOV");
        public static KubernetesPluginType OSDevice { get; } = new KubernetesPluginType("OSDevice");
        public static KubernetesPluginType MACVLAN { get; } = new KubernetesPluginType("MACVLAN");
        public static KubernetesPluginType IPVLAN { get; } = new KubernetesPluginType("IPVLAN");

        public static bool operator ==(KubernetesPluginType left, KubernetesPluginType right) => left.Equals(right);
        public static bool operator !=(KubernetesPluginType left, KubernetesPluginType right) => !left.Equals(right);

        public static explicit operator string(KubernetesPluginType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KubernetesPluginType other && Equals(other);
        public bool Equals(KubernetesPluginType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indication of whether this network will or will not perform IP address management and allocate IP addresses when attached.
    /// </summary>
    [EnumType]
    public readonly struct L3NetworkConfigurationIpamEnabled : IEquatable<L3NetworkConfigurationIpamEnabled>
    {
        private readonly string _value;

        private L3NetworkConfigurationIpamEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static L3NetworkConfigurationIpamEnabled True { get; } = new L3NetworkConfigurationIpamEnabled("True");
        public static L3NetworkConfigurationIpamEnabled False { get; } = new L3NetworkConfigurationIpamEnabled("False");

        public static bool operator ==(L3NetworkConfigurationIpamEnabled left, L3NetworkConfigurationIpamEnabled right) => left.Equals(right);
        public static bool operator !=(L3NetworkConfigurationIpamEnabled left, L3NetworkConfigurationIpamEnabled right) => !left.Equals(right);

        public static explicit operator string(L3NetworkConfigurationIpamEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is L3NetworkConfigurationIpamEnabled other && Equals(other);
        public bool Equals(L3NetworkConfigurationIpamEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy for creating the OS disk.
    /// </summary>
    [EnumType]
    public readonly struct OsDiskCreateOption : IEquatable<OsDiskCreateOption>
    {
        private readonly string _value;

        private OsDiskCreateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsDiskCreateOption Ephemeral { get; } = new OsDiskCreateOption("Ephemeral");

        public static bool operator ==(OsDiskCreateOption left, OsDiskCreateOption right) => left.Equals(right);
        public static bool operator !=(OsDiskCreateOption left, OsDiskCreateOption right) => !left.Equals(right);

        public static explicit operator string(OsDiskCreateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsDiskCreateOption other && Equals(other);
        public bool Equals(OsDiskCreateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy for deleting the OS disk.
    /// </summary>
    [EnumType]
    public readonly struct OsDiskDeleteOption : IEquatable<OsDiskDeleteOption>
    {
        private readonly string _value;

        private OsDiskDeleteOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsDiskDeleteOption Delete { get; } = new OsDiskDeleteOption("Delete");

        public static bool operator ==(OsDiskDeleteOption left, OsDiskDeleteOption right) => left.Equals(right);
        public static bool operator !=(OsDiskDeleteOption left, OsDiskDeleteOption right) => !left.Equals(right);

        public static explicit operator string(OsDiskDeleteOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsDiskDeleteOption other && Equals(other);
        public bool Equals(OsDiskDeleteOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode of operation for runtime protection.
    /// </summary>
    [EnumType]
    public readonly struct RuntimeProtectionEnforcementLevel : IEquatable<RuntimeProtectionEnforcementLevel>
    {
        private readonly string _value;

        private RuntimeProtectionEnforcementLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuntimeProtectionEnforcementLevel Audit { get; } = new RuntimeProtectionEnforcementLevel("Audit");
        public static RuntimeProtectionEnforcementLevel Disabled { get; } = new RuntimeProtectionEnforcementLevel("Disabled");
        public static RuntimeProtectionEnforcementLevel OnDemand { get; } = new RuntimeProtectionEnforcementLevel("OnDemand");
        public static RuntimeProtectionEnforcementLevel Passive { get; } = new RuntimeProtectionEnforcementLevel("Passive");
        public static RuntimeProtectionEnforcementLevel RealTime { get; } = new RuntimeProtectionEnforcementLevel("RealTime");

        public static bool operator ==(RuntimeProtectionEnforcementLevel left, RuntimeProtectionEnforcementLevel right) => left.Equals(right);
        public static bool operator !=(RuntimeProtectionEnforcementLevel left, RuntimeProtectionEnforcementLevel right) => !left.Equals(right);

        public static explicit operator string(RuntimeProtectionEnforcementLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuntimeProtectionEnforcementLevel other && Equals(other);
        public bool Equals(RuntimeProtectionEnforcementLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selection of how the type evaluation is applied to the cluster calculation.
    /// </summary>
    [EnumType]
    public readonly struct ValidationThresholdGrouping : IEquatable<ValidationThresholdGrouping>
    {
        private readonly string _value;

        private ValidationThresholdGrouping(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValidationThresholdGrouping PerCluster { get; } = new ValidationThresholdGrouping("PerCluster");
        public static ValidationThresholdGrouping PerRack { get; } = new ValidationThresholdGrouping("PerRack");

        public static bool operator ==(ValidationThresholdGrouping left, ValidationThresholdGrouping right) => left.Equals(right);
        public static bool operator !=(ValidationThresholdGrouping left, ValidationThresholdGrouping right) => !left.Equals(right);

        public static explicit operator string(ValidationThresholdGrouping value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValidationThresholdGrouping other && Equals(other);
        public bool Equals(ValidationThresholdGrouping other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selection of how the threshold should be evaluated.
    /// </summary>
    [EnumType]
    public readonly struct ValidationThresholdType : IEquatable<ValidationThresholdType>
    {
        private readonly string _value;

        private ValidationThresholdType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValidationThresholdType CountSuccess { get; } = new ValidationThresholdType("CountSuccess");
        public static ValidationThresholdType PercentSuccess { get; } = new ValidationThresholdType("PercentSuccess");

        public static bool operator ==(ValidationThresholdType left, ValidationThresholdType right) => left.Equals(right);
        public static bool operator !=(ValidationThresholdType left, ValidationThresholdType right) => !left.Equals(right);

        public static explicit operator string(ValidationThresholdType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValidationThresholdType other && Equals(other);
        public bool Equals(ValidationThresholdType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selects the boot method for the virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineBootMethod : IEquatable<VirtualMachineBootMethod>
    {
        private readonly string _value;

        private VirtualMachineBootMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineBootMethod UEFI { get; } = new VirtualMachineBootMethod("UEFI");
        public static VirtualMachineBootMethod BIOS { get; } = new VirtualMachineBootMethod("BIOS");

        public static bool operator ==(VirtualMachineBootMethod left, VirtualMachineBootMethod right) => left.Equals(right);
        public static bool operator !=(VirtualMachineBootMethod left, VirtualMachineBootMethod right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineBootMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineBootMethod other && Equals(other);
        public bool Equals(VirtualMachineBootMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the device model to use.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineDeviceModelType : IEquatable<VirtualMachineDeviceModelType>
    {
        private readonly string _value;

        private VirtualMachineDeviceModelType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineDeviceModelType T1 { get; } = new VirtualMachineDeviceModelType("T1");
        public static VirtualMachineDeviceModelType T2 { get; } = new VirtualMachineDeviceModelType("T2");

        public static bool operator ==(VirtualMachineDeviceModelType left, VirtualMachineDeviceModelType right) => left.Equals(right);
        public static bool operator !=(VirtualMachineDeviceModelType left, VirtualMachineDeviceModelType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineDeviceModelType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineDeviceModelType other && Equals(other);
        public bool Equals(VirtualMachineDeviceModelType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP allocation mechanism for the virtual machine.
    /// Dynamic and Static are only valid for l3Network which may also specify Disabled.
    /// Otherwise, Disabled is the only permitted value.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineIPAllocationMethod : IEquatable<VirtualMachineIPAllocationMethod>
    {
        private readonly string _value;

        private VirtualMachineIPAllocationMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineIPAllocationMethod Dynamic { get; } = new VirtualMachineIPAllocationMethod("Dynamic");
        public static VirtualMachineIPAllocationMethod Static { get; } = new VirtualMachineIPAllocationMethod("Static");
        public static VirtualMachineIPAllocationMethod Disabled { get; } = new VirtualMachineIPAllocationMethod("Disabled");

        public static bool operator ==(VirtualMachineIPAllocationMethod left, VirtualMachineIPAllocationMethod right) => left.Equals(right);
        public static bool operator !=(VirtualMachineIPAllocationMethod left, VirtualMachineIPAllocationMethod right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineIPAllocationMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineIPAllocationMethod other && Equals(other);
        public bool Equals(VirtualMachineIPAllocationMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated, the value will be ignored if provided. The indicator of whether one of the specified CPU cores is isolated to run the emulator thread for this virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineIsolateEmulatorThread : IEquatable<VirtualMachineIsolateEmulatorThread>
    {
        private readonly string _value;

        private VirtualMachineIsolateEmulatorThread(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineIsolateEmulatorThread True { get; } = new VirtualMachineIsolateEmulatorThread("True");
        public static VirtualMachineIsolateEmulatorThread False { get; } = new VirtualMachineIsolateEmulatorThread("False");

        public static bool operator ==(VirtualMachineIsolateEmulatorThread left, VirtualMachineIsolateEmulatorThread right) => left.Equals(right);
        public static bool operator !=(VirtualMachineIsolateEmulatorThread left, VirtualMachineIsolateEmulatorThread right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineIsolateEmulatorThread value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineIsolateEmulatorThread other && Equals(other);
        public bool Equals(VirtualMachineIsolateEmulatorThread other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope for the virtual machine affinity or anti-affinity placement hint. It should always be "Machine" in the case of node affinity.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePlacementHintPodAffinityScope : IEquatable<VirtualMachinePlacementHintPodAffinityScope>
    {
        private readonly string _value;

        private VirtualMachinePlacementHintPodAffinityScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePlacementHintPodAffinityScope Rack { get; } = new VirtualMachinePlacementHintPodAffinityScope("Rack");
        public static VirtualMachinePlacementHintPodAffinityScope Machine { get; } = new VirtualMachinePlacementHintPodAffinityScope("Machine");

        public static bool operator ==(VirtualMachinePlacementHintPodAffinityScope left, VirtualMachinePlacementHintPodAffinityScope right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePlacementHintPodAffinityScope left, VirtualMachinePlacementHintPodAffinityScope right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePlacementHintPodAffinityScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePlacementHintPodAffinityScope other && Equals(other);
        public bool Equals(VirtualMachinePlacementHintPodAffinityScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specification of whether this hint supports affinity or anti-affinity with the referenced resources.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePlacementHintType : IEquatable<VirtualMachinePlacementHintType>
    {
        private readonly string _value;

        private VirtualMachinePlacementHintType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePlacementHintType Affinity { get; } = new VirtualMachinePlacementHintType("Affinity");
        public static VirtualMachinePlacementHintType AntiAffinity { get; } = new VirtualMachinePlacementHintType("AntiAffinity");

        public static bool operator ==(VirtualMachinePlacementHintType left, VirtualMachinePlacementHintType right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePlacementHintType left, VirtualMachinePlacementHintType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePlacementHintType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePlacementHintType other && Equals(other);
        public bool Equals(VirtualMachinePlacementHintType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the hint is a hard or soft requirement during scheduling.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineSchedulingExecution : IEquatable<VirtualMachineSchedulingExecution>
    {
        private readonly string _value;

        private VirtualMachineSchedulingExecution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineSchedulingExecution Hard { get; } = new VirtualMachineSchedulingExecution("Hard");
        public static VirtualMachineSchedulingExecution Soft { get; } = new VirtualMachineSchedulingExecution("Soft");

        public static bool operator ==(VirtualMachineSchedulingExecution left, VirtualMachineSchedulingExecution right) => left.Equals(right);
        public static bool operator !=(VirtualMachineSchedulingExecution left, VirtualMachineSchedulingExecution right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineSchedulingExecution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineSchedulingExecution other && Equals(other);
        public bool Equals(VirtualMachineSchedulingExecution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated, use virtualizationModel instead. The type of the virtio interface.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineVirtioInterfaceType : IEquatable<VirtualMachineVirtioInterfaceType>
    {
        private readonly string _value;

        private VirtualMachineVirtioInterfaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineVirtioInterfaceType Modern { get; } = new VirtualMachineVirtioInterfaceType("Modern");
        public static VirtualMachineVirtioInterfaceType Transitional { get; } = new VirtualMachineVirtioInterfaceType("Transitional");

        public static bool operator ==(VirtualMachineVirtioInterfaceType left, VirtualMachineVirtioInterfaceType right) => left.Equals(right);
        public static bool operator !=(VirtualMachineVirtioInterfaceType left, VirtualMachineVirtioInterfaceType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineVirtioInterfaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineVirtioInterfaceType other && Equals(other);
        public bool Equals(VirtualMachineVirtioInterfaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
