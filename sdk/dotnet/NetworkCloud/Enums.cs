// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.NetworkCloud
{
    /// <summary>
    /// The access level allowed for the users in this key set.
    /// </summary>
    [EnumType]
    public readonly struct BareMetalMachineKeySetPrivilegeLevel : IEquatable<BareMetalMachineKeySetPrivilegeLevel>
    {
        private readonly string _value;

        private BareMetalMachineKeySetPrivilegeLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BareMetalMachineKeySetPrivilegeLevel Standard { get; } = new BareMetalMachineKeySetPrivilegeLevel("Standard");
        public static BareMetalMachineKeySetPrivilegeLevel Superuser { get; } = new BareMetalMachineKeySetPrivilegeLevel("Superuser");

        public static bool operator ==(BareMetalMachineKeySetPrivilegeLevel left, BareMetalMachineKeySetPrivilegeLevel right) => left.Equals(right);
        public static bool operator !=(BareMetalMachineKeySetPrivilegeLevel left, BareMetalMachineKeySetPrivilegeLevel right) => !left.Equals(right);

        public static explicit operator string(BareMetalMachineKeySetPrivilegeLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BareMetalMachineKeySetPrivilegeLevel other && Equals(other);
        public bool Equals(BareMetalMachineKeySetPrivilegeLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access level allowed for the users in this key set.
    /// </summary>
    [EnumType]
    public readonly struct BmcKeySetPrivilegeLevel : IEquatable<BmcKeySetPrivilegeLevel>
    {
        private readonly string _value;

        private BmcKeySetPrivilegeLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BmcKeySetPrivilegeLevel ReadOnly { get; } = new BmcKeySetPrivilegeLevel("ReadOnly");
        public static BmcKeySetPrivilegeLevel Administrator { get; } = new BmcKeySetPrivilegeLevel("Administrator");

        public static bool operator ==(BmcKeySetPrivilegeLevel left, BmcKeySetPrivilegeLevel right) => left.Equals(right);
        public static bool operator !=(BmcKeySetPrivilegeLevel left, BmcKeySetPrivilegeLevel right) => !left.Equals(right);

        public static explicit operator string(BmcKeySetPrivilegeLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BmcKeySetPrivilegeLevel other && Equals(other);
        public bool Equals(BmcKeySetPrivilegeLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the platform default endpoints are allowed for the egress traffic.
    /// </summary>
    [EnumType]
    public readonly struct CloudServicesNetworkEnableDefaultEgressEndpoints : IEquatable<CloudServicesNetworkEnableDefaultEgressEndpoints>
    {
        private readonly string _value;

        private CloudServicesNetworkEnableDefaultEgressEndpoints(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudServicesNetworkEnableDefaultEgressEndpoints True { get; } = new CloudServicesNetworkEnableDefaultEgressEndpoints("True");
        public static CloudServicesNetworkEnableDefaultEgressEndpoints False { get; } = new CloudServicesNetworkEnableDefaultEgressEndpoints("False");

        public static bool operator ==(CloudServicesNetworkEnableDefaultEgressEndpoints left, CloudServicesNetworkEnableDefaultEgressEndpoints right) => left.Equals(right);
        public static bool operator !=(CloudServicesNetworkEnableDefaultEgressEndpoints left, CloudServicesNetworkEnableDefaultEgressEndpoints right) => !left.Equals(right);

        public static explicit operator string(CloudServicesNetworkEnableDefaultEgressEndpoints value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudServicesNetworkEnableDefaultEgressEndpoints other && Equals(other);
        public bool Equals(CloudServicesNetworkEnableDefaultEgressEndpoints other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of rack configuration for the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterType : IEquatable<ClusterType>
    {
        private readonly string _value;

        private ClusterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterType SingleRack { get; } = new ClusterType("SingleRack");
        public static ClusterType MultiRack { get; } = new ClusterType("MultiRack");

        public static bool operator ==(ClusterType left, ClusterType right) => left.Equals(right);
        public static bool operator !=(ClusterType left, ClusterType right) => !left.Equals(right);

        public static explicit operator string(ClusterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterType other && Equals(other);
        public bool Equals(ClusterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the console access is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ConsoleEnabled : IEquatable<ConsoleEnabled>
    {
        private readonly string _value;

        private ConsoleEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConsoleEnabled True { get; } = new ConsoleEnabled("True");
        public static ConsoleEnabled False { get; } = new ConsoleEnabled("False");

        public static bool operator ==(ConsoleEnabled left, ConsoleEnabled right) => left.Equals(right);
        public static bool operator !=(ConsoleEnabled left, ConsoleEnabled right) => !left.Equals(right);

        public static explicit operator string(ConsoleEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsoleEnabled other && Equals(other);
        public bool Equals(ConsoleEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether this is the default gateway.
    /// Only one of the attached networks (including the CloudServicesNetwork attachment) for a single machine may be specified as True.
    /// </summary>
    [EnumType]
    public readonly struct DefaultGateway : IEquatable<DefaultGateway>
    {
        private readonly string _value;

        private DefaultGateway(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultGateway True { get; } = new DefaultGateway("True");
        public static DefaultGateway False { get; } = new DefaultGateway("False");

        public static bool operator ==(DefaultGateway left, DefaultGateway right) => left.Equals(right);
        public static bool operator !=(DefaultGateway left, DefaultGateway right) => !left.Equals(right);

        public static explicit operator string(DefaultGateway value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultGateway other && Equals(other);
        public bool Equals(DefaultGateway other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether or not to disable IPAM allocation on the network attachment definition injected into the Hybrid AKS Cluster.
    /// </summary>
    [EnumType]
    public readonly struct HybridAksIpamEnabled : IEquatable<HybridAksIpamEnabled>
    {
        private readonly string _value;

        private HybridAksIpamEnabled(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HybridAksIpamEnabled True { get; } = new HybridAksIpamEnabled("True");
        public static HybridAksIpamEnabled False { get; } = new HybridAksIpamEnabled("False");

        public static bool operator ==(HybridAksIpamEnabled left, HybridAksIpamEnabled right) => left.Equals(right);
        public static bool operator !=(HybridAksIpamEnabled left, HybridAksIpamEnabled right) => !left.Equals(right);

        public static explicit operator string(HybridAksIpamEnabled value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HybridAksIpamEnabled other && Equals(other);
        public bool Equals(HybridAksIpamEnabled other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network plugin type for Hybrid AKS.
    /// </summary>
    [EnumType]
    public readonly struct HybridAksPluginType : IEquatable<HybridAksPluginType>
    {
        private readonly string _value;

        private HybridAksPluginType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HybridAksPluginType DPDK { get; } = new HybridAksPluginType("DPDK");
        public static HybridAksPluginType SRIOV { get; } = new HybridAksPluginType("SRIOV");
        public static HybridAksPluginType OSDevice { get; } = new HybridAksPluginType("OSDevice");

        public static bool operator ==(HybridAksPluginType left, HybridAksPluginType right) => left.Equals(right);
        public static bool operator !=(HybridAksPluginType left, HybridAksPluginType right) => !left.Equals(right);

        public static explicit operator string(HybridAksPluginType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HybridAksPluginType other && Equals(other);
        public bool Equals(HybridAksPluginType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the IP address allocation, defaulted to "DualStack".
    /// </summary>
    [EnumType]
    public readonly struct IpAllocationType : IEquatable<IpAllocationType>
    {
        private readonly string _value;

        private IpAllocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpAllocationType IPV4 { get; } = new IpAllocationType("IPV4");
        public static IpAllocationType IPV6 { get; } = new IpAllocationType("IPV6");
        public static IpAllocationType DualStack { get; } = new IpAllocationType("DualStack");

        public static bool operator ==(IpAllocationType left, IpAllocationType right) => left.Equals(right);
        public static bool operator !=(IpAllocationType left, IpAllocationType right) => !left.Equals(right);

        public static explicit operator string(IpAllocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpAllocationType other && Equals(other);
        public bool Equals(IpAllocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy for creating the OS disk.
    /// </summary>
    [EnumType]
    public readonly struct OsDiskCreateOption : IEquatable<OsDiskCreateOption>
    {
        private readonly string _value;

        private OsDiskCreateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsDiskCreateOption Ephemeral { get; } = new OsDiskCreateOption("Ephemeral");

        public static bool operator ==(OsDiskCreateOption left, OsDiskCreateOption right) => left.Equals(right);
        public static bool operator !=(OsDiskCreateOption left, OsDiskCreateOption right) => !left.Equals(right);

        public static explicit operator string(OsDiskCreateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsDiskCreateOption other && Equals(other);
        public bool Equals(OsDiskCreateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy for deleting the OS disk.
    /// </summary>
    [EnumType]
    public readonly struct OsDiskDeleteOption : IEquatable<OsDiskDeleteOption>
    {
        private readonly string _value;

        private OsDiskDeleteOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsDiskDeleteOption Delete { get; } = new OsDiskDeleteOption("Delete");

        public static bool operator ==(OsDiskDeleteOption left, OsDiskDeleteOption right) => left.Equals(right);
        public static bool operator !=(OsDiskDeleteOption left, OsDiskDeleteOption right) => !left.Equals(right);

        public static explicit operator string(OsDiskDeleteOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsDiskDeleteOption other && Equals(other);
        public bool Equals(OsDiskDeleteOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selection of how the type evaluation is applied to the cluster calculation.
    /// </summary>
    [EnumType]
    public readonly struct ValidationThresholdGrouping : IEquatable<ValidationThresholdGrouping>
    {
        private readonly string _value;

        private ValidationThresholdGrouping(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValidationThresholdGrouping PerCluster { get; } = new ValidationThresholdGrouping("PerCluster");
        public static ValidationThresholdGrouping PerRack { get; } = new ValidationThresholdGrouping("PerRack");

        public static bool operator ==(ValidationThresholdGrouping left, ValidationThresholdGrouping right) => left.Equals(right);
        public static bool operator !=(ValidationThresholdGrouping left, ValidationThresholdGrouping right) => !left.Equals(right);

        public static explicit operator string(ValidationThresholdGrouping value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValidationThresholdGrouping other && Equals(other);
        public bool Equals(ValidationThresholdGrouping other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selection of how the threshold should be evaluated.
    /// </summary>
    [EnumType]
    public readonly struct ValidationThresholdType : IEquatable<ValidationThresholdType>
    {
        private readonly string _value;

        private ValidationThresholdType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValidationThresholdType CountSuccess { get; } = new ValidationThresholdType("CountSuccess");
        public static ValidationThresholdType PercentSuccess { get; } = new ValidationThresholdType("PercentSuccess");

        public static bool operator ==(ValidationThresholdType left, ValidationThresholdType right) => left.Equals(right);
        public static bool operator !=(ValidationThresholdType left, ValidationThresholdType right) => !left.Equals(right);

        public static explicit operator string(ValidationThresholdType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValidationThresholdType other && Equals(other);
        public bool Equals(ValidationThresholdType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Selects the boot method for the virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineBootMethod : IEquatable<VirtualMachineBootMethod>
    {
        private readonly string _value;

        private VirtualMachineBootMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineBootMethod UEFI { get; } = new VirtualMachineBootMethod("UEFI");
        public static VirtualMachineBootMethod BIOS { get; } = new VirtualMachineBootMethod("BIOS");

        public static bool operator ==(VirtualMachineBootMethod left, VirtualMachineBootMethod right) => left.Equals(right);
        public static bool operator !=(VirtualMachineBootMethod left, VirtualMachineBootMethod right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineBootMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineBootMethod other && Equals(other);
        public bool Equals(VirtualMachineBootMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the device model to use.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineDeviceModelType : IEquatable<VirtualMachineDeviceModelType>
    {
        private readonly string _value;

        private VirtualMachineDeviceModelType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineDeviceModelType T1 { get; } = new VirtualMachineDeviceModelType("T1");
        public static VirtualMachineDeviceModelType T2 { get; } = new VirtualMachineDeviceModelType("T2");

        public static bool operator ==(VirtualMachineDeviceModelType left, VirtualMachineDeviceModelType right) => left.Equals(right);
        public static bool operator !=(VirtualMachineDeviceModelType left, VirtualMachineDeviceModelType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineDeviceModelType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineDeviceModelType other && Equals(other);
        public bool Equals(VirtualMachineDeviceModelType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP allocation mechanism for the virtual machine.
    /// Dynamic and Static are only valid for l3Network which may also specify Disabled.
    /// Otherwise, Disabled is the only permitted value.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineIPAllocationMethod : IEquatable<VirtualMachineIPAllocationMethod>
    {
        private readonly string _value;

        private VirtualMachineIPAllocationMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineIPAllocationMethod Dynamic { get; } = new VirtualMachineIPAllocationMethod("Dynamic");
        public static VirtualMachineIPAllocationMethod Static { get; } = new VirtualMachineIPAllocationMethod("Static");
        public static VirtualMachineIPAllocationMethod Disabled { get; } = new VirtualMachineIPAllocationMethod("Disabled");

        public static bool operator ==(VirtualMachineIPAllocationMethod left, VirtualMachineIPAllocationMethod right) => left.Equals(right);
        public static bool operator !=(VirtualMachineIPAllocationMethod left, VirtualMachineIPAllocationMethod right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineIPAllocationMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineIPAllocationMethod other && Equals(other);
        public bool Equals(VirtualMachineIPAllocationMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated, the value will be ignored if provided. The indicator of whether one of the specified CPU cores is isolated to run the emulator thread for this virtual machine.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineIsolateEmulatorThread : IEquatable<VirtualMachineIsolateEmulatorThread>
    {
        private readonly string _value;

        private VirtualMachineIsolateEmulatorThread(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineIsolateEmulatorThread True { get; } = new VirtualMachineIsolateEmulatorThread("True");
        public static VirtualMachineIsolateEmulatorThread False { get; } = new VirtualMachineIsolateEmulatorThread("False");

        public static bool operator ==(VirtualMachineIsolateEmulatorThread left, VirtualMachineIsolateEmulatorThread right) => left.Equals(right);
        public static bool operator !=(VirtualMachineIsolateEmulatorThread left, VirtualMachineIsolateEmulatorThread right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineIsolateEmulatorThread value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineIsolateEmulatorThread other && Equals(other);
        public bool Equals(VirtualMachineIsolateEmulatorThread other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope for the virtual machine affinity or anti-affinity placement hint. It should always be "Machine" in the case of node affinity.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePlacementHintPodAffinityScope : IEquatable<VirtualMachinePlacementHintPodAffinityScope>
    {
        private readonly string _value;

        private VirtualMachinePlacementHintPodAffinityScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePlacementHintPodAffinityScope Rack { get; } = new VirtualMachinePlacementHintPodAffinityScope("Rack");
        public static VirtualMachinePlacementHintPodAffinityScope Machine { get; } = new VirtualMachinePlacementHintPodAffinityScope("Machine");

        public static bool operator ==(VirtualMachinePlacementHintPodAffinityScope left, VirtualMachinePlacementHintPodAffinityScope right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePlacementHintPodAffinityScope left, VirtualMachinePlacementHintPodAffinityScope right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePlacementHintPodAffinityScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePlacementHintPodAffinityScope other && Equals(other);
        public bool Equals(VirtualMachinePlacementHintPodAffinityScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specification of whether this hint supports affinity or anti-affinity with the referenced resources.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePlacementHintType : IEquatable<VirtualMachinePlacementHintType>
    {
        private readonly string _value;

        private VirtualMachinePlacementHintType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachinePlacementHintType Affinity { get; } = new VirtualMachinePlacementHintType("Affinity");
        public static VirtualMachinePlacementHintType AntiAffinity { get; } = new VirtualMachinePlacementHintType("AntiAffinity");

        public static bool operator ==(VirtualMachinePlacementHintType left, VirtualMachinePlacementHintType right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePlacementHintType left, VirtualMachinePlacementHintType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePlacementHintType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePlacementHintType other && Equals(other);
        public bool Equals(VirtualMachinePlacementHintType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The indicator of whether the hint is a hard or soft requirement during scheduling.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineSchedulingExecution : IEquatable<VirtualMachineSchedulingExecution>
    {
        private readonly string _value;

        private VirtualMachineSchedulingExecution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineSchedulingExecution Hard { get; } = new VirtualMachineSchedulingExecution("Hard");
        public static VirtualMachineSchedulingExecution Soft { get; } = new VirtualMachineSchedulingExecution("Soft");

        public static bool operator ==(VirtualMachineSchedulingExecution left, VirtualMachineSchedulingExecution right) => left.Equals(right);
        public static bool operator !=(VirtualMachineSchedulingExecution left, VirtualMachineSchedulingExecution right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineSchedulingExecution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineSchedulingExecution other && Equals(other);
        public bool Equals(VirtualMachineSchedulingExecution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field Deprecated, use virtualizationModel instead. The type of the virtio interface.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachineVirtioInterfaceType : IEquatable<VirtualMachineVirtioInterfaceType>
    {
        private readonly string _value;

        private VirtualMachineVirtioInterfaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VirtualMachineVirtioInterfaceType Modern { get; } = new VirtualMachineVirtioInterfaceType("Modern");
        public static VirtualMachineVirtioInterfaceType Transitional { get; } = new VirtualMachineVirtioInterfaceType("Transitional");

        public static bool operator ==(VirtualMachineVirtioInterfaceType left, VirtualMachineVirtioInterfaceType right) => left.Equals(right);
        public static bool operator !=(VirtualMachineVirtioInterfaceType left, VirtualMachineVirtioInterfaceType right) => !left.Equals(right);

        public static explicit operator string(VirtualMachineVirtioInterfaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachineVirtioInterfaceType other && Equals(other);
        public bool Equals(VirtualMachineVirtioInterfaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
