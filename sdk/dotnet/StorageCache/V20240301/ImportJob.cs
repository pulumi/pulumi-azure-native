// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.StorageCache.V20240301
{
    /// <summary>
    /// An import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
    /// </summary>
    [AzureNativeResourceType("azure-native:storagecache/v20240301:ImportJob")]
    public partial class ImportJob : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A recent and frequently updated rate of total files, directories, and symlinks imported per second.
        /// </summary>
        [Output("blobsImportedPerSecond")]
        public Output<double> BlobsImportedPerSecond { get; private set; } = null!;

        /// <summary>
        /// A recent and frequently updated rate of blobs walked per second.
        /// </summary>
        [Output("blobsWalkedPerSecond")]
        public Output<double> BlobsWalkedPerSecond { get; private set; } = null!;

        /// <summary>
        /// How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        /// </summary>
        [Output("conflictResolutionMode")]
        public Output<string?> ConflictResolutionMode { get; private set; } = null!;

        /// <summary>
        /// An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        /// </summary>
        [Output("importPrefixes")]
        public Output<ImmutableArray<string>> ImportPrefixes { get; private set; } = null!;

        /// <summary>
        /// The time of the last completed archive operation
        /// </summary>
        [Output("lastCompletionTime")]
        public Output<string> LastCompletionTime { get; private set; } = null!;

        /// <summary>
        /// The time the latest archive operation started
        /// </summary>
        [Output("lastStartedTime")]
        public Output<string> LastStartedTime { get; private set; } = null!;

        /// <summary>
        /// The geo-location where the resource lives
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        /// </summary>
        [Output("maximumErrors")]
        public Output<int?> MaximumErrors { get; private set; } = null!;

        /// <summary>
        /// The name of the resource
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// ARM provisioning state.
        /// </summary>
        [Output("provisioningState")]
        public Output<string> ProvisioningState { get; private set; } = null!;

        /// <summary>
        /// The state of the import job. InProgress indicates the import is still running. Canceled indicates it has been canceled by the user. Completed indicates import finished, successfully importing all discovered blobs into the Lustre namespace. CompletedPartial indicates the import finished but some blobs either were found to be conflicting and could not be imported or other errors were encountered. Failed means the import was unable to complete due to a fatal error.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// The status message of the import job.
        /// </summary>
        [Output("statusMessage")]
        public Output<string> StatusMessage { get; private set; } = null!;

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Output("systemData")]
        public Output<Outputs.SystemDataResponse> SystemData { get; private set; } = null!;

        /// <summary>
        /// Resource tags.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// The total blobs that have been imported since import began.
        /// </summary>
        [Output("totalBlobsImported")]
        public Output<double> TotalBlobsImported { get; private set; } = null!;

        /// <summary>
        /// The total blob objects walked.
        /// </summary>
        [Output("totalBlobsWalked")]
        public Output<double> TotalBlobsWalked { get; private set; } = null!;

        /// <summary>
        /// Number of conflicts in the import job.
        /// </summary>
        [Output("totalConflicts")]
        public Output<int> TotalConflicts { get; private set; } = null!;

        /// <summary>
        /// Number of errors in the import job.
        /// </summary>
        [Output("totalErrors")]
        public Output<int> TotalErrors { get; private set; } = null!;

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;


        /// <summary>
        /// Create a ImportJob resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ImportJob(string name, ImportJobArgs args, CustomResourceOptions? options = null)
            : base("azure-native:storagecache/v20240301:ImportJob", name, args ?? new ImportJobArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ImportJob(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("azure-native:storagecache/v20240301:ImportJob", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "azure-native:storagecache/v20240301:importJob" },
                    new global::Pulumi.Alias { Type = "azure-native:storagecache:ImportJob" },
                    new global::Pulumi.Alias { Type = "azure-native:storagecache:importJob" },
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ImportJob resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ImportJob Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new ImportJob(name, id, options);
        }
    }

    public sealed class ImportJobArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name for the AML file system. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        /// </summary>
        [Input("amlFilesystemName", required: true)]
        public Input<string> AmlFilesystemName { get; set; } = null!;

        /// <summary>
        /// How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        /// </summary>
        [Input("conflictResolutionMode")]
        public InputUnion<string, Pulumi.AzureNative.StorageCache.V20240301.ConflictResolutionMode>? ConflictResolutionMode { get; set; }

        /// <summary>
        /// Name for the import job. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        /// </summary>
        [Input("importJobName")]
        public Input<string>? ImportJobName { get; set; }

        [Input("importPrefixes")]
        private InputList<string>? _importPrefixes;

        /// <summary>
        /// An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        /// </summary>
        public InputList<string> ImportPrefixes
        {
            get => _importPrefixes ?? (_importPrefixes = new InputList<string>());
            set => _importPrefixes = value;
        }

        /// <summary>
        /// The geo-location where the resource lives
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        /// </summary>
        [Input("maximumErrors")]
        public Input<int>? MaximumErrors { get; set; }

        /// <summary>
        /// The name of the resource group. The name is case insensitive.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Resource tags.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        public ImportJobArgs()
        {
            ConflictResolutionMode = "Fail";
            MaximumErrors = 0;
        }
        public static new ImportJobArgs Empty => new ImportJobArgs();
    }
}
