// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.StorageCache.V20240701
{
    /// <summary>
    /// The type of identity used for the resource.
    /// </summary>
    [EnumType]
    public readonly struct AmlFilesystemIdentityType : IEquatable<AmlFilesystemIdentityType>
    {
        private readonly string _value;

        private AmlFilesystemIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AmlFilesystemIdentityType UserAssigned { get; } = new AmlFilesystemIdentityType("UserAssigned");
        public static AmlFilesystemIdentityType None { get; } = new AmlFilesystemIdentityType("None");

        public static bool operator ==(AmlFilesystemIdentityType left, AmlFilesystemIdentityType right) => left.Equals(right);
        public static bool operator !=(AmlFilesystemIdentityType left, AmlFilesystemIdentityType right) => !left.Equals(right);

        public static explicit operator string(AmlFilesystemIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AmlFilesystemIdentityType other && Equals(other);
        public bool Equals(AmlFilesystemIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Squash mode of the AML file system. 'All': User and Group IDs on files will be squashed to the provided values for all users on non-trusted systems. 'RootOnly': User and Group IDs on files will be squashed to provided values for solely the root user on non-trusted systems. 'None': No squashing of User and Group IDs is performed for any users on any systems.
    /// </summary>
    [EnumType]
    public readonly struct AmlFilesystemSquashMode : IEquatable<AmlFilesystemSquashMode>
    {
        private readonly string _value;

        private AmlFilesystemSquashMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AmlFilesystemSquashMode None { get; } = new AmlFilesystemSquashMode("None");
        public static AmlFilesystemSquashMode RootOnly { get; } = new AmlFilesystemSquashMode("RootOnly");
        public static AmlFilesystemSquashMode All { get; } = new AmlFilesystemSquashMode("All");

        public static bool operator ==(AmlFilesystemSquashMode left, AmlFilesystemSquashMode right) => left.Equals(right);
        public static bool operator !=(AmlFilesystemSquashMode left, AmlFilesystemSquashMode right) => !left.Equals(right);

        public static explicit operator string(AmlFilesystemSquashMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AmlFilesystemSquashMode other && Equals(other);
        public bool Equals(AmlFilesystemSquashMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The administrative status of the auto export job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto export job. By default it is set to 'Enable'.
    /// </summary>
    [EnumType]
    public readonly struct AutoExportJobAdminStatus : IEquatable<AutoExportJobAdminStatus>
    {
        private readonly string _value;

        private AutoExportJobAdminStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoExportJobAdminStatus Active { get; } = new AutoExportJobAdminStatus("Active");
        public static AutoExportJobAdminStatus Cancel { get; } = new AutoExportJobAdminStatus("Cancel");

        public static bool operator ==(AutoExportJobAdminStatus left, AutoExportJobAdminStatus right) => left.Equals(right);
        public static bool operator !=(AutoExportJobAdminStatus left, AutoExportJobAdminStatus right) => !left.Equals(right);

        public static explicit operator string(AutoExportJobAdminStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoExportJobAdminStatus other && Equals(other);
        public bool Equals(AutoExportJobAdminStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operational state of auto export. InProgress indicates the export is running.  Disabling indicates the user has requested to disable the export but the disabling is still in progress. Disabled indicates auto export has been disabled.  DisableFailed indicates the disabling has failed.  Failed means the export was unable to continue, due to a fatal error.
    /// </summary>
    [EnumType]
    public readonly struct AutoExportStatusType : IEquatable<AutoExportStatusType>
    {
        private readonly string _value;

        private AutoExportStatusType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoExportStatusType InProgress { get; } = new AutoExportStatusType("InProgress");
        public static AutoExportStatusType Disabling { get; } = new AutoExportStatusType("Disabling");
        public static AutoExportStatusType Disabled { get; } = new AutoExportStatusType("Disabled");
        public static AutoExportStatusType DisableFailed { get; } = new AutoExportStatusType("DisableFailed");
        public static AutoExportStatusType Failed { get; } = new AutoExportStatusType("Failed");

        public static bool operator ==(AutoExportStatusType left, AutoExportStatusType right) => left.Equals(right);
        public static bool operator !=(AutoExportStatusType left, AutoExportStatusType right) => !left.Equals(right);

        public static explicit operator string(AutoExportStatusType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoExportStatusType other && Equals(other);
        public bool Equals(AutoExportStatusType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the cache
    /// </summary>
    [EnumType]
    public readonly struct CacheIdentityType : IEquatable<CacheIdentityType>
    {
        private readonly string _value;

        private CacheIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CacheIdentityType SystemAssigned { get; } = new CacheIdentityType("SystemAssigned");
        public static CacheIdentityType UserAssigned { get; } = new CacheIdentityType("UserAssigned");
        public static CacheIdentityType SystemAssigned_UserAssigned { get; } = new CacheIdentityType("SystemAssigned, UserAssigned");
        public static CacheIdentityType None { get; } = new CacheIdentityType("None");

        public static bool operator ==(CacheIdentityType left, CacheIdentityType right) => left.Equals(right);
        public static bool operator !=(CacheIdentityType left, CacheIdentityType right) => !left.Equals(right);

        public static explicit operator string(CacheIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CacheIdentityType other && Equals(other);
        public bool Equals(CacheIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
    /// </summary>
    [EnumType]
    public readonly struct ConflictResolutionMode : IEquatable<ConflictResolutionMode>
    {
        private readonly string _value;

        private ConflictResolutionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConflictResolutionMode Fail { get; } = new ConflictResolutionMode("Fail");
        public static ConflictResolutionMode Skip { get; } = new ConflictResolutionMode("Skip");
        public static ConflictResolutionMode OverwriteIfDirty { get; } = new ConflictResolutionMode("OverwriteIfDirty");
        public static ConflictResolutionMode OverwriteAlways { get; } = new ConflictResolutionMode("OverwriteAlways");

        public static bool operator ==(ConflictResolutionMode left, ConflictResolutionMode right) => left.Equals(right);
        public static bool operator !=(ConflictResolutionMode left, ConflictResolutionMode right) => !left.Equals(right);

        public static explicit operator string(ConflictResolutionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConflictResolutionMode other && Equals(other);
        public bool Equals(ConflictResolutionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The administrative status of the import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will cancel the current active import job. By default it is set to 'Enable'.
    /// </summary>
    [EnumType]
    public readonly struct ImportJobAdminStatus : IEquatable<ImportJobAdminStatus>
    {
        private readonly string _value;

        private ImportJobAdminStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImportJobAdminStatus Active { get; } = new ImportJobAdminStatus("Active");
        public static ImportJobAdminStatus Cancel { get; } = new ImportJobAdminStatus("Cancel");

        public static bool operator ==(ImportJobAdminStatus left, ImportJobAdminStatus right) => left.Equals(right);
        public static bool operator !=(ImportJobAdminStatus left, ImportJobAdminStatus right) => !left.Equals(right);

        public static explicit operator string(ImportJobAdminStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImportJobAdminStatus other && Equals(other);
        public bool Equals(ImportJobAdminStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Day of the week on which the maintenance window will occur.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceDayOfWeekType : IEquatable<MaintenanceDayOfWeekType>
    {
        private readonly string _value;

        private MaintenanceDayOfWeekType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MaintenanceDayOfWeekType Monday { get; } = new MaintenanceDayOfWeekType("Monday");
        public static MaintenanceDayOfWeekType Tuesday { get; } = new MaintenanceDayOfWeekType("Tuesday");
        public static MaintenanceDayOfWeekType Wednesday { get; } = new MaintenanceDayOfWeekType("Wednesday");
        public static MaintenanceDayOfWeekType Thursday { get; } = new MaintenanceDayOfWeekType("Thursday");
        public static MaintenanceDayOfWeekType Friday { get; } = new MaintenanceDayOfWeekType("Friday");
        public static MaintenanceDayOfWeekType Saturday { get; } = new MaintenanceDayOfWeekType("Saturday");
        public static MaintenanceDayOfWeekType Sunday { get; } = new MaintenanceDayOfWeekType("Sunday");

        public static bool operator ==(MaintenanceDayOfWeekType left, MaintenanceDayOfWeekType right) => left.Equals(right);
        public static bool operator !=(MaintenanceDayOfWeekType left, MaintenanceDayOfWeekType right) => !left.Equals(right);

        public static explicit operator string(MaintenanceDayOfWeekType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceDayOfWeekType other && Equals(other);
        public bool Equals(MaintenanceDayOfWeekType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Access allowed by this rule.
    /// </summary>
    [EnumType]
    public readonly struct NfsAccessRuleAccess : IEquatable<NfsAccessRuleAccess>
    {
        private readonly string _value;

        private NfsAccessRuleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NfsAccessRuleAccess No { get; } = new NfsAccessRuleAccess("no");
        public static NfsAccessRuleAccess Ro { get; } = new NfsAccessRuleAccess("ro");
        public static NfsAccessRuleAccess Rw { get; } = new NfsAccessRuleAccess("rw");

        public static bool operator ==(NfsAccessRuleAccess left, NfsAccessRuleAccess right) => left.Equals(right);
        public static bool operator !=(NfsAccessRuleAccess left, NfsAccessRuleAccess right) => !left.Equals(right);

        public static explicit operator string(NfsAccessRuleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NfsAccessRuleAccess other && Equals(other);
        public bool Equals(NfsAccessRuleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope for this rule. The scope and filter determine which clients match the rule.
    /// </summary>
    [EnumType]
    public readonly struct NfsAccessRuleScope : IEquatable<NfsAccessRuleScope>
    {
        private readonly string _value;

        private NfsAccessRuleScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NfsAccessRuleScope @Default { get; } = new NfsAccessRuleScope("default");
        public static NfsAccessRuleScope Network { get; } = new NfsAccessRuleScope("network");
        public static NfsAccessRuleScope Host { get; } = new NfsAccessRuleScope("host");

        public static bool operator ==(NfsAccessRuleScope left, NfsAccessRuleScope right) => left.Equals(right);
        public static bool operator !=(NfsAccessRuleScope left, NfsAccessRuleScope right) => !left.Equals(right);

        public static explicit operator string(NfsAccessRuleScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NfsAccessRuleScope other && Equals(other);
        public bool Equals(NfsAccessRuleScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Storage target operational state.
    /// </summary>
    [EnumType]
    public readonly struct OperationalStateType : IEquatable<OperationalStateType>
    {
        private readonly string _value;

        private OperationalStateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperationalStateType Ready { get; } = new OperationalStateType("Ready");
        public static OperationalStateType Busy { get; } = new OperationalStateType("Busy");
        public static OperationalStateType Suspended { get; } = new OperationalStateType("Suspended");
        public static OperationalStateType Flushing { get; } = new OperationalStateType("Flushing");

        public static bool operator ==(OperationalStateType left, OperationalStateType right) => left.Equals(right);
        public static bool operator !=(OperationalStateType left, OperationalStateType right) => !left.Equals(right);

        public static explicit operator string(OperationalStateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationalStateType other && Equals(other);
        public bool Equals(OperationalStateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the Storage Target.
    /// </summary>
    [EnumType]
    public readonly struct StorageTargetType : IEquatable<StorageTargetType>
    {
        private readonly string _value;

        private StorageTargetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageTargetType Nfs3 { get; } = new StorageTargetType("nfs3");
        public static StorageTargetType Clfs { get; } = new StorageTargetType("clfs");
        public static StorageTargetType Unknown { get; } = new StorageTargetType("unknown");
        public static StorageTargetType BlobNfs { get; } = new StorageTargetType("blobNfs");

        public static bool operator ==(StorageTargetType left, StorageTargetType right) => left.Equals(right);
        public static bool operator !=(StorageTargetType left, StorageTargetType right) => !left.Equals(right);

        public static explicit operator string(StorageTargetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageTargetType other && Equals(other);
        public bool Equals(StorageTargetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This setting determines how the cache gets username and group names for clients.
    /// </summary>
    [EnumType]
    public readonly struct UsernameSource : IEquatable<UsernameSource>
    {
        private readonly string _value;

        private UsernameSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UsernameSource AD { get; } = new UsernameSource("AD");
        public static UsernameSource LDAP { get; } = new UsernameSource("LDAP");
        public static UsernameSource File { get; } = new UsernameSource("File");
        public static UsernameSource None { get; } = new UsernameSource("None");

        public static bool operator ==(UsernameSource left, UsernameSource right) => left.Equals(right);
        public static bool operator !=(UsernameSource left, UsernameSource right) => !left.Equals(right);

        public static explicit operator string(UsernameSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UsernameSource other && Equals(other);
        public bool Equals(UsernameSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
