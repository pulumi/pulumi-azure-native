// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.StorageCache.V20231101Preview
{
    /// <summary>
    /// The type of identity used for the resource.
    /// </summary>
    [EnumType]
    public readonly struct AmlFilesystemIdentityType : IEquatable<AmlFilesystemIdentityType>
    {
        private readonly string _value;

        private AmlFilesystemIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AmlFilesystemIdentityType UserAssigned { get; } = new AmlFilesystemIdentityType("UserAssigned");
        public static AmlFilesystemIdentityType None { get; } = new AmlFilesystemIdentityType("None");

        public static bool operator ==(AmlFilesystemIdentityType left, AmlFilesystemIdentityType right) => left.Equals(right);
        public static bool operator !=(AmlFilesystemIdentityType left, AmlFilesystemIdentityType right) => !left.Equals(right);

        public static explicit operator string(AmlFilesystemIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AmlFilesystemIdentityType other && Equals(other);
        public bool Equals(AmlFilesystemIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Squash mode of the AML file system. 'All': User and Group IDs on files will be squashed to the provided values for all users on non-trusted systems. 'RootOnly': User and Group IDs on files will be squashed to provided values for solely the root user on non-trusted systems. 'None': No squashing of User and Group IDs is performed for any users on any systems.
    /// </summary>
    [EnumType]
    public readonly struct AmlFilesystemSquashMode : IEquatable<AmlFilesystemSquashMode>
    {
        private readonly string _value;

        private AmlFilesystemSquashMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AmlFilesystemSquashMode None { get; } = new AmlFilesystemSquashMode("None");
        public static AmlFilesystemSquashMode RootOnly { get; } = new AmlFilesystemSquashMode("RootOnly");
        public static AmlFilesystemSquashMode All { get; } = new AmlFilesystemSquashMode("All");

        public static bool operator ==(AmlFilesystemSquashMode left, AmlFilesystemSquashMode right) => left.Equals(right);
        public static bool operator !=(AmlFilesystemSquashMode left, AmlFilesystemSquashMode right) => !left.Equals(right);

        public static explicit operator string(AmlFilesystemSquashMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AmlFilesystemSquashMode other && Equals(other);
        public bool Equals(AmlFilesystemSquashMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the cache
    /// </summary>
    [EnumType]
    public readonly struct CacheIdentityType : IEquatable<CacheIdentityType>
    {
        private readonly string _value;

        private CacheIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CacheIdentityType SystemAssigned { get; } = new CacheIdentityType("SystemAssigned");
        public static CacheIdentityType UserAssigned { get; } = new CacheIdentityType("UserAssigned");
        public static CacheIdentityType SystemAssigned_UserAssigned { get; } = new CacheIdentityType("SystemAssigned, UserAssigned");
        public static CacheIdentityType None { get; } = new CacheIdentityType("None");

        public static bool operator ==(CacheIdentityType left, CacheIdentityType right) => left.Equals(right);
        public static bool operator !=(CacheIdentityType left, CacheIdentityType right) => !left.Equals(right);

        public static explicit operator string(CacheIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CacheIdentityType other && Equals(other);
        public bool Equals(CacheIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Day of the week on which the maintenance window will occur.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceDayOfWeekType : IEquatable<MaintenanceDayOfWeekType>
    {
        private readonly string _value;

        private MaintenanceDayOfWeekType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MaintenanceDayOfWeekType Monday { get; } = new MaintenanceDayOfWeekType("Monday");
        public static MaintenanceDayOfWeekType Tuesday { get; } = new MaintenanceDayOfWeekType("Tuesday");
        public static MaintenanceDayOfWeekType Wednesday { get; } = new MaintenanceDayOfWeekType("Wednesday");
        public static MaintenanceDayOfWeekType Thursday { get; } = new MaintenanceDayOfWeekType("Thursday");
        public static MaintenanceDayOfWeekType Friday { get; } = new MaintenanceDayOfWeekType("Friday");
        public static MaintenanceDayOfWeekType Saturday { get; } = new MaintenanceDayOfWeekType("Saturday");
        public static MaintenanceDayOfWeekType Sunday { get; } = new MaintenanceDayOfWeekType("Sunday");

        public static bool operator ==(MaintenanceDayOfWeekType left, MaintenanceDayOfWeekType right) => left.Equals(right);
        public static bool operator !=(MaintenanceDayOfWeekType left, MaintenanceDayOfWeekType right) => !left.Equals(right);

        public static explicit operator string(MaintenanceDayOfWeekType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceDayOfWeekType other && Equals(other);
        public bool Equals(MaintenanceDayOfWeekType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Access allowed by this rule.
    /// </summary>
    [EnumType]
    public readonly struct NfsAccessRuleAccess : IEquatable<NfsAccessRuleAccess>
    {
        private readonly string _value;

        private NfsAccessRuleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NfsAccessRuleAccess No { get; } = new NfsAccessRuleAccess("no");
        public static NfsAccessRuleAccess Ro { get; } = new NfsAccessRuleAccess("ro");
        public static NfsAccessRuleAccess Rw { get; } = new NfsAccessRuleAccess("rw");

        public static bool operator ==(NfsAccessRuleAccess left, NfsAccessRuleAccess right) => left.Equals(right);
        public static bool operator !=(NfsAccessRuleAccess left, NfsAccessRuleAccess right) => !left.Equals(right);

        public static explicit operator string(NfsAccessRuleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NfsAccessRuleAccess other && Equals(other);
        public bool Equals(NfsAccessRuleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope for this rule. The scope and filter determine which clients match the rule.
    /// </summary>
    [EnumType]
    public readonly struct NfsAccessRuleScope : IEquatable<NfsAccessRuleScope>
    {
        private readonly string _value;

        private NfsAccessRuleScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NfsAccessRuleScope @Default { get; } = new NfsAccessRuleScope("default");
        public static NfsAccessRuleScope Network { get; } = new NfsAccessRuleScope("network");
        public static NfsAccessRuleScope Host { get; } = new NfsAccessRuleScope("host");

        public static bool operator ==(NfsAccessRuleScope left, NfsAccessRuleScope right) => left.Equals(right);
        public static bool operator !=(NfsAccessRuleScope left, NfsAccessRuleScope right) => !left.Equals(right);

        public static explicit operator string(NfsAccessRuleScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NfsAccessRuleScope other && Equals(other);
        public bool Equals(NfsAccessRuleScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Storage target operational state.
    /// </summary>
    [EnumType]
    public readonly struct OperationalStateType : IEquatable<OperationalStateType>
    {
        private readonly string _value;

        private OperationalStateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperationalStateType Ready { get; } = new OperationalStateType("Ready");
        public static OperationalStateType Busy { get; } = new OperationalStateType("Busy");
        public static OperationalStateType Suspended { get; } = new OperationalStateType("Suspended");
        public static OperationalStateType Flushing { get; } = new OperationalStateType("Flushing");

        public static bool operator ==(OperationalStateType left, OperationalStateType right) => left.Equals(right);
        public static bool operator !=(OperationalStateType left, OperationalStateType right) => !left.Equals(right);

        public static explicit operator string(OperationalStateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationalStateType other && Equals(other);
        public bool Equals(OperationalStateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the Storage Target.
    /// </summary>
    [EnumType]
    public readonly struct StorageTargetType : IEquatable<StorageTargetType>
    {
        private readonly string _value;

        private StorageTargetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageTargetType Nfs3 { get; } = new StorageTargetType("nfs3");
        public static StorageTargetType Clfs { get; } = new StorageTargetType("clfs");
        public static StorageTargetType Unknown { get; } = new StorageTargetType("unknown");
        public static StorageTargetType BlobNfs { get; } = new StorageTargetType("blobNfs");

        public static bool operator ==(StorageTargetType left, StorageTargetType right) => left.Equals(right);
        public static bool operator !=(StorageTargetType left, StorageTargetType right) => !left.Equals(right);

        public static explicit operator string(StorageTargetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageTargetType other && Equals(other);
        public bool Equals(StorageTargetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This setting determines how the cache gets username and group names for clients.
    /// </summary>
    [EnumType]
    public readonly struct UsernameSource : IEquatable<UsernameSource>
    {
        private readonly string _value;

        private UsernameSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UsernameSource AD { get; } = new UsernameSource("AD");
        public static UsernameSource LDAP { get; } = new UsernameSource("LDAP");
        public static UsernameSource File { get; } = new UsernameSource("File");
        public static UsernameSource None { get; } = new UsernameSource("None");

        public static bool operator ==(UsernameSource left, UsernameSource right) => left.Equals(right);
        public static bool operator !=(UsernameSource left, UsernameSource right) => !left.Equals(right);

        public static explicit operator string(UsernameSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UsernameSource other && Equals(other);
        public bool Equals(UsernameSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
