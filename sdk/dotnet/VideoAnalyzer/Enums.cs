// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.VideoAnalyzer
{
    /// <summary>
    /// Elliptical curve algorithm to be used: ES256, ES384 or ES512.
    /// </summary>
    [EnumType]
    public readonly struct AccessPolicyEccAlgo : IEquatable<AccessPolicyEccAlgo>
    {
        private readonly string _value;

        private AccessPolicyEccAlgo(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ES265
        /// </summary>
        public static AccessPolicyEccAlgo ES256 { get; } = new AccessPolicyEccAlgo("ES256");
        /// <summary>
        /// ES384
        /// </summary>
        public static AccessPolicyEccAlgo ES384 { get; } = new AccessPolicyEccAlgo("ES384");
        /// <summary>
        /// ES512
        /// </summary>
        public static AccessPolicyEccAlgo ES512 { get; } = new AccessPolicyEccAlgo("ES512");

        public static bool operator ==(AccessPolicyEccAlgo left, AccessPolicyEccAlgo right) => left.Equals(right);
        public static bool operator !=(AccessPolicyEccAlgo left, AccessPolicyEccAlgo right) => !left.Equals(right);

        public static explicit operator string(AccessPolicyEccAlgo value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessPolicyEccAlgo other && Equals(other);
        public bool Equals(AccessPolicyEccAlgo other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the access level granted by this policy.
    /// </summary>
    [EnumType]
    public readonly struct AccessPolicyRole : IEquatable<AccessPolicyRole>
    {
        private readonly string _value;

        private AccessPolicyRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Reader role allows for read-only operations to be performed through the client APIs.
        /// </summary>
        public static AccessPolicyRole Reader { get; } = new AccessPolicyRole("Reader");

        public static bool operator ==(AccessPolicyRole left, AccessPolicyRole right) => left.Equals(right);
        public static bool operator !=(AccessPolicyRole left, AccessPolicyRole right) => !left.Equals(right);

        public static explicit operator string(AccessPolicyRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessPolicyRole other && Equals(other);
        public bool Equals(AccessPolicyRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// RSA algorithm to be used: RS256, RS384 or RS512.
    /// </summary>
    [EnumType]
    public readonly struct AccessPolicyRsaAlgo : IEquatable<AccessPolicyRsaAlgo>
    {
        private readonly string _value;

        private AccessPolicyRsaAlgo(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RS256
        /// </summary>
        public static AccessPolicyRsaAlgo RS256 { get; } = new AccessPolicyRsaAlgo("RS256");
        /// <summary>
        /// RS384
        /// </summary>
        public static AccessPolicyRsaAlgo RS384 { get; } = new AccessPolicyRsaAlgo("RS384");
        /// <summary>
        /// RS512
        /// </summary>
        public static AccessPolicyRsaAlgo RS512 { get; } = new AccessPolicyRsaAlgo("RS512");

        public static bool operator ==(AccessPolicyRsaAlgo left, AccessPolicyRsaAlgo right) => left.Equals(right);
        public static bool operator !=(AccessPolicyRsaAlgo left, AccessPolicyRsaAlgo right) => !left.Equals(right);

        public static explicit operator string(AccessPolicyRsaAlgo value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessPolicyRsaAlgo other && Equals(other);
        public bool Equals(AccessPolicyRsaAlgo other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key used to encrypt the Account Key.
    /// </summary>
    [EnumType]
    public readonly struct AccountEncryptionKeyType : IEquatable<AccountEncryptionKeyType>
    {
        private readonly string _value;

        private AccountEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Account Key is encrypted with a System Key.
        /// </summary>
        public static AccountEncryptionKeyType SystemKey { get; } = new AccountEncryptionKeyType("SystemKey");
        /// <summary>
        /// The Account Key is encrypted with a Customer Key.
        /// </summary>
        public static AccountEncryptionKeyType CustomerKey { get; } = new AccountEncryptionKeyType("CustomerKey");

        public static bool operator ==(AccountEncryptionKeyType left, AccountEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(AccountEncryptionKeyType left, AccountEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(AccountEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountEncryptionKeyType other && Equals(other);
        public bool Equals(AccountEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the built-in encoding preset.
    /// </summary>
    [EnumType]
    public readonly struct EncoderSystemPresetType : IEquatable<EncoderSystemPresetType>
    {
        private readonly string _value;

        private EncoderSystemPresetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 540 pixels, and at a maximum bitrate of 2000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps
        /// </summary>
        public static EncoderSystemPresetType SingleLayer_540p_H264_AAC { get; } = new EncoderSystemPresetType("SingleLayer_540p_H264_AAC");
        /// <summary>
        /// Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 720 pixels, and at a maximum bitrate of 3500 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps
        /// </summary>
        public static EncoderSystemPresetType SingleLayer_720p_H264_AAC { get; } = new EncoderSystemPresetType("SingleLayer_720p_H264_AAC");
        /// <summary>
        /// Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 1080 pixels, and at a maximum bitrate of 6000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps
        /// </summary>
        public static EncoderSystemPresetType SingleLayer_1080p_H264_AAC { get; } = new EncoderSystemPresetType("SingleLayer_1080p_H264_AAC");
        /// <summary>
        /// Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 2160 pixels, and at a maximum bitrate of 16000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps
        /// </summary>
        public static EncoderSystemPresetType SingleLayer_2160p_H264_AAC { get; } = new EncoderSystemPresetType("SingleLayer_2160p_H264_AAC");

        public static bool operator ==(EncoderSystemPresetType left, EncoderSystemPresetType right) => left.Equals(right);
        public static bool operator !=(EncoderSystemPresetType left, EncoderSystemPresetType right) => !left.Equals(right);

        public static explicit operator string(EncoderSystemPresetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncoderSystemPresetType other && Equals(other);
        public bool Equals(EncoderSystemPresetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Topology kind.
    /// </summary>
    [EnumType]
    public readonly struct Kind : IEquatable<Kind>
    {
        private readonly string _value;

        private Kind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Live pipeline topology resource.
        /// </summary>
        public static Kind Live { get; } = new Kind("Live");
        /// <summary>
        /// Batch pipeline topology resource.
        /// </summary>
        public static Kind Batch { get; } = new Kind("Batch");

        public static bool operator ==(Kind left, Kind right) => left.Equals(right);
        public static bool operator !=(Kind left, Kind right) => !left.Equals(right);

        public static explicit operator string(Kind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Kind other && Equals(other);
        public bool Equals(Kind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the parameter.
    /// </summary>
    [EnumType]
    public readonly struct ParameterType : IEquatable<ParameterType>
    {
        private readonly string _value;

        private ParameterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The parameter's value is a string.
        /// </summary>
        public static ParameterType String { get; } = new ParameterType("String");
        /// <summary>
        /// The parameter's value is a string that holds sensitive information.
        /// </summary>
        public static ParameterType SecretString { get; } = new ParameterType("SecretString");
        /// <summary>
        /// The parameter's value is a 32-bit signed integer.
        /// </summary>
        public static ParameterType Int { get; } = new ParameterType("Int");
        /// <summary>
        /// The parameter's value is a 64-bit double-precision floating point.
        /// </summary>
        public static ParameterType Double { get; } = new ParameterType("Double");
        /// <summary>
        /// The parameter's value is a boolean value that is either true or false.
        /// </summary>
        public static ParameterType Bool { get; } = new ParameterType("Bool");

        public static bool operator ==(ParameterType left, ParameterType right) => left.Equals(right);
        public static bool operator !=(ParameterType left, ParameterType right) => !left.Equals(right);

        public static explicit operator string(ParameterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ParameterType other && Equals(other);
        public bool Equals(ParameterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are exchanged through long lived HTTP connections, and the RTP packages are interleaved in the HTTP connections alongside the RTSP messages.
    /// </summary>
    [EnumType]
    public readonly struct RtspTransport : IEquatable<RtspTransport>
    {
        private readonly string _value;

        private RtspTransport(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HTTP transport. RTSP messages are exchanged over long running HTTP requests and RTP packets are interleaved within the HTTP channel.
        /// </summary>
        public static RtspTransport Http { get; } = new RtspTransport("Http");
        /// <summary>
        /// TCP transport. RTSP is used directly over TCP and RTP packets are interleaved within the TCP channel.
        /// </summary>
        public static RtspTransport Tcp { get; } = new RtspTransport("Tcp");

        public static bool operator ==(RtspTransport left, RtspTransport right) => left.Equals(right);
        public static bool operator !=(RtspTransport left, RtspTransport right) => !left.Equals(right);

        public static explicit operator string(RtspTransport value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RtspTransport other && Equals(other);
        public bool Equals(RtspTransport other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU name.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents the Live S1 SKU name. Using this SKU you can create live pipelines to capture, record, and stream live video from RTSP-capable cameras at bitrate settings from 0.5 Kbps to 3000 Kbps.
        /// </summary>
        public static SkuName Live_S1 { get; } = new SkuName("Live_S1");
        /// <summary>
        /// Represents the Batch S1 SKU name. Using this SKU you can create pipeline jobs to process recorded content.
        /// </summary>
        public static SkuName Batch_S1 { get; } = new SkuName("Batch_S1");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes the video scaling mode to be applied. Default mode is 'Pad'. If the mode is 'Pad' or 'Stretch' then both width and height must be specified. Else if the mode is 'PreserveAspectRatio' then only one of width or height need be provided.
    /// </summary>
    [EnumType]
    public readonly struct VideoScaleMode : IEquatable<VideoScaleMode>
    {
        private readonly string _value;

        private VideoScaleMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Pads the video with black horizontal stripes (letterbox) or black vertical stripes (pillar-box) so the video is resized to the specified dimensions while not altering the content aspect ratio.
        /// </summary>
        public static VideoScaleMode Pad { get; } = new VideoScaleMode("Pad");
        /// <summary>
        /// Preserves the same aspect ratio as the input video. If only one video dimension is provided, the second dimension is calculated based on the input video aspect ratio. When 2 dimensions are provided, the video is resized to fit the most constraining dimension, considering the input video size and aspect ratio.
        /// </summary>
        public static VideoScaleMode PreserveAspectRatio { get; } = new VideoScaleMode("PreserveAspectRatio");
        /// <summary>
        /// Stretches the original video so it resized to the specified dimensions.
        /// </summary>
        public static VideoScaleMode Stretch { get; } = new VideoScaleMode("Stretch");

        public static bool operator ==(VideoScaleMode left, VideoScaleMode right) => left.Equals(right);
        public static bool operator !=(VideoScaleMode left, VideoScaleMode right) => !left.Equals(right);

        public static explicit operator string(VideoScaleMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VideoScaleMode other && Equals(other);
        public bool Equals(VideoScaleMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
