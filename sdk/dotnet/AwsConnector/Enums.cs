// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.AwsConnector
{
    /// <summary>
    /// Specifies the transfer acceleration status of the bucket.
    /// </summary>
    [EnumType]
    public readonly struct AccelerateConfigurationAccelerationStatus : IEquatable<AccelerateConfigurationAccelerationStatus>
    {
        private readonly string _value;

        private AccelerateConfigurationAccelerationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AccelerateConfigurationAccelerationStatus enum Enabled
        /// </summary>
        public static AccelerateConfigurationAccelerationStatus Enabled { get; } = new AccelerateConfigurationAccelerationStatus("Enabled");
        /// <summary>
        /// AccelerateConfigurationAccelerationStatus enum Suspended
        /// </summary>
        public static AccelerateConfigurationAccelerationStatus Suspended { get; } = new AccelerateConfigurationAccelerationStatus("Suspended");

        public static bool operator ==(AccelerateConfigurationAccelerationStatus left, AccelerateConfigurationAccelerationStatus right) => left.Equals(right);
        public static bool operator !=(AccelerateConfigurationAccelerationStatus left, AccelerateConfigurationAccelerationStatus right) => !left.Equals(right);

        public static explicit operator string(AccelerateConfigurationAccelerationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccelerateConfigurationAccelerationStatus other && Equals(other);
        public bool Equals(AccelerateConfigurationAccelerationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is a legacy property, and it is not recommended for most use cases. A majority of modern use cases in Amazon S3 no longer require the use of ACLs, and we recommend that you keep ACLs disabled. For more information, see [Controlling object ownership](https://docs.aws.amazon.com//AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.  A canned access control list (ACL) that grants predefined permissions to the bucket. For more information about canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the *Amazon S3 User Guide*.  S3 buckets are created with ACLs disabled by default. Therefore, unless you explicitly set the [AWS::S3::OwnershipControls](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html) property to enable ACLs, your resource will fail to deploy with any value other than Private. Use cases requiring ACLs are uncommon.  The majority of access control configurations can be successfully and more easily achieved with bucket policies. For more information, see [AWS::S3::BucketPolicy](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html). For examples of common policy configurations, including S3 Server Access Logs buckets and more, see [Bucket policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html) in the *Amazon S3 User Guide*.
    /// </summary>
    [EnumType]
    public readonly struct AccessControl : IEquatable<AccessControl>
    {
        private readonly string _value;

        private AccessControl(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AccessControl enum AuthenticatedRead
        /// </summary>
        public static AccessControl AuthenticatedRead { get; } = new AccessControl("AuthenticatedRead");
        /// <summary>
        /// AccessControl enum AwsExecRead
        /// </summary>
        public static AccessControl AwsExecRead { get; } = new AccessControl("AwsExecRead");
        /// <summary>
        /// AccessControl enum BucketOwnerFullControl
        /// </summary>
        public static AccessControl BucketOwnerFullControl { get; } = new AccessControl("BucketOwnerFullControl");
        /// <summary>
        /// AccessControl enum BucketOwnerRead
        /// </summary>
        public static AccessControl BucketOwnerRead { get; } = new AccessControl("BucketOwnerRead");
        /// <summary>
        /// AccessControl enum LogDeliveryWrite
        /// </summary>
        public static AccessControl LogDeliveryWrite { get; } = new AccessControl("LogDeliveryWrite");
        /// <summary>
        /// AccessControl enum Private
        /// </summary>
        public static AccessControl Private { get; } = new AccessControl("Private");
        /// <summary>
        /// AccessControl enum PublicRead
        /// </summary>
        public static AccessControl PublicRead { get; } = new AccessControl("PublicRead");
        /// <summary>
        /// AccessControl enum PublicReadWrite
        /// </summary>
        public static AccessControl PublicReadWrite { get; } = new AccessControl("PublicReadWrite");

        public static bool operator ==(AccessControl left, AccessControl right) => left.Equals(right);
        public static bool operator !=(AccessControl left, AccessControl right) => !left.Equals(right);

        public static explicit operator string(AccessControl value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessControl other && Equals(other);
        public bool Equals(AccessControl other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct Action : IEquatable<Action>
    {
        private readonly string _value;

        private Action(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Action enum ALLOW
        /// </summary>
        public static Action ALLOW { get; } = new Action("ALLOW");
        /// <summary>
        /// Action enum BLOCK
        /// </summary>
        public static Action BLOCK { get; } = new Action("BLOCK");
        /// <summary>
        /// Action enum CAPTCHA
        /// </summary>
        public static Action CAPTCHA { get; } = new Action("CAPTCHA");
        /// <summary>
        /// Action enum CHALLENGE
        /// </summary>
        public static Action CHALLENGE { get; } = new Action("CHALLENGE");
        /// <summary>
        /// Action enum COUNT
        /// </summary>
        public static Action COUNT { get; } = new Action("COUNT");
        /// <summary>
        /// Action enum EXCLUDED_AS_COUNT
        /// </summary>
        public static Action EXCLUDED_AS_COUNT { get; } = new Action("EXCLUDED_AS_COUNT");

        public static bool operator ==(Action left, Action right) => left.Equals(right);
        public static bool operator !=(Action left, Action right) => !left.Equals(right);

        public static explicit operator string(Action value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Action other && Equals(other);
        public bool Equals(Action other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Status of the Addon
    /// </summary>
    [EnumType]
    public readonly struct AddOnStatus : IEquatable<AddOnStatus>
    {
        private readonly string _value;

        private AddOnStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AddOnStatus enum Disabled
        /// </summary>
        public static AddOnStatus Disabled { get; } = new AddOnStatus("Disabled");
        /// <summary>
        /// AddOnStatus enum Disabling
        /// </summary>
        public static AddOnStatus Disabling { get; } = new AddOnStatus("Disabling");
        /// <summary>
        /// AddOnStatus enum Enabled
        /// </summary>
        public static AddOnStatus Enabled { get; } = new AddOnStatus("Enabled");
        /// <summary>
        /// AddOnStatus enum Enabling
        /// </summary>
        public static AddOnStatus Enabling { get; } = new AddOnStatus("Enabling");
        /// <summary>
        /// AddOnStatus enum Failed
        /// </summary>
        public static AddOnStatus Failed { get; } = new AddOnStatus("Failed");
        /// <summary>
        /// AddOnStatus enum Terminated
        /// </summary>
        public static AddOnStatus Terminated { get; } = new AddOnStatus("Terminated");
        /// <summary>
        /// AddOnStatus enum Terminating
        /// </summary>
        public static AddOnStatus Terminating { get; } = new AddOnStatus("Terminating");

        public static bool operator ==(AddOnStatus left, AddOnStatus right) => left.Equals(right);
        public static bool operator !=(AddOnStatus left, AddOnStatus right) => !left.Equals(right);

        public static explicit operator string(AddOnStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddOnStatus other && Equals(other);
        public bool Equals(AddOnStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AmdSevSnpSpecification : IEquatable<AmdSevSnpSpecification>
    {
        private readonly string _value;

        private AmdSevSnpSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AmdSevSnpSpecification enum disabled
        /// </summary>
        public static AmdSevSnpSpecification Disabled { get; } = new AmdSevSnpSpecification("disabled");
        /// <summary>
        /// AmdSevSnpSpecification enum enabled
        /// </summary>
        public static AmdSevSnpSpecification Enabled { get; } = new AmdSevSnpSpecification("enabled");

        public static bool operator ==(AmdSevSnpSpecification left, AmdSevSnpSpecification right) => left.Equals(right);
        public static bool operator !=(AmdSevSnpSpecification left, AmdSevSnpSpecification right) => !left.Equals(right);

        public static explicit operator string(AmdSevSnpSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AmdSevSnpSpecification other && Equals(other);
        public bool Equals(AmdSevSnpSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AnomalyResultEnum : IEquatable<AnomalyResultEnum>
    {
        private readonly string _value;

        private AnomalyResultEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AnomalyResultEnum enum anomalous
        /// </summary>
        public static AnomalyResultEnum Anomalous { get; } = new AnomalyResultEnum("anomalous");
        /// <summary>
        /// AnomalyResultEnum enum normal
        /// </summary>
        public static AnomalyResultEnum Normal { get; } = new AnomalyResultEnum("normal");

        public static bool operator ==(AnomalyResultEnum left, AnomalyResultEnum right) => left.Equals(right);
        public static bool operator !=(AnomalyResultEnum left, AnomalyResultEnum right) => !left.Equals(right);

        public static explicit operator string(AnomalyResultEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AnomalyResultEnum other && Equals(other);
        public bool Equals(AnomalyResultEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of app.
    /// </summary>
    [EnumType]
    public readonly struct AppType : IEquatable<AppType>
    {
        private readonly string _value;

        private AppType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AppType enum Canvas
        /// </summary>
        public static AppType Canvas { get; } = new AppType("Canvas");
        /// <summary>
        /// AppType enum JupyterServer
        /// </summary>
        public static AppType JupyterServer { get; } = new AppType("JupyterServer");
        /// <summary>
        /// AppType enum KernelGateway
        /// </summary>
        public static AppType KernelGateway { get; } = new AppType("KernelGateway");
        /// <summary>
        /// AppType enum RSessionGateway
        /// </summary>
        public static AppType RSessionGateway { get; } = new AppType("RSessionGateway");
        /// <summary>
        /// AppType enum RStudioServerPro
        /// </summary>
        public static AppType RStudioServerPro { get; } = new AppType("RStudioServerPro");

        public static bool operator ==(AppType left, AppType right) => left.Equals(right);
        public static bool operator !=(AppType left, AppType right) => !left.Equals(right);

        public static explicit operator string(AppType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AppType other && Equals(other);
        public bool Equals(AppType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ArchitectureValues : IEquatable<ArchitectureValues>
    {
        private readonly string _value;

        private ArchitectureValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ArchitectureValues enum arm64
        /// </summary>
        public static ArchitectureValues Arm64 { get; } = new ArchitectureValues("arm64");
        /// <summary>
        /// ArchitectureValues enum arm64_mac
        /// </summary>
        public static ArchitectureValues Arm64_mac { get; } = new ArchitectureValues("arm64_mac");
        /// <summary>
        /// ArchitectureValues enum i386
        /// </summary>
        public static ArchitectureValues I386 { get; } = new ArchitectureValues("i386");
        /// <summary>
        /// ArchitectureValues enum x86_64
        /// </summary>
        public static ArchitectureValues X86_64 { get; } = new ArchitectureValues("x86_64");
        /// <summary>
        /// ArchitectureValues enum x86_64_mac
        /// </summary>
        public static ArchitectureValues X86_64_mac { get; } = new ArchitectureValues("x86_64_mac");

        public static bool operator ==(ArchitectureValues left, ArchitectureValues right) => left.Equals(right);
        public static bool operator !=(ArchitectureValues left, ArchitectureValues right) => !left.Equals(right);

        public static explicit operator string(ArchitectureValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArchitectureValues other && Equals(other);
        public bool Equals(ArchitectureValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Architectures enum
    /// </summary>
    [EnumType]
    public readonly struct Architectures : IEquatable<Architectures>
    {
        private readonly string _value;

        private Architectures(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Architectures enum arm64
        /// </summary>
        public static Architectures Arm64 { get; } = new Architectures("arm64");
        /// <summary>
        /// Architectures enum x86_64
        /// </summary>
        public static Architectures X86_64 { get; } = new Architectures("x86_64");

        public static bool operator ==(Architectures left, Architectures right) => left.Equals(right);
        public static bool operator !=(Architectures left, Architectures right) => !left.Equals(right);

        public static explicit operator string(Architectures value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Architectures other && Equals(other);
        public bool Equals(Architectures other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ArtifactNamespace : IEquatable<ArtifactNamespace>
    {
        private readonly string _value;

        private ArtifactNamespace(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ArtifactNamespace enum BUILD_ID
        /// </summary>
        public static ArtifactNamespace BUILD_ID { get; } = new ArtifactNamespace("BUILD_ID");
        /// <summary>
        /// ArtifactNamespace enum NONE
        /// </summary>
        public static ArtifactNamespace NONE { get; } = new ArtifactNamespace("NONE");

        public static bool operator ==(ArtifactNamespace left, ArtifactNamespace right) => left.Equals(right);
        public static bool operator !=(ArtifactNamespace left, ArtifactNamespace right) => !left.Equals(right);

        public static explicit operator string(ArtifactNamespace value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArtifactNamespace other && Equals(other);
        public bool Equals(ArtifactNamespace other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ArtifactPackaging : IEquatable<ArtifactPackaging>
    {
        private readonly string _value;

        private ArtifactPackaging(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ArtifactPackaging enum NONE
        /// </summary>
        public static ArtifactPackaging NONE { get; } = new ArtifactPackaging("NONE");
        /// <summary>
        /// ArtifactPackaging enum ZIP
        /// </summary>
        public static ArtifactPackaging ZIP { get; } = new ArtifactPackaging("ZIP");

        public static bool operator ==(ArtifactPackaging left, ArtifactPackaging right) => left.Equals(right);
        public static bool operator !=(ArtifactPackaging left, ArtifactPackaging right) => !left.Equals(right);

        public static explicit operator string(ArtifactPackaging value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArtifactPackaging other && Equals(other);
        public bool Equals(ArtifactPackaging other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ArtifactsType : IEquatable<ArtifactsType>
    {
        private readonly string _value;

        private ArtifactsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ArtifactsType enum CODEPIPELINE
        /// </summary>
        public static ArtifactsType CODEPIPELINE { get; } = new ArtifactsType("CODEPIPELINE");
        /// <summary>
        /// ArtifactsType enum NO_ARTIFACTS
        /// </summary>
        public static ArtifactsType NO_ARTIFACTS { get; } = new ArtifactsType("NO_ARTIFACTS");
        /// <summary>
        /// ArtifactsType enum S3
        /// </summary>
        public static ArtifactsType S3 { get; } = new ArtifactsType("S3");

        public static bool operator ==(ArtifactsType left, ArtifactsType right) => left.Equals(right);
        public static bool operator !=(ArtifactsType left, ArtifactsType right) => !left.Equals(right);

        public static explicit operator string(ArtifactsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArtifactsType other && Equals(other);
        public bool Equals(ArtifactsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AttachmentStatus : IEquatable<AttachmentStatus>
    {
        private readonly string _value;

        private AttachmentStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AttachmentStatus enum attached
        /// </summary>
        public static AttachmentStatus Attached { get; } = new AttachmentStatus("attached");
        /// <summary>
        /// AttachmentStatus enum attaching
        /// </summary>
        public static AttachmentStatus Attaching { get; } = new AttachmentStatus("attaching");
        /// <summary>
        /// AttachmentStatus enum detached
        /// </summary>
        public static AttachmentStatus Detached { get; } = new AttachmentStatus("detached");
        /// <summary>
        /// AttachmentStatus enum detaching
        /// </summary>
        public static AttachmentStatus Detaching { get; } = new AttachmentStatus("detaching");

        public static bool operator ==(AttachmentStatus left, AttachmentStatus right) => left.Equals(right);
        public static bool operator !=(AttachmentStatus left, AttachmentStatus right) => !left.Equals(right);

        public static explicit operator string(AttachmentStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachmentStatus other && Equals(other);
        public bool Equals(AttachmentStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AuthType : IEquatable<AuthType>
    {
        private readonly string _value;

        private AuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AuthType enum BASIC_AUTH
        /// </summary>
        public static AuthType BASIC_AUTH { get; } = new AuthType("BASIC_AUTH");
        /// <summary>
        /// AuthType enum CODECONNECTIONS
        /// </summary>
        public static AuthType CODECONNECTIONS { get; } = new AuthType("CODECONNECTIONS");
        /// <summary>
        /// AuthType enum OAUTH
        /// </summary>
        public static AuthType OAUTH { get; } = new AuthType("OAUTH");
        /// <summary>
        /// AuthType enum PERSONAL_ACCESS_TOKEN
        /// </summary>
        public static AuthType PERSONAL_ACCESS_TOKEN { get; } = new AuthType("PERSONAL_ACCESS_TOKEN");

        public static bool operator ==(AuthType left, AuthType right) => left.Equals(right);
        public static bool operator !=(AuthType left, AuthType right) => !left.Equals(right);

        public static explicit operator string(AuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthType other && Equals(other);
        public bool Equals(AuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AuthenticationMode : IEquatable<AuthenticationMode>
    {
        private readonly string _value;

        private AuthenticationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AuthenticationMode enum API
        /// </summary>
        public static AuthenticationMode API { get; } = new AuthenticationMode("API");
        /// <summary>
        /// AuthenticationMode enum API_AND_CONFIG_MAP
        /// </summary>
        public static AuthenticationMode API_AND_CONFIG_MAP { get; } = new AuthenticationMode("API_AND_CONFIG_MAP");
        /// <summary>
        /// AuthenticationMode enum CONFIG_MAP
        /// </summary>
        public static AuthenticationMode CONFIG_MAP { get; } = new AuthenticationMode("CONFIG_MAP");

        public static bool operator ==(AuthenticationMode left, AuthenticationMode right) => left.Equals(right);
        public static bool operator !=(AuthenticationMode left, AuthenticationMode right) => !left.Equals(right);

        public static explicit operator string(AuthenticationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthenticationMode other && Equals(other);
        public bool Equals(AuthenticationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AuthenticationType : IEquatable<AuthenticationType>
    {
        private readonly string _value;

        private AuthenticationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AuthenticationType enum AMAZON_COGNITO_USER_POOLS
        /// </summary>
        public static AuthenticationType AMAZON_COGNITO_USER_POOLS { get; } = new AuthenticationType("AMAZON_COGNITO_USER_POOLS");
        /// <summary>
        /// AuthenticationType enum API_KEY
        /// </summary>
        public static AuthenticationType API_KEY { get; } = new AuthenticationType("API_KEY");
        /// <summary>
        /// AuthenticationType enum AWS_IAM
        /// </summary>
        public static AuthenticationType AWS_IAM { get; } = new AuthenticationType("AWS_IAM");
        /// <summary>
        /// AuthenticationType enum AWS_LAMBDA
        /// </summary>
        public static AuthenticationType AWS_LAMBDA { get; } = new AuthenticationType("AWS_LAMBDA");
        /// <summary>
        /// AuthenticationType enum OPENID_CONNECT
        /// </summary>
        public static AuthenticationType OPENID_CONNECT { get; } = new AuthenticationType("OPENID_CONNECT");

        public static bool operator ==(AuthenticationType left, AuthenticationType right) => left.Equals(right);
        public static bool operator !=(AuthenticationType left, AuthenticationType right) => !left.Equals(right);

        public static explicit operator string(AuthenticationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthenticationType other && Equals(other);
        public bool Equals(AuthenticationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to use the Amazon ECS task role defined in a task definition when mounting the Amazon EFS file system. If it is turned on, transit encryption must be turned on in the ``EFSVolumeConfiguration``. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Using Amazon EFS access points](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the *Amazon Elastic Container Service Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct AuthorizationConfigIAM : IEquatable<AuthorizationConfigIAM>
    {
        private readonly string _value;

        private AuthorizationConfigIAM(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AuthorizationConfigIAM enum DISABLED
        /// </summary>
        public static AuthorizationConfigIAM DISABLED { get; } = new AuthorizationConfigIAM("DISABLED");
        /// <summary>
        /// AuthorizationConfigIAM enum ENABLED
        /// </summary>
        public static AuthorizationConfigIAM ENABLED { get; } = new AuthorizationConfigIAM("ENABLED");

        public static bool operator ==(AuthorizationConfigIAM left, AuthorizationConfigIAM right) => left.Equals(right);
        public static bool operator !=(AuthorizationConfigIAM left, AuthorizationConfigIAM right) => !left.Equals(right);

        public static explicit operator string(AuthorizationConfigIAM value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthorizationConfigIAM other && Equals(other);
        public bool Equals(AuthorizationConfigIAM other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct AutoTuneState : IEquatable<AutoTuneState>
    {
        private readonly string _value;

        private AutoTuneState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AutoTuneState enum DISABLED
        /// </summary>
        public static AutoTuneState DISABLED { get; } = new AutoTuneState("DISABLED");
        /// <summary>
        /// AutoTuneState enum DISABLED_AND_ROLLBACK_COMPLETE
        /// </summary>
        public static AutoTuneState DISABLED_AND_ROLLBACK_COMPLETE { get; } = new AutoTuneState("DISABLED_AND_ROLLBACK_COMPLETE");
        /// <summary>
        /// AutoTuneState enum DISABLED_AND_ROLLBACK_ERROR
        /// </summary>
        public static AutoTuneState DISABLED_AND_ROLLBACK_ERROR { get; } = new AutoTuneState("DISABLED_AND_ROLLBACK_ERROR");
        /// <summary>
        /// AutoTuneState enum DISABLED_AND_ROLLBACK_IN_PROGRESS
        /// </summary>
        public static AutoTuneState DISABLED_AND_ROLLBACK_IN_PROGRESS { get; } = new AutoTuneState("DISABLED_AND_ROLLBACK_IN_PROGRESS");
        /// <summary>
        /// AutoTuneState enum DISABLED_AND_ROLLBACK_SCHEDULED
        /// </summary>
        public static AutoTuneState DISABLED_AND_ROLLBACK_SCHEDULED { get; } = new AutoTuneState("DISABLED_AND_ROLLBACK_SCHEDULED");
        /// <summary>
        /// AutoTuneState enum DISABLE_IN_PROGRESS
        /// </summary>
        public static AutoTuneState DISABLE_IN_PROGRESS { get; } = new AutoTuneState("DISABLE_IN_PROGRESS");
        /// <summary>
        /// AutoTuneState enum ENABLED
        /// </summary>
        public static AutoTuneState ENABLED { get; } = new AutoTuneState("ENABLED");
        /// <summary>
        /// AutoTuneState enum ENABLE_IN_PROGRESS
        /// </summary>
        public static AutoTuneState ENABLE_IN_PROGRESS { get; } = new AutoTuneState("ENABLE_IN_PROGRESS");
        /// <summary>
        /// AutoTuneState enum ERROR
        /// </summary>
        public static AutoTuneState ERROR { get; } = new AutoTuneState("ERROR");

        public static bool operator ==(AutoTuneState left, AutoTuneState right) => left.Equals(right);
        public static bool operator !=(AutoTuneState left, AutoTuneState right) => !left.Equals(right);

        public static explicit operator string(AutoTuneState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoTuneState other && Equals(other);
        public bool Equals(AutoTuneState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the task's elastic network interface receives a public IP address. The default value is ``DISABLED``.
    /// </summary>
    [EnumType]
    public readonly struct AwsVpcConfigurationAssignPublicIp : IEquatable<AwsVpcConfigurationAssignPublicIp>
    {
        private readonly string _value;

        private AwsVpcConfigurationAssignPublicIp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AwsVpcConfigurationAssignPublicIp enum DISABLED
        /// </summary>
        public static AwsVpcConfigurationAssignPublicIp DISABLED { get; } = new AwsVpcConfigurationAssignPublicIp("DISABLED");
        /// <summary>
        /// AwsVpcConfigurationAssignPublicIp enum ENABLED
        /// </summary>
        public static AwsVpcConfigurationAssignPublicIp ENABLED { get; } = new AwsVpcConfigurationAssignPublicIp("ENABLED");

        public static bool operator ==(AwsVpcConfigurationAssignPublicIp left, AwsVpcConfigurationAssignPublicIp right) => left.Equals(right);
        public static bool operator !=(AwsVpcConfigurationAssignPublicIp left, AwsVpcConfigurationAssignPublicIp right) => !left.Equals(right);

        public static explicit operator string(AwsVpcConfigurationAssignPublicIp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AwsVpcConfigurationAssignPublicIp other && Equals(other);
        public bool Equals(AwsVpcConfigurationAssignPublicIp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set the backup policy status for the file system.  +   *ENABLED* - Turns automatic backups on for the file system.   +   *DISABLED* - Turns automatic backups off for the file system.
    /// </summary>
    [EnumType]
    public readonly struct BackupPolicyStatus : IEquatable<BackupPolicyStatus>
    {
        private readonly string _value;

        private BackupPolicyStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// BackupPolicyStatus enum DISABLED
        /// </summary>
        public static BackupPolicyStatus DISABLED { get; } = new BackupPolicyStatus("DISABLED");
        /// <summary>
        /// BackupPolicyStatus enum ENABLED
        /// </summary>
        public static BackupPolicyStatus ENABLED { get; } = new BackupPolicyStatus("ENABLED");

        public static bool operator ==(BackupPolicyStatus left, BackupPolicyStatus right) => left.Equals(right);
        public static bool operator !=(BackupPolicyStatus left, BackupPolicyStatus right) => !left.Equals(right);

        public static explicit operator string(BackupPolicyStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupPolicyStatus other && Equals(other);
        public bool Equals(BackupPolicyStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct BatchReportModeType : IEquatable<BatchReportModeType>
    {
        private readonly string _value;

        private BatchReportModeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// BatchReportModeType enum REPORT_AGGREGATED_BATCH
        /// </summary>
        public static BatchReportModeType REPORT_AGGREGATED_BATCH { get; } = new BatchReportModeType("REPORT_AGGREGATED_BATCH");
        /// <summary>
        /// BatchReportModeType enum REPORT_INDIVIDUAL_BUILDS
        /// </summary>
        public static BatchReportModeType REPORT_INDIVIDUAL_BUILDS { get; } = new BatchReportModeType("REPORT_INDIVIDUAL_BUILDS");

        public static bool operator ==(BatchReportModeType left, BatchReportModeType right) => left.Equals(right);
        public static bool operator !=(BatchReportModeType left, BatchReportModeType right) => !left.Equals(right);

        public static explicit operator string(BatchReportModeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchReportModeType other && Equals(other);
        public bool Equals(BatchReportModeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct BootModeValues : IEquatable<BootModeValues>
    {
        private readonly string _value;

        private BootModeValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// BootModeValues enum legacy-bios
        /// </summary>
        public static BootModeValues LegacyBios { get; } = new BootModeValues("legacy-bios");
        /// <summary>
        /// BootModeValues enum uefi
        /// </summary>
        public static BootModeValues Uefi { get; } = new BootModeValues("uefi");
        /// <summary>
        /// BootModeValues enum uefi-preferred
        /// </summary>
        public static BootModeValues UefiPreferred { get; } = new BootModeValues("uefi-preferred");

        public static bool operator ==(BootModeValues left, BootModeValues right) => left.Equals(right);
        public static bool operator !=(BootModeValues left, BootModeValues right) => !left.Equals(right);

        public static explicit operator string(BootModeValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BootModeValues other && Equals(other);
        public bool Equals(BootModeValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct BucketOwnerAccess : IEquatable<BucketOwnerAccess>
    {
        private readonly string _value;

        private BucketOwnerAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// BucketOwnerAccess enum FULL
        /// </summary>
        public static BucketOwnerAccess FULL { get; } = new BucketOwnerAccess("FULL");
        /// <summary>
        /// BucketOwnerAccess enum NONE
        /// </summary>
        public static BucketOwnerAccess NONE { get; } = new BucketOwnerAccess("NONE");
        /// <summary>
        /// BucketOwnerAccess enum READ_ONLY
        /// </summary>
        public static BucketOwnerAccess READ_ONLY { get; } = new BucketOwnerAccess("READ_ONLY");

        public static bool operator ==(BucketOwnerAccess left, BucketOwnerAccess right) => left.Equals(right);
        public static bool operator !=(BucketOwnerAccess left, BucketOwnerAccess right) => !left.Equals(right);

        public static explicit operator string(BucketOwnerAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BucketOwnerAccess other && Equals(other);
        public bool Equals(BucketOwnerAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property status
    /// </summary>
    [EnumType]
    public readonly struct CFNFeatureConfigurationStatus : IEquatable<CFNFeatureConfigurationStatus>
    {
        private readonly string _value;

        private CFNFeatureConfigurationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CFNFeatureConfigurationStatus enum DISABLED
        /// </summary>
        public static CFNFeatureConfigurationStatus DISABLED { get; } = new CFNFeatureConfigurationStatus("DISABLED");
        /// <summary>
        /// CFNFeatureConfigurationStatus enum ENABLED
        /// </summary>
        public static CFNFeatureConfigurationStatus ENABLED { get; } = new CFNFeatureConfigurationStatus("ENABLED");

        public static bool operator ==(CFNFeatureConfigurationStatus left, CFNFeatureConfigurationStatus right) => left.Equals(right);
        public static bool operator !=(CFNFeatureConfigurationStatus left, CFNFeatureConfigurationStatus right) => !left.Equals(right);

        public static explicit operator string(CFNFeatureConfigurationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CFNFeatureConfigurationStatus other && Equals(other);
        public bool Equals(CFNFeatureConfigurationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CacheMode enum
    /// </summary>
    [EnumType]
    public readonly struct CacheMode : IEquatable<CacheMode>
    {
        private readonly string _value;

        private CacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CacheMode enum LOCAL_CUSTOM_CACHE
        /// </summary>
        public static CacheMode LOCAL_CUSTOM_CACHE { get; } = new CacheMode("LOCAL_CUSTOM_CACHE");
        /// <summary>
        /// CacheMode enum LOCAL_DOCKER_LAYER_CACHE
        /// </summary>
        public static CacheMode LOCAL_DOCKER_LAYER_CACHE { get; } = new CacheMode("LOCAL_DOCKER_LAYER_CACHE");
        /// <summary>
        /// CacheMode enum LOCAL_SOURCE_CACHE
        /// </summary>
        public static CacheMode LOCAL_SOURCE_CACHE { get; } = new CacheMode("LOCAL_SOURCE_CACHE");

        public static bool operator ==(CacheMode left, CacheMode right) => left.Equals(right);
        public static bool operator !=(CacheMode left, CacheMode right) => !left.Equals(right);

        public static explicit operator string(CacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CacheMode other && Equals(other);
        public bool Equals(CacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct CacheType : IEquatable<CacheType>
    {
        private readonly string _value;

        private CacheType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CacheType enum LOCAL
        /// </summary>
        public static CacheType LOCAL { get; } = new CacheType("LOCAL");
        /// <summary>
        /// CacheType enum NO_CACHE
        /// </summary>
        public static CacheType NO_CACHE { get; } = new CacheType("NO_CACHE");
        /// <summary>
        /// CacheType enum S3
        /// </summary>
        public static CacheType S3 { get; } = new CacheType("S3");

        public static bool operator ==(CacheType left, CacheType right) => left.Equals(right);
        public static bool operator !=(CacheType left, CacheType right) => !left.Equals(right);

        public static explicit operator string(CacheType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CacheType other && Equals(other);
        public bool Equals(CacheType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
    /// </summary>
    [EnumType]
    public readonly struct CallAs : IEquatable<CallAs>
    {
        private readonly string _value;

        private CallAs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CallAs enum DELEGATED_ADMIN
        /// </summary>
        public static CallAs DELEGATED_ADMIN { get; } = new CallAs("DELEGATED_ADMIN");
        /// <summary>
        /// CallAs enum SELF
        /// </summary>
        public static CallAs SELF { get; } = new CallAs("SELF");

        public static bool operator ==(CallAs left, CallAs right) => left.Equals(right);
        public static bool operator !=(CallAs left, CallAs right) => !left.Equals(right);

        public static explicit operator string(CallAs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CallAs other && Equals(other);
        public bool Equals(CallAs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Capabilities enum
    /// </summary>
    [EnumType]
    public readonly struct Capabilities : IEquatable<Capabilities>
    {
        private readonly string _value;

        private Capabilities(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Capabilities enum CAPABILITY_AUTO_EXPAND
        /// </summary>
        public static Capabilities CAPABILITY_AUTO_EXPAND { get; } = new Capabilities("CAPABILITY_AUTO_EXPAND");
        /// <summary>
        /// Capabilities enum CAPABILITY_IAM
        /// </summary>
        public static Capabilities CAPABILITY_IAM { get; } = new Capabilities("CAPABILITY_IAM");
        /// <summary>
        /// Capabilities enum CAPABILITY_NAMED_IAM
        /// </summary>
        public static Capabilities CAPABILITY_NAMED_IAM { get; } = new Capabilities("CAPABILITY_NAMED_IAM");

        public static bool operator ==(Capabilities left, Capabilities right) => left.Equals(right);
        public static bool operator !=(Capabilities left, Capabilities right) => !left.Equals(right);

        public static explicit operator string(Capabilities value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Capabilities other && Equals(other);
        public bool Equals(Capabilities other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct CapacityReservationPreference : IEquatable<CapacityReservationPreference>
    {
        private readonly string _value;

        private CapacityReservationPreference(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CapacityReservationPreference enum none
        /// </summary>
        public static CapacityReservationPreference None { get; } = new CapacityReservationPreference("none");
        /// <summary>
        /// CapacityReservationPreference enum open
        /// </summary>
        public static CapacityReservationPreference Open { get; } = new CapacityReservationPreference("open");

        public static bool operator ==(CapacityReservationPreference left, CapacityReservationPreference right) => left.Equals(right);
        public static bool operator !=(CapacityReservationPreference left, CapacityReservationPreference right) => !left.Equals(right);

        public static explicit operator string(CapacityReservationPreference value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityReservationPreference other && Equals(other);
        public bool Equals(CapacityReservationPreference other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct CertificateStatus : IEquatable<CertificateStatus>
    {
        private readonly string _value;

        private CertificateStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CertificateStatus enum EXPIRED
        /// </summary>
        public static CertificateStatus EXPIRED { get; } = new CertificateStatus("EXPIRED");
        /// <summary>
        /// CertificateStatus enum FAILED
        /// </summary>
        public static CertificateStatus FAILED { get; } = new CertificateStatus("FAILED");
        /// <summary>
        /// CertificateStatus enum INACTIVE
        /// </summary>
        public static CertificateStatus INACTIVE { get; } = new CertificateStatus("INACTIVE");
        /// <summary>
        /// CertificateStatus enum ISSUED
        /// </summary>
        public static CertificateStatus ISSUED { get; } = new CertificateStatus("ISSUED");
        /// <summary>
        /// CertificateStatus enum PENDING_VALIDATION
        /// </summary>
        public static CertificateStatus PENDING_VALIDATION { get; } = new CertificateStatus("PENDING_VALIDATION");
        /// <summary>
        /// CertificateStatus enum REVOKED
        /// </summary>
        public static CertificateStatus REVOKED { get; } = new CertificateStatus("REVOKED");
        /// <summary>
        /// CertificateStatus enum VALIDATION_TIMED_OUT
        /// </summary>
        public static CertificateStatus VALIDATION_TIMED_OUT { get; } = new CertificateStatus("VALIDATION_TIMED_OUT");

        public static bool operator ==(CertificateStatus left, CertificateStatus right) => left.Equals(right);
        public static bool operator !=(CertificateStatus left, CertificateStatus right) => !left.Equals(right);

        public static explicit operator string(CertificateStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateStatus other && Equals(other);
        public bool Equals(CertificateStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct CertificateType : IEquatable<CertificateType>
    {
        private readonly string _value;

        private CertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CertificateType enum AMAZON_ISSUED
        /// </summary>
        public static CertificateType AMAZON_ISSUED { get; } = new CertificateType("AMAZON_ISSUED");
        /// <summary>
        /// CertificateType enum IMPORTED
        /// </summary>
        public static CertificateType IMPORTED { get; } = new CertificateType("IMPORTED");
        /// <summary>
        /// CertificateType enum PRIVATE
        /// </summary>
        public static CertificateType PRIVATE { get; } = new CertificateType("PRIVATE");

        public static bool operator ==(CertificateType left, CertificateType right) => left.Equals(right);
        public static bool operator !=(CertificateType left, CertificateType right) => !left.Equals(right);

        public static explicit operator string(CertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateType other && Equals(other);
        public bool Equals(CertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ClusterEndpointEncryptionType : IEquatable<ClusterEndpointEncryptionType>
    {
        private readonly string _value;

        private ClusterEndpointEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ClusterEndpointEncryptionType enum NONE
        /// </summary>
        public static ClusterEndpointEncryptionType NONE { get; } = new ClusterEndpointEncryptionType("NONE");
        /// <summary>
        /// ClusterEndpointEncryptionType enum TLS
        /// </summary>
        public static ClusterEndpointEncryptionType TLS { get; } = new ClusterEndpointEncryptionType("TLS");

        public static bool operator ==(ClusterEndpointEncryptionType left, ClusterEndpointEncryptionType right) => left.Equals(right);
        public static bool operator !=(ClusterEndpointEncryptionType left, ClusterEndpointEncryptionType right) => !left.Equals(right);

        public static explicit operator string(ClusterEndpointEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterEndpointEncryptionType other && Equals(other);
        public bool Equals(ClusterEndpointEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ClusterIssueCode : IEquatable<ClusterIssueCode>
    {
        private readonly string _value;

        private ClusterIssueCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ClusterIssueCode enum AccessDenied
        /// </summary>
        public static ClusterIssueCode AccessDenied { get; } = new ClusterIssueCode("AccessDenied");
        /// <summary>
        /// ClusterIssueCode enum ClusterUnreachable
        /// </summary>
        public static ClusterIssueCode ClusterUnreachable { get; } = new ClusterIssueCode("ClusterUnreachable");
        /// <summary>
        /// ClusterIssueCode enum ConfigurationConflict
        /// </summary>
        public static ClusterIssueCode ConfigurationConflict { get; } = new ClusterIssueCode("ConfigurationConflict");
        /// <summary>
        /// ClusterIssueCode enum Ec2SecurityGroupNotFound
        /// </summary>
        public static ClusterIssueCode Ec2SecurityGroupNotFound { get; } = new ClusterIssueCode("Ec2SecurityGroupNotFound");
        /// <summary>
        /// ClusterIssueCode enum Ec2ServiceNotSubscribed
        /// </summary>
        public static ClusterIssueCode Ec2ServiceNotSubscribed { get; } = new ClusterIssueCode("Ec2ServiceNotSubscribed");
        /// <summary>
        /// ClusterIssueCode enum Ec2SubnetNotFound
        /// </summary>
        public static ClusterIssueCode Ec2SubnetNotFound { get; } = new ClusterIssueCode("Ec2SubnetNotFound");
        /// <summary>
        /// ClusterIssueCode enum IamRoleNotFound
        /// </summary>
        public static ClusterIssueCode IamRoleNotFound { get; } = new ClusterIssueCode("IamRoleNotFound");
        /// <summary>
        /// ClusterIssueCode enum InsufficientFreeAddresses
        /// </summary>
        public static ClusterIssueCode InsufficientFreeAddresses { get; } = new ClusterIssueCode("InsufficientFreeAddresses");
        /// <summary>
        /// ClusterIssueCode enum InternalFailure
        /// </summary>
        public static ClusterIssueCode InternalFailure { get; } = new ClusterIssueCode("InternalFailure");
        /// <summary>
        /// ClusterIssueCode enum KmsGrantRevoked
        /// </summary>
        public static ClusterIssueCode KmsGrantRevoked { get; } = new ClusterIssueCode("KmsGrantRevoked");
        /// <summary>
        /// ClusterIssueCode enum KmsKeyDisabled
        /// </summary>
        public static ClusterIssueCode KmsKeyDisabled { get; } = new ClusterIssueCode("KmsKeyDisabled");
        /// <summary>
        /// ClusterIssueCode enum KmsKeyMarkedForDeletion
        /// </summary>
        public static ClusterIssueCode KmsKeyMarkedForDeletion { get; } = new ClusterIssueCode("KmsKeyMarkedForDeletion");
        /// <summary>
        /// ClusterIssueCode enum KmsKeyNotFound
        /// </summary>
        public static ClusterIssueCode KmsKeyNotFound { get; } = new ClusterIssueCode("KmsKeyNotFound");
        /// <summary>
        /// ClusterIssueCode enum Other
        /// </summary>
        public static ClusterIssueCode Other { get; } = new ClusterIssueCode("Other");
        /// <summary>
        /// ClusterIssueCode enum ResourceLimitExceeded
        /// </summary>
        public static ClusterIssueCode ResourceLimitExceeded { get; } = new ClusterIssueCode("ResourceLimitExceeded");
        /// <summary>
        /// ClusterIssueCode enum ResourceNotFound
        /// </summary>
        public static ClusterIssueCode ResourceNotFound { get; } = new ClusterIssueCode("ResourceNotFound");
        /// <summary>
        /// ClusterIssueCode enum StsRegionalEndpointDisabled
        /// </summary>
        public static ClusterIssueCode StsRegionalEndpointDisabled { get; } = new ClusterIssueCode("StsRegionalEndpointDisabled");
        /// <summary>
        /// ClusterIssueCode enum UnsupportedVersion
        /// </summary>
        public static ClusterIssueCode UnsupportedVersion { get; } = new ClusterIssueCode("UnsupportedVersion");
        /// <summary>
        /// ClusterIssueCode enum VpcNotFound
        /// </summary>
        public static ClusterIssueCode VpcNotFound { get; } = new ClusterIssueCode("VpcNotFound");

        public static bool operator ==(ClusterIssueCode left, ClusterIssueCode right) => left.Equals(right);
        public static bool operator !=(ClusterIssueCode left, ClusterIssueCode right) => !left.Equals(right);

        public static explicit operator string(ClusterIssueCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterIssueCode other && Equals(other);
        public bool Equals(ClusterIssueCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ClusterState : IEquatable<ClusterState>
    {
        private readonly string _value;

        private ClusterState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ClusterState enum BOOTSTRAPPING
        /// </summary>
        public static ClusterState BOOTSTRAPPING { get; } = new ClusterState("BOOTSTRAPPING");
        /// <summary>
        /// ClusterState enum RUNNING
        /// </summary>
        public static ClusterState RUNNING { get; } = new ClusterState("RUNNING");
        /// <summary>
        /// ClusterState enum STARTING
        /// </summary>
        public static ClusterState STARTING { get; } = new ClusterState("STARTING");
        /// <summary>
        /// ClusterState enum TERMINATED
        /// </summary>
        public static ClusterState TERMINATED { get; } = new ClusterState("TERMINATED");
        /// <summary>
        /// ClusterState enum TERMINATED_WITH_ERRORS
        /// </summary>
        public static ClusterState TERMINATED_WITH_ERRORS { get; } = new ClusterState("TERMINATED_WITH_ERRORS");
        /// <summary>
        /// ClusterState enum TERMINATING
        /// </summary>
        public static ClusterState TERMINATING { get; } = new ClusterState("TERMINATING");
        /// <summary>
        /// ClusterState enum WAITING
        /// </summary>
        public static ClusterState WAITING { get; } = new ClusterState("WAITING");

        public static bool operator ==(ClusterState left, ClusterState right) => left.Equals(right);
        public static bool operator !=(ClusterState left, ClusterState right) => !left.Equals(right);

        public static explicit operator string(ClusterState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterState other && Equals(other);
        public bool Equals(ClusterState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ClusterStateChangeReasonCode : IEquatable<ClusterStateChangeReasonCode>
    {
        private readonly string _value;

        private ClusterStateChangeReasonCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ClusterStateChangeReasonCode enum ALL_STEPS_COMPLETED
        /// </summary>
        public static ClusterStateChangeReasonCode ALL_STEPS_COMPLETED { get; } = new ClusterStateChangeReasonCode("ALL_STEPS_COMPLETED");
        /// <summary>
        /// ClusterStateChangeReasonCode enum BOOTSTRAP_FAILURE
        /// </summary>
        public static ClusterStateChangeReasonCode BOOTSTRAP_FAILURE { get; } = new ClusterStateChangeReasonCode("BOOTSTRAP_FAILURE");
        /// <summary>
        /// ClusterStateChangeReasonCode enum INSTANCE_FAILURE
        /// </summary>
        public static ClusterStateChangeReasonCode INSTANCE_FAILURE { get; } = new ClusterStateChangeReasonCode("INSTANCE_FAILURE");
        /// <summary>
        /// ClusterStateChangeReasonCode enum INSTANCE_FLEET_TIMEOUT
        /// </summary>
        public static ClusterStateChangeReasonCode INSTANCE_FLEET_TIMEOUT { get; } = new ClusterStateChangeReasonCode("INSTANCE_FLEET_TIMEOUT");
        /// <summary>
        /// ClusterStateChangeReasonCode enum INTERNAL_ERROR
        /// </summary>
        public static ClusterStateChangeReasonCode INTERNAL_ERROR { get; } = new ClusterStateChangeReasonCode("INTERNAL_ERROR");
        /// <summary>
        /// ClusterStateChangeReasonCode enum STEP_FAILURE
        /// </summary>
        public static ClusterStateChangeReasonCode STEP_FAILURE { get; } = new ClusterStateChangeReasonCode("STEP_FAILURE");
        /// <summary>
        /// ClusterStateChangeReasonCode enum USER_REQUEST
        /// </summary>
        public static ClusterStateChangeReasonCode USER_REQUEST { get; } = new ClusterStateChangeReasonCode("USER_REQUEST");
        /// <summary>
        /// ClusterStateChangeReasonCode enum VALIDATION_ERROR
        /// </summary>
        public static ClusterStateChangeReasonCode VALIDATION_ERROR { get; } = new ClusterStateChangeReasonCode("VALIDATION_ERROR");

        public static bool operator ==(ClusterStateChangeReasonCode left, ClusterStateChangeReasonCode right) => left.Equals(right);
        public static bool operator !=(ClusterStateChangeReasonCode left, ClusterStateChangeReasonCode right) => !left.Equals(right);

        public static explicit operator string(ClusterStateChangeReasonCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterStateChangeReasonCode other && Equals(other);
        public bool Equals(ClusterStateChangeReasonCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ClusterStatus : IEquatable<ClusterStatus>
    {
        private readonly string _value;

        private ClusterStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ClusterStatus enum ACTIVE
        /// </summary>
        public static ClusterStatus ACTIVE { get; } = new ClusterStatus("ACTIVE");
        /// <summary>
        /// ClusterStatus enum CREATING
        /// </summary>
        public static ClusterStatus CREATING { get; } = new ClusterStatus("CREATING");
        /// <summary>
        /// ClusterStatus enum DELETING
        /// </summary>
        public static ClusterStatus DELETING { get; } = new ClusterStatus("DELETING");
        /// <summary>
        /// ClusterStatus enum FAILED
        /// </summary>
        public static ClusterStatus FAILED { get; } = new ClusterStatus("FAILED");
        /// <summary>
        /// ClusterStatus enum PENDING
        /// </summary>
        public static ClusterStatus PENDING { get; } = new ClusterStatus("PENDING");
        /// <summary>
        /// ClusterStatus enum UPDATING
        /// </summary>
        public static ClusterStatus UPDATING { get; } = new ClusterStatus("UPDATING");

        public static bool operator ==(ClusterStatus left, ClusterStatus right) => left.Equals(right);
        public static bool operator !=(ClusterStatus left, ClusterStatus right) => !left.Equals(right);

        public static explicit operator string(ClusterStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterStatus other && Equals(other);
        public bool Equals(ClusterStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ComplianceSeverity : IEquatable<ComplianceSeverity>
    {
        private readonly string _value;

        private ComplianceSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ComplianceSeverity enum CRITICAL
        /// </summary>
        public static ComplianceSeverity CRITICAL { get; } = new ComplianceSeverity("CRITICAL");
        /// <summary>
        /// ComplianceSeverity enum HIGH
        /// </summary>
        public static ComplianceSeverity HIGH { get; } = new ComplianceSeverity("HIGH");
        /// <summary>
        /// ComplianceSeverity enum INFORMATIONAL
        /// </summary>
        public static ComplianceSeverity INFORMATIONAL { get; } = new ComplianceSeverity("INFORMATIONAL");
        /// <summary>
        /// ComplianceSeverity enum LOW
        /// </summary>
        public static ComplianceSeverity LOW { get; } = new ComplianceSeverity("LOW");
        /// <summary>
        /// ComplianceSeverity enum MEDIUM
        /// </summary>
        public static ComplianceSeverity MEDIUM { get; } = new ComplianceSeverity("MEDIUM");
        /// <summary>
        /// ComplianceSeverity enum UNSPECIFIED
        /// </summary>
        public static ComplianceSeverity UNSPECIFIED { get; } = new ComplianceSeverity("UNSPECIFIED");

        public static bool operator ==(ComplianceSeverity left, ComplianceSeverity right) => left.Equals(right);
        public static bool operator !=(ComplianceSeverity left, ComplianceSeverity right) => !left.Equals(right);

        public static explicit operator string(ComplianceSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComplianceSeverity other && Equals(other);
        public bool Equals(ComplianceSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ComplianceStatus : IEquatable<ComplianceStatus>
    {
        private readonly string _value;

        private ComplianceStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ComplianceStatus enum COMPLIANT
        /// </summary>
        public static ComplianceStatus COMPLIANT { get; } = new ComplianceStatus("COMPLIANT");
        /// <summary>
        /// ComplianceStatus enum NON_COMPLIANT
        /// </summary>
        public static ComplianceStatus NON_COMPLIANT { get; } = new ComplianceStatus("NON_COMPLIANT");

        public static bool operator ==(ComplianceStatus left, ComplianceStatus right) => left.Equals(right);
        public static bool operator !=(ComplianceStatus left, ComplianceStatus right) => !left.Equals(right);

        public static explicit operator string(ComplianceStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComplianceStatus other && Equals(other);
        public bool Equals(ComplianceStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ComputeType : IEquatable<ComputeType>
    {
        private readonly string _value;

        private ComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ComputeType enum BUILD_GENERAL1_2XLARGE
        /// </summary>
        public static ComputeType BUILD_GENERAL1_2XLARGE { get; } = new ComputeType("BUILD_GENERAL1_2XLARGE");
        /// <summary>
        /// ComputeType enum BUILD_GENERAL1_LARGE
        /// </summary>
        public static ComputeType BUILD_GENERAL1_LARGE { get; } = new ComputeType("BUILD_GENERAL1_LARGE");
        /// <summary>
        /// ComputeType enum BUILD_GENERAL1_MEDIUM
        /// </summary>
        public static ComputeType BUILD_GENERAL1_MEDIUM { get; } = new ComputeType("BUILD_GENERAL1_MEDIUM");
        /// <summary>
        /// ComputeType enum BUILD_GENERAL1_SMALL
        /// </summary>
        public static ComputeType BUILD_GENERAL1_SMALL { get; } = new ComputeType("BUILD_GENERAL1_SMALL");
        /// <summary>
        /// ComputeType enum BUILD_GENERAL1_XLARGE
        /// </summary>
        public static ComputeType BUILD_GENERAL1_XLARGE { get; } = new ComputeType("BUILD_GENERAL1_XLARGE");
        /// <summary>
        /// ComputeType enum BUILD_LAMBDA_10GB
        /// </summary>
        public static ComputeType BUILD_LAMBDA_10GB { get; } = new ComputeType("BUILD_LAMBDA_10GB");
        /// <summary>
        /// ComputeType enum BUILD_LAMBDA_1GB
        /// </summary>
        public static ComputeType BUILD_LAMBDA_1GB { get; } = new ComputeType("BUILD_LAMBDA_1GB");
        /// <summary>
        /// ComputeType enum BUILD_LAMBDA_2GB
        /// </summary>
        public static ComputeType BUILD_LAMBDA_2GB { get; } = new ComputeType("BUILD_LAMBDA_2GB");
        /// <summary>
        /// ComputeType enum BUILD_LAMBDA_4GB
        /// </summary>
        public static ComputeType BUILD_LAMBDA_4GB { get; } = new ComputeType("BUILD_LAMBDA_4GB");
        /// <summary>
        /// ComputeType enum BUILD_LAMBDA_8GB
        /// </summary>
        public static ComputeType BUILD_LAMBDA_8GB { get; } = new ComputeType("BUILD_LAMBDA_8GB");

        public static bool operator ==(ComputeType left, ComputeType right) => left.Equals(right);
        public static bool operator !=(ComputeType left, ComputeType right) => !left.Equals(right);

        public static explicit operator string(ComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeType other && Equals(other);
        public bool Equals(ComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ConfigChangeStatus : IEquatable<ConfigChangeStatus>
    {
        private readonly string _value;

        private ConfigChangeStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ConfigChangeStatus enum ApplyingChanges
        /// </summary>
        public static ConfigChangeStatus ApplyingChanges { get; } = new ConfigChangeStatus("ApplyingChanges");
        /// <summary>
        /// ConfigChangeStatus enum Cancelled
        /// </summary>
        public static ConfigChangeStatus Cancelled { get; } = new ConfigChangeStatus("Cancelled");
        /// <summary>
        /// ConfigChangeStatus enum Completed
        /// </summary>
        public static ConfigChangeStatus Completed { get; } = new ConfigChangeStatus("Completed");
        /// <summary>
        /// ConfigChangeStatus enum Initializing
        /// </summary>
        public static ConfigChangeStatus Initializing { get; } = new ConfigChangeStatus("Initializing");
        /// <summary>
        /// ConfigChangeStatus enum Pending
        /// </summary>
        public static ConfigChangeStatus Pending { get; } = new ConfigChangeStatus("Pending");
        /// <summary>
        /// ConfigChangeStatus enum PendingUserInput
        /// </summary>
        public static ConfigChangeStatus PendingUserInput { get; } = new ConfigChangeStatus("PendingUserInput");
        /// <summary>
        /// ConfigChangeStatus enum Validating
        /// </summary>
        public static ConfigChangeStatus Validating { get; } = new ConfigChangeStatus("Validating");
        /// <summary>
        /// ConfigChangeStatus enum ValidationFailed
        /// </summary>
        public static ConfigChangeStatus ValidationFailed { get; } = new ConfigChangeStatus("ValidationFailed");

        public static bool operator ==(ConfigChangeStatus left, ConfigChangeStatus right) => left.Equals(right);
        public static bool operator !=(ConfigChangeStatus left, ConfigChangeStatus right) => !left.Equals(right);

        public static explicit operator string(ConfigChangeStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConfigChangeStatus other && Equals(other);
        public bool Equals(ConfigChangeStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ContinuousBackupsStatus : IEquatable<ContinuousBackupsStatus>
    {
        private readonly string _value;

        private ContinuousBackupsStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ContinuousBackupsStatus enum DISABLED
        /// </summary>
        public static ContinuousBackupsStatus DISABLED { get; } = new ContinuousBackupsStatus("DISABLED");
        /// <summary>
        /// ContinuousBackupsStatus enum ENABLED
        /// </summary>
        public static ContinuousBackupsStatus ENABLED { get; } = new ContinuousBackupsStatus("ENABLED");

        public static bool operator ==(ContinuousBackupsStatus left, ContinuousBackupsStatus right) => left.Equals(right);
        public static bool operator !=(ContinuousBackupsStatus left, ContinuousBackupsStatus right) => !left.Equals(right);

        public static explicit operator string(ContinuousBackupsStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContinuousBackupsStatus other && Equals(other);
        public bool Equals(ContinuousBackupsStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CorsRuleAllowedMethods enum
    /// </summary>
    [EnumType]
    public readonly struct CorsRuleAllowedMethods : IEquatable<CorsRuleAllowedMethods>
    {
        private readonly string _value;

        private CorsRuleAllowedMethods(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CorsRuleAllowedMethods enum DELETE
        /// </summary>
        public static CorsRuleAllowedMethods DELETE { get; } = new CorsRuleAllowedMethods("DELETE");
        /// <summary>
        /// CorsRuleAllowedMethods enum GET
        /// </summary>
        public static CorsRuleAllowedMethods GET { get; } = new CorsRuleAllowedMethods("GET");
        /// <summary>
        /// CorsRuleAllowedMethods enum HEAD
        /// </summary>
        public static CorsRuleAllowedMethods HEAD { get; } = new CorsRuleAllowedMethods("HEAD");
        /// <summary>
        /// CorsRuleAllowedMethods enum POST
        /// </summary>
        public static CorsRuleAllowedMethods POST { get; } = new CorsRuleAllowedMethods("POST");
        /// <summary>
        /// CorsRuleAllowedMethods enum PUT
        /// </summary>
        public static CorsRuleAllowedMethods PUT { get; } = new CorsRuleAllowedMethods("PUT");

        public static bool operator ==(CorsRuleAllowedMethods left, CorsRuleAllowedMethods right) => left.Equals(right);
        public static bool operator !=(CorsRuleAllowedMethods left, CorsRuleAllowedMethods right) => !left.Equals(right);

        public static explicit operator string(CorsRuleAllowedMethods value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CorsRuleAllowedMethods other && Equals(other);
        public bool Equals(CorsRuleAllowedMethods other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct CredentialProviderType : IEquatable<CredentialProviderType>
    {
        private readonly string _value;

        private CredentialProviderType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CredentialProviderType enum SECRETS_MANAGER
        /// </summary>
        public static CredentialProviderType SECRETS_MANAGER { get; } = new CredentialProviderType("SECRETS_MANAGER");

        public static bool operator ==(CredentialProviderType left, CredentialProviderType right) => left.Equals(right);
        public static bool operator !=(CredentialProviderType left, CredentialProviderType right) => !left.Equals(right);

        public static explicit operator string(CredentialProviderType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CredentialProviderType other && Equals(other);
        public bool Equals(CredentialProviderType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DataSourceLevelMetricsBehavior : IEquatable<DataSourceLevelMetricsBehavior>
    {
        private readonly string _value;

        private DataSourceLevelMetricsBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DataSourceLevelMetricsBehavior enum FULL_REQUEST_DATA_SOURCE_METRICS
        /// </summary>
        public static DataSourceLevelMetricsBehavior FULL_REQUEST_DATA_SOURCE_METRICS { get; } = new DataSourceLevelMetricsBehavior("FULL_REQUEST_DATA_SOURCE_METRICS");
        /// <summary>
        /// DataSourceLevelMetricsBehavior enum PER_DATA_SOURCE_METRICS
        /// </summary>
        public static DataSourceLevelMetricsBehavior PER_DATA_SOURCE_METRICS { get; } = new DataSourceLevelMetricsBehavior("PER_DATA_SOURCE_METRICS");

        public static bool operator ==(DataSourceLevelMetricsBehavior left, DataSourceLevelMetricsBehavior right) => left.Equals(right);
        public static bool operator !=(DataSourceLevelMetricsBehavior left, DataSourceLevelMetricsBehavior right) => !left.Equals(right);

        public static explicit operator string(DataSourceLevelMetricsBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataSourceLevelMetricsBehavior other && Equals(other);
        public bool Equals(DataSourceLevelMetricsBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The data type of the parameter, such as ``text`` or ``aws:ec2:image``. The default is ``text``.
    /// </summary>
    [EnumType]
    public readonly struct DataType : IEquatable<DataType>
    {
        private readonly string _value;

        private DataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DataType enum aws:ec2:image
        /// </summary>
        public static DataType AwsEc2Image { get; } = new DataType("aws:ec2:image");
        /// <summary>
        /// DataType enum text
        /// </summary>
        public static DataType Text { get; } = new DataType("text");

        public static bool operator ==(DataType left, DataType right) => left.Equals(right);
        public static bool operator !=(DataType left, DataType right) => !left.Equals(right);

        public static explicit operator string(DataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataType other && Equals(other);
        public bool Equals(DataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DefaultAction : IEquatable<DefaultAction>
    {
        private readonly string _value;

        private DefaultAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DefaultAction enum ALLOW
        /// </summary>
        public static DefaultAction ALLOW { get; } = new DefaultAction("ALLOW");
        /// <summary>
        /// DefaultAction enum DENY
        /// </summary>
        public static DefaultAction DENY { get; } = new DefaultAction("DENY");

        public static bool operator ==(DefaultAction left, DefaultAction right) => left.Equals(right);
        public static bool operator !=(DefaultAction left, DefaultAction right) => !left.Equals(right);

        public static explicit operator string(DefaultAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultAction other && Equals(other);
        public bool Equals(DefaultAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default handling for logs that don't match any of the specified filtering conditions.
    /// </summary>
    [EnumType]
    public readonly struct DefaultBehavior : IEquatable<DefaultBehavior>
    {
        private readonly string _value;

        private DefaultBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DefaultBehavior enum DROP
        /// </summary>
        public static DefaultBehavior DROP { get; } = new DefaultBehavior("DROP");
        /// <summary>
        /// DefaultBehavior enum KEEP
        /// </summary>
        public static DefaultBehavior KEEP { get; } = new DefaultBehavior("KEEP");

        public static bool operator ==(DefaultBehavior left, DefaultBehavior right) => left.Equals(right);
        public static bool operator !=(DefaultBehavior left, DefaultBehavior right) => !left.Equals(right);

        public static explicit operator string(DefaultBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultBehavior other && Equals(other);
        public bool Equals(DefaultBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default Object Lock retention mode you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
    /// </summary>
    [EnumType]
    public readonly struct DefaultRetentionMode : IEquatable<DefaultRetentionMode>
    {
        private readonly string _value;

        private DefaultRetentionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DefaultRetentionMode enum COMPLIANCE
        /// </summary>
        public static DefaultRetentionMode COMPLIANCE { get; } = new DefaultRetentionMode("COMPLIANCE");
        /// <summary>
        /// DefaultRetentionMode enum GOVERNANCE
        /// </summary>
        public static DefaultRetentionMode GOVERNANCE { get; } = new DefaultRetentionMode("GOVERNANCE");

        public static bool operator ==(DefaultRetentionMode left, DefaultRetentionMode right) => left.Equals(right);
        public static bool operator !=(DefaultRetentionMode left, DefaultRetentionMode right) => !left.Equals(right);

        public static explicit operator string(DefaultRetentionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultRetentionMode other && Equals(other);
        public bool Equals(DefaultRetentionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to replicate delete markers. Disabled by default.
    /// </summary>
    [EnumType]
    public readonly struct DeleteMarkerReplicationStatus : IEquatable<DeleteMarkerReplicationStatus>
    {
        private readonly string _value;

        private DeleteMarkerReplicationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DeleteMarkerReplicationStatus enum Disabled
        /// </summary>
        public static DeleteMarkerReplicationStatus Disabled { get; } = new DeleteMarkerReplicationStatus("Disabled");
        /// <summary>
        /// DeleteMarkerReplicationStatus enum Enabled
        /// </summary>
        public static DeleteMarkerReplicationStatus Enabled { get; } = new DeleteMarkerReplicationStatus("Enabled");

        public static bool operator ==(DeleteMarkerReplicationStatus left, DeleteMarkerReplicationStatus right) => left.Equals(right);
        public static bool operator !=(DeleteMarkerReplicationStatus left, DeleteMarkerReplicationStatus right) => !left.Equals(right);

        public static explicit operator string(DeleteMarkerReplicationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeleteMarkerReplicationStatus other && Equals(other);
        public bool Equals(DeleteMarkerReplicationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deployment controller type to use. There are three deployment controller types available:  + ECS The rolling update (ECS) deployment type involves replacing the current running version of the container with the latest version. The number of containers Amazon ECS adds or removes from the service during a rolling update is controlled by adjusting the minimum and maximum number of healthy tasks allowed during a service deployment, as specified in the DeploymentConfiguration. + CODE_DEPLOY The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model powered by , which allows you to verify a new deployment of a service before sending production traffic to it. + EXTERNAL The external (EXTERNAL) deployment type enables you to use any third-party deployment controller for full control over the deployment process for an Amazon ECS service.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentControllerType : IEquatable<DeploymentControllerType>
    {
        private readonly string _value;

        private DeploymentControllerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DeploymentControllerType enum CODE_DEPLOY
        /// </summary>
        public static DeploymentControllerType CODE_DEPLOY { get; } = new DeploymentControllerType("CODE_DEPLOY");
        /// <summary>
        /// DeploymentControllerType enum ECS
        /// </summary>
        public static DeploymentControllerType ECS { get; } = new DeploymentControllerType("ECS");
        /// <summary>
        /// DeploymentControllerType enum EXTERNAL
        /// </summary>
        public static DeploymentControllerType EXTERNAL { get; } = new DeploymentControllerType("EXTERNAL");

        public static bool operator ==(DeploymentControllerType left, DeploymentControllerType right) => left.Equals(right);
        public static bool operator !=(DeploymentControllerType left, DeploymentControllerType right) => !left.Equals(right);

        public static explicit operator string(DeploymentControllerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentControllerType other && Equals(other);
        public bool Equals(DeploymentControllerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DeploymentStatus : IEquatable<DeploymentStatus>
    {
        private readonly string _value;

        private DeploymentStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DeploymentStatus enum COMPLETED
        /// </summary>
        public static DeploymentStatus COMPLETED { get; } = new DeploymentStatus("COMPLETED");
        /// <summary>
        /// DeploymentStatus enum ELIGIBLE
        /// </summary>
        public static DeploymentStatus ELIGIBLE { get; } = new DeploymentStatus("ELIGIBLE");
        /// <summary>
        /// DeploymentStatus enum IN_PROGRESS
        /// </summary>
        public static DeploymentStatus IN_PROGRESS { get; } = new DeploymentStatus("IN_PROGRESS");
        /// <summary>
        /// DeploymentStatus enum NOT_ELIGIBLE
        /// </summary>
        public static DeploymentStatus NOT_ELIGIBLE { get; } = new DeploymentStatus("NOT_ELIGIBLE");
        /// <summary>
        /// DeploymentStatus enum PENDING_UPDATE
        /// </summary>
        public static DeploymentStatus PENDING_UPDATE { get; } = new DeploymentStatus("PENDING_UPDATE");

        public static bool operator ==(DeploymentStatus left, DeploymentStatus right) => left.Equals(right);
        public static bool operator !=(DeploymentStatus left, DeploymentStatus right) => !left.Equals(right);

        public static explicit operator string(DeploymentStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentStatus other && Equals(other);
        public bool Equals(DeploymentStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The filter type you want to apply on organizational units and accounts.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentTargetsAccountFilterType : IEquatable<DeploymentTargetsAccountFilterType>
    {
        private readonly string _value;

        private DeploymentTargetsAccountFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DeploymentTargetsAccountFilterType enum DIFFERENCE
        /// </summary>
        public static DeploymentTargetsAccountFilterType DIFFERENCE { get; } = new DeploymentTargetsAccountFilterType("DIFFERENCE");
        /// <summary>
        /// DeploymentTargetsAccountFilterType enum INTERSECTION
        /// </summary>
        public static DeploymentTargetsAccountFilterType INTERSECTION { get; } = new DeploymentTargetsAccountFilterType("INTERSECTION");
        /// <summary>
        /// DeploymentTargetsAccountFilterType enum NONE
        /// </summary>
        public static DeploymentTargetsAccountFilterType NONE { get; } = new DeploymentTargetsAccountFilterType("NONE");
        /// <summary>
        /// DeploymentTargetsAccountFilterType enum UNION
        /// </summary>
        public static DeploymentTargetsAccountFilterType UNION { get; } = new DeploymentTargetsAccountFilterType("UNION");

        public static bool operator ==(DeploymentTargetsAccountFilterType left, DeploymentTargetsAccountFilterType right) => left.Equals(right);
        public static bool operator !=(DeploymentTargetsAccountFilterType left, DeploymentTargetsAccountFilterType right) => !left.Equals(right);

        public static explicit operator string(DeploymentTargetsAccountFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentTargetsAccountFilterType other && Equals(other);
        public bool Equals(DeploymentTargetsAccountFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the file format used when exporting data to Amazon S3.  *Allowed values*: ``CSV`` | ``ORC`` | ``Parquet``
    /// </summary>
    [EnumType]
    public readonly struct DestinationFormat : IEquatable<DestinationFormat>
    {
        private readonly string _value;

        private DestinationFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DestinationFormat enum CSV
        /// </summary>
        public static DestinationFormat CSV { get; } = new DestinationFormat("CSV");
        /// <summary>
        /// DestinationFormat enum ORC
        /// </summary>
        public static DestinationFormat ORC { get; } = new DestinationFormat("ORC");
        /// <summary>
        /// DestinationFormat enum Parquet
        /// </summary>
        public static DestinationFormat Parquet { get; } = new DestinationFormat("Parquet");

        public static bool operator ==(DestinationFormat left, DestinationFormat right) => left.Equals(right);
        public static bool operator !=(DestinationFormat left, DestinationFormat right) => !left.Equals(right);

        public static explicit operator string(DestinationFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DestinationFormat other && Equals(other);
        public bool Equals(DestinationFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DeviceType : IEquatable<DeviceType>
    {
        private readonly string _value;

        private DeviceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DeviceType enum ebs
        /// </summary>
        public static DeviceType Ebs { get; } = new DeviceType("ebs");
        /// <summary>
        /// DeviceType enum instance-store
        /// </summary>
        public static DeviceType InstanceStore { get; } = new DeviceType("instance-store");

        public static bool operator ==(DeviceType left, DeviceType right) => left.Equals(right);
        public static bool operator !=(DeviceType left, DeviceType right) => !left.Equals(right);

        public static explicit operator string(DeviceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeviceType other && Equals(other);
        public bool Equals(DeviceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method used to distribute log data to the destination, which can be either random or grouped by log stream.
    /// </summary>
    [EnumType]
    public readonly struct Distribution : IEquatable<Distribution>
    {
        private readonly string _value;

        private Distribution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Distribution enum ByLogStream
        /// </summary>
        public static Distribution ByLogStream { get; } = new Distribution("ByLogStream");
        /// <summary>
        /// Distribution enum Random
        /// </summary>
        public static Distribution Random { get; } = new Distribution("Random");

        public static bool operator ==(Distribution left, Distribution right) => left.Equals(right);
        public static bool operator !=(Distribution left, Distribution right) => !left.Equals(right);

        public static explicit operator string(Distribution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Distribution other && Equals(other);
        public bool Equals(Distribution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DomainProcessingStatusType : IEquatable<DomainProcessingStatusType>
    {
        private readonly string _value;

        private DomainProcessingStatusType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DomainProcessingStatusType enum Active
        /// </summary>
        public static DomainProcessingStatusType Active { get; } = new DomainProcessingStatusType("Active");
        /// <summary>
        /// DomainProcessingStatusType enum Creating
        /// </summary>
        public static DomainProcessingStatusType Creating { get; } = new DomainProcessingStatusType("Creating");
        /// <summary>
        /// DomainProcessingStatusType enum Deleting
        /// </summary>
        public static DomainProcessingStatusType Deleting { get; } = new DomainProcessingStatusType("Deleting");
        /// <summary>
        /// DomainProcessingStatusType enum Isolated
        /// </summary>
        public static DomainProcessingStatusType Isolated { get; } = new DomainProcessingStatusType("Isolated");
        /// <summary>
        /// DomainProcessingStatusType enum Modifying
        /// </summary>
        public static DomainProcessingStatusType Modifying { get; } = new DomainProcessingStatusType("Modifying");
        /// <summary>
        /// DomainProcessingStatusType enum UpdatingServiceSoftware
        /// </summary>
        public static DomainProcessingStatusType UpdatingServiceSoftware { get; } = new DomainProcessingStatusType("UpdatingServiceSoftware");
        /// <summary>
        /// DomainProcessingStatusType enum UpgradingEngineVersion
        /// </summary>
        public static DomainProcessingStatusType UpgradingEngineVersion { get; } = new DomainProcessingStatusType("UpgradingEngineVersion");

        public static bool operator ==(DomainProcessingStatusType left, DomainProcessingStatusType right) => left.Equals(right);
        public static bool operator !=(DomainProcessingStatusType left, DomainProcessingStatusType right) => !left.Equals(right);

        public static explicit operator string(DomainProcessingStatusType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainProcessingStatusType other && Equals(other);
        public bool Equals(DomainProcessingStatusType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct DomainType : IEquatable<DomainType>
    {
        private readonly string _value;

        private DomainType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DomainType enum standard
        /// </summary>
        public static DomainType Standard { get; } = new DomainType("standard");
        /// <summary>
        /// DomainType enum vpc
        /// </summary>
        public static DomainType Vpc { get; } = new DomainType("vpc");

        public static bool operator ==(DomainType left, DomainType right) => left.Equals(right);
        public static bool operator !=(DomainType left, DomainType right) => !left.Equals(right);

        public static explicit operator string(DomainType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainType other && Equals(other);
        public bool Equals(DomainType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to propagate the tags from the task definition to the Amazon EBS volume. Tags can only propagate to a ``SERVICE`` specified in ``ServiceVolumeConfiguration``. If no value is specified, the tags aren't propagated.
    /// </summary>
    [EnumType]
    public readonly struct EBSTagSpecificationPropagateTags : IEquatable<EBSTagSpecificationPropagateTags>
    {
        private readonly string _value;

        private EBSTagSpecificationPropagateTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EBSTagSpecificationPropagateTags enum SERVICE
        /// </summary>
        public static EBSTagSpecificationPropagateTags SERVICE { get; } = new EBSTagSpecificationPropagateTags("SERVICE");
        /// <summary>
        /// EBSTagSpecificationPropagateTags enum TASK_DEFINITION
        /// </summary>
        public static EBSTagSpecificationPropagateTags TASK_DEFINITION { get; } = new EBSTagSpecificationPropagateTags("TASK_DEFINITION");

        public static bool operator ==(EBSTagSpecificationPropagateTags left, EBSTagSpecificationPropagateTags right) => left.Equals(right);
        public static bool operator !=(EBSTagSpecificationPropagateTags left, EBSTagSpecificationPropagateTags right) => !left.Equals(right);

        public static explicit operator string(EBSTagSpecificationPropagateTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EBSTagSpecificationPropagateTags other && Equals(other);
        public bool Equals(EBSTagSpecificationPropagateTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to use encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be turned on if Amazon EFS IAM authorization is used. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Encrypting data in transit](https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html) in the *Amazon Elastic File System User Guide*.
    /// </summary>
    [EnumType]
    public readonly struct EFSVolumeConfigurationTransitEncryption : IEquatable<EFSVolumeConfigurationTransitEncryption>
    {
        private readonly string _value;

        private EFSVolumeConfigurationTransitEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EFSVolumeConfigurationTransitEncryption enum DISABLED
        /// </summary>
        public static EFSVolumeConfigurationTransitEncryption DISABLED { get; } = new EFSVolumeConfigurationTransitEncryption("DISABLED");
        /// <summary>
        /// EFSVolumeConfigurationTransitEncryption enum ENABLED
        /// </summary>
        public static EFSVolumeConfigurationTransitEncryption ENABLED { get; } = new EFSVolumeConfigurationTransitEncryption("ENABLED");

        public static bool operator ==(EFSVolumeConfigurationTransitEncryption left, EFSVolumeConfigurationTransitEncryption right) => left.Equals(right);
        public static bool operator !=(EFSVolumeConfigurationTransitEncryption left, EFSVolumeConfigurationTransitEncryption right) => !left.Equals(right);

        public static explicit operator string(EFSVolumeConfigurationTransitEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EFSVolumeConfigurationTransitEncryption other && Equals(other);
        public bool Equals(EFSVolumeConfigurationTransitEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption type to use. If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see [Protecting data using server-side encryption with an key stored in (SSE-KMS)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html) in the *Amazon Simple Storage Service Console Developer Guide*. If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see [Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) in the *Ama The encryption type to use.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionConfigurationEncryptionType : IEquatable<EncryptionConfigurationEncryptionType>
    {
        private readonly string _value;

        private EncryptionConfigurationEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EncryptionConfigurationEncryptionType enum AES256
        /// </summary>
        public static EncryptionConfigurationEncryptionType AES256 { get; } = new EncryptionConfigurationEncryptionType("AES256");
        /// <summary>
        /// EncryptionConfigurationEncryptionType enum KMS
        /// </summary>
        public static EncryptionConfigurationEncryptionType KMS { get; } = new EncryptionConfigurationEncryptionType("KMS");

        public static bool operator ==(EncryptionConfigurationEncryptionType left, EncryptionConfigurationEncryptionType right) => left.Equals(right);
        public static bool operator !=(EncryptionConfigurationEncryptionType left, EncryptionConfigurationEncryptionType right) => !left.Equals(right);

        public static explicit operator string(EncryptionConfigurationEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionConfigurationEncryptionType other && Equals(other);
        public bool Equals(EncryptionConfigurationEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentType : IEquatable<EnvironmentType>
    {
        private readonly string _value;

        private EnvironmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EnvironmentType enum ARM_CONTAINER
        /// </summary>
        public static EnvironmentType ARM_CONTAINER { get; } = new EnvironmentType("ARM_CONTAINER");
        /// <summary>
        /// EnvironmentType enum ARM_LAMBDA_CONTAINER
        /// </summary>
        public static EnvironmentType ARM_LAMBDA_CONTAINER { get; } = new EnvironmentType("ARM_LAMBDA_CONTAINER");
        /// <summary>
        /// EnvironmentType enum LINUX_CONTAINER
        /// </summary>
        public static EnvironmentType LINUX_CONTAINER { get; } = new EnvironmentType("LINUX_CONTAINER");
        /// <summary>
        /// EnvironmentType enum LINUX_GPU_CONTAINER
        /// </summary>
        public static EnvironmentType LINUX_GPU_CONTAINER { get; } = new EnvironmentType("LINUX_GPU_CONTAINER");
        /// <summary>
        /// EnvironmentType enum LINUX_LAMBDA_CONTAINER
        /// </summary>
        public static EnvironmentType LINUX_LAMBDA_CONTAINER { get; } = new EnvironmentType("LINUX_LAMBDA_CONTAINER");
        /// <summary>
        /// EnvironmentType enum WINDOWS_CONTAINER
        /// </summary>
        public static EnvironmentType WINDOWS_CONTAINER { get; } = new EnvironmentType("WINDOWS_CONTAINER");
        /// <summary>
        /// EnvironmentType enum WINDOWS_SERVER_2019_CONTAINER
        /// </summary>
        public static EnvironmentType WINDOWS_SERVER_2019_CONTAINER { get; } = new EnvironmentType("WINDOWS_SERVER_2019_CONTAINER");

        public static bool operator ==(EnvironmentType left, EnvironmentType right) => left.Equals(right);
        public static bool operator !=(EnvironmentType left, EnvironmentType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentType other && Equals(other);
        public bool Equals(EnvironmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentVariableType : IEquatable<EnvironmentVariableType>
    {
        private readonly string _value;

        private EnvironmentVariableType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EnvironmentVariableType enum PARAMETER_STORE
        /// </summary>
        public static EnvironmentVariableType PARAMETER_STORE { get; } = new EnvironmentVariableType("PARAMETER_STORE");
        /// <summary>
        /// EnvironmentVariableType enum PLAINTEXT
        /// </summary>
        public static EnvironmentVariableType PLAINTEXT { get; } = new EnvironmentVariableType("PLAINTEXT");
        /// <summary>
        /// EnvironmentVariableType enum SECRETS_MANAGER
        /// </summary>
        public static EnvironmentVariableType SECRETS_MANAGER { get; } = new EnvironmentVariableType("SECRETS_MANAGER");

        public static bool operator ==(EnvironmentVariableType left, EnvironmentVariableType right) => left.Equals(right);
        public static bool operator !=(EnvironmentVariableType left, EnvironmentVariableType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentVariableType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentVariableType other && Equals(other);
        public bool Equals(EnvironmentVariableType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct EventCode : IEquatable<EventCode>
    {
        private readonly string _value;

        private EventCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EventCode enum instance-reboot
        /// </summary>
        public static EventCode InstanceReboot { get; } = new EventCode("instance-reboot");
        /// <summary>
        /// EventCode enum instance-retirement
        /// </summary>
        public static EventCode InstanceRetirement { get; } = new EventCode("instance-retirement");
        /// <summary>
        /// EventCode enum instance-stop
        /// </summary>
        public static EventCode InstanceStop { get; } = new EventCode("instance-stop");
        /// <summary>
        /// EventCode enum system-maintenance
        /// </summary>
        public static EventCode SystemMaintenance { get; } = new EventCode("system-maintenance");
        /// <summary>
        /// EventCode enum system-reboot
        /// </summary>
        public static EventCode SystemReboot { get; } = new EventCode("system-reboot");

        public static bool operator ==(EventCode left, EventCode right) => left.Equals(right);
        public static bool operator !=(EventCode left, EventCode right) => !left.Equals(right);

        public static explicit operator string(EventCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventCode other && Equals(other);
        public bool Equals(EventCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
    /// </summary>
    [EnumType]
    public readonly struct EventSelectorReadWriteType : IEquatable<EventSelectorReadWriteType>
    {
        private readonly string _value;

        private EventSelectorReadWriteType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EventSelectorReadWriteType enum All
        /// </summary>
        public static EventSelectorReadWriteType All { get; } = new EventSelectorReadWriteType("All");
        /// <summary>
        /// EventSelectorReadWriteType enum ReadOnly
        /// </summary>
        public static EventSelectorReadWriteType ReadOnly { get; } = new EventSelectorReadWriteType("ReadOnly");
        /// <summary>
        /// EventSelectorReadWriteType enum WriteOnly
        /// </summary>
        public static EventSelectorReadWriteType WriteOnly { get; } = new EventSelectorReadWriteType("WriteOnly");

        public static bool operator ==(EventSelectorReadWriteType left, EventSelectorReadWriteType right) => left.Equals(right);
        public static bool operator !=(EventSelectorReadWriteType left, EventSelectorReadWriteType right) => !left.Equals(right);

        public static explicit operator string(EventSelectorReadWriteType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSelectorReadWriteType other && Equals(other);
        public bool Equals(EventSelectorReadWriteType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ExportSourceType : IEquatable<ExportSourceType>
    {
        private readonly string _value;

        private ExportSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ExportSourceType enum CLUSTER
        /// </summary>
        public static ExportSourceType CLUSTER { get; } = new ExportSourceType("CLUSTER");
        /// <summary>
        /// ExportSourceType enum SNAPSHOT
        /// </summary>
        public static ExportSourceType SNAPSHOT { get; } = new ExportSourceType("SNAPSHOT");

        public static bool operator ==(ExportSourceType left, ExportSourceType right) => left.Equals(right);
        public static bool operator !=(ExportSourceType left, ExportSourceType right) => !left.Equals(right);

        public static explicit operator string(ExportSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExportSourceType other && Equals(other);
        public bool Equals(ExportSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ExtendedKeyUsageName enum
    /// </summary>
    [EnumType]
    public readonly struct ExtendedKeyUsageName : IEquatable<ExtendedKeyUsageName>
    {
        private readonly string _value;

        private ExtendedKeyUsageName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ExtendedKeyUsageName enum ANY
        /// </summary>
        public static ExtendedKeyUsageName ANY { get; } = new ExtendedKeyUsageName("ANY");
        /// <summary>
        /// ExtendedKeyUsageName enum CODE_SIGNING
        /// </summary>
        public static ExtendedKeyUsageName CODE_SIGNING { get; } = new ExtendedKeyUsageName("CODE_SIGNING");
        /// <summary>
        /// ExtendedKeyUsageName enum CUSTOM
        /// </summary>
        public static ExtendedKeyUsageName CUSTOM { get; } = new ExtendedKeyUsageName("CUSTOM");
        /// <summary>
        /// ExtendedKeyUsageName enum EMAIL_PROTECTION
        /// </summary>
        public static ExtendedKeyUsageName EMAIL_PROTECTION { get; } = new ExtendedKeyUsageName("EMAIL_PROTECTION");
        /// <summary>
        /// ExtendedKeyUsageName enum IPSEC_END_SYSTEM
        /// </summary>
        public static ExtendedKeyUsageName IPSEC_END_SYSTEM { get; } = new ExtendedKeyUsageName("IPSEC_END_SYSTEM");
        /// <summary>
        /// ExtendedKeyUsageName enum IPSEC_TUNNEL
        /// </summary>
        public static ExtendedKeyUsageName IPSEC_TUNNEL { get; } = new ExtendedKeyUsageName("IPSEC_TUNNEL");
        /// <summary>
        /// ExtendedKeyUsageName enum IPSEC_USER
        /// </summary>
        public static ExtendedKeyUsageName IPSEC_USER { get; } = new ExtendedKeyUsageName("IPSEC_USER");
        /// <summary>
        /// ExtendedKeyUsageName enum NONE
        /// </summary>
        public static ExtendedKeyUsageName NONE { get; } = new ExtendedKeyUsageName("NONE");
        /// <summary>
        /// ExtendedKeyUsageName enum OCSP_SIGNING
        /// </summary>
        public static ExtendedKeyUsageName OCSP_SIGNING { get; } = new ExtendedKeyUsageName("OCSP_SIGNING");
        /// <summary>
        /// ExtendedKeyUsageName enum TIME_STAMPING
        /// </summary>
        public static ExtendedKeyUsageName TIME_STAMPING { get; } = new ExtendedKeyUsageName("TIME_STAMPING");
        /// <summary>
        /// ExtendedKeyUsageName enum TLS_WEB_CLIENT_AUTHENTICATION
        /// </summary>
        public static ExtendedKeyUsageName TLS_WEB_CLIENT_AUTHENTICATION { get; } = new ExtendedKeyUsageName("TLS_WEB_CLIENT_AUTHENTICATION");
        /// <summary>
        /// ExtendedKeyUsageName enum TLS_WEB_SERVER_AUTHENTICATION
        /// </summary>
        public static ExtendedKeyUsageName TLS_WEB_SERVER_AUTHENTICATION { get; } = new ExtendedKeyUsageName("TLS_WEB_SERVER_AUTHENTICATION");

        public static bool operator ==(ExtendedKeyUsageName left, ExtendedKeyUsageName right) => left.Equals(right);
        public static bool operator !=(ExtendedKeyUsageName left, ExtendedKeyUsageName right) => !left.Equals(right);

        public static explicit operator string(ExtendedKeyUsageName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedKeyUsageName other && Equals(other);
        public bool Equals(ExtendedKeyUsageName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the feature set supported by the new organization. Each feature set supports different levels of functionality.
    /// </summary>
    [EnumType]
    public readonly struct FeatureSet : IEquatable<FeatureSet>
    {
        private readonly string _value;

        private FeatureSet(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FeatureSet enum ALL
        /// </summary>
        public static FeatureSet ALL { get; } = new FeatureSet("ALL");
        /// <summary>
        /// FeatureSet enum CONSOLIDATED_BILLING
        /// </summary>
        public static FeatureSet CONSOLIDATED_BILLING { get; } = new FeatureSet("CONSOLIDATED_BILLING");

        public static bool operator ==(FeatureSet left, FeatureSet right) => left.Equals(right);
        public static bool operator !=(FeatureSet left, FeatureSet right) => !left.Equals(right);

        public static explicit operator string(FeatureSet value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeatureSet other && Equals(other);
        public bool Equals(FeatureSet other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct FieldLogLevel : IEquatable<FieldLogLevel>
    {
        private readonly string _value;

        private FieldLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FieldLogLevel enum ALL
        /// </summary>
        public static FieldLogLevel ALL { get; } = new FieldLogLevel("ALL");
        /// <summary>
        /// FieldLogLevel enum ERROR
        /// </summary>
        public static FieldLogLevel ERROR { get; } = new FieldLogLevel("ERROR");
        /// <summary>
        /// FieldLogLevel enum NONE
        /// </summary>
        public static FieldLogLevel NONE { get; } = new FieldLogLevel("NONE");

        public static bool operator ==(FieldLogLevel left, FieldLogLevel right) => left.Equals(right);
        public static bool operator !=(FieldLogLevel left, FieldLogLevel right) => !left.Equals(right);

        public static explicit operator string(FieldLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FieldLogLevel other && Equals(other);
        public bool Equals(FieldLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property fileFormat
    /// </summary>
    [EnumType]
    public readonly struct FileFormat : IEquatable<FileFormat>
    {
        private readonly string _value;

        private FileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FileFormat enum parquet
        /// </summary>
        public static FileFormat Parquet { get; } = new FileFormat("parquet");
        /// <summary>
        /// FileFormat enum plain-text
        /// </summary>
        public static FileFormat PlainText { get; } = new FileFormat("plain-text");

        public static bool operator ==(FileFormat left, FileFormat right) => left.Equals(right);
        public static bool operator !=(FileFormat left, FileFormat right) => !left.Equals(right);

        public static explicit operator string(FileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileFormat other && Equals(other);
        public bool Equals(FileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the file system's replication overwrite protection.  +   ``ENABLED`` – The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ``ENABLED`` by default.   +   ``DISABLED`` – The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.  +   ``REPLICATING`` – The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled, the file system becomes writeable.
    /// </summary>
    [EnumType]
    public readonly struct FileSystemProtectionReplicationOverwriteProtection : IEquatable<FileSystemProtectionReplicationOverwriteProtection>
    {
        private readonly string _value;

        private FileSystemProtectionReplicationOverwriteProtection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FileSystemProtectionReplicationOverwriteProtection enum DISABLED
        /// </summary>
        public static FileSystemProtectionReplicationOverwriteProtection DISABLED { get; } = new FileSystemProtectionReplicationOverwriteProtection("DISABLED");
        /// <summary>
        /// FileSystemProtectionReplicationOverwriteProtection enum ENABLED
        /// </summary>
        public static FileSystemProtectionReplicationOverwriteProtection ENABLED { get; } = new FileSystemProtectionReplicationOverwriteProtection("ENABLED");

        public static bool operator ==(FileSystemProtectionReplicationOverwriteProtection left, FileSystemProtectionReplicationOverwriteProtection right) => left.Equals(right);
        public static bool operator !=(FileSystemProtectionReplicationOverwriteProtection left, FileSystemProtectionReplicationOverwriteProtection right) => !left.Equals(right);

        public static explicit operator string(FileSystemProtectionReplicationOverwriteProtection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileSystemProtectionReplicationOverwriteProtection other && Equals(other);
        public bool Equals(FileSystemProtectionReplicationOverwriteProtection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct FileSystemType : IEquatable<FileSystemType>
    {
        private readonly string _value;

        private FileSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FileSystemType enum EFS
        /// </summary>
        public static FileSystemType EFS { get; } = new FileSystemType("EFS");

        public static bool operator ==(FileSystemType left, FileSystemType right) => left.Equals(right);
        public static bool operator !=(FileSystemType left, FileSystemType right) => !left.Equals(right);

        public static explicit operator string(FileSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileSystemType other && Equals(other);
        public bool Equals(FileSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to handle logs that satisfy the filter's conditions and requirement.
    /// </summary>
    [EnumType]
    public readonly struct FilterBehavior : IEquatable<FilterBehavior>
    {
        private readonly string _value;

        private FilterBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FilterBehavior enum DROP
        /// </summary>
        public static FilterBehavior DROP { get; } = new FilterBehavior("DROP");
        /// <summary>
        /// FilterBehavior enum KEEP
        /// </summary>
        public static FilterBehavior KEEP { get; } = new FilterBehavior("KEEP");

        public static bool operator ==(FilterBehavior left, FilterBehavior right) => left.Equals(right);
        public static bool operator !=(FilterBehavior left, FilterBehavior right) => !left.Equals(right);

        public static explicit operator string(FilterBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterBehavior other && Equals(other);
        public bool Equals(FilterBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct FilterRequirement : IEquatable<FilterRequirement>
    {
        private readonly string _value;

        private FilterRequirement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// FilterRequirement enum MEETS_ALL
        /// </summary>
        public static FilterRequirement MEETS_ALL { get; } = new FilterRequirement("MEETS_ALL");
        /// <summary>
        /// FilterRequirement enum MEETS_ANY
        /// </summary>
        public static FilterRequirement MEETS_ANY { get; } = new FilterRequirement("MEETS_ANY");

        public static bool operator ==(FilterRequirement left, FilterRequirement right) => left.Equals(right);
        public static bool operator !=(FilterRequirement left, FilterRequirement right) => !left.Equals(right);

        public static explicit operator string(FilterRequirement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterRequirement other && Equals(other);
        public bool Equals(FilterRequirement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct GraphQLApiIntrospectionConfig : IEquatable<GraphQLApiIntrospectionConfig>
    {
        private readonly string _value;

        private GraphQLApiIntrospectionConfig(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// GraphQLApiIntrospectionConfig enum DISABLED
        /// </summary>
        public static GraphQLApiIntrospectionConfig DISABLED { get; } = new GraphQLApiIntrospectionConfig("DISABLED");
        /// <summary>
        /// GraphQLApiIntrospectionConfig enum ENABLED
        /// </summary>
        public static GraphQLApiIntrospectionConfig ENABLED { get; } = new GraphQLApiIntrospectionConfig("ENABLED");

        public static bool operator ==(GraphQLApiIntrospectionConfig left, GraphQLApiIntrospectionConfig right) => left.Equals(right);
        public static bool operator !=(GraphQLApiIntrospectionConfig left, GraphQLApiIntrospectionConfig right) => !left.Equals(right);

        public static explicit operator string(GraphQLApiIntrospectionConfig value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GraphQLApiIntrospectionConfig other && Equals(other);
        public bool Equals(GraphQLApiIntrospectionConfig other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct GraphQLApiType : IEquatable<GraphQLApiType>
    {
        private readonly string _value;

        private GraphQLApiType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// GraphQLApiType enum GRAPHQL
        /// </summary>
        public static GraphQLApiType GRAPHQL { get; } = new GraphQLApiType("GRAPHQL");
        /// <summary>
        /// GraphQLApiType enum MERGED
        /// </summary>
        public static GraphQLApiType MERGED { get; } = new GraphQLApiType("MERGED");

        public static bool operator ==(GraphQLApiType left, GraphQLApiType right) => left.Equals(right);
        public static bool operator !=(GraphQLApiType left, GraphQLApiType right) => !left.Equals(right);

        public static explicit operator string(GraphQLApiType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GraphQLApiType other && Equals(other);
        public bool Equals(GraphQLApiType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct GraphQLApiVisibility : IEquatable<GraphQLApiVisibility>
    {
        private readonly string _value;

        private GraphQLApiVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// GraphQLApiVisibility enum GLOBAL
        /// </summary>
        public static GraphQLApiVisibility GLOBAL { get; } = new GraphQLApiVisibility("GLOBAL");
        /// <summary>
        /// GraphQLApiVisibility enum PRIVATE
        /// </summary>
        public static GraphQLApiVisibility PRIVATE { get; } = new GraphQLApiVisibility("PRIVATE");

        public static bool operator ==(GraphQLApiVisibility left, GraphQLApiVisibility right) => left.Equals(right);
        public static bool operator !=(GraphQLApiVisibility left, GraphQLApiVisibility right) => !left.Equals(right);

        public static explicit operator string(GraphQLApiVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GraphQLApiVisibility other && Equals(other);
        public bool Equals(GraphQLApiVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property direction
    /// </summary>
    [EnumType]
    public readonly struct HeaderDirection : IEquatable<HeaderDirection>
    {
        private readonly string _value;

        private HeaderDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HeaderDirection enum ANY
        /// </summary>
        public static HeaderDirection ANY { get; } = new HeaderDirection("ANY");
        /// <summary>
        /// HeaderDirection enum FORWARD
        /// </summary>
        public static HeaderDirection FORWARD { get; } = new HeaderDirection("FORWARD");

        public static bool operator ==(HeaderDirection left, HeaderDirection right) => left.Equals(right);
        public static bool operator !=(HeaderDirection left, HeaderDirection right) => !left.Equals(right);

        public static explicit operator string(HeaderDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HeaderDirection other && Equals(other);
        public bool Equals(HeaderDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property protocol
    /// </summary>
    [EnumType]
    public readonly struct HeaderProtocol : IEquatable<HeaderProtocol>
    {
        private readonly string _value;

        private HeaderProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HeaderProtocol enum DCERPC
        /// </summary>
        public static HeaderProtocol DCERPC { get; } = new HeaderProtocol("DCERPC");
        /// <summary>
        /// HeaderProtocol enum DHCP
        /// </summary>
        public static HeaderProtocol DHCP { get; } = new HeaderProtocol("DHCP");
        /// <summary>
        /// HeaderProtocol enum DNS
        /// </summary>
        public static HeaderProtocol DNS { get; } = new HeaderProtocol("DNS");
        /// <summary>
        /// HeaderProtocol enum FTP
        /// </summary>
        public static HeaderProtocol FTP { get; } = new HeaderProtocol("FTP");
        /// <summary>
        /// HeaderProtocol enum HTTP
        /// </summary>
        public static HeaderProtocol HTTP { get; } = new HeaderProtocol("HTTP");
        /// <summary>
        /// HeaderProtocol enum ICMP
        /// </summary>
        public static HeaderProtocol ICMP { get; } = new HeaderProtocol("ICMP");
        /// <summary>
        /// HeaderProtocol enum IKEV2
        /// </summary>
        public static HeaderProtocol IKEV2 { get; } = new HeaderProtocol("IKEV2");
        /// <summary>
        /// HeaderProtocol enum IMAP
        /// </summary>
        public static HeaderProtocol IMAP { get; } = new HeaderProtocol("IMAP");
        /// <summary>
        /// HeaderProtocol enum IP
        /// </summary>
        public static HeaderProtocol IP { get; } = new HeaderProtocol("IP");
        /// <summary>
        /// HeaderProtocol enum KRB5
        /// </summary>
        public static HeaderProtocol KRB5 { get; } = new HeaderProtocol("KRB5");
        /// <summary>
        /// HeaderProtocol enum MSN
        /// </summary>
        public static HeaderProtocol MSN { get; } = new HeaderProtocol("MSN");
        /// <summary>
        /// HeaderProtocol enum NTP
        /// </summary>
        public static HeaderProtocol NTP { get; } = new HeaderProtocol("NTP");
        /// <summary>
        /// HeaderProtocol enum SMB
        /// </summary>
        public static HeaderProtocol SMB { get; } = new HeaderProtocol("SMB");
        /// <summary>
        /// HeaderProtocol enum SMTP
        /// </summary>
        public static HeaderProtocol SMTP { get; } = new HeaderProtocol("SMTP");
        /// <summary>
        /// HeaderProtocol enum SSH
        /// </summary>
        public static HeaderProtocol SSH { get; } = new HeaderProtocol("SSH");
        /// <summary>
        /// HeaderProtocol enum TCP
        /// </summary>
        public static HeaderProtocol TCP { get; } = new HeaderProtocol("TCP");
        /// <summary>
        /// HeaderProtocol enum TFTP
        /// </summary>
        public static HeaderProtocol TFTP { get; } = new HeaderProtocol("TFTP");
        /// <summary>
        /// HeaderProtocol enum TLS
        /// </summary>
        public static HeaderProtocol TLS { get; } = new HeaderProtocol("TLS");
        /// <summary>
        /// HeaderProtocol enum UDP
        /// </summary>
        public static HeaderProtocol UDP { get; } = new HeaderProtocol("UDP");

        public static bool operator ==(HeaderProtocol left, HeaderProtocol right) => left.Equals(right);
        public static bool operator !=(HeaderProtocol left, HeaderProtocol right) => !left.Equals(right);

        public static explicit operator string(HeaderProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HeaderProtocol other && Equals(other);
        public bool Equals(HeaderProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct HostnameType : IEquatable<HostnameType>
    {
        private readonly string _value;

        private HostnameType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HostnameType enum ip-name
        /// </summary>
        public static HostnameType IpName { get; } = new HostnameType("ip-name");
        /// <summary>
        /// HostnameType enum resource-name
        /// </summary>
        public static HostnameType ResourceName { get; } = new HostnameType("resource-name");

        public static bool operator ==(HostnameType left, HostnameType right) => left.Equals(right);
        public static bool operator !=(HostnameType left, HostnameType right) => !left.Equals(right);

        public static explicit operator string(HostnameType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostnameType other && Equals(other);
        public bool Equals(HostnameType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct HttpTokensState : IEquatable<HttpTokensState>
    {
        private readonly string _value;

        private HttpTokensState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HttpTokensState enum optional
        /// </summary>
        public static HttpTokensState Optional { get; } = new HttpTokensState("optional");
        /// <summary>
        /// HttpTokensState enum required
        /// </summary>
        public static HttpTokensState Required { get; } = new HttpTokensState("required");

        public static bool operator ==(HttpTokensState left, HttpTokensState right) => left.Equals(right);
        public static bool operator !=(HttpTokensState left, HttpTokensState right) => !left.Equals(right);

        public static explicit operator string(HttpTokensState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpTokensState other && Equals(other);
        public bool Equals(HttpTokensState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct HypervisorType : IEquatable<HypervisorType>
    {
        private readonly string _value;

        private HypervisorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// HypervisorType enum ovm
        /// </summary>
        public static HypervisorType Ovm { get; } = new HypervisorType("ovm");
        /// <summary>
        /// HypervisorType enum xen
        /// </summary>
        public static HypervisorType Xen { get; } = new HypervisorType("xen");

        public static bool operator ==(HypervisorType left, HypervisorType right) => left.Equals(right);
        public static bool operator !=(HypervisorType left, HypervisorType right) => !left.Equals(right);

        public static explicit operator string(HypervisorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HypervisorType other && Equals(other);
        public bool Equals(HypervisorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct IPAddressType : IEquatable<IPAddressType>
    {
        private readonly string _value;

        private IPAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IPAddressType enum dualstack
        /// </summary>
        public static IPAddressType Dualstack { get; } = new IPAddressType("dualstack");
        /// <summary>
        /// IPAddressType enum ipv4
        /// </summary>
        public static IPAddressType Ipv4 { get; } = new IPAddressType("ipv4");

        public static bool operator ==(IPAddressType left, IPAddressType right) => left.Equals(right);
        public static bool operator !=(IPAddressType left, IPAddressType right) => !left.Equals(right);

        public static explicit operator string(IPAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAddressType other && Equals(other);
        public bool Equals(IPAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ImagePullCredentialsType : IEquatable<ImagePullCredentialsType>
    {
        private readonly string _value;

        private ImagePullCredentialsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ImagePullCredentialsType enum CODEBUILD
        /// </summary>
        public static ImagePullCredentialsType CODEBUILD { get; } = new ImagePullCredentialsType("CODEBUILD");
        /// <summary>
        /// ImagePullCredentialsType enum SERVICE_ROLE
        /// </summary>
        public static ImagePullCredentialsType SERVICE_ROLE { get; } = new ImagePullCredentialsType("SERVICE_ROLE");

        public static bool operator ==(ImagePullCredentialsType left, ImagePullCredentialsType right) => left.Equals(right);
        public static bool operator !=(ImagePullCredentialsType left, ImagePullCredentialsType right) => !left.Equals(right);

        public static explicit operator string(ImagePullCredentialsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImagePullCredentialsType other && Equals(other);
        public bool Equals(ImagePullCredentialsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ImageState : IEquatable<ImageState>
    {
        private readonly string _value;

        private ImageState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ImageState enum available
        /// </summary>
        public static ImageState Available { get; } = new ImageState("available");
        /// <summary>
        /// ImageState enum deregistered
        /// </summary>
        public static ImageState Deregistered { get; } = new ImageState("deregistered");
        /// <summary>
        /// ImageState enum disabled
        /// </summary>
        public static ImageState Disabled { get; } = new ImageState("disabled");
        /// <summary>
        /// ImageState enum error
        /// </summary>
        public static ImageState Error { get; } = new ImageState("error");
        /// <summary>
        /// ImageState enum failed
        /// </summary>
        public static ImageState Failed { get; } = new ImageState("failed");
        /// <summary>
        /// ImageState enum invalid
        /// </summary>
        public static ImageState Invalid { get; } = new ImageState("invalid");
        /// <summary>
        /// ImageState enum pending
        /// </summary>
        public static ImageState Pending { get; } = new ImageState("pending");
        /// <summary>
        /// ImageState enum transient
        /// </summary>
        public static ImageState Transient { get; } = new ImageState("transient");

        public static bool operator ==(ImageState left, ImageState right) => left.Equals(right);
        public static bool operator !=(ImageState left, ImageState right) => !left.Equals(right);

        public static explicit operator string(ImageState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageState other && Equals(other);
        public bool Equals(ImageState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE`` is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
    /// </summary>
    [EnumType]
    public readonly struct ImageTagMutability : IEquatable<ImageTagMutability>
    {
        private readonly string _value;

        private ImageTagMutability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ImageTagMutability enum IMMUTABLE
        /// </summary>
        public static ImageTagMutability IMMUTABLE { get; } = new ImageTagMutability("IMMUTABLE");
        /// <summary>
        /// ImageTagMutability enum MUTABLE
        /// </summary>
        public static ImageTagMutability MUTABLE { get; } = new ImageTagMutability("MUTABLE");

        public static bool operator ==(ImageTagMutability left, ImageTagMutability right) => left.Equals(right);
        public static bool operator !=(ImageTagMutability left, ImageTagMutability right) => !left.Equals(right);

        public static explicit operator string(ImageTagMutability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageTagMutability other && Equals(other);
        public bool Equals(ImageTagMutability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ImageTypeValues : IEquatable<ImageTypeValues>
    {
        private readonly string _value;

        private ImageTypeValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ImageTypeValues enum kernel
        /// </summary>
        public static ImageTypeValues Kernel { get; } = new ImageTypeValues("kernel");
        /// <summary>
        /// ImageTypeValues enum machine
        /// </summary>
        public static ImageTypeValues Machine { get; } = new ImageTypeValues("machine");
        /// <summary>
        /// ImageTypeValues enum ramdisk
        /// </summary>
        public static ImageTypeValues Ramdisk { get; } = new ImageTypeValues("ramdisk");

        public static bool operator ==(ImageTypeValues left, ImageTypeValues right) => left.Equals(right);
        public static bool operator !=(ImageTypeValues left, ImageTypeValues right) => !left.Equals(right);

        public static explicit operator string(ImageTypeValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageTypeValues other && Equals(other);
        public bool Equals(ImageTypeValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ImdsSupportValues : IEquatable<ImdsSupportValues>
    {
        private readonly string _value;

        private ImdsSupportValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ImdsSupportValues enum v2.0
        /// </summary>
        public static ImdsSupportValues V20 { get; } = new ImdsSupportValues("v2.0");

        public static bool operator ==(ImdsSupportValues left, ImdsSupportValues right) => left.Equals(right);
        public static bool operator !=(ImdsSupportValues left, ImdsSupportValues right) => !left.Equals(right);

        public static explicit operator string(ImdsSupportValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImdsSupportValues other && Equals(other);
        public bool Equals(ImdsSupportValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InitiatedBy : IEquatable<InitiatedBy>
    {
        private readonly string _value;

        private InitiatedBy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InitiatedBy enum CUSTOMER
        /// </summary>
        public static InitiatedBy CUSTOMER { get; } = new InitiatedBy("CUSTOMER");
        /// <summary>
        /// InitiatedBy enum SERVICE
        /// </summary>
        public static InitiatedBy SERVICE { get; } = new InitiatedBy("SERVICE");

        public static bool operator ==(InitiatedBy left, InitiatedBy right) => left.Equals(right);
        public static bool operator !=(InitiatedBy left, InitiatedBy right) => !left.Equals(right);

        public static explicit operator string(InitiatedBy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InitiatedBy other && Equals(other);
        public bool Equals(InitiatedBy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceAutoRecoveryState : IEquatable<InstanceAutoRecoveryState>
    {
        private readonly string _value;

        private InstanceAutoRecoveryState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceAutoRecoveryState enum default
        /// </summary>
        public static InstanceAutoRecoveryState Default { get; } = new InstanceAutoRecoveryState("default");
        /// <summary>
        /// InstanceAutoRecoveryState enum disabled
        /// </summary>
        public static InstanceAutoRecoveryState Disabled { get; } = new InstanceAutoRecoveryState("disabled");

        public static bool operator ==(InstanceAutoRecoveryState left, InstanceAutoRecoveryState right) => left.Equals(right);
        public static bool operator !=(InstanceAutoRecoveryState left, InstanceAutoRecoveryState right) => !left.Equals(right);

        public static explicit operator string(InstanceAutoRecoveryState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceAutoRecoveryState other && Equals(other);
        public bool Equals(InstanceAutoRecoveryState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceBootModeValues : IEquatable<InstanceBootModeValues>
    {
        private readonly string _value;

        private InstanceBootModeValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceBootModeValues enum legacy-bios
        /// </summary>
        public static InstanceBootModeValues LegacyBios { get; } = new InstanceBootModeValues("legacy-bios");
        /// <summary>
        /// InstanceBootModeValues enum uefi
        /// </summary>
        public static InstanceBootModeValues Uefi { get; } = new InstanceBootModeValues("uefi");

        public static bool operator ==(InstanceBootModeValues left, InstanceBootModeValues right) => left.Equals(right);
        public static bool operator !=(InstanceBootModeValues left, InstanceBootModeValues right) => !left.Equals(right);

        public static explicit operator string(InstanceBootModeValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceBootModeValues other && Equals(other);
        public bool Equals(InstanceBootModeValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceCollectionType : IEquatable<InstanceCollectionType>
    {
        private readonly string _value;

        private InstanceCollectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceCollectionType enum INSTANCE_FLEET
        /// </summary>
        public static InstanceCollectionType INSTANCE_FLEET { get; } = new InstanceCollectionType("INSTANCE_FLEET");
        /// <summary>
        /// InstanceCollectionType enum INSTANCE_GROUP
        /// </summary>
        public static InstanceCollectionType INSTANCE_GROUP { get; } = new InstanceCollectionType("INSTANCE_GROUP");

        public static bool operator ==(InstanceCollectionType left, InstanceCollectionType right) => left.Equals(right);
        public static bool operator !=(InstanceCollectionType left, InstanceCollectionType right) => !left.Equals(right);

        public static explicit operator string(InstanceCollectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceCollectionType other && Equals(other);
        public bool Equals(InstanceCollectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceLifecycleType : IEquatable<InstanceLifecycleType>
    {
        private readonly string _value;

        private InstanceLifecycleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceLifecycleType enum capacity-block
        /// </summary>
        public static InstanceLifecycleType CapacityBlock { get; } = new InstanceLifecycleType("capacity-block");
        /// <summary>
        /// InstanceLifecycleType enum scheduled
        /// </summary>
        public static InstanceLifecycleType Scheduled { get; } = new InstanceLifecycleType("scheduled");
        /// <summary>
        /// InstanceLifecycleType enum spot
        /// </summary>
        public static InstanceLifecycleType Spot { get; } = new InstanceLifecycleType("spot");

        public static bool operator ==(InstanceLifecycleType left, InstanceLifecycleType right) => left.Equals(right);
        public static bool operator !=(InstanceLifecycleType left, InstanceLifecycleType right) => !left.Equals(right);

        public static explicit operator string(InstanceLifecycleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceLifecycleType other && Equals(other);
        public bool Equals(InstanceLifecycleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataEndpointState : IEquatable<InstanceMetadataEndpointState>
    {
        private readonly string _value;

        private InstanceMetadataEndpointState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceMetadataEndpointState enum disabled
        /// </summary>
        public static InstanceMetadataEndpointState Disabled { get; } = new InstanceMetadataEndpointState("disabled");
        /// <summary>
        /// InstanceMetadataEndpointState enum enabled
        /// </summary>
        public static InstanceMetadataEndpointState Enabled { get; } = new InstanceMetadataEndpointState("enabled");

        public static bool operator ==(InstanceMetadataEndpointState left, InstanceMetadataEndpointState right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataEndpointState left, InstanceMetadataEndpointState right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataEndpointState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataEndpointState other && Equals(other);
        public bool Equals(InstanceMetadataEndpointState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataOptionsState : IEquatable<InstanceMetadataOptionsState>
    {
        private readonly string _value;

        private InstanceMetadataOptionsState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceMetadataOptionsState enum applied
        /// </summary>
        public static InstanceMetadataOptionsState Applied { get; } = new InstanceMetadataOptionsState("applied");
        /// <summary>
        /// InstanceMetadataOptionsState enum pending
        /// </summary>
        public static InstanceMetadataOptionsState Pending { get; } = new InstanceMetadataOptionsState("pending");

        public static bool operator ==(InstanceMetadataOptionsState left, InstanceMetadataOptionsState right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataOptionsState left, InstanceMetadataOptionsState right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataOptionsState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataOptionsState other && Equals(other);
        public bool Equals(InstanceMetadataOptionsState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataProtocolState : IEquatable<InstanceMetadataProtocolState>
    {
        private readonly string _value;

        private InstanceMetadataProtocolState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceMetadataProtocolState enum disabled
        /// </summary>
        public static InstanceMetadataProtocolState Disabled { get; } = new InstanceMetadataProtocolState("disabled");
        /// <summary>
        /// InstanceMetadataProtocolState enum enabled
        /// </summary>
        public static InstanceMetadataProtocolState Enabled { get; } = new InstanceMetadataProtocolState("enabled");

        public static bool operator ==(InstanceMetadataProtocolState left, InstanceMetadataProtocolState right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataProtocolState left, InstanceMetadataProtocolState right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataProtocolState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataProtocolState other && Equals(other);
        public bool Equals(InstanceMetadataProtocolState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataTagsState : IEquatable<InstanceMetadataTagsState>
    {
        private readonly string _value;

        private InstanceMetadataTagsState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceMetadataTagsState enum disabled
        /// </summary>
        public static InstanceMetadataTagsState Disabled { get; } = new InstanceMetadataTagsState("disabled");
        /// <summary>
        /// InstanceMetadataTagsState enum enabled
        /// </summary>
        public static InstanceMetadataTagsState Enabled { get; } = new InstanceMetadataTagsState("enabled");

        public static bool operator ==(InstanceMetadataTagsState left, InstanceMetadataTagsState right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataTagsState left, InstanceMetadataTagsState right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataTagsState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataTagsState other && Equals(other);
        public bool Equals(InstanceMetadataTagsState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceRoleType : IEquatable<InstanceRoleType>
    {
        private readonly string _value;

        private InstanceRoleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceRoleType enum CORE
        /// </summary>
        public static InstanceRoleType CORE { get; } = new InstanceRoleType("CORE");
        /// <summary>
        /// InstanceRoleType enum MASTER
        /// </summary>
        public static InstanceRoleType MASTER { get; } = new InstanceRoleType("MASTER");
        /// <summary>
        /// InstanceRoleType enum TASK
        /// </summary>
        public static InstanceRoleType TASK { get; } = new InstanceRoleType("TASK");

        public static bool operator ==(InstanceRoleType left, InstanceRoleType right) => left.Equals(right);
        public static bool operator !=(InstanceRoleType left, InstanceRoleType right) => !left.Equals(right);

        public static explicit operator string(InstanceRoleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceRoleType other && Equals(other);
        public bool Equals(InstanceRoleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceStateName : IEquatable<InstanceStateName>
    {
        private readonly string _value;

        private InstanceStateName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceStateName enum pending
        /// </summary>
        public static InstanceStateName Pending { get; } = new InstanceStateName("pending");
        /// <summary>
        /// InstanceStateName enum running
        /// </summary>
        public static InstanceStateName Running { get; } = new InstanceStateName("running");
        /// <summary>
        /// InstanceStateName enum shutting-down
        /// </summary>
        public static InstanceStateName ShuttingDown { get; } = new InstanceStateName("shutting-down");
        /// <summary>
        /// InstanceStateName enum stopped
        /// </summary>
        public static InstanceStateName Stopped { get; } = new InstanceStateName("stopped");
        /// <summary>
        /// InstanceStateName enum stopping
        /// </summary>
        public static InstanceStateName Stopping { get; } = new InstanceStateName("stopping");
        /// <summary>
        /// InstanceStateName enum terminated
        /// </summary>
        public static InstanceStateName Terminated { get; } = new InstanceStateName("terminated");

        public static bool operator ==(InstanceStateName left, InstanceStateName right) => left.Equals(right);
        public static bool operator !=(InstanceStateName left, InstanceStateName right) => !left.Equals(right);

        public static explicit operator string(InstanceStateName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceStateName other && Equals(other);
        public bool Equals(InstanceStateName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct InstanceType : IEquatable<InstanceType>
    {
        private readonly string _value;

        private InstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InstanceType enum ml.c4.2xlarge
        /// </summary>
        public static InstanceType MlC42xlarge { get; } = new InstanceType("ml.c4.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c4.4xlarge
        /// </summary>
        public static InstanceType MlC44xlarge { get; } = new InstanceType("ml.c4.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c4.8xlarge
        /// </summary>
        public static InstanceType MlC48xlarge { get; } = new InstanceType("ml.c4.8xlarge");
        /// <summary>
        /// InstanceType enum ml.c4.xlarge
        /// </summary>
        public static InstanceType MlC4Xlarge { get; } = new InstanceType("ml.c4.xlarge");
        /// <summary>
        /// InstanceType enum ml.c5.18xlarge
        /// </summary>
        public static InstanceType MlC518xlarge { get; } = new InstanceType("ml.c5.18xlarge");
        /// <summary>
        /// InstanceType enum ml.c5.2xlarge
        /// </summary>
        public static InstanceType MlC52xlarge { get; } = new InstanceType("ml.c5.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c5.4xlarge
        /// </summary>
        public static InstanceType MlC54xlarge { get; } = new InstanceType("ml.c5.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c5.9xlarge
        /// </summary>
        public static InstanceType MlC59xlarge { get; } = new InstanceType("ml.c5.9xlarge");
        /// <summary>
        /// InstanceType enum ml.c5.xlarge
        /// </summary>
        public static InstanceType MlC5Xlarge { get; } = new InstanceType("ml.c5.xlarge");
        /// <summary>
        /// InstanceType enum ml.c5d.18xlarge
        /// </summary>
        public static InstanceType MlC5d18xlarge { get; } = new InstanceType("ml.c5d.18xlarge");
        /// <summary>
        /// InstanceType enum ml.c5d.2xlarge
        /// </summary>
        public static InstanceType MlC5d2xlarge { get; } = new InstanceType("ml.c5d.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c5d.4xlarge
        /// </summary>
        public static InstanceType MlC5d4xlarge { get; } = new InstanceType("ml.c5d.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c5d.9xlarge
        /// </summary>
        public static InstanceType MlC5d9xlarge { get; } = new InstanceType("ml.c5d.9xlarge");
        /// <summary>
        /// InstanceType enum ml.c5d.xlarge
        /// </summary>
        public static InstanceType MlC5dXlarge { get; } = new InstanceType("ml.c5d.xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.12xlarge
        /// </summary>
        public static InstanceType MlC6i12xlarge { get; } = new InstanceType("ml.c6i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.16xlarge
        /// </summary>
        public static InstanceType MlC6i16xlarge { get; } = new InstanceType("ml.c6i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.24xlarge
        /// </summary>
        public static InstanceType MlC6i24xlarge { get; } = new InstanceType("ml.c6i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.2xlarge
        /// </summary>
        public static InstanceType MlC6i2xlarge { get; } = new InstanceType("ml.c6i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.32xlarge
        /// </summary>
        public static InstanceType MlC6i32xlarge { get; } = new InstanceType("ml.c6i.32xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.4xlarge
        /// </summary>
        public static InstanceType MlC6i4xlarge { get; } = new InstanceType("ml.c6i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.8xlarge
        /// </summary>
        public static InstanceType MlC6i8xlarge { get; } = new InstanceType("ml.c6i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.c6i.large
        /// </summary>
        public static InstanceType MlC6iLarge { get; } = new InstanceType("ml.c6i.large");
        /// <summary>
        /// InstanceType enum ml.c6i.xlarge
        /// </summary>
        public static InstanceType MlC6iXlarge { get; } = new InstanceType("ml.c6i.xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.12xlarge
        /// </summary>
        public static InstanceType MlC6id12xlarge { get; } = new InstanceType("ml.c6id.12xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.16xlarge
        /// </summary>
        public static InstanceType MlC6id16xlarge { get; } = new InstanceType("ml.c6id.16xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.24xlarge
        /// </summary>
        public static InstanceType MlC6id24xlarge { get; } = new InstanceType("ml.c6id.24xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.2xlarge
        /// </summary>
        public static InstanceType MlC6id2xlarge { get; } = new InstanceType("ml.c6id.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.32xlarge
        /// </summary>
        public static InstanceType MlC6id32xlarge { get; } = new InstanceType("ml.c6id.32xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.4xlarge
        /// </summary>
        public static InstanceType MlC6id4xlarge { get; } = new InstanceType("ml.c6id.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.8xlarge
        /// </summary>
        public static InstanceType MlC6id8xlarge { get; } = new InstanceType("ml.c6id.8xlarge");
        /// <summary>
        /// InstanceType enum ml.c6id.large
        /// </summary>
        public static InstanceType MlC6idLarge { get; } = new InstanceType("ml.c6id.large");
        /// <summary>
        /// InstanceType enum ml.c6id.xlarge
        /// </summary>
        public static InstanceType MlC6idXlarge { get; } = new InstanceType("ml.c6id.xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.12xlarge
        /// </summary>
        public static InstanceType MlC7i12xlarge { get; } = new InstanceType("ml.c7i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.16xlarge
        /// </summary>
        public static InstanceType MlC7i16xlarge { get; } = new InstanceType("ml.c7i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.24xlarge
        /// </summary>
        public static InstanceType MlC7i24xlarge { get; } = new InstanceType("ml.c7i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.2xlarge
        /// </summary>
        public static InstanceType MlC7i2xlarge { get; } = new InstanceType("ml.c7i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.48xlarge
        /// </summary>
        public static InstanceType MlC7i48xlarge { get; } = new InstanceType("ml.c7i.48xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.4xlarge
        /// </summary>
        public static InstanceType MlC7i4xlarge { get; } = new InstanceType("ml.c7i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.8xlarge
        /// </summary>
        public static InstanceType MlC7i8xlarge { get; } = new InstanceType("ml.c7i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.c7i.large
        /// </summary>
        public static InstanceType MlC7iLarge { get; } = new InstanceType("ml.c7i.large");
        /// <summary>
        /// InstanceType enum ml.c7i.xlarge
        /// </summary>
        public static InstanceType MlC7iXlarge { get; } = new InstanceType("ml.c7i.xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.12xlarge
        /// </summary>
        public static InstanceType MlG4dn12xlarge { get; } = new InstanceType("ml.g4dn.12xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.16xlarge
        /// </summary>
        public static InstanceType MlG4dn16xlarge { get; } = new InstanceType("ml.g4dn.16xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.2xlarge
        /// </summary>
        public static InstanceType MlG4dn2xlarge { get; } = new InstanceType("ml.g4dn.2xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.4xlarge
        /// </summary>
        public static InstanceType MlG4dn4xlarge { get; } = new InstanceType("ml.g4dn.4xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.8xlarge
        /// </summary>
        public static InstanceType MlG4dn8xlarge { get; } = new InstanceType("ml.g4dn.8xlarge");
        /// <summary>
        /// InstanceType enum ml.g4dn.xlarge
        /// </summary>
        public static InstanceType MlG4dnXlarge { get; } = new InstanceType("ml.g4dn.xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.12xlarge
        /// </summary>
        public static InstanceType MlG512xlarge { get; } = new InstanceType("ml.g5.12xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.16xlarge
        /// </summary>
        public static InstanceType MlG516xlarge { get; } = new InstanceType("ml.g5.16xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.24xlarge
        /// </summary>
        public static InstanceType MlG524xlarge { get; } = new InstanceType("ml.g5.24xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.2xlarge
        /// </summary>
        public static InstanceType MlG52xlarge { get; } = new InstanceType("ml.g5.2xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.48xlarge
        /// </summary>
        public static InstanceType MlG548xlarge { get; } = new InstanceType("ml.g5.48xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.4xlarge
        /// </summary>
        public static InstanceType MlG54xlarge { get; } = new InstanceType("ml.g5.4xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.8xlarge
        /// </summary>
        public static InstanceType MlG58xlarge { get; } = new InstanceType("ml.g5.8xlarge");
        /// <summary>
        /// InstanceType enum ml.g5.xlarge
        /// </summary>
        public static InstanceType MlG5Xlarge { get; } = new InstanceType("ml.g5.xlarge");
        /// <summary>
        /// InstanceType enum ml.inf1.24xlarge
        /// </summary>
        public static InstanceType MlInf124xlarge { get; } = new InstanceType("ml.inf1.24xlarge");
        /// <summary>
        /// InstanceType enum ml.inf1.2xlarge
        /// </summary>
        public static InstanceType MlInf12xlarge { get; } = new InstanceType("ml.inf1.2xlarge");
        /// <summary>
        /// InstanceType enum ml.inf1.6xlarge
        /// </summary>
        public static InstanceType MlInf16xlarge { get; } = new InstanceType("ml.inf1.6xlarge");
        /// <summary>
        /// InstanceType enum ml.inf1.xlarge
        /// </summary>
        public static InstanceType MlInf1Xlarge { get; } = new InstanceType("ml.inf1.xlarge");
        /// <summary>
        /// InstanceType enum ml.m4.10xlarge
        /// </summary>
        public static InstanceType MlM410xlarge { get; } = new InstanceType("ml.m4.10xlarge");
        /// <summary>
        /// InstanceType enum ml.m4.16xlarge
        /// </summary>
        public static InstanceType MlM416xlarge { get; } = new InstanceType("ml.m4.16xlarge");
        /// <summary>
        /// InstanceType enum ml.m4.2xlarge
        /// </summary>
        public static InstanceType MlM42xlarge { get; } = new InstanceType("ml.m4.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m4.4xlarge
        /// </summary>
        public static InstanceType MlM44xlarge { get; } = new InstanceType("ml.m4.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m4.xlarge
        /// </summary>
        public static InstanceType MlM4Xlarge { get; } = new InstanceType("ml.m4.xlarge");
        /// <summary>
        /// InstanceType enum ml.m5.12xlarge
        /// </summary>
        public static InstanceType MlM512xlarge { get; } = new InstanceType("ml.m5.12xlarge");
        /// <summary>
        /// InstanceType enum ml.m5.24xlarge
        /// </summary>
        public static InstanceType MlM524xlarge { get; } = new InstanceType("ml.m5.24xlarge");
        /// <summary>
        /// InstanceType enum ml.m5.2xlarge
        /// </summary>
        public static InstanceType MlM52xlarge { get; } = new InstanceType("ml.m5.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m5.4xlarge
        /// </summary>
        public static InstanceType MlM54xlarge { get; } = new InstanceType("ml.m5.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m5.xlarge
        /// </summary>
        public static InstanceType MlM5Xlarge { get; } = new InstanceType("ml.m5.xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.12xlarge
        /// </summary>
        public static InstanceType MlM5d12xlarge { get; } = new InstanceType("ml.m5d.12xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.16xlarge
        /// </summary>
        public static InstanceType MlM5d16xlarge { get; } = new InstanceType("ml.m5d.16xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.24xlarge
        /// </summary>
        public static InstanceType MlM5d24xlarge { get; } = new InstanceType("ml.m5d.24xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.2xlarge
        /// </summary>
        public static InstanceType MlM5d2xlarge { get; } = new InstanceType("ml.m5d.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.4xlarge
        /// </summary>
        public static InstanceType MlM5d4xlarge { get; } = new InstanceType("ml.m5d.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.8xlarge
        /// </summary>
        public static InstanceType MlM5d8xlarge { get; } = new InstanceType("ml.m5d.8xlarge");
        /// <summary>
        /// InstanceType enum ml.m5d.large
        /// </summary>
        public static InstanceType MlM5dLarge { get; } = new InstanceType("ml.m5d.large");
        /// <summary>
        /// InstanceType enum ml.m5d.xlarge
        /// </summary>
        public static InstanceType MlM5dXlarge { get; } = new InstanceType("ml.m5d.xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.12xlarge
        /// </summary>
        public static InstanceType MlM6i12xlarge { get; } = new InstanceType("ml.m6i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.16xlarge
        /// </summary>
        public static InstanceType MlM6i16xlarge { get; } = new InstanceType("ml.m6i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.24xlarge
        /// </summary>
        public static InstanceType MlM6i24xlarge { get; } = new InstanceType("ml.m6i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.2xlarge
        /// </summary>
        public static InstanceType MlM6i2xlarge { get; } = new InstanceType("ml.m6i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.32xlarge
        /// </summary>
        public static InstanceType MlM6i32xlarge { get; } = new InstanceType("ml.m6i.32xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.4xlarge
        /// </summary>
        public static InstanceType MlM6i4xlarge { get; } = new InstanceType("ml.m6i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.8xlarge
        /// </summary>
        public static InstanceType MlM6i8xlarge { get; } = new InstanceType("ml.m6i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.m6i.large
        /// </summary>
        public static InstanceType MlM6iLarge { get; } = new InstanceType("ml.m6i.large");
        /// <summary>
        /// InstanceType enum ml.m6i.xlarge
        /// </summary>
        public static InstanceType MlM6iXlarge { get; } = new InstanceType("ml.m6i.xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.12xlarge
        /// </summary>
        public static InstanceType MlM6id12xlarge { get; } = new InstanceType("ml.m6id.12xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.16xlarge
        /// </summary>
        public static InstanceType MlM6id16xlarge { get; } = new InstanceType("ml.m6id.16xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.24xlarge
        /// </summary>
        public static InstanceType MlM6id24xlarge { get; } = new InstanceType("ml.m6id.24xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.2xlarge
        /// </summary>
        public static InstanceType MlM6id2xlarge { get; } = new InstanceType("ml.m6id.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.32xlarge
        /// </summary>
        public static InstanceType MlM6id32xlarge { get; } = new InstanceType("ml.m6id.32xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.4xlarge
        /// </summary>
        public static InstanceType MlM6id4xlarge { get; } = new InstanceType("ml.m6id.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.8xlarge
        /// </summary>
        public static InstanceType MlM6id8xlarge { get; } = new InstanceType("ml.m6id.8xlarge");
        /// <summary>
        /// InstanceType enum ml.m6id.large
        /// </summary>
        public static InstanceType MlM6idLarge { get; } = new InstanceType("ml.m6id.large");
        /// <summary>
        /// InstanceType enum ml.m6id.xlarge
        /// </summary>
        public static InstanceType MlM6idXlarge { get; } = new InstanceType("ml.m6id.xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.12xlarge
        /// </summary>
        public static InstanceType MlM7i12xlarge { get; } = new InstanceType("ml.m7i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.16xlarge
        /// </summary>
        public static InstanceType MlM7i16xlarge { get; } = new InstanceType("ml.m7i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.24xlarge
        /// </summary>
        public static InstanceType MlM7i24xlarge { get; } = new InstanceType("ml.m7i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.2xlarge
        /// </summary>
        public static InstanceType MlM7i2xlarge { get; } = new InstanceType("ml.m7i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.48xlarge
        /// </summary>
        public static InstanceType MlM7i48xlarge { get; } = new InstanceType("ml.m7i.48xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.4xlarge
        /// </summary>
        public static InstanceType MlM7i4xlarge { get; } = new InstanceType("ml.m7i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.8xlarge
        /// </summary>
        public static InstanceType MlM7i8xlarge { get; } = new InstanceType("ml.m7i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.m7i.large
        /// </summary>
        public static InstanceType MlM7iLarge { get; } = new InstanceType("ml.m7i.large");
        /// <summary>
        /// InstanceType enum ml.m7i.xlarge
        /// </summary>
        public static InstanceType MlM7iXlarge { get; } = new InstanceType("ml.m7i.xlarge");
        /// <summary>
        /// InstanceType enum ml.p2.16xlarge
        /// </summary>
        public static InstanceType MlP216xlarge { get; } = new InstanceType("ml.p2.16xlarge");
        /// <summary>
        /// InstanceType enum ml.p2.8xlarge
        /// </summary>
        public static InstanceType MlP28xlarge { get; } = new InstanceType("ml.p2.8xlarge");
        /// <summary>
        /// InstanceType enum ml.p2.xlarge
        /// </summary>
        public static InstanceType MlP2Xlarge { get; } = new InstanceType("ml.p2.xlarge");
        /// <summary>
        /// InstanceType enum ml.p3.16xlarge
        /// </summary>
        public static InstanceType MlP316xlarge { get; } = new InstanceType("ml.p3.16xlarge");
        /// <summary>
        /// InstanceType enum ml.p3.2xlarge
        /// </summary>
        public static InstanceType MlP32xlarge { get; } = new InstanceType("ml.p3.2xlarge");
        /// <summary>
        /// InstanceType enum ml.p3.8xlarge
        /// </summary>
        public static InstanceType MlP38xlarge { get; } = new InstanceType("ml.p3.8xlarge");
        /// <summary>
        /// InstanceType enum ml.p3dn.24xlarge
        /// </summary>
        public static InstanceType MlP3dn24xlarge { get; } = new InstanceType("ml.p3dn.24xlarge");
        /// <summary>
        /// InstanceType enum ml.p4d.24xlarge
        /// </summary>
        public static InstanceType MlP4d24xlarge { get; } = new InstanceType("ml.p4d.24xlarge");
        /// <summary>
        /// InstanceType enum ml.p4de.24xlarge
        /// </summary>
        public static InstanceType MlP4de24xlarge { get; } = new InstanceType("ml.p4de.24xlarge");
        /// <summary>
        /// InstanceType enum ml.p5.48xlarge
        /// </summary>
        public static InstanceType MlP548xlarge { get; } = new InstanceType("ml.p5.48xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.12xlarge
        /// </summary>
        public static InstanceType MlR512xlarge { get; } = new InstanceType("ml.r5.12xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.16xlarge
        /// </summary>
        public static InstanceType MlR516xlarge { get; } = new InstanceType("ml.r5.16xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.24xlarge
        /// </summary>
        public static InstanceType MlR524xlarge { get; } = new InstanceType("ml.r5.24xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.2xlarge
        /// </summary>
        public static InstanceType MlR52xlarge { get; } = new InstanceType("ml.r5.2xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.4xlarge
        /// </summary>
        public static InstanceType MlR54xlarge { get; } = new InstanceType("ml.r5.4xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.8xlarge
        /// </summary>
        public static InstanceType MlR58xlarge { get; } = new InstanceType("ml.r5.8xlarge");
        /// <summary>
        /// InstanceType enum ml.r5.large
        /// </summary>
        public static InstanceType MlR5Large { get; } = new InstanceType("ml.r5.large");
        /// <summary>
        /// InstanceType enum ml.r5.xlarge
        /// </summary>
        public static InstanceType MlR5Xlarge { get; } = new InstanceType("ml.r5.xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.12xlarge
        /// </summary>
        public static InstanceType MlR6i12xlarge { get; } = new InstanceType("ml.r6i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.16xlarge
        /// </summary>
        public static InstanceType MlR6i16xlarge { get; } = new InstanceType("ml.r6i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.24xlarge
        /// </summary>
        public static InstanceType MlR6i24xlarge { get; } = new InstanceType("ml.r6i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.2xlarge
        /// </summary>
        public static InstanceType MlR6i2xlarge { get; } = new InstanceType("ml.r6i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.32xlarge
        /// </summary>
        public static InstanceType MlR6i32xlarge { get; } = new InstanceType("ml.r6i.32xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.4xlarge
        /// </summary>
        public static InstanceType MlR6i4xlarge { get; } = new InstanceType("ml.r6i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.8xlarge
        /// </summary>
        public static InstanceType MlR6i8xlarge { get; } = new InstanceType("ml.r6i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.r6i.large
        /// </summary>
        public static InstanceType MlR6iLarge { get; } = new InstanceType("ml.r6i.large");
        /// <summary>
        /// InstanceType enum ml.r6i.xlarge
        /// </summary>
        public static InstanceType MlR6iXlarge { get; } = new InstanceType("ml.r6i.xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.12xlarge
        /// </summary>
        public static InstanceType MlR6id12xlarge { get; } = new InstanceType("ml.r6id.12xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.16xlarge
        /// </summary>
        public static InstanceType MlR6id16xlarge { get; } = new InstanceType("ml.r6id.16xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.24xlarge
        /// </summary>
        public static InstanceType MlR6id24xlarge { get; } = new InstanceType("ml.r6id.24xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.2xlarge
        /// </summary>
        public static InstanceType MlR6id2xlarge { get; } = new InstanceType("ml.r6id.2xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.32xlarge
        /// </summary>
        public static InstanceType MlR6id32xlarge { get; } = new InstanceType("ml.r6id.32xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.4xlarge
        /// </summary>
        public static InstanceType MlR6id4xlarge { get; } = new InstanceType("ml.r6id.4xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.8xlarge
        /// </summary>
        public static InstanceType MlR6id8xlarge { get; } = new InstanceType("ml.r6id.8xlarge");
        /// <summary>
        /// InstanceType enum ml.r6id.large
        /// </summary>
        public static InstanceType MlR6idLarge { get; } = new InstanceType("ml.r6id.large");
        /// <summary>
        /// InstanceType enum ml.r6id.xlarge
        /// </summary>
        public static InstanceType MlR6idXlarge { get; } = new InstanceType("ml.r6id.xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.12xlarge
        /// </summary>
        public static InstanceType MlR7i12xlarge { get; } = new InstanceType("ml.r7i.12xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.16xlarge
        /// </summary>
        public static InstanceType MlR7i16xlarge { get; } = new InstanceType("ml.r7i.16xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.24xlarge
        /// </summary>
        public static InstanceType MlR7i24xlarge { get; } = new InstanceType("ml.r7i.24xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.2xlarge
        /// </summary>
        public static InstanceType MlR7i2xlarge { get; } = new InstanceType("ml.r7i.2xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.48xlarge
        /// </summary>
        public static InstanceType MlR7i48xlarge { get; } = new InstanceType("ml.r7i.48xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.4xlarge
        /// </summary>
        public static InstanceType MlR7i4xlarge { get; } = new InstanceType("ml.r7i.4xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.8xlarge
        /// </summary>
        public static InstanceType MlR7i8xlarge { get; } = new InstanceType("ml.r7i.8xlarge");
        /// <summary>
        /// InstanceType enum ml.r7i.large
        /// </summary>
        public static InstanceType MlR7iLarge { get; } = new InstanceType("ml.r7i.large");
        /// <summary>
        /// InstanceType enum ml.r7i.xlarge
        /// </summary>
        public static InstanceType MlR7iXlarge { get; } = new InstanceType("ml.r7i.xlarge");
        /// <summary>
        /// InstanceType enum ml.t2.2xlarge
        /// </summary>
        public static InstanceType MlT22xlarge { get; } = new InstanceType("ml.t2.2xlarge");
        /// <summary>
        /// InstanceType enum ml.t2.large
        /// </summary>
        public static InstanceType MlT2Large { get; } = new InstanceType("ml.t2.large");
        /// <summary>
        /// InstanceType enum ml.t2.medium
        /// </summary>
        public static InstanceType MlT2Medium { get; } = new InstanceType("ml.t2.medium");
        /// <summary>
        /// InstanceType enum ml.t2.xlarge
        /// </summary>
        public static InstanceType MlT2Xlarge { get; } = new InstanceType("ml.t2.xlarge");
        /// <summary>
        /// InstanceType enum ml.t3.2xlarge
        /// </summary>
        public static InstanceType MlT32xlarge { get; } = new InstanceType("ml.t3.2xlarge");
        /// <summary>
        /// InstanceType enum ml.t3.large
        /// </summary>
        public static InstanceType MlT3Large { get; } = new InstanceType("ml.t3.large");
        /// <summary>
        /// InstanceType enum ml.t3.medium
        /// </summary>
        public static InstanceType MlT3Medium { get; } = new InstanceType("ml.t3.medium");
        /// <summary>
        /// InstanceType enum ml.t3.xlarge
        /// </summary>
        public static InstanceType MlT3Xlarge { get; } = new InstanceType("ml.t3.xlarge");

        public static bool operator ==(InstanceType left, InstanceType right) => left.Equals(right);
        public static bool operator !=(InstanceType left, InstanceType right) => !left.Equals(right);

        public static explicit operator string(InstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceType other && Equals(other);
        public bool Equals(InstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the status of the configuration.
    /// </summary>
    [EnumType]
    public readonly struct IntelligentTieringConfigurationStatus : IEquatable<IntelligentTieringConfigurationStatus>
    {
        private readonly string _value;

        private IntelligentTieringConfigurationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IntelligentTieringConfigurationStatus enum Disabled
        /// </summary>
        public static IntelligentTieringConfigurationStatus Disabled { get; } = new IntelligentTieringConfigurationStatus("Disabled");
        /// <summary>
        /// IntelligentTieringConfigurationStatus enum Enabled
        /// </summary>
        public static IntelligentTieringConfigurationStatus Enabled { get; } = new IntelligentTieringConfigurationStatus("Enabled");

        public static bool operator ==(IntelligentTieringConfigurationStatus left, IntelligentTieringConfigurationStatus right) => left.Equals(right);
        public static bool operator !=(IntelligentTieringConfigurationStatus left, IntelligentTieringConfigurationStatus right) => !left.Equals(right);

        public static explicit operator string(IntelligentTieringConfigurationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntelligentTieringConfigurationStatus other && Equals(other);
        public bool Equals(IntelligentTieringConfigurationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Object versions to include in the inventory list. If set to ``All``, the list includes all the object versions, which adds the version-related fields ``VersionId``, ``IsLatest``, and ``DeleteMarker`` to the list. If set to ``Current``, the list does not contain these version-related fields.
    /// </summary>
    [EnumType]
    public readonly struct InventoryConfigurationIncludedObjectVersions : IEquatable<InventoryConfigurationIncludedObjectVersions>
    {
        private readonly string _value;

        private InventoryConfigurationIncludedObjectVersions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InventoryConfigurationIncludedObjectVersions enum All
        /// </summary>
        public static InventoryConfigurationIncludedObjectVersions All { get; } = new InventoryConfigurationIncludedObjectVersions("All");
        /// <summary>
        /// InventoryConfigurationIncludedObjectVersions enum Current
        /// </summary>
        public static InventoryConfigurationIncludedObjectVersions Current { get; } = new InventoryConfigurationIncludedObjectVersions("Current");

        public static bool operator ==(InventoryConfigurationIncludedObjectVersions left, InventoryConfigurationIncludedObjectVersions right) => left.Equals(right);
        public static bool operator !=(InventoryConfigurationIncludedObjectVersions left, InventoryConfigurationIncludedObjectVersions right) => !left.Equals(right);

        public static explicit operator string(InventoryConfigurationIncludedObjectVersions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InventoryConfigurationIncludedObjectVersions other && Equals(other);
        public bool Equals(InventoryConfigurationIncludedObjectVersions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// InventoryConfigurationOptionalFields enum
    /// </summary>
    [EnumType]
    public readonly struct InventoryConfigurationOptionalFields : IEquatable<InventoryConfigurationOptionalFields>
    {
        private readonly string _value;

        private InventoryConfigurationOptionalFields(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InventoryConfigurationOptionalFields enum BucketKeyStatus
        /// </summary>
        public static InventoryConfigurationOptionalFields BucketKeyStatus { get; } = new InventoryConfigurationOptionalFields("BucketKeyStatus");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ChecksumAlgorithm
        /// </summary>
        public static InventoryConfigurationOptionalFields ChecksumAlgorithm { get; } = new InventoryConfigurationOptionalFields("ChecksumAlgorithm");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ETag
        /// </summary>
        public static InventoryConfigurationOptionalFields ETag { get; } = new InventoryConfigurationOptionalFields("ETag");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum EncryptionStatus
        /// </summary>
        public static InventoryConfigurationOptionalFields EncryptionStatus { get; } = new InventoryConfigurationOptionalFields("EncryptionStatus");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum IntelligentTieringAccessTier
        /// </summary>
        public static InventoryConfigurationOptionalFields IntelligentTieringAccessTier { get; } = new InventoryConfigurationOptionalFields("IntelligentTieringAccessTier");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum IsMultipartUploaded
        /// </summary>
        public static InventoryConfigurationOptionalFields IsMultipartUploaded { get; } = new InventoryConfigurationOptionalFields("IsMultipartUploaded");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum LastModifiedDate
        /// </summary>
        public static InventoryConfigurationOptionalFields LastModifiedDate { get; } = new InventoryConfigurationOptionalFields("LastModifiedDate");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ObjectAccessControlList
        /// </summary>
        public static InventoryConfigurationOptionalFields ObjectAccessControlList { get; } = new InventoryConfigurationOptionalFields("ObjectAccessControlList");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ObjectLockLegalHoldStatus
        /// </summary>
        public static InventoryConfigurationOptionalFields ObjectLockLegalHoldStatus { get; } = new InventoryConfigurationOptionalFields("ObjectLockLegalHoldStatus");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ObjectLockMode
        /// </summary>
        public static InventoryConfigurationOptionalFields ObjectLockMode { get; } = new InventoryConfigurationOptionalFields("ObjectLockMode");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ObjectLockRetainUntilDate
        /// </summary>
        public static InventoryConfigurationOptionalFields ObjectLockRetainUntilDate { get; } = new InventoryConfigurationOptionalFields("ObjectLockRetainUntilDate");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ObjectOwner
        /// </summary>
        public static InventoryConfigurationOptionalFields ObjectOwner { get; } = new InventoryConfigurationOptionalFields("ObjectOwner");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum ReplicationStatus
        /// </summary>
        public static InventoryConfigurationOptionalFields ReplicationStatus { get; } = new InventoryConfigurationOptionalFields("ReplicationStatus");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum Size
        /// </summary>
        public static InventoryConfigurationOptionalFields Size { get; } = new InventoryConfigurationOptionalFields("Size");
        /// <summary>
        /// InventoryConfigurationOptionalFields enum StorageClass
        /// </summary>
        public static InventoryConfigurationOptionalFields StorageClass { get; } = new InventoryConfigurationOptionalFields("StorageClass");

        public static bool operator ==(InventoryConfigurationOptionalFields left, InventoryConfigurationOptionalFields right) => left.Equals(right);
        public static bool operator !=(InventoryConfigurationOptionalFields left, InventoryConfigurationOptionalFields right) => !left.Equals(right);

        public static explicit operator string(InventoryConfigurationOptionalFields value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InventoryConfigurationOptionalFields other && Equals(other);
        public bool Equals(InventoryConfigurationOptionalFields other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the schedule for generating inventory results.
    /// </summary>
    [EnumType]
    public readonly struct InventoryConfigurationScheduleFrequency : IEquatable<InventoryConfigurationScheduleFrequency>
    {
        private readonly string _value;

        private InventoryConfigurationScheduleFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// InventoryConfigurationScheduleFrequency enum Daily
        /// </summary>
        public static InventoryConfigurationScheduleFrequency Daily { get; } = new InventoryConfigurationScheduleFrequency("Daily");
        /// <summary>
        /// InventoryConfigurationScheduleFrequency enum Weekly
        /// </summary>
        public static InventoryConfigurationScheduleFrequency Weekly { get; } = new InventoryConfigurationScheduleFrequency("Weekly");

        public static bool operator ==(InventoryConfigurationScheduleFrequency left, InventoryConfigurationScheduleFrequency right) => left.Equals(right);
        public static bool operator !=(InventoryConfigurationScheduleFrequency left, InventoryConfigurationScheduleFrequency right) => !left.Equals(right);

        public static explicit operator string(InventoryConfigurationScheduleFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InventoryConfigurationScheduleFrequency other && Equals(other);
        public bool Equals(InventoryConfigurationScheduleFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct IpFamily : IEquatable<IpFamily>
    {
        private readonly string _value;

        private IpFamily(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IpFamily enum ipv4
        /// </summary>
        public static IpFamily Ipv4 { get; } = new IpFamily("ipv4");
        /// <summary>
        /// IpFamily enum ipv6
        /// </summary>
        public static IpFamily Ipv6 { get; } = new IpFamily("ipv6");

        public static bool operator ==(IpFamily left, IpFamily right) => left.Equals(right);
        public static bool operator !=(IpFamily left, IpFamily right) => !left.Equals(right);

        public static explicit operator string(IpFamily value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpFamily other && Equals(other);
        public bool Equals(IpFamily other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct IpamState : IEquatable<IpamState>
    {
        private readonly string _value;

        private IpamState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IpamState enum create-complete
        /// </summary>
        public static IpamState CreateComplete { get; } = new IpamState("create-complete");
        /// <summary>
        /// IpamState enum create-failed
        /// </summary>
        public static IpamState CreateFailed { get; } = new IpamState("create-failed");
        /// <summary>
        /// IpamState enum create-in-progress
        /// </summary>
        public static IpamState CreateInProgress { get; } = new IpamState("create-in-progress");
        /// <summary>
        /// IpamState enum delete-complete
        /// </summary>
        public static IpamState DeleteComplete { get; } = new IpamState("delete-complete");
        /// <summary>
        /// IpamState enum delete-failed
        /// </summary>
        public static IpamState DeleteFailed { get; } = new IpamState("delete-failed");
        /// <summary>
        /// IpamState enum delete-in-progress
        /// </summary>
        public static IpamState DeleteInProgress { get; } = new IpamState("delete-in-progress");
        /// <summary>
        /// IpamState enum isolate-complete
        /// </summary>
        public static IpamState IsolateComplete { get; } = new IpamState("isolate-complete");
        /// <summary>
        /// IpamState enum isolate-in-progress
        /// </summary>
        public static IpamState IsolateInProgress { get; } = new IpamState("isolate-in-progress");
        /// <summary>
        /// IpamState enum modify-complete
        /// </summary>
        public static IpamState ModifyComplete { get; } = new IpamState("modify-complete");
        /// <summary>
        /// IpamState enum modify-failed
        /// </summary>
        public static IpamState ModifyFailed { get; } = new IpamState("modify-failed");
        /// <summary>
        /// IpamState enum modify-in-progress
        /// </summary>
        public static IpamState ModifyInProgress { get; } = new IpamState("modify-in-progress");
        /// <summary>
        /// IpamState enum restore-in-progress
        /// </summary>
        public static IpamState RestoreInProgress { get; } = new IpamState("restore-in-progress");

        public static bool operator ==(IpamState left, IpamState right) => left.Equals(right);
        public static bool operator !=(IpamState left, IpamState right) => !left.Equals(right);

        public static explicit operator string(IpamState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamState other && Equals(other);
        public bool Equals(IpamState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct IpamTier : IEquatable<IpamTier>
    {
        private readonly string _value;

        private IpamTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IpamTier enum advanced
        /// </summary>
        public static IpamTier Advanced { get; } = new IpamTier("advanced");
        /// <summary>
        /// IpamTier enum free
        /// </summary>
        public static IpamTier Free { get; } = new IpamTier("free");

        public static bool operator ==(IpamTier left, IpamTier right) => left.Equals(right);
        public static bool operator !=(IpamTier left, IpamTier right) => !left.Equals(right);

        public static explicit operator string(IpamTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamTier other && Equals(other);
        public bool Equals(IpamTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct JobComparator : IEquatable<JobComparator>
    {
        private readonly string _value;

        private JobComparator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JobComparator enum CONTAINS
        /// </summary>
        public static JobComparator CONTAINS { get; } = new JobComparator("CONTAINS");
        /// <summary>
        /// JobComparator enum EQ
        /// </summary>
        public static JobComparator EQ { get; } = new JobComparator("EQ");
        /// <summary>
        /// JobComparator enum GT
        /// </summary>
        public static JobComparator GT { get; } = new JobComparator("GT");
        /// <summary>
        /// JobComparator enum GTE
        /// </summary>
        public static JobComparator GTE { get; } = new JobComparator("GTE");
        /// <summary>
        /// JobComparator enum LT
        /// </summary>
        public static JobComparator LT { get; } = new JobComparator("LT");
        /// <summary>
        /// JobComparator enum LTE
        /// </summary>
        public static JobComparator LTE { get; } = new JobComparator("LTE");
        /// <summary>
        /// JobComparator enum NE
        /// </summary>
        public static JobComparator NE { get; } = new JobComparator("NE");
        /// <summary>
        /// JobComparator enum STARTS_WITH
        /// </summary>
        public static JobComparator STARTS_WITH { get; } = new JobComparator("STARTS_WITH");

        public static bool operator ==(JobComparator left, JobComparator right) => left.Equals(right);
        public static bool operator !=(JobComparator left, JobComparator right) => !left.Equals(right);

        public static explicit operator string(JobComparator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobComparator other && Equals(other);
        public bool Equals(JobComparator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct JobStatus : IEquatable<JobStatus>
    {
        private readonly string _value;

        private JobStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JobStatus enum CANCELLED
        /// </summary>
        public static JobStatus CANCELLED { get; } = new JobStatus("CANCELLED");
        /// <summary>
        /// JobStatus enum COMPLETE
        /// </summary>
        public static JobStatus COMPLETE { get; } = new JobStatus("COMPLETE");
        /// <summary>
        /// JobStatus enum IDLE
        /// </summary>
        public static JobStatus IDLE { get; } = new JobStatus("IDLE");
        /// <summary>
        /// JobStatus enum PAUSED
        /// </summary>
        public static JobStatus PAUSED { get; } = new JobStatus("PAUSED");
        /// <summary>
        /// JobStatus enum RUNNING
        /// </summary>
        public static JobStatus RUNNING { get; } = new JobStatus("RUNNING");
        /// <summary>
        /// JobStatus enum USER_PAUSED
        /// </summary>
        public static JobStatus USER_PAUSED { get; } = new JobStatus("USER_PAUSED");

        public static bool operator ==(JobStatus left, JobStatus right) => left.Equals(right);
        public static bool operator !=(JobStatus left, JobStatus right) => !left.Equals(right);

        public static explicit operator string(JobStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobStatus other && Equals(other);
        public bool Equals(JobStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        private JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JobType enum ONE_TIME
        /// </summary>
        public static JobType ONE_TIME { get; } = new JobType("ONE_TIME");
        /// <summary>
        /// JobType enum SCHEDULED
        /// </summary>
        public static JobType SCHEDULED { get; } = new JobType("SCHEDULED");

        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);

        public static explicit operator string(JobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobType other && Equals(other);
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method by which the account joined the organization.
    /// </summary>
    [EnumType]
    public readonly struct JoinedMethod : IEquatable<JoinedMethod>
    {
        private readonly string _value;

        private JoinedMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JoinedMethod enum CREATED
        /// </summary>
        public static JoinedMethod CREATED { get; } = new JoinedMethod("CREATED");
        /// <summary>
        /// JoinedMethod enum INVITED
        /// </summary>
        public static JoinedMethod INVITED { get; } = new JoinedMethod("INVITED");

        public static bool operator ==(JoinedMethod left, JoinedMethod right) => left.Equals(right);
        public static bool operator !=(JoinedMethod left, JoinedMethod right) => !left.Equals(right);

        public static explicit operator string(JoinedMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JoinedMethod other && Equals(other);
        public bool Equals(JoinedMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct KeyAlgorithm : IEquatable<KeyAlgorithm>
    {
        private readonly string _value;

        private KeyAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeyAlgorithm enum EC_prime256v1
        /// </summary>
        public static KeyAlgorithm EC_prime256v1 { get; } = new KeyAlgorithm("EC_prime256v1");
        /// <summary>
        /// KeyAlgorithm enum EC_secp384r1
        /// </summary>
        public static KeyAlgorithm EC_secp384r1 { get; } = new KeyAlgorithm("EC_secp384r1");
        /// <summary>
        /// KeyAlgorithm enum EC_secp521r1
        /// </summary>
        public static KeyAlgorithm EC_secp521r1 { get; } = new KeyAlgorithm("EC_secp521r1");
        /// <summary>
        /// KeyAlgorithm enum RSA_1024
        /// </summary>
        public static KeyAlgorithm RSA_1024 { get; } = new KeyAlgorithm("RSA_1024");
        /// <summary>
        /// KeyAlgorithm enum RSA_2048
        /// </summary>
        public static KeyAlgorithm RSA_2048 { get; } = new KeyAlgorithm("RSA_2048");
        /// <summary>
        /// KeyAlgorithm enum RSA_3072
        /// </summary>
        public static KeyAlgorithm RSA_3072 { get; } = new KeyAlgorithm("RSA_3072");
        /// <summary>
        /// KeyAlgorithm enum RSA_4096
        /// </summary>
        public static KeyAlgorithm RSA_4096 { get; } = new KeyAlgorithm("RSA_4096");

        public static bool operator ==(KeyAlgorithm left, KeyAlgorithm right) => left.Equals(right);
        public static bool operator !=(KeyAlgorithm left, KeyAlgorithm right) => !left.Equals(right);

        public static explicit operator string(KeyAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyAlgorithm other && Equals(other);
        public bool Equals(KeyAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the key pair. Default: ``pem``
    /// </summary>
    [EnumType]
    public readonly struct KeyFormat : IEquatable<KeyFormat>
    {
        private readonly string _value;

        private KeyFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeyFormat enum pem
        /// </summary>
        public static KeyFormat Pem { get; } = new KeyFormat("pem");
        /// <summary>
        /// KeyFormat enum ppk
        /// </summary>
        public static KeyFormat Ppk { get; } = new KeyFormat("ppk");

        public static bool operator ==(KeyFormat left, KeyFormat right) => left.Equals(right);
        public static bool operator !=(KeyFormat left, KeyFormat right) => !left.Equals(right);

        public static explicit operator string(KeyFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyFormat other && Equals(other);
        public bool Equals(KeyFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of KMS key to create. The default value, ``SYMMETRIC_DEFAULT``, creates a KMS key with a 256-bit symmetric key for encryption and decryption. In China Regions, ``SYMMETRIC_DEFAULT`` creates a 128-bit symmetric key that uses SM4 encryption. You can't change the ``KeySpec`` value after the KMS key is created. For help choosing a key spec for your KMS key, see [Choosing a KMS key type](https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html) in the *Developer Guide*. The ``KeySpec`` property determines the type of key material in the KMS key and the algorithms that the KMS key supports. To further restrict the algorithms that can be used with the KMS key, use a condition key in its key policy or IAM policy. For more information, see [condition keys](https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms) in the *Developer Guide*.  If you change the value of the ``KeySpec`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.    [services that are integrated with](https://docs.aws.amazon.com/kms/features/#AWS_Service_Integration) use symmetric encryption KMS keys to protect your data. These services do not support encryption with asymmetric KMS keys. For help determining whether a KMS key is asymmetric, see [Identifying asymmetric KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html) in the *Developer Guide*.   KMS supports the following key specs for KMS keys:  +  Symmetric encryption key (default)  +   ``SYMMETRIC_DEFAULT`` (AES-256-GCM)    +  HMAC keys (symmetric)  +   ``HMAC_224``   +   ``HMAC_256``   +   ``HMAC_384``   +   ``HMAC_512``     +  Asymmetric RSA key pairs  +   ``RSA_2048``   +   ``RSA_3072``   +   ``RSA_4096``     +  Asymmetric NIST-recommended elliptic curve key pairs  +   ``ECC_NIST_P256`` (secp256r1)  +   ``ECC_NIST_P384`` (secp384r1)  +   ``ECC_NIST_P521`` (secp521r1)    +  Other asymmetric elliptic curve key pairs  +   ``ECC_SECG_P256K1`` (secp256k1), commonly used for cryptocurrencies.    +  SM2 key pairs (China Regions only)  +   ``SM2``
    /// </summary>
    [EnumType]
    public readonly struct KeySpec : IEquatable<KeySpec>
    {
        private readonly string _value;

        private KeySpec(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeySpec enum ECC_NIST_P256
        /// </summary>
        public static KeySpec ECC_NIST_P256 { get; } = new KeySpec("ECC_NIST_P256");
        /// <summary>
        /// KeySpec enum ECC_NIST_P384
        /// </summary>
        public static KeySpec ECC_NIST_P384 { get; } = new KeySpec("ECC_NIST_P384");
        /// <summary>
        /// KeySpec enum ECC_NIST_P521
        /// </summary>
        public static KeySpec ECC_NIST_P521 { get; } = new KeySpec("ECC_NIST_P521");
        /// <summary>
        /// KeySpec enum ECC_SECG_P256K1
        /// </summary>
        public static KeySpec ECC_SECG_P256K1 { get; } = new KeySpec("ECC_SECG_P256K1");
        /// <summary>
        /// KeySpec enum HMAC_224
        /// </summary>
        public static KeySpec HMAC_224 { get; } = new KeySpec("HMAC_224");
        /// <summary>
        /// KeySpec enum HMAC_256
        /// </summary>
        public static KeySpec HMAC_256 { get; } = new KeySpec("HMAC_256");
        /// <summary>
        /// KeySpec enum HMAC_384
        /// </summary>
        public static KeySpec HMAC_384 { get; } = new KeySpec("HMAC_384");
        /// <summary>
        /// KeySpec enum HMAC_512
        /// </summary>
        public static KeySpec HMAC_512 { get; } = new KeySpec("HMAC_512");
        /// <summary>
        /// KeySpec enum RSA_2048
        /// </summary>
        public static KeySpec RSA_2048 { get; } = new KeySpec("RSA_2048");
        /// <summary>
        /// KeySpec enum RSA_3072
        /// </summary>
        public static KeySpec RSA_3072 { get; } = new KeySpec("RSA_3072");
        /// <summary>
        /// KeySpec enum RSA_4096
        /// </summary>
        public static KeySpec RSA_4096 { get; } = new KeySpec("RSA_4096");
        /// <summary>
        /// KeySpec enum SM2
        /// </summary>
        public static KeySpec SM2 { get; } = new KeySpec("SM2");
        /// <summary>
        /// KeySpec enum SYMMETRIC_DEFAULT
        /// </summary>
        public static KeySpec SYMMETRIC_DEFAULT { get; } = new KeySpec("SYMMETRIC_DEFAULT");

        public static bool operator ==(KeySpec left, KeySpec right) => left.Equals(right);
        public static bool operator !=(KeySpec left, KeySpec right) => !left.Equals(right);

        public static explicit operator string(KeySpec value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeySpec other && Equals(other);
        public bool Equals(KeySpec other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``
    /// </summary>
    [EnumType]
    public readonly struct KeyType : IEquatable<KeyType>
    {
        private readonly string _value;

        private KeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeyType enum ed25519
        /// </summary>
        public static KeyType Ed25519 { get; } = new KeyType("ed25519");
        /// <summary>
        /// KeyType enum rsa
        /// </summary>
        public static KeyType Rsa { get; } = new KeyType("rsa");

        public static bool operator ==(KeyType left, KeyType right) => left.Equals(right);
        public static bool operator !=(KeyType left, KeyType right) => !left.Equals(right);

        public static explicit operator string(KeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyType other && Equals(other);
        public bool Equals(KeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) for which you can use the KMS key. The default value is ``ENCRYPT_DECRYPT``. This property is required for asymmetric KMS keys and HMAC KMS keys. You can't change the ``KeyUsage`` value after the KMS key is created.  If you change the value of the ``KeyUsage`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  Select only one valid value.  +  For symmetric encryption KMS keys, omit the property or specify ``ENCRYPT_DECRYPT``.  +  For asymmetric KMS keys with RSA key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For asymmetric KMS keys with ECC key material, specify ``SIGN_VERIFY``.  +  For asymmetric KMS keys with SM2 (China Regions only) key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For HMAC KMS keys, specify ``GENERATE_VERIFY_MAC``.
    /// </summary>
    [EnumType]
    public readonly struct KeyUsage : IEquatable<KeyUsage>
    {
        private readonly string _value;

        private KeyUsage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeyUsage enum ENCRYPT_DECRYPT
        /// </summary>
        public static KeyUsage ENCRYPT_DECRYPT { get; } = new KeyUsage("ENCRYPT_DECRYPT");
        /// <summary>
        /// KeyUsage enum GENERATE_VERIFY_MAC
        /// </summary>
        public static KeyUsage GENERATE_VERIFY_MAC { get; } = new KeyUsage("GENERATE_VERIFY_MAC");
        /// <summary>
        /// KeyUsage enum SIGN_VERIFY
        /// </summary>
        public static KeyUsage SIGN_VERIFY { get; } = new KeyUsage("SIGN_VERIFY");

        public static bool operator ==(KeyUsage left, KeyUsage right) => left.Equals(right);
        public static bool operator !=(KeyUsage left, KeyUsage right) => !left.Equals(right);

        public static explicit operator string(KeyUsage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyUsage other && Equals(other);
        public bool Equals(KeyUsage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// KeyUsageName enum
    /// </summary>
    [EnumType]
    public readonly struct KeyUsageName : IEquatable<KeyUsageName>
    {
        private readonly string _value;

        private KeyUsageName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KeyUsageName enum ANY
        /// </summary>
        public static KeyUsageName ANY { get; } = new KeyUsageName("ANY");
        /// <summary>
        /// KeyUsageName enum CERTIFICATE_SIGNING
        /// </summary>
        public static KeyUsageName CERTIFICATE_SIGNING { get; } = new KeyUsageName("CERTIFICATE_SIGNING");
        /// <summary>
        /// KeyUsageName enum CRL_SIGNING
        /// </summary>
        public static KeyUsageName CRL_SIGNING { get; } = new KeyUsageName("CRL_SIGNING");
        /// <summary>
        /// KeyUsageName enum CUSTOM
        /// </summary>
        public static KeyUsageName CUSTOM { get; } = new KeyUsageName("CUSTOM");
        /// <summary>
        /// KeyUsageName enum DATA_ENCIPHERMENT
        /// </summary>
        public static KeyUsageName DATA_ENCIPHERMENT { get; } = new KeyUsageName("DATA_ENCIPHERMENT");
        /// <summary>
        /// KeyUsageName enum DECIPHER_ONLY
        /// </summary>
        public static KeyUsageName DECIPHER_ONLY { get; } = new KeyUsageName("DECIPHER_ONLY");
        /// <summary>
        /// KeyUsageName enum DIGITAL_SIGNATURE
        /// </summary>
        public static KeyUsageName DIGITAL_SIGNATURE { get; } = new KeyUsageName("DIGITAL_SIGNATURE");
        /// <summary>
        /// KeyUsageName enum ENCIPHER_ONLY
        /// </summary>
        public static KeyUsageName ENCIPHER_ONLY { get; } = new KeyUsageName("ENCIPHER_ONLY");
        /// <summary>
        /// KeyUsageName enum KEY_AGREEMENT
        /// </summary>
        public static KeyUsageName KEY_AGREEMENT { get; } = new KeyUsageName("KEY_AGREEMENT");
        /// <summary>
        /// KeyUsageName enum KEY_ENCIPHERMENT
        /// </summary>
        public static KeyUsageName KEY_ENCIPHERMENT { get; } = new KeyUsageName("KEY_ENCIPHERMENT");
        /// <summary>
        /// KeyUsageName enum NON_REPUDIATION
        /// </summary>
        public static KeyUsageName NON_REPUDIATION { get; } = new KeyUsageName("NON_REPUDIATION");

        public static bool operator ==(KeyUsageName left, KeyUsageName right) => left.Equals(right);
        public static bool operator !=(KeyUsageName left, KeyUsageName right) => !left.Equals(right);

        public static explicit operator string(KeyUsageName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyUsageName other && Equals(other);
        public bool Equals(KeyUsageName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The precision for the time and date that the stream was created.
    /// </summary>
    [EnumType]
    public readonly struct KinesisStreamSpecificationApproximateCreationDateTimePrecision : IEquatable<KinesisStreamSpecificationApproximateCreationDateTimePrecision>
    {
        private readonly string _value;

        private KinesisStreamSpecificationApproximateCreationDateTimePrecision(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// KinesisStreamSpecificationApproximateCreationDateTimePrecision enum MICROSECOND
        /// </summary>
        public static KinesisStreamSpecificationApproximateCreationDateTimePrecision MICROSECOND { get; } = new KinesisStreamSpecificationApproximateCreationDateTimePrecision("MICROSECOND");
        /// <summary>
        /// KinesisStreamSpecificationApproximateCreationDateTimePrecision enum MILLISECOND
        /// </summary>
        public static KinesisStreamSpecificationApproximateCreationDateTimePrecision MILLISECOND { get; } = new KinesisStreamSpecificationApproximateCreationDateTimePrecision("MILLISECOND");

        public static bool operator ==(KinesisStreamSpecificationApproximateCreationDateTimePrecision left, KinesisStreamSpecificationApproximateCreationDateTimePrecision right) => left.Equals(right);
        public static bool operator !=(KinesisStreamSpecificationApproximateCreationDateTimePrecision left, KinesisStreamSpecificationApproximateCreationDateTimePrecision right) => !left.Equals(right);

        public static explicit operator string(KinesisStreamSpecificationApproximateCreationDateTimePrecision value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KinesisStreamSpecificationApproximateCreationDateTimePrecision other && Equals(other);
        public bool Equals(KinesisStreamSpecificationApproximateCreationDateTimePrecision other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct LastRunErrorStatusCode : IEquatable<LastRunErrorStatusCode>
    {
        private readonly string _value;

        private LastRunErrorStatusCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LastRunErrorStatusCode enum ERROR
        /// </summary>
        public static LastRunErrorStatusCode ERROR { get; } = new LastRunErrorStatusCode("ERROR");
        /// <summary>
        /// LastRunErrorStatusCode enum NONE
        /// </summary>
        public static LastRunErrorStatusCode NONE { get; } = new LastRunErrorStatusCode("NONE");

        public static bool operator ==(LastRunErrorStatusCode left, LastRunErrorStatusCode right) => left.Equals(right);
        public static bool operator !=(LastRunErrorStatusCode left, LastRunErrorStatusCode right) => !left.Equals(right);

        public static explicit operator string(LastRunErrorStatusCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LastRunErrorStatusCode other && Equals(other);
        public bool Equals(LastRunErrorStatusCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The launch type on which to run your service. For more information, see [Amazon ECS Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct LaunchType : IEquatable<LaunchType>
    {
        private readonly string _value;

        private LaunchType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LaunchType enum EC2
        /// </summary>
        public static LaunchType EC2 { get; } = new LaunchType("EC2");
        /// <summary>
        /// LaunchType enum EXTERNAL
        /// </summary>
        public static LaunchType EXTERNAL { get; } = new LaunchType("EXTERNAL");
        /// <summary>
        /// LaunchType enum FARGATE
        /// </summary>
        public static LaunchType FARGATE { get; } = new LaunchType("FARGATE");

        public static bool operator ==(LaunchType left, LaunchType right) => left.Equals(right);
        public static bool operator !=(LaunchType left, LaunchType right) => !left.Equals(right);

        public static explicit operator string(LaunchType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LaunchType other && Equals(other);
        public bool Equals(LaunchType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
    /// </summary>
    [EnumType]
    public readonly struct LogDestinationType : IEquatable<LogDestinationType>
    {
        private readonly string _value;

        private LogDestinationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LogDestinationType enum cloud-watch-logs
        /// </summary>
        public static LogDestinationType CloudWatchLogs { get; } = new LogDestinationType("cloud-watch-logs");
        /// <summary>
        /// LogDestinationType enum kinesis-data-firehose
        /// </summary>
        public static LogDestinationType KinesisDataFirehose { get; } = new LogDestinationType("kinesis-data-firehose");
        /// <summary>
        /// LogDestinationType enum s3
        /// </summary>
        public static LogDestinationType S3 { get; } = new LogDestinationType("s3");

        public static bool operator ==(LogDestinationType left, LogDestinationType right) => left.Equals(right);
        public static bool operator !=(LogDestinationType left, LogDestinationType right) => !left.Equals(right);

        public static explicit operator string(LogDestinationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogDestinationType other && Equals(other);
        public bool Equals(LogDestinationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the log group class for this log group. There are two classes:  +  The ``Standard`` log class supports all CWL features.  +  The ``Infrequent Access`` log class supports a subset of CWL features and incurs lower costs.   For details about the features supported by each class, see [Log classes](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html)
    /// </summary>
    [EnumType]
    public readonly struct LogGroupClass : IEquatable<LogGroupClass>
    {
        private readonly string _value;

        private LogGroupClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LogGroupClass enum INFREQUENT_ACCESS
        /// </summary>
        public static LogGroupClass INFREQUENT_ACCESS { get; } = new LogGroupClass("INFREQUENT_ACCESS");
        /// <summary>
        /// LogGroupClass enum STANDARD
        /// </summary>
        public static LogGroupClass STANDARD { get; } = new LogGroupClass("STANDARD");

        public static bool operator ==(LogGroupClass left, LogGroupClass right) => left.Equals(right);
        public static bool operator !=(LogGroupClass left, LogGroupClass right) => !left.Equals(right);

        public static explicit operator string(LogGroupClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogGroupClass other && Equals(other);
        public bool Equals(LogGroupClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// LogType enum
    /// </summary>
    [EnumType]
    public readonly struct LogType : IEquatable<LogType>
    {
        private readonly string _value;

        private LogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LogType enum api
        /// </summary>
        public static LogType Api { get; } = new LogType("api");
        /// <summary>
        /// LogType enum audit
        /// </summary>
        public static LogType Audit { get; } = new LogType("audit");
        /// <summary>
        /// LogType enum authenticator
        /// </summary>
        public static LogType Authenticator { get; } = new LogType("authenticator");
        /// <summary>
        /// LogType enum controllerManager
        /// </summary>
        public static LogType ControllerManager { get; } = new LogType("controllerManager");
        /// <summary>
        /// LogType enum scheduler
        /// </summary>
        public static LogType Scheduler { get; } = new LogType("scheduler");

        public static bool operator ==(LogType left, LogType right) => left.Equals(right);
        public static bool operator !=(LogType left, LogType right) => !left.Equals(right);

        public static explicit operator string(LogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogType other && Equals(other);
        public bool Equals(LogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigApplicationLogLevel : IEquatable<LoggingConfigApplicationLogLevel>
    {
        private readonly string _value;

        private LoggingConfigApplicationLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LoggingConfigApplicationLogLevel enum DEBUG
        /// </summary>
        public static LoggingConfigApplicationLogLevel DEBUG { get; } = new LoggingConfigApplicationLogLevel("DEBUG");
        /// <summary>
        /// LoggingConfigApplicationLogLevel enum ERROR
        /// </summary>
        public static LoggingConfigApplicationLogLevel ERROR { get; } = new LoggingConfigApplicationLogLevel("ERROR");
        /// <summary>
        /// LoggingConfigApplicationLogLevel enum FATAL
        /// </summary>
        public static LoggingConfigApplicationLogLevel FATAL { get; } = new LoggingConfigApplicationLogLevel("FATAL");
        /// <summary>
        /// LoggingConfigApplicationLogLevel enum INFO
        /// </summary>
        public static LoggingConfigApplicationLogLevel INFO { get; } = new LoggingConfigApplicationLogLevel("INFO");
        /// <summary>
        /// LoggingConfigApplicationLogLevel enum TRACE
        /// </summary>
        public static LoggingConfigApplicationLogLevel TRACE { get; } = new LoggingConfigApplicationLogLevel("TRACE");
        /// <summary>
        /// LoggingConfigApplicationLogLevel enum WARN
        /// </summary>
        public static LoggingConfigApplicationLogLevel WARN { get; } = new LoggingConfigApplicationLogLevel("WARN");

        public static bool operator ==(LoggingConfigApplicationLogLevel left, LoggingConfigApplicationLogLevel right) => left.Equals(right);
        public static bool operator !=(LoggingConfigApplicationLogLevel left, LoggingConfigApplicationLogLevel right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigApplicationLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigApplicationLogLevel other && Equals(other);
        public bool Equals(LoggingConfigApplicationLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigLogFormat : IEquatable<LoggingConfigLogFormat>
    {
        private readonly string _value;

        private LoggingConfigLogFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LoggingConfigLogFormat enum JSON
        /// </summary>
        public static LoggingConfigLogFormat JSON { get; } = new LoggingConfigLogFormat("JSON");
        /// <summary>
        /// LoggingConfigLogFormat enum Text
        /// </summary>
        public static LoggingConfigLogFormat Text { get; } = new LoggingConfigLogFormat("Text");

        public static bool operator ==(LoggingConfigLogFormat left, LoggingConfigLogFormat right) => left.Equals(right);
        public static bool operator !=(LoggingConfigLogFormat left, LoggingConfigLogFormat right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigLogFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigLogFormat other && Equals(other);
        public bool Equals(LoggingConfigLogFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property protocol
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigProtocol : IEquatable<LoggingConfigProtocol>
    {
        private readonly string _value;

        private LoggingConfigProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LoggingConfigProtocol enum application
        /// </summary>
        public static LoggingConfigProtocol Application { get; } = new LoggingConfigProtocol("application");
        /// <summary>
        /// LoggingConfigProtocol enum firehose
        /// </summary>
        public static LoggingConfigProtocol Firehose { get; } = new LoggingConfigProtocol("firehose");
        /// <summary>
        /// LoggingConfigProtocol enum http/s
        /// </summary>
        public static LoggingConfigProtocol HttpS { get; } = new LoggingConfigProtocol("http/s");
        /// <summary>
        /// LoggingConfigProtocol enum lambda
        /// </summary>
        public static LoggingConfigProtocol Lambda { get; } = new LoggingConfigProtocol("lambda");
        /// <summary>
        /// LoggingConfigProtocol enum sqs
        /// </summary>
        public static LoggingConfigProtocol Sqs { get; } = new LoggingConfigProtocol("sqs");

        public static bool operator ==(LoggingConfigProtocol left, LoggingConfigProtocol right) => left.Equals(right);
        public static bool operator !=(LoggingConfigProtocol left, LoggingConfigProtocol right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigProtocol other && Equals(other);
        public bool Equals(LoggingConfigProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigSystemLogLevel : IEquatable<LoggingConfigSystemLogLevel>
    {
        private readonly string _value;

        private LoggingConfigSystemLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LoggingConfigSystemLogLevel enum DEBUG
        /// </summary>
        public static LoggingConfigSystemLogLevel DEBUG { get; } = new LoggingConfigSystemLogLevel("DEBUG");
        /// <summary>
        /// LoggingConfigSystemLogLevel enum INFO
        /// </summary>
        public static LoggingConfigSystemLogLevel INFO { get; } = new LoggingConfigSystemLogLevel("INFO");
        /// <summary>
        /// LoggingConfigSystemLogLevel enum WARN
        /// </summary>
        public static LoggingConfigSystemLogLevel WARN { get; } = new LoggingConfigSystemLogLevel("WARN");

        public static bool operator ==(LoggingConfigSystemLogLevel left, LoggingConfigSystemLogLevel right) => left.Equals(right);
        public static bool operator !=(LoggingConfigSystemLogLevel left, LoggingConfigSystemLogLevel right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigSystemLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigSystemLogLevel other && Equals(other);
        public bool Equals(LoggingConfigSystemLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct LogsConfigStatusType : IEquatable<LogsConfigStatusType>
    {
        private readonly string _value;

        private LogsConfigStatusType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// LogsConfigStatusType enum DISABLED
        /// </summary>
        public static LogsConfigStatusType DISABLED { get; } = new LogsConfigStatusType("DISABLED");
        /// <summary>
        /// LogsConfigStatusType enum ENABLED
        /// </summary>
        public static LogsConfigStatusType ENABLED { get; } = new LogsConfigStatusType("ENABLED");

        public static bool operator ==(LogsConfigStatusType left, LogsConfigStatusType right) => left.Equals(right);
        public static bool operator !=(LogsConfigStatusType left, LogsConfigStatusType right) => !left.Equals(right);

        public static explicit operator string(LogsConfigStatusType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogsConfigStatusType other && Equals(other);
        public bool Equals(LogsConfigStatusType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct MaximumExecutionFrequency : IEquatable<MaximumExecutionFrequency>
    {
        private readonly string _value;

        private MaximumExecutionFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MaximumExecutionFrequency enum One_Hour
        /// </summary>
        public static MaximumExecutionFrequency One_Hour { get; } = new MaximumExecutionFrequency("One_Hour");
        /// <summary>
        /// MaximumExecutionFrequency enum Six_Hours
        /// </summary>
        public static MaximumExecutionFrequency Six_Hours { get; } = new MaximumExecutionFrequency("Six_Hours");
        /// <summary>
        /// MaximumExecutionFrequency enum Three_Hours
        /// </summary>
        public static MaximumExecutionFrequency Three_Hours { get; } = new MaximumExecutionFrequency("Three_Hours");
        /// <summary>
        /// MaximumExecutionFrequency enum Twelve_Hours
        /// </summary>
        public static MaximumExecutionFrequency Twelve_Hours { get; } = new MaximumExecutionFrequency("Twelve_Hours");
        /// <summary>
        /// MaximumExecutionFrequency enum TwentyFour_Hours
        /// </summary>
        public static MaximumExecutionFrequency TwentyFour_Hours { get; } = new MaximumExecutionFrequency("TwentyFour_Hours");

        public static bool operator ==(MaximumExecutionFrequency left, MaximumExecutionFrequency right) => left.Equals(right);
        public static bool operator !=(MaximumExecutionFrequency left, MaximumExecutionFrequency right) => !left.Equals(right);

        public static explicit operator string(MaximumExecutionFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaximumExecutionFrequency other && Equals(other);
        public bool Equals(MaximumExecutionFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit to assign to the metric. If you omit this, the unit is set as ``None``.
    /// </summary>
    [EnumType]
    public readonly struct MetricTransformationUnit : IEquatable<MetricTransformationUnit>
    {
        private readonly string _value;

        private MetricTransformationUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MetricTransformationUnit enum Bits
        /// </summary>
        public static MetricTransformationUnit Bits { get; } = new MetricTransformationUnit("Bits");
        /// <summary>
        /// MetricTransformationUnit enum Bits/Second
        /// </summary>
        public static MetricTransformationUnit BitsSecond { get; } = new MetricTransformationUnit("Bits/Second");
        /// <summary>
        /// MetricTransformationUnit enum Bytes
        /// </summary>
        public static MetricTransformationUnit Bytes { get; } = new MetricTransformationUnit("Bytes");
        /// <summary>
        /// MetricTransformationUnit enum Bytes/Second
        /// </summary>
        public static MetricTransformationUnit BytesSecond { get; } = new MetricTransformationUnit("Bytes/Second");
        /// <summary>
        /// MetricTransformationUnit enum Count
        /// </summary>
        public static MetricTransformationUnit Count { get; } = new MetricTransformationUnit("Count");
        /// <summary>
        /// MetricTransformationUnit enum Count/Second
        /// </summary>
        public static MetricTransformationUnit CountSecond { get; } = new MetricTransformationUnit("Count/Second");
        /// <summary>
        /// MetricTransformationUnit enum Gigabits
        /// </summary>
        public static MetricTransformationUnit Gigabits { get; } = new MetricTransformationUnit("Gigabits");
        /// <summary>
        /// MetricTransformationUnit enum Gigabits/Second
        /// </summary>
        public static MetricTransformationUnit GigabitsSecond { get; } = new MetricTransformationUnit("Gigabits/Second");
        /// <summary>
        /// MetricTransformationUnit enum Gigabytes
        /// </summary>
        public static MetricTransformationUnit Gigabytes { get; } = new MetricTransformationUnit("Gigabytes");
        /// <summary>
        /// MetricTransformationUnit enum Gigabytes/Second
        /// </summary>
        public static MetricTransformationUnit GigabytesSecond { get; } = new MetricTransformationUnit("Gigabytes/Second");
        /// <summary>
        /// MetricTransformationUnit enum Kilobits
        /// </summary>
        public static MetricTransformationUnit Kilobits { get; } = new MetricTransformationUnit("Kilobits");
        /// <summary>
        /// MetricTransformationUnit enum Kilobits/Second
        /// </summary>
        public static MetricTransformationUnit KilobitsSecond { get; } = new MetricTransformationUnit("Kilobits/Second");
        /// <summary>
        /// MetricTransformationUnit enum Kilobytes
        /// </summary>
        public static MetricTransformationUnit Kilobytes { get; } = new MetricTransformationUnit("Kilobytes");
        /// <summary>
        /// MetricTransformationUnit enum Kilobytes/Second
        /// </summary>
        public static MetricTransformationUnit KilobytesSecond { get; } = new MetricTransformationUnit("Kilobytes/Second");
        /// <summary>
        /// MetricTransformationUnit enum Megabits
        /// </summary>
        public static MetricTransformationUnit Megabits { get; } = new MetricTransformationUnit("Megabits");
        /// <summary>
        /// MetricTransformationUnit enum Megabits/Second
        /// </summary>
        public static MetricTransformationUnit MegabitsSecond { get; } = new MetricTransformationUnit("Megabits/Second");
        /// <summary>
        /// MetricTransformationUnit enum Megabytes
        /// </summary>
        public static MetricTransformationUnit Megabytes { get; } = new MetricTransformationUnit("Megabytes");
        /// <summary>
        /// MetricTransformationUnit enum Megabytes/Second
        /// </summary>
        public static MetricTransformationUnit MegabytesSecond { get; } = new MetricTransformationUnit("Megabytes/Second");
        /// <summary>
        /// MetricTransformationUnit enum Microseconds
        /// </summary>
        public static MetricTransformationUnit Microseconds { get; } = new MetricTransformationUnit("Microseconds");
        /// <summary>
        /// MetricTransformationUnit enum Milliseconds
        /// </summary>
        public static MetricTransformationUnit Milliseconds { get; } = new MetricTransformationUnit("Milliseconds");
        /// <summary>
        /// MetricTransformationUnit enum None
        /// </summary>
        public static MetricTransformationUnit None { get; } = new MetricTransformationUnit("None");
        /// <summary>
        /// MetricTransformationUnit enum Percent
        /// </summary>
        public static MetricTransformationUnit Percent { get; } = new MetricTransformationUnit("Percent");
        /// <summary>
        /// MetricTransformationUnit enum Seconds
        /// </summary>
        public static MetricTransformationUnit Seconds { get; } = new MetricTransformationUnit("Seconds");
        /// <summary>
        /// MetricTransformationUnit enum Terabits
        /// </summary>
        public static MetricTransformationUnit Terabits { get; } = new MetricTransformationUnit("Terabits");
        /// <summary>
        /// MetricTransformationUnit enum Terabits/Second
        /// </summary>
        public static MetricTransformationUnit TerabitsSecond { get; } = new MetricTransformationUnit("Terabits/Second");
        /// <summary>
        /// MetricTransformationUnit enum Terabytes
        /// </summary>
        public static MetricTransformationUnit Terabytes { get; } = new MetricTransformationUnit("Terabytes");
        /// <summary>
        /// MetricTransformationUnit enum Terabytes/Second
        /// </summary>
        public static MetricTransformationUnit TerabytesSecond { get; } = new MetricTransformationUnit("Terabytes/Second");

        public static bool operator ==(MetricTransformationUnit left, MetricTransformationUnit right) => left.Equals(right);
        public static bool operator !=(MetricTransformationUnit left, MetricTransformationUnit right) => !left.Equals(right);

        public static explicit operator string(MetricTransformationUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricTransformationUnit other && Equals(other);
        public bool Equals(MetricTransformationUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the replication metrics are enabled.
    /// </summary>
    [EnumType]
    public readonly struct MetricsStatus : IEquatable<MetricsStatus>
    {
        private readonly string _value;

        private MetricsStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MetricsStatus enum Disabled
        /// </summary>
        public static MetricsStatus Disabled { get; } = new MetricsStatus("Disabled");
        /// <summary>
        /// MetricsStatus enum Enabled
        /// </summary>
        public static MetricsStatus Enabled { get; } = new MetricsStatus("Enabled");

        public static bool operator ==(MetricsStatus left, MetricsStatus right) => left.Equals(right);
        public static bool operator !=(MetricsStatus left, MetricsStatus right) => !left.Equals(right);

        public static explicit operator string(MetricsStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricsStatus other && Equals(other);
        public bool Equals(MetricsStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct MitigationInEffectEnum : IEquatable<MitigationInEffectEnum>
    {
        private readonly string _value;

        private MitigationInEffectEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MitigationInEffectEnum enum no
        /// </summary>
        public static MitigationInEffectEnum No { get; } = new MitigationInEffectEnum("no");
        /// <summary>
        /// MitigationInEffectEnum enum yes
        /// </summary>
        public static MitigationInEffectEnum Yes { get; } = new MitigationInEffectEnum("yes");

        public static bool operator ==(MitigationInEffectEnum left, MitigationInEffectEnum right) => left.Equals(right);
        public static bool operator !=(MitigationInEffectEnum left, MitigationInEffectEnum right) => !left.Equals(right);

        public static explicit operator string(MitigationInEffectEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MitigationInEffectEnum other && Equals(other);
        public bool Equals(MitigationInEffectEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct MonitoringState : IEquatable<MonitoringState>
    {
        private readonly string _value;

        private MonitoringState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// MonitoringState enum disabled
        /// </summary>
        public static MonitoringState Disabled { get; } = new MonitoringState("disabled");
        /// <summary>
        /// MonitoringState enum disabling
        /// </summary>
        public static MonitoringState Disabling { get; } = new MonitoringState("disabling");
        /// <summary>
        /// MonitoringState enum enabled
        /// </summary>
        public static MonitoringState Enabled { get; } = new MonitoringState("enabled");
        /// <summary>
        /// MonitoringState enum pending
        /// </summary>
        public static MonitoringState Pending { get; } = new MonitoringState("pending");

        public static bool operator ==(MonitoringState left, MonitoringState right) => left.Equals(right);
        public static bool operator !=(MonitoringState left, MonitoringState right) => !left.Equals(right);

        public static explicit operator string(MonitoringState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringState other && Equals(other);
        public bool Equals(MonitoringState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceStatus : IEquatable<NetworkInterfaceStatus>
    {
        private readonly string _value;

        private NetworkInterfaceStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NetworkInterfaceStatus enum associated
        /// </summary>
        public static NetworkInterfaceStatus Associated { get; } = new NetworkInterfaceStatus("associated");
        /// <summary>
        /// NetworkInterfaceStatus enum attaching
        /// </summary>
        public static NetworkInterfaceStatus Attaching { get; } = new NetworkInterfaceStatus("attaching");
        /// <summary>
        /// NetworkInterfaceStatus enum available
        /// </summary>
        public static NetworkInterfaceStatus Available { get; } = new NetworkInterfaceStatus("available");
        /// <summary>
        /// NetworkInterfaceStatus enum detaching
        /// </summary>
        public static NetworkInterfaceStatus Detaching { get; } = new NetworkInterfaceStatus("detaching");
        /// <summary>
        /// NetworkInterfaceStatus enum in-use
        /// </summary>
        public static NetworkInterfaceStatus InUse { get; } = new NetworkInterfaceStatus("in-use");

        public static bool operator ==(NetworkInterfaceStatus left, NetworkInterfaceStatus right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceStatus left, NetworkInterfaceStatus right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceStatus other && Equals(other);
        public bool Equals(NetworkInterfaceStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether this Access Point allows access from the public Internet. If VpcConfiguration is specified for this Access Point, then NetworkOrigin is VPC, and the Access Point doesn't allow access from the public Internet. Otherwise, NetworkOrigin is Internet, and the Access Point allows access from the public Internet, subject to the Access Point and bucket access policies.
    /// </summary>
    [EnumType]
    public readonly struct NetworkOrigin : IEquatable<NetworkOrigin>
    {
        private readonly string _value;

        private NetworkOrigin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NetworkOrigin enum Internet
        /// </summary>
        public static NetworkOrigin Internet { get; } = new NetworkOrigin("Internet");
        /// <summary>
        /// NetworkOrigin enum VPC
        /// </summary>
        public static NetworkOrigin VPC { get; } = new NetworkOrigin("VPC");

        public static bool operator ==(NetworkOrigin left, NetworkOrigin right) => left.Equals(right);
        public static bool operator !=(NetworkOrigin left, NetworkOrigin right) => !left.Equals(right);

        public static explicit operator string(NetworkOrigin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkOrigin other && Equals(other);
        public bool Equals(NetworkOrigin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The class of storage used to store the object.
    /// </summary>
    [EnumType]
    public readonly struct NoncurrentVersionTransitionStorageClass : IEquatable<NoncurrentVersionTransitionStorageClass>
    {
        private readonly string _value;

        private NoncurrentVersionTransitionStorageClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum DEEP_ARCHIVE
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass DEEP_ARCHIVE { get; } = new NoncurrentVersionTransitionStorageClass("DEEP_ARCHIVE");
        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum GLACIER
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass GLACIER { get; } = new NoncurrentVersionTransitionStorageClass("GLACIER");
        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum GLACIER_IR
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass GLACIER_IR { get; } = new NoncurrentVersionTransitionStorageClass("GLACIER_IR");
        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum INTELLIGENT_TIERING
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass INTELLIGENT_TIERING { get; } = new NoncurrentVersionTransitionStorageClass("INTELLIGENT_TIERING");
        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum ONEZONE_IA
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass ONEZONE_IA { get; } = new NoncurrentVersionTransitionStorageClass("ONEZONE_IA");
        /// <summary>
        /// NoncurrentVersionTransitionStorageClass enum STANDARD_IA
        /// </summary>
        public static NoncurrentVersionTransitionStorageClass STANDARD_IA { get; } = new NoncurrentVersionTransitionStorageClass("STANDARD_IA");

        public static bool operator ==(NoncurrentVersionTransitionStorageClass left, NoncurrentVersionTransitionStorageClass right) => left.Equals(right);
        public static bool operator !=(NoncurrentVersionTransitionStorageClass left, NoncurrentVersionTransitionStorageClass right) => !left.Equals(right);

        public static explicit operator string(NoncurrentVersionTransitionStorageClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NoncurrentVersionTransitionStorageClass other && Equals(other);
        public bool Equals(NoncurrentVersionTransitionStorageClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct NotebookInstanceStatus : IEquatable<NotebookInstanceStatus>
    {
        private readonly string _value;

        private NotebookInstanceStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NotebookInstanceStatus enum Deleting
        /// </summary>
        public static NotebookInstanceStatus Deleting { get; } = new NotebookInstanceStatus("Deleting");
        /// <summary>
        /// NotebookInstanceStatus enum Failed
        /// </summary>
        public static NotebookInstanceStatus Failed { get; } = new NotebookInstanceStatus("Failed");
        /// <summary>
        /// NotebookInstanceStatus enum InService
        /// </summary>
        public static NotebookInstanceStatus InService { get; } = new NotebookInstanceStatus("InService");
        /// <summary>
        /// NotebookInstanceStatus enum Pending
        /// </summary>
        public static NotebookInstanceStatus Pending { get; } = new NotebookInstanceStatus("Pending");
        /// <summary>
        /// NotebookInstanceStatus enum Stopped
        /// </summary>
        public static NotebookInstanceStatus Stopped { get; } = new NotebookInstanceStatus("Stopped");
        /// <summary>
        /// NotebookInstanceStatus enum Stopping
        /// </summary>
        public static NotebookInstanceStatus Stopping { get; } = new NotebookInstanceStatus("Stopping");
        /// <summary>
        /// NotebookInstanceStatus enum Updating
        /// </summary>
        public static NotebookInstanceStatus Updating { get; } = new NotebookInstanceStatus("Updating");

        public static bool operator ==(NotebookInstanceStatus left, NotebookInstanceStatus right) => left.Equals(right);
        public static bool operator !=(NotebookInstanceStatus left, NotebookInstanceStatus right) => !left.Equals(right);

        public static explicit operator string(NotebookInstanceStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NotebookInstanceStatus other && Equals(other);
        public bool Equals(NotebookInstanceStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct OpenSearchPartitionInstanceType : IEquatable<OpenSearchPartitionInstanceType>
    {
        private readonly string _value;

        private OpenSearchPartitionInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// OpenSearchPartitionInstanceType enum c4.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C42xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c4.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c4.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C44xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c4.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c4.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C48xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c4.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c4.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C4LargeSearch { get; } = new OpenSearchPartitionInstanceType("c4.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c4.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C4XlargeSearch { get; } = new OpenSearchPartitionInstanceType("c4.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.18xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C518xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.18xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C52xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C54xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.9xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C59xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.9xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C5LargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c5.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C5XlargeSearch { get; } = new OpenSearchPartitionInstanceType("c5.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6g12xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6g2xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6g4xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6g8xlargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6gLargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum c6g.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType C6gXlargeSearch { get; } = new OpenSearchPartitionInstanceType("c6g.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum d2.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType D22xlargeSearch { get; } = new OpenSearchPartitionInstanceType("d2.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum d2.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType D24xlargeSearch { get; } = new OpenSearchPartitionInstanceType("d2.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum d2.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType D28xlargeSearch { get; } = new OpenSearchPartitionInstanceType("d2.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum d2.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType D2XlargeSearch { get; } = new OpenSearchPartitionInstanceType("d2.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i2.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I22xlargeSearch { get; } = new OpenSearchPartitionInstanceType("i2.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i2.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I2XlargeSearch { get; } = new OpenSearchPartitionInstanceType("i2.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.16xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I316xlargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.16xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I32xlargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I34xlargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I38xlargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I3LargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum i3.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType I3XlargeSearch { get; } = new OpenSearchPartitionInstanceType("i3.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m3.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M32xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m3.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m3.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M3LargeSearch { get; } = new OpenSearchPartitionInstanceType("m3.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m3.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M3MediumSearch { get; } = new OpenSearchPartitionInstanceType("m3.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m3.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M3XlargeSearch { get; } = new OpenSearchPartitionInstanceType("m3.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m4.10xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M410xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m4.10xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m4.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M42xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m4.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m4.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M44xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m4.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m4.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M4LargeSearch { get; } = new OpenSearchPartitionInstanceType("m4.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m4.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M4XlargeSearch { get; } = new OpenSearchPartitionInstanceType("m4.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M512xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.24xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M524xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.24xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M52xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M54xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M5LargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m5.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M5XlargeSearch { get; } = new OpenSearchPartitionInstanceType("m5.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6g12xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6g2xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6g4xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6g8xlargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6gLargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum m6g.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType M6gXlargeSearch { get; } = new OpenSearchPartitionInstanceType("m6g.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or112xlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.16xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or116xlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.16xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or12xlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or14xlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or18xlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or1LargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or1MediumSearch { get; } = new OpenSearchPartitionInstanceType("or1.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum or1.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Or1XlargeSearch { get; } = new OpenSearchPartitionInstanceType("or1.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r3.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R32xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r3.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r3.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R34xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r3.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r3.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R38xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r3.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r3.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R3LargeSearch { get; } = new OpenSearchPartitionInstanceType("r3.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r3.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R3XlargeSearch { get; } = new OpenSearchPartitionInstanceType("r3.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.16xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R416xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.16xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R42xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R44xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R48xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R4LargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r4.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R4XlargeSearch { get; } = new OpenSearchPartitionInstanceType("r4.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R512xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.24xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R524xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.24xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R52xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R54xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R5LargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r5.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R5XlargeSearch { get; } = new OpenSearchPartitionInstanceType("r5.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6g12xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6g2xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6g4xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6g8xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gLargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6g.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gXlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6g.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.12xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gd12xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.12xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.16xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gd16xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.16xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gd2xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.4xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gd4xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.4xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.8xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gd8xlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.8xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gdLargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum r6gd.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType R6gdXlargeSearch { get; } = new OpenSearchPartitionInstanceType("r6gd.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t2.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T2MediumSearch { get; } = new OpenSearchPartitionInstanceType("t2.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t2.micro.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T2MicroSearch { get; } = new OpenSearchPartitionInstanceType("t2.micro.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t2.small.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T2SmallSearch { get; } = new OpenSearchPartitionInstanceType("t2.small.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.2xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T32xlargeSearch { get; } = new OpenSearchPartitionInstanceType("t3.2xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3LargeSearch { get; } = new OpenSearchPartitionInstanceType("t3.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3MediumSearch { get; } = new OpenSearchPartitionInstanceType("t3.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.micro.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3MicroSearch { get; } = new OpenSearchPartitionInstanceType("t3.micro.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.nano.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3NanoSearch { get; } = new OpenSearchPartitionInstanceType("t3.nano.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.small.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3SmallSearch { get; } = new OpenSearchPartitionInstanceType("t3.small.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t3.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T3XlargeSearch { get; } = new OpenSearchPartitionInstanceType("t3.xlarge.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t4g.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T4gMediumSearch { get; } = new OpenSearchPartitionInstanceType("t4g.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum t4g.small.search
        /// </summary>
        public static OpenSearchPartitionInstanceType T4gSmallSearch { get; } = new OpenSearchPartitionInstanceType("t4g.small.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum ultrawarm1.large.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Ultrawarm1LargeSearch { get; } = new OpenSearchPartitionInstanceType("ultrawarm1.large.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum ultrawarm1.medium.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Ultrawarm1MediumSearch { get; } = new OpenSearchPartitionInstanceType("ultrawarm1.medium.search");
        /// <summary>
        /// OpenSearchPartitionInstanceType enum ultrawarm1.xlarge.search
        /// </summary>
        public static OpenSearchPartitionInstanceType Ultrawarm1XlargeSearch { get; } = new OpenSearchPartitionInstanceType("ultrawarm1.xlarge.search");

        public static bool operator ==(OpenSearchPartitionInstanceType left, OpenSearchPartitionInstanceType right) => left.Equals(right);
        public static bool operator !=(OpenSearchPartitionInstanceType left, OpenSearchPartitionInstanceType right) => !left.Equals(right);

        public static explicit operator string(OpenSearchPartitionInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OpenSearchPartitionInstanceType other && Equals(other);
        public bool Equals(OpenSearchPartitionInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct OpenSearchWarmPartitionInstanceType : IEquatable<OpenSearchWarmPartitionInstanceType>
    {
        private readonly string _value;

        private OpenSearchWarmPartitionInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// OpenSearchWarmPartitionInstanceType enum ultrawarm1.large.search
        /// </summary>
        public static OpenSearchWarmPartitionInstanceType Ultrawarm1LargeSearch { get; } = new OpenSearchWarmPartitionInstanceType("ultrawarm1.large.search");
        /// <summary>
        /// OpenSearchWarmPartitionInstanceType enum ultrawarm1.medium.search
        /// </summary>
        public static OpenSearchWarmPartitionInstanceType Ultrawarm1MediumSearch { get; } = new OpenSearchWarmPartitionInstanceType("ultrawarm1.medium.search");
        /// <summary>
        /// OpenSearchWarmPartitionInstanceType enum ultrawarm1.xlarge.search
        /// </summary>
        public static OpenSearchWarmPartitionInstanceType Ultrawarm1XlargeSearch { get; } = new OpenSearchWarmPartitionInstanceType("ultrawarm1.xlarge.search");

        public static bool operator ==(OpenSearchWarmPartitionInstanceType left, OpenSearchWarmPartitionInstanceType right) => left.Equals(right);
        public static bool operator !=(OpenSearchWarmPartitionInstanceType left, OpenSearchWarmPartitionInstanceType right) => !left.Equals(right);

        public static explicit operator string(OpenSearchWarmPartitionInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OpenSearchWarmPartitionInstanceType other && Equals(other);
        public bool Equals(OpenSearchWarmPartitionInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct OperationLevelMetricsConfig : IEquatable<OperationLevelMetricsConfig>
    {
        private readonly string _value;

        private OperationLevelMetricsConfig(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// OperationLevelMetricsConfig enum DISABLED
        /// </summary>
        public static OperationLevelMetricsConfig DISABLED { get; } = new OperationLevelMetricsConfig("DISABLED");
        /// <summary>
        /// OperationLevelMetricsConfig enum ENABLED
        /// </summary>
        public static OperationLevelMetricsConfig ENABLED { get; } = new OperationLevelMetricsConfig("ENABLED");

        public static bool operator ==(OperationLevelMetricsConfig left, OperationLevelMetricsConfig right) => left.Equals(right);
        public static bool operator !=(OperationLevelMetricsConfig left, OperationLevelMetricsConfig right) => !left.Equals(right);

        public static explicit operator string(OperationLevelMetricsConfig value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationLevelMetricsConfig other && Equals(other);
        public bool Equals(OperationLevelMetricsConfig other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
    /// </summary>
    [EnumType]
    public readonly struct OperationPreferencesRegionConcurrencyType : IEquatable<OperationPreferencesRegionConcurrencyType>
    {
        private readonly string _value;

        private OperationPreferencesRegionConcurrencyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// OperationPreferencesRegionConcurrencyType enum PARALLEL
        /// </summary>
        public static OperationPreferencesRegionConcurrencyType PARALLEL { get; } = new OperationPreferencesRegionConcurrencyType("PARALLEL");
        /// <summary>
        /// OperationPreferencesRegionConcurrencyType enum SEQUENTIAL
        /// </summary>
        public static OperationPreferencesRegionConcurrencyType SEQUENTIAL { get; } = new OperationPreferencesRegionConcurrencyType("SEQUENTIAL");

        public static bool operator ==(OperationPreferencesRegionConcurrencyType left, OperationPreferencesRegionConcurrencyType right) => left.Equals(right);
        public static bool operator !=(OperationPreferencesRegionConcurrencyType left, OperationPreferencesRegionConcurrencyType right) => !left.Equals(right);

        public static explicit operator string(OperationPreferencesRegionConcurrencyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationPreferencesRegionConcurrencyType other && Equals(other);
        public bool Equals(OperationPreferencesRegionConcurrencyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source of the key material for the KMS key. You cannot change the origin after you create the KMS key. The default is ``AWS_KMS``, which means that KMS creates the key material. To [create a KMS key with no key material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-create-cmk.html) (for imported key material), set this value to ``EXTERNAL``. For more information about importing key material into KMS, see [Importing Key Material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html) in the *Developer Guide*. You can ignore ``ENABLED`` when Origin is ``EXTERNAL``. When a KMS key with Origin ``EXTERNAL`` is created, the key state is ``PENDING_IMPORT`` and ``ENABLED`` is ``false``. After you import the key material, ``ENABLED`` updated to ``true``. The KMS key can then be used for Cryptographic Operations.    CFN doesn't support creating an ``Origin`` parameter of the ``AWS_CLOUDHSM`` or ``EXTERNAL_KEY_STORE`` values.
    /// </summary>
    [EnumType]
    public readonly struct Origin : IEquatable<Origin>
    {
        private readonly string _value;

        private Origin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Origin enum AWS_KMS
        /// </summary>
        public static Origin AWS_KMS { get; } = new Origin("AWS_KMS");
        /// <summary>
        /// Origin enum EXTERNAL
        /// </summary>
        public static Origin EXTERNAL { get; } = new Origin("EXTERNAL");

        public static bool operator ==(Origin left, Origin right) => left.Equals(right);
        public static bool operator !=(Origin left, Origin right) => !left.Equals(right);

        public static explicit operator string(Origin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Origin other && Equals(other);
        public bool Equals(Origin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies an object ownership rule.
    /// </summary>
    [EnumType]
    public readonly struct OwnershipControlsRuleObjectOwnership : IEquatable<OwnershipControlsRuleObjectOwnership>
    {
        private readonly string _value;

        private OwnershipControlsRuleObjectOwnership(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// OwnershipControlsRuleObjectOwnership enum BucketOwnerEnforced
        /// </summary>
        public static OwnershipControlsRuleObjectOwnership BucketOwnerEnforced { get; } = new OwnershipControlsRuleObjectOwnership("BucketOwnerEnforced");
        /// <summary>
        /// OwnershipControlsRuleObjectOwnership enum BucketOwnerPreferred
        /// </summary>
        public static OwnershipControlsRuleObjectOwnership BucketOwnerPreferred { get; } = new OwnershipControlsRuleObjectOwnership("BucketOwnerPreferred");
        /// <summary>
        /// OwnershipControlsRuleObjectOwnership enum ObjectWriter
        /// </summary>
        public static OwnershipControlsRuleObjectOwnership ObjectWriter { get; } = new OwnershipControlsRuleObjectOwnership("ObjectWriter");

        public static bool operator ==(OwnershipControlsRuleObjectOwnership left, OwnershipControlsRuleObjectOwnership right) => left.Equals(right);
        public static bool operator !=(OwnershipControlsRuleObjectOwnership left, OwnershipControlsRuleObjectOwnership right) => !left.Equals(right);

        public static explicit operator string(OwnershipControlsRuleObjectOwnership value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OwnershipControlsRuleObjectOwnership other && Equals(other);
        public bool Equals(OwnershipControlsRuleObjectOwnership other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
    /// </summary>
    [EnumType]
    public readonly struct PackageType : IEquatable<PackageType>
    {
        private readonly string _value;

        private PackageType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PackageType enum Image
        /// </summary>
        public static PackageType Image { get; } = new PackageType("Image");
        /// <summary>
        /// PackageType enum Zip
        /// </summary>
        public static PackageType Zip { get; } = new PackageType("Zip");

        public static bool operator ==(PackageType left, PackageType right) => left.Equals(right);
        public static bool operator !=(PackageType left, PackageType right) => !left.Equals(right);

        public static explicit operator string(PackageType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageType other && Equals(other);
        public bool Equals(PackageType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the partition date source for the partitioned prefix. PartitionDateSource can be EventTime or DeliveryTime.
    /// </summary>
    [EnumType]
    public readonly struct PartitionedPrefixPartitionDateSource : IEquatable<PartitionedPrefixPartitionDateSource>
    {
        private readonly string _value;

        private PartitionedPrefixPartitionDateSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PartitionedPrefixPartitionDateSource enum DeliveryTime
        /// </summary>
        public static PartitionedPrefixPartitionDateSource DeliveryTime { get; } = new PartitionedPrefixPartitionDateSource("DeliveryTime");
        /// <summary>
        /// PartitionedPrefixPartitionDateSource enum EventTime
        /// </summary>
        public static PartitionedPrefixPartitionDateSource EventTime { get; } = new PartitionedPrefixPartitionDateSource("EventTime");

        public static bool operator ==(PartitionedPrefixPartitionDateSource left, PartitionedPrefixPartitionDateSource right) => left.Equals(right);
        public static bool operator !=(PartitionedPrefixPartitionDateSource left, PartitionedPrefixPartitionDateSource right) => !left.Equals(right);

        public static explicit operator string(PartitionedPrefixPartitionDateSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PartitionedPrefixPartitionDateSource other && Equals(other);
        public bool Equals(PartitionedPrefixPartitionDateSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct Permission : IEquatable<Permission>
    {
        private readonly string _value;

        private Permission(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Permission enum FULL_CONTROL
        /// </summary>
        public static Permission FULL_CONTROL { get; } = new Permission("FULL_CONTROL");
        /// <summary>
        /// Permission enum READ
        /// </summary>
        public static Permission READ { get; } = new Permission("READ");
        /// <summary>
        /// Permission enum READ_ACP
        /// </summary>
        public static Permission READ_ACP { get; } = new Permission("READ_ACP");
        /// <summary>
        /// Permission enum WRITE
        /// </summary>
        public static Permission WRITE { get; } = new Permission("WRITE");
        /// <summary>
        /// Permission enum WRITE_ACP
        /// </summary>
        public static Permission WRITE_ACP { get; } = new Permission("WRITE_ACP");

        public static bool operator ==(Permission left, Permission right) => left.Equals(right);
        public static bool operator !=(Permission left, Permission right) => !left.Equals(right);

        public static explicit operator string(Permission value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Permission other && Equals(other);
        public bool Equals(Permission other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
    /// </summary>
    [EnumType]
    public readonly struct PermissionModel : IEquatable<PermissionModel>
    {
        private readonly string _value;

        private PermissionModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PermissionModel enum SELF_MANAGED
        /// </summary>
        public static PermissionModel SELF_MANAGED { get; } = new PermissionModel("SELF_MANAGED");
        /// <summary>
        /// PermissionModel enum SERVICE_MANAGED
        /// </summary>
        public static PermissionModel SERVICE_MANAGED { get; } = new PermissionModel("SERVICE_MANAGED");

        public static bool operator ==(PermissionModel left, PermissionModel right) => left.Equals(right);
        public static bool operator !=(PermissionModel left, PermissionModel right) => !left.Equals(right);

        public static explicit operator string(PermissionModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PermissionModel other && Equals(other);
        public bool Equals(PermissionModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PingStatus : IEquatable<PingStatus>
    {
        private readonly string _value;

        private PingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PingStatus enum ConnectionLost
        /// </summary>
        public static PingStatus ConnectionLost { get; } = new PingStatus("ConnectionLost");
        /// <summary>
        /// PingStatus enum Inactive
        /// </summary>
        public static PingStatus Inactive { get; } = new PingStatus("Inactive");
        /// <summary>
        /// PingStatus enum Online
        /// </summary>
        public static PingStatus Online { get; } = new PingStatus("Online");

        public static bool operator ==(PingStatus left, PingStatus right) => left.Equals(right);
        public static bool operator !=(PingStatus left, PingStatus right) => !left.Equals(right);

        public static explicit operator string(PingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PingStatus other && Equals(other);
        public bool Equals(PingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.
    /// </summary>
    [EnumType]
    public readonly struct PlacementConstraintType : IEquatable<PlacementConstraintType>
    {
        private readonly string _value;

        private PlacementConstraintType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PlacementConstraintType enum distinctInstance
        /// </summary>
        public static PlacementConstraintType DistinctInstance { get; } = new PlacementConstraintType("distinctInstance");
        /// <summary>
        /// PlacementConstraintType enum memberOf
        /// </summary>
        public static PlacementConstraintType MemberOf { get; } = new PlacementConstraintType("memberOf");

        public static bool operator ==(PlacementConstraintType left, PlacementConstraintType right) => left.Equals(right);
        public static bool operator !=(PlacementConstraintType left, PlacementConstraintType right) => !left.Equals(right);

        public static explicit operator string(PlacementConstraintType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlacementConstraintType other && Equals(other);
        public bool Equals(PlacementConstraintType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PlacementGroupStrategy : IEquatable<PlacementGroupStrategy>
    {
        private readonly string _value;

        private PlacementGroupStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PlacementGroupStrategy enum CLUSTER
        /// </summary>
        public static PlacementGroupStrategy CLUSTER { get; } = new PlacementGroupStrategy("CLUSTER");
        /// <summary>
        /// PlacementGroupStrategy enum NONE
        /// </summary>
        public static PlacementGroupStrategy NONE { get; } = new PlacementGroupStrategy("NONE");
        /// <summary>
        /// PlacementGroupStrategy enum PARTITION
        /// </summary>
        public static PlacementGroupStrategy PARTITION { get; } = new PlacementGroupStrategy("PARTITION");
        /// <summary>
        /// PlacementGroupStrategy enum SPREAD
        /// </summary>
        public static PlacementGroupStrategy SPREAD { get; } = new PlacementGroupStrategy("SPREAD");

        public static bool operator ==(PlacementGroupStrategy left, PlacementGroupStrategy right) => left.Equals(right);
        public static bool operator !=(PlacementGroupStrategy left, PlacementGroupStrategy right) => !left.Equals(right);

        public static explicit operator string(PlacementGroupStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlacementGroupStrategy other && Equals(other);
        public bool Equals(PlacementGroupStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of placement strategy. The ``random`` placement strategy randomly places tasks on available candidates. The ``spread`` placement strategy spreads placement across available candidates evenly based on the ``field`` parameter. The ``binpack`` strategy places tasks on available candidates that have the least available amount of the resource that's specified with the ``field`` parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory but still enough to run the task.
    /// </summary>
    [EnumType]
    public readonly struct PlacementStrategyType : IEquatable<PlacementStrategyType>
    {
        private readonly string _value;

        private PlacementStrategyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PlacementStrategyType enum binpack
        /// </summary>
        public static PlacementStrategyType Binpack { get; } = new PlacementStrategyType("binpack");
        /// <summary>
        /// PlacementStrategyType enum random
        /// </summary>
        public static PlacementStrategyType Random { get; } = new PlacementStrategyType("random");
        /// <summary>
        /// PlacementStrategyType enum spread
        /// </summary>
        public static PlacementStrategyType Spread { get; } = new PlacementStrategyType("spread");

        public static bool operator ==(PlacementStrategyType left, PlacementStrategyType right) => left.Equals(right);
        public static bool operator !=(PlacementStrategyType left, PlacementStrategyType right) => !left.Equals(right);

        public static explicit operator string(PlacementStrategyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlacementStrategyType other && Equals(other);
        public bool Equals(PlacementStrategyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PlatformType : IEquatable<PlatformType>
    {
        private readonly string _value;

        private PlatformType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PlatformType enum Linux
        /// </summary>
        public static PlatformType Linux { get; } = new PlatformType("Linux");
        /// <summary>
        /// PlatformType enum MacOS
        /// </summary>
        public static PlatformType MacOS { get; } = new PlatformType("MacOS");
        /// <summary>
        /// PlatformType enum Windows
        /// </summary>
        public static PlatformType Windows { get; } = new PlatformType("Windows");

        public static bool operator ==(PlatformType left, PlatformType right) => left.Equals(right);
        public static bool operator !=(PlatformType left, PlatformType right) => !left.Equals(right);

        public static explicit operator string(PlatformType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlatformType other && Equals(other);
        public bool Equals(PlatformType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PlatformValues : IEquatable<PlatformValues>
    {
        private readonly string _value;

        private PlatformValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PlatformValues enum Windows
        /// </summary>
        public static PlatformValues Windows { get; } = new PlatformValues("Windows");

        public static bool operator ==(PlatformValues left, PlatformValues right) => left.Equals(right);
        public static bool operator !=(PlatformValues left, PlatformValues right) => !left.Equals(right);

        public static explicit operator string(PlatformValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlatformValues other && Equals(other);
        public bool Equals(PlatformValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PointInTimeRecoveryStatus : IEquatable<PointInTimeRecoveryStatus>
    {
        private readonly string _value;

        private PointInTimeRecoveryStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PointInTimeRecoveryStatus enum DISABLED
        /// </summary>
        public static PointInTimeRecoveryStatus DISABLED { get; } = new PointInTimeRecoveryStatus("DISABLED");
        /// <summary>
        /// PointInTimeRecoveryStatus enum ENABLED
        /// </summary>
        public static PointInTimeRecoveryStatus ENABLED { get; } = new PointInTimeRecoveryStatus("ENABLED");

        public static bool operator ==(PointInTimeRecoveryStatus left, PointInTimeRecoveryStatus right) => left.Equals(right);
        public static bool operator !=(PointInTimeRecoveryStatus left, PointInTimeRecoveryStatus right) => !left.Equals(right);

        public static explicit operator string(PointInTimeRecoveryStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PointInTimeRecoveryStatus other && Equals(other);
        public bool Equals(PointInTimeRecoveryStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The application protocol that's used for the port mapping. This parameter only applies to Service Connect. We recommend that you set this parameter to be consistent with the protocol that your application uses. If you set this parameter, Amazon ECS adds protocol-specific connection handling to the Service Connect proxy. If you set this parameter, Amazon ECS adds protocol-specific telemetry in the Amazon ECS console and CloudWatch. If you don't set a value for this parameter, then TCP is used. However, Amazon ECS doesn't add protocol-specific telemetry for TCP.  ``appProtocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct PortMappingAppProtocol : IEquatable<PortMappingAppProtocol>
    {
        private readonly string _value;

        private PortMappingAppProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PortMappingAppProtocol enum grpc
        /// </summary>
        public static PortMappingAppProtocol Grpc { get; } = new PortMappingAppProtocol("grpc");
        /// <summary>
        /// PortMappingAppProtocol enum http
        /// </summary>
        public static PortMappingAppProtocol Http { get; } = new PortMappingAppProtocol("http");
        /// <summary>
        /// PortMappingAppProtocol enum http2
        /// </summary>
        public static PortMappingAppProtocol Http2 { get; } = new PortMappingAppProtocol("http2");

        public static bool operator ==(PortMappingAppProtocol left, PortMappingAppProtocol right) => left.Equals(right);
        public static bool operator !=(PortMappingAppProtocol left, PortMappingAppProtocol right) => !left.Equals(right);

        public static explicit operator string(PortMappingAppProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PortMappingAppProtocol other && Equals(other);
        public bool Equals(PortMappingAppProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the processor feature. Valid names are ``coreCount`` and ``threadsPerCore``.
    /// </summary>
    [EnumType]
    public readonly struct ProcessorFeatureName : IEquatable<ProcessorFeatureName>
    {
        private readonly string _value;

        private ProcessorFeatureName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ProcessorFeatureName enum coreCount
        /// </summary>
        public static ProcessorFeatureName CoreCount { get; } = new ProcessorFeatureName("coreCount");
        /// <summary>
        /// ProcessorFeatureName enum threadsPerCore
        /// </summary>
        public static ProcessorFeatureName ThreadsPerCore { get; } = new ProcessorFeatureName("threadsPerCore");

        public static bool operator ==(ProcessorFeatureName left, ProcessorFeatureName right) => left.Equals(right);
        public static bool operator !=(ProcessorFeatureName left, ProcessorFeatureName right) => !left.Equals(right);

        public static explicit operator string(ProcessorFeatureName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProcessorFeatureName other && Equals(other);
        public bool Equals(ProcessorFeatureName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ProductCodeValues : IEquatable<ProductCodeValues>
    {
        private readonly string _value;

        private ProductCodeValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ProductCodeValues enum devpay
        /// </summary>
        public static ProductCodeValues Devpay { get; } = new ProductCodeValues("devpay");
        /// <summary>
        /// ProductCodeValues enum marketplace
        /// </summary>
        public static ProductCodeValues Marketplace { get; } = new ProductCodeValues("marketplace");

        public static bool operator ==(ProductCodeValues left, ProductCodeValues right) => left.Equals(right);
        public static bool operator !=(ProductCodeValues left, ProductCodeValues right) => !left.Equals(right);

        public static explicit operator string(ProductCodeValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProductCodeValues other && Equals(other);
        public bool Equals(ProductCodeValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ProjectVisibilityType : IEquatable<ProjectVisibilityType>
    {
        private readonly string _value;

        private ProjectVisibilityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ProjectVisibilityType enum PRIVATE
        /// </summary>
        public static ProjectVisibilityType PRIVATE { get; } = new ProjectVisibilityType("PRIVATE");
        /// <summary>
        /// ProjectVisibilityType enum PUBLIC_READ
        /// </summary>
        public static ProjectVisibilityType PUBLIC_READ { get; } = new ProjectVisibilityType("PUBLIC_READ");

        public static bool operator ==(ProjectVisibilityType left, ProjectVisibilityType right) => left.Equals(right);
        public static bool operator !=(ProjectVisibilityType left, ProjectVisibilityType right) => !left.Equals(right);

        public static explicit operator string(ProjectVisibilityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProjectVisibilityType other && Equals(other);
        public bool Equals(ProjectVisibilityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The default is ``NONE``.
    /// </summary>
    [EnumType]
    public readonly struct PropagateTags : IEquatable<PropagateTags>
    {
        private readonly string _value;

        private PropagateTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PropagateTags enum SERVICE
        /// </summary>
        public static PropagateTags SERVICE { get; } = new PropagateTags("SERVICE");
        /// <summary>
        /// PropagateTags enum TASK_DEFINITION
        /// </summary>
        public static PropagateTags TASK_DEFINITION { get; } = new PropagateTags("TASK_DEFINITION");

        public static bool operator ==(PropagateTags left, PropagateTags right) => left.Equals(right);
        public static bool operator !=(PropagateTags left, PropagateTags right) => !left.Equals(right);

        public static explicit operator string(PropagateTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PropagateTags other && Equals(other);
        public bool Equals(PropagateTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct PropertyValueType : IEquatable<PropertyValueType>
    {
        private readonly string _value;

        private PropertyValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// PropertyValueType enum PLAIN_TEXT
        /// </summary>
        public static PropertyValueType PLAIN_TEXT { get; } = new PropertyValueType("PLAIN_TEXT");
        /// <summary>
        /// PropertyValueType enum STRINGIFIED_JSON
        /// </summary>
        public static PropertyValueType STRINGIFIED_JSON { get; } = new PropertyValueType("STRINGIFIED_JSON");

        public static bool operator ==(PropertyValueType left, PropertyValueType right) => left.Equals(right);
        public static bool operator !=(PropertyValueType left, PropertyValueType right) => !left.Equals(right);

        public static explicit operator string(PropertyValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PropertyValueType other && Equals(other);
        public bool Equals(PropertyValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RRType : IEquatable<RRType>
    {
        private readonly string _value;

        private RRType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RRType enum A
        /// </summary>
        public static RRType A { get; } = new RRType("A");
        /// <summary>
        /// RRType enum AAAA
        /// </summary>
        public static RRType AAAA { get; } = new RRType("AAAA");
        /// <summary>
        /// RRType enum CAA
        /// </summary>
        public static RRType CAA { get; } = new RRType("CAA");
        /// <summary>
        /// RRType enum CNAME
        /// </summary>
        public static RRType CNAME { get; } = new RRType("CNAME");
        /// <summary>
        /// RRType enum DS
        /// </summary>
        public static RRType DS { get; } = new RRType("DS");
        /// <summary>
        /// RRType enum MX
        /// </summary>
        public static RRType MX { get; } = new RRType("MX");
        /// <summary>
        /// RRType enum NAPTR
        /// </summary>
        public static RRType NAPTR { get; } = new RRType("NAPTR");
        /// <summary>
        /// RRType enum NS
        /// </summary>
        public static RRType NS { get; } = new RRType("NS");
        /// <summary>
        /// RRType enum PTR
        /// </summary>
        public static RRType PTR { get; } = new RRType("PTR");
        /// <summary>
        /// RRType enum SOA
        /// </summary>
        public static RRType SOA { get; } = new RRType("SOA");
        /// <summary>
        /// RRType enum SPF
        /// </summary>
        public static RRType SPF { get; } = new RRType("SPF");
        /// <summary>
        /// RRType enum SRV
        /// </summary>
        public static RRType SRV { get; } = new RRType("SRV");
        /// <summary>
        /// RRType enum TXT
        /// </summary>
        public static RRType TXT { get; } = new RRType("TXT");

        public static bool operator ==(RRType left, RRType right) => left.Equals(right);
        public static bool operator !=(RRType left, RRType right) => !left.Equals(right);

        public static explicit operator string(RRType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RRType other && Equals(other);
        public bool Equals(RRType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RecorderStatus : IEquatable<RecorderStatus>
    {
        private readonly string _value;

        private RecorderStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RecorderStatus enum Failure
        /// </summary>
        public static RecorderStatus Failure { get; } = new RecorderStatus("Failure");
        /// <summary>
        /// RecorderStatus enum Pending
        /// </summary>
        public static RecorderStatus Pending { get; } = new RecorderStatus("Pending");
        /// <summary>
        /// RecorderStatus enum Success
        /// </summary>
        public static RecorderStatus Success { get; } = new RecorderStatus("Success");

        public static bool operator ==(RecorderStatus left, RecorderStatus right) => left.Equals(right);
        public static bool operator !=(RecorderStatus left, RecorderStatus right) => !left.Equals(right);

        public static explicit operator string(RecorderStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecorderStatus other && Equals(other);
        public bool Equals(RecorderStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RecordingFrequency : IEquatable<RecordingFrequency>
    {
        private readonly string _value;

        private RecordingFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RecordingFrequency enum CONTINUOUS
        /// </summary>
        public static RecordingFrequency CONTINUOUS { get; } = new RecordingFrequency("CONTINUOUS");
        /// <summary>
        /// RecordingFrequency enum DAILY
        /// </summary>
        public static RecordingFrequency DAILY { get; } = new RecordingFrequency("DAILY");

        public static bool operator ==(RecordingFrequency left, RecordingFrequency right) => left.Equals(right);
        public static bool operator !=(RecordingFrequency left, RecordingFrequency right) => !left.Equals(right);

        public static explicit operator string(RecordingFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingFrequency other && Equals(other);
        public bool Equals(RecordingFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RecordingStrategyType : IEquatable<RecordingStrategyType>
    {
        private readonly string _value;

        private RecordingStrategyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RecordingStrategyType enum ALL_SUPPORTED_RESOURCE_TYPES
        /// </summary>
        public static RecordingStrategyType ALL_SUPPORTED_RESOURCE_TYPES { get; } = new RecordingStrategyType("ALL_SUPPORTED_RESOURCE_TYPES");
        /// <summary>
        /// RecordingStrategyType enum EXCLUSION_BY_RESOURCE_TYPES
        /// </summary>
        public static RecordingStrategyType EXCLUSION_BY_RESOURCE_TYPES { get; } = new RecordingStrategyType("EXCLUSION_BY_RESOURCE_TYPES");
        /// <summary>
        /// RecordingStrategyType enum INCLUSION_BY_RESOURCE_TYPES
        /// </summary>
        public static RecordingStrategyType INCLUSION_BY_RESOURCE_TYPES { get; } = new RecordingStrategyType("INCLUSION_BY_RESOURCE_TYPES");

        public static bool operator ==(RecordingStrategyType left, RecordingStrategyType right) => left.Equals(right);
        public static bool operator !=(RecordingStrategyType left, RecordingStrategyType right) => !left.Equals(right);

        public static explicit operator string(RecordingStrategyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingStrategyType other && Equals(other);
        public bool Equals(RecordingStrategyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
    /// </summary>
    [EnumType]
    public readonly struct RedirectAllRequestsToProtocol : IEquatable<RedirectAllRequestsToProtocol>
    {
        private readonly string _value;

        private RedirectAllRequestsToProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RedirectAllRequestsToProtocol enum http
        /// </summary>
        public static RedirectAllRequestsToProtocol Http { get; } = new RedirectAllRequestsToProtocol("http");
        /// <summary>
        /// RedirectAllRequestsToProtocol enum https
        /// </summary>
        public static RedirectAllRequestsToProtocol Https { get; } = new RedirectAllRequestsToProtocol("https");

        public static bool operator ==(RedirectAllRequestsToProtocol left, RedirectAllRequestsToProtocol right) => left.Equals(right);
        public static bool operator !=(RedirectAllRequestsToProtocol left, RedirectAllRequestsToProtocol right) => !left.Equals(right);

        public static explicit operator string(RedirectAllRequestsToProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedirectAllRequestsToProtocol other && Equals(other);
        public bool Equals(RedirectAllRequestsToProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
    /// </summary>
    [EnumType]
    public readonly struct RedirectRuleProtocol : IEquatable<RedirectRuleProtocol>
    {
        private readonly string _value;

        private RedirectRuleProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RedirectRuleProtocol enum http
        /// </summary>
        public static RedirectRuleProtocol Http { get; } = new RedirectRuleProtocol("http");
        /// <summary>
        /// RedirectRuleProtocol enum https
        /// </summary>
        public static RedirectRuleProtocol Https { get; } = new RedirectRuleProtocol("https");

        public static bool operator ==(RedirectRuleProtocol left, RedirectRuleProtocol right) => left.Equals(right);
        public static bool operator !=(RedirectRuleProtocol left, RedirectRuleProtocol right) => !left.Equals(right);

        public static explicit operator string(RedirectRuleProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RedirectRuleProtocol other && Equals(other);
        public bool Equals(RedirectRuleProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RenewalEligibility : IEquatable<RenewalEligibility>
    {
        private readonly string _value;

        private RenewalEligibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RenewalEligibility enum ELIGIBLE
        /// </summary>
        public static RenewalEligibility ELIGIBLE { get; } = new RenewalEligibility("ELIGIBLE");
        /// <summary>
        /// RenewalEligibility enum INELIGIBLE
        /// </summary>
        public static RenewalEligibility INELIGIBLE { get; } = new RenewalEligibility("INELIGIBLE");

        public static bool operator ==(RenewalEligibility left, RenewalEligibility right) => left.Equals(right);
        public static bool operator !=(RenewalEligibility left, RenewalEligibility right) => !left.Equals(right);

        public static explicit operator string(RenewalEligibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RenewalEligibility other && Equals(other);
        public bool Equals(RenewalEligibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether Amazon S3 replicates modifications on replicas.  *Allowed values*: ``Enabled`` | ``Disabled``
    /// </summary>
    [EnumType]
    public readonly struct ReplicaModificationsStatus : IEquatable<ReplicaModificationsStatus>
    {
        private readonly string _value;

        private ReplicaModificationsStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ReplicaModificationsStatus enum Disabled
        /// </summary>
        public static ReplicaModificationsStatus Disabled { get; } = new ReplicaModificationsStatus("Disabled");
        /// <summary>
        /// ReplicaModificationsStatus enum Enabled
        /// </summary>
        public static ReplicaModificationsStatus Enabled { get; } = new ReplicaModificationsStatus("Enabled");

        public static bool operator ==(ReplicaModificationsStatus left, ReplicaModificationsStatus right) => left.Equals(right);
        public static bool operator !=(ReplicaModificationsStatus left, ReplicaModificationsStatus right) => !left.Equals(right);

        public static explicit operator string(ReplicaModificationsStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicaModificationsStatus other && Equals(other);
        public bool Equals(ReplicaModificationsStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica.  For valid values, see the ``StorageClass`` element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the *Amazon S3 API Reference*.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationDestinationStorageClass : IEquatable<ReplicationDestinationStorageClass>
    {
        private readonly string _value;

        private ReplicationDestinationStorageClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ReplicationDestinationStorageClass enum DEEP_ARCHIVE
        /// </summary>
        public static ReplicationDestinationStorageClass DEEP_ARCHIVE { get; } = new ReplicationDestinationStorageClass("DEEP_ARCHIVE");
        /// <summary>
        /// ReplicationDestinationStorageClass enum GLACIER
        /// </summary>
        public static ReplicationDestinationStorageClass GLACIER { get; } = new ReplicationDestinationStorageClass("GLACIER");
        /// <summary>
        /// ReplicationDestinationStorageClass enum GLACIER_IR
        /// </summary>
        public static ReplicationDestinationStorageClass GLACIER_IR { get; } = new ReplicationDestinationStorageClass("GLACIER_IR");
        /// <summary>
        /// ReplicationDestinationStorageClass enum INTELLIGENT_TIERING
        /// </summary>
        public static ReplicationDestinationStorageClass INTELLIGENT_TIERING { get; } = new ReplicationDestinationStorageClass("INTELLIGENT_TIERING");
        /// <summary>
        /// ReplicationDestinationStorageClass enum ONEZONE_IA
        /// </summary>
        public static ReplicationDestinationStorageClass ONEZONE_IA { get; } = new ReplicationDestinationStorageClass("ONEZONE_IA");
        /// <summary>
        /// ReplicationDestinationStorageClass enum REDUCED_REDUNDANCY
        /// </summary>
        public static ReplicationDestinationStorageClass REDUCED_REDUNDANCY { get; } = new ReplicationDestinationStorageClass("REDUCED_REDUNDANCY");
        /// <summary>
        /// ReplicationDestinationStorageClass enum STANDARD
        /// </summary>
        public static ReplicationDestinationStorageClass STANDARD { get; } = new ReplicationDestinationStorageClass("STANDARD");
        /// <summary>
        /// ReplicationDestinationStorageClass enum STANDARD_IA
        /// </summary>
        public static ReplicationDestinationStorageClass STANDARD_IA { get; } = new ReplicationDestinationStorageClass("STANDARD_IA");

        public static bool operator ==(ReplicationDestinationStorageClass left, ReplicationDestinationStorageClass right) => left.Equals(right);
        public static bool operator !=(ReplicationDestinationStorageClass left, ReplicationDestinationStorageClass right) => !left.Equals(right);

        public static explicit operator string(ReplicationDestinationStorageClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationDestinationStorageClass other && Equals(other);
        public bool Equals(ReplicationDestinationStorageClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the rule is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationRuleStatus : IEquatable<ReplicationRuleStatus>
    {
        private readonly string _value;

        private ReplicationRuleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ReplicationRuleStatus enum Disabled
        /// </summary>
        public static ReplicationRuleStatus Disabled { get; } = new ReplicationRuleStatus("Disabled");
        /// <summary>
        /// ReplicationRuleStatus enum Enabled
        /// </summary>
        public static ReplicationRuleStatus Enabled { get; } = new ReplicationRuleStatus("Enabled");

        public static bool operator ==(ReplicationRuleStatus left, ReplicationRuleStatus right) => left.Equals(right);
        public static bool operator !=(ReplicationRuleStatus left, ReplicationRuleStatus right) => !left.Equals(right);

        public static explicit operator string(ReplicationRuleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationRuleStatus other && Equals(other);
        public bool Equals(ReplicationRuleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the replication time is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ReplicationTimeStatus : IEquatable<ReplicationTimeStatus>
    {
        private readonly string _value;

        private ReplicationTimeStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ReplicationTimeStatus enum Disabled
        /// </summary>
        public static ReplicationTimeStatus Disabled { get; } = new ReplicationTimeStatus("Disabled");
        /// <summary>
        /// ReplicationTimeStatus enum Enabled
        /// </summary>
        public static ReplicationTimeStatus Enabled { get; } = new ReplicationTimeStatus("Enabled");

        public static bool operator ==(ReplicationTimeStatus left, ReplicationTimeStatus right) => left.Equals(right);
        public static bool operator !=(ReplicationTimeStatus left, ReplicationTimeStatus right) => !left.Equals(right);

        public static explicit operator string(ReplicationTimeStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReplicationTimeStatus other && Equals(other);
        public bool Equals(ReplicationTimeStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct RepoUpgradeOnBoot : IEquatable<RepoUpgradeOnBoot>
    {
        private readonly string _value;

        private RepoUpgradeOnBoot(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RepoUpgradeOnBoot enum NONE
        /// </summary>
        public static RepoUpgradeOnBoot NONE { get; } = new RepoUpgradeOnBoot("NONE");
        /// <summary>
        /// RepoUpgradeOnBoot enum SECURITY
        /// </summary>
        public static RepoUpgradeOnBoot SECURITY { get; } = new RepoUpgradeOnBoot("SECURITY");

        public static bool operator ==(RepoUpgradeOnBoot left, RepoUpgradeOnBoot right) => left.Equals(right);
        public static bool operator !=(RepoUpgradeOnBoot left, RepoUpgradeOnBoot right) => !left.Equals(right);

        public static explicit operator string(RepoUpgradeOnBoot value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RepoUpgradeOnBoot other && Equals(other);
        public bool Equals(RepoUpgradeOnBoot other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ResolverLevelMetricsBehavior : IEquatable<ResolverLevelMetricsBehavior>
    {
        private readonly string _value;

        private ResolverLevelMetricsBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ResolverLevelMetricsBehavior enum FULL_REQUEST_RESOLVER_METRICS
        /// </summary>
        public static ResolverLevelMetricsBehavior FULL_REQUEST_RESOLVER_METRICS { get; } = new ResolverLevelMetricsBehavior("FULL_REQUEST_RESOLVER_METRICS");
        /// <summary>
        /// ResolverLevelMetricsBehavior enum PER_RESOLVER_METRICS
        /// </summary>
        public static ResolverLevelMetricsBehavior PER_RESOLVER_METRICS { get; } = new ResolverLevelMetricsBehavior("PER_RESOLVER_METRICS");

        public static bool operator ==(ResolverLevelMetricsBehavior left, ResolverLevelMetricsBehavior right) => left.Equals(right);
        public static bool operator !=(ResolverLevelMetricsBehavior left, ResolverLevelMetricsBehavior right) => !left.Equals(right);

        public static explicit operator string(ResolverLevelMetricsBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResolverLevelMetricsBehavior other && Equals(other);
        public bool Equals(ResolverLevelMetricsBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ResourceRecordSetFailover : IEquatable<ResourceRecordSetFailover>
    {
        private readonly string _value;

        private ResourceRecordSetFailover(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ResourceRecordSetFailover enum PRIMARY
        /// </summary>
        public static ResourceRecordSetFailover PRIMARY { get; } = new ResourceRecordSetFailover("PRIMARY");
        /// <summary>
        /// ResourceRecordSetFailover enum SECONDARY
        /// </summary>
        public static ResourceRecordSetFailover SECONDARY { get; } = new ResourceRecordSetFailover("SECONDARY");

        public static bool operator ==(ResourceRecordSetFailover left, ResourceRecordSetFailover right) => left.Equals(right);
        public static bool operator !=(ResourceRecordSetFailover left, ResourceRecordSetFailover right) => !left.Equals(right);

        public static explicit operator string(ResourceRecordSetFailover value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceRecordSetFailover other && Equals(other);
        public bool Equals(ResourceRecordSetFailover other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ResourceRecordSetRegion : IEquatable<ResourceRecordSetRegion>
    {
        private readonly string _value;

        private ResourceRecordSetRegion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ResourceRecordSetRegion enum af-south-1
        /// </summary>
        public static ResourceRecordSetRegion AfSouth1 { get; } = new ResourceRecordSetRegion("af-south-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-east-1
        /// </summary>
        public static ResourceRecordSetRegion ApEast1 { get; } = new ResourceRecordSetRegion("ap-east-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-northeast-1
        /// </summary>
        public static ResourceRecordSetRegion ApNortheast1 { get; } = new ResourceRecordSetRegion("ap-northeast-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-northeast-2
        /// </summary>
        public static ResourceRecordSetRegion ApNortheast2 { get; } = new ResourceRecordSetRegion("ap-northeast-2");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-northeast-3
        /// </summary>
        public static ResourceRecordSetRegion ApNortheast3 { get; } = new ResourceRecordSetRegion("ap-northeast-3");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-south-1
        /// </summary>
        public static ResourceRecordSetRegion ApSouth1 { get; } = new ResourceRecordSetRegion("ap-south-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-south-2
        /// </summary>
        public static ResourceRecordSetRegion ApSouth2 { get; } = new ResourceRecordSetRegion("ap-south-2");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-southeast-1
        /// </summary>
        public static ResourceRecordSetRegion ApSoutheast1 { get; } = new ResourceRecordSetRegion("ap-southeast-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-southeast-2
        /// </summary>
        public static ResourceRecordSetRegion ApSoutheast2 { get; } = new ResourceRecordSetRegion("ap-southeast-2");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-southeast-3
        /// </summary>
        public static ResourceRecordSetRegion ApSoutheast3 { get; } = new ResourceRecordSetRegion("ap-southeast-3");
        /// <summary>
        /// ResourceRecordSetRegion enum ap-southeast-4
        /// </summary>
        public static ResourceRecordSetRegion ApSoutheast4 { get; } = new ResourceRecordSetRegion("ap-southeast-4");
        /// <summary>
        /// ResourceRecordSetRegion enum ca-central-1
        /// </summary>
        public static ResourceRecordSetRegion CaCentral1 { get; } = new ResourceRecordSetRegion("ca-central-1");
        /// <summary>
        /// ResourceRecordSetRegion enum ca-west-1
        /// </summary>
        public static ResourceRecordSetRegion CaWest1 { get; } = new ResourceRecordSetRegion("ca-west-1");
        /// <summary>
        /// ResourceRecordSetRegion enum cn-north-1
        /// </summary>
        public static ResourceRecordSetRegion CnNorth1 { get; } = new ResourceRecordSetRegion("cn-north-1");
        /// <summary>
        /// ResourceRecordSetRegion enum cn-northwest-1
        /// </summary>
        public static ResourceRecordSetRegion CnNorthwest1 { get; } = new ResourceRecordSetRegion("cn-northwest-1");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-central-1
        /// </summary>
        public static ResourceRecordSetRegion EuCentral1 { get; } = new ResourceRecordSetRegion("eu-central-1");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-central-2
        /// </summary>
        public static ResourceRecordSetRegion EuCentral2 { get; } = new ResourceRecordSetRegion("eu-central-2");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-north-1
        /// </summary>
        public static ResourceRecordSetRegion EuNorth1 { get; } = new ResourceRecordSetRegion("eu-north-1");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-south-1
        /// </summary>
        public static ResourceRecordSetRegion EuSouth1 { get; } = new ResourceRecordSetRegion("eu-south-1");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-south-2
        /// </summary>
        public static ResourceRecordSetRegion EuSouth2 { get; } = new ResourceRecordSetRegion("eu-south-2");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-west-1
        /// </summary>
        public static ResourceRecordSetRegion EuWest1 { get; } = new ResourceRecordSetRegion("eu-west-1");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-west-2
        /// </summary>
        public static ResourceRecordSetRegion EuWest2 { get; } = new ResourceRecordSetRegion("eu-west-2");
        /// <summary>
        /// ResourceRecordSetRegion enum eu-west-3
        /// </summary>
        public static ResourceRecordSetRegion EuWest3 { get; } = new ResourceRecordSetRegion("eu-west-3");
        /// <summary>
        /// ResourceRecordSetRegion enum il-central-1
        /// </summary>
        public static ResourceRecordSetRegion IlCentral1 { get; } = new ResourceRecordSetRegion("il-central-1");
        /// <summary>
        /// ResourceRecordSetRegion enum me-central-1
        /// </summary>
        public static ResourceRecordSetRegion MeCentral1 { get; } = new ResourceRecordSetRegion("me-central-1");
        /// <summary>
        /// ResourceRecordSetRegion enum me-south-1
        /// </summary>
        public static ResourceRecordSetRegion MeSouth1 { get; } = new ResourceRecordSetRegion("me-south-1");
        /// <summary>
        /// ResourceRecordSetRegion enum sa-east-1
        /// </summary>
        public static ResourceRecordSetRegion SaEast1 { get; } = new ResourceRecordSetRegion("sa-east-1");
        /// <summary>
        /// ResourceRecordSetRegion enum us-east-1
        /// </summary>
        public static ResourceRecordSetRegion UsEast1 { get; } = new ResourceRecordSetRegion("us-east-1");
        /// <summary>
        /// ResourceRecordSetRegion enum us-east-2
        /// </summary>
        public static ResourceRecordSetRegion UsEast2 { get; } = new ResourceRecordSetRegion("us-east-2");
        /// <summary>
        /// ResourceRecordSetRegion enum us-west-1
        /// </summary>
        public static ResourceRecordSetRegion UsWest1 { get; } = new ResourceRecordSetRegion("us-west-1");
        /// <summary>
        /// ResourceRecordSetRegion enum us-west-2
        /// </summary>
        public static ResourceRecordSetRegion UsWest2 { get; } = new ResourceRecordSetRegion("us-west-2");

        public static bool operator ==(ResourceRecordSetRegion left, ResourceRecordSetRegion right) => left.Equals(right);
        public static bool operator !=(ResourceRecordSetRegion left, ResourceRecordSetRegion right) => !left.Equals(right);

        public static explicit operator string(ResourceRecordSetRegion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceRecordSetRegion other && Equals(other);
        public bool Equals(ResourceRecordSetRegion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The instance type that the image version runs on.
    /// </summary>
    [EnumType]
    public readonly struct ResourceSpecInstanceType : IEquatable<ResourceSpecInstanceType>
    {
        private readonly string _value;

        private ResourceSpecInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC512xlarge { get; } = new ResourceSpecInstanceType("ml.c5.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.18xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC518xlarge { get; } = new ResourceSpecInstanceType("ml.c5.18xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC524xlarge { get; } = new ResourceSpecInstanceType("ml.c5.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC52xlarge { get; } = new ResourceSpecInstanceType("ml.c5.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC54xlarge { get; } = new ResourceSpecInstanceType("ml.c5.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.9xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC59xlarge { get; } = new ResourceSpecInstanceType("ml.c5.9xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.large
        /// </summary>
        public static ResourceSpecInstanceType MlC5Large { get; } = new ResourceSpecInstanceType("ml.c5.large");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.c5.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlC5Xlarge { get; } = new ResourceSpecInstanceType("ml.c5.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dn12xlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dn16xlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dn2xlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dn4xlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dn8xlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g4dn.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG4dnXlarge { get; } = new ResourceSpecInstanceType("ml.g4dn.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG512xlarge { get; } = new ResourceSpecInstanceType("ml.g5.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG516xlarge { get; } = new ResourceSpecInstanceType("ml.g5.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG524xlarge { get; } = new ResourceSpecInstanceType("ml.g5.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG52xlarge { get; } = new ResourceSpecInstanceType("ml.g5.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.48xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG548xlarge { get; } = new ResourceSpecInstanceType("ml.g5.48xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG54xlarge { get; } = new ResourceSpecInstanceType("ml.g5.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG58xlarge { get; } = new ResourceSpecInstanceType("ml.g5.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.g5.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlG5Xlarge { get; } = new ResourceSpecInstanceType("ml.g5.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.geospatial.interactive
        /// </summary>
        public static ResourceSpecInstanceType MlGeospatialInteractive { get; } = new ResourceSpecInstanceType("ml.geospatial.interactive");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM512xlarge { get; } = new ResourceSpecInstanceType("ml.m5.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM516xlarge { get; } = new ResourceSpecInstanceType("ml.m5.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM524xlarge { get; } = new ResourceSpecInstanceType("ml.m5.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM52xlarge { get; } = new ResourceSpecInstanceType("ml.m5.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM54xlarge { get; } = new ResourceSpecInstanceType("ml.m5.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM58xlarge { get; } = new ResourceSpecInstanceType("ml.m5.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.large
        /// </summary>
        public static ResourceSpecInstanceType MlM5Large { get; } = new ResourceSpecInstanceType("ml.m5.large");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5Xlarge { get; } = new ResourceSpecInstanceType("ml.m5.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d12xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d16xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d24xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d2xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d4xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5d8xlarge { get; } = new ResourceSpecInstanceType("ml.m5d.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.large
        /// </summary>
        public static ResourceSpecInstanceType MlM5dLarge { get; } = new ResourceSpecInstanceType("ml.m5d.large");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.m5d.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlM5dXlarge { get; } = new ResourceSpecInstanceType("ml.m5d.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p3.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP316xlarge { get; } = new ResourceSpecInstanceType("ml.p3.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p3.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP32xlarge { get; } = new ResourceSpecInstanceType("ml.p3.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p3.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP38xlarge { get; } = new ResourceSpecInstanceType("ml.p3.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p3dn.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP3dn24xlarge { get; } = new ResourceSpecInstanceType("ml.p3dn.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p4d.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP4d24xlarge { get; } = new ResourceSpecInstanceType("ml.p4d.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.p4de.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlP4de24xlarge { get; } = new ResourceSpecInstanceType("ml.p4de.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.12xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR512xlarge { get; } = new ResourceSpecInstanceType("ml.r5.12xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.16xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR516xlarge { get; } = new ResourceSpecInstanceType("ml.r5.16xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.24xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR524xlarge { get; } = new ResourceSpecInstanceType("ml.r5.24xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR52xlarge { get; } = new ResourceSpecInstanceType("ml.r5.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.4xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR54xlarge { get; } = new ResourceSpecInstanceType("ml.r5.4xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.8xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR58xlarge { get; } = new ResourceSpecInstanceType("ml.r5.8xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.large
        /// </summary>
        public static ResourceSpecInstanceType MlR5Large { get; } = new ResourceSpecInstanceType("ml.r5.large");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.r5.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlR5Xlarge { get; } = new ResourceSpecInstanceType("ml.r5.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlT32xlarge { get; } = new ResourceSpecInstanceType("ml.t3.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.large
        /// </summary>
        public static ResourceSpecInstanceType MlT3Large { get; } = new ResourceSpecInstanceType("ml.t3.large");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.medium
        /// </summary>
        public static ResourceSpecInstanceType MlT3Medium { get; } = new ResourceSpecInstanceType("ml.t3.medium");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.micro
        /// </summary>
        public static ResourceSpecInstanceType MlT3Micro { get; } = new ResourceSpecInstanceType("ml.t3.micro");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.small
        /// </summary>
        public static ResourceSpecInstanceType MlT3Small { get; } = new ResourceSpecInstanceType("ml.t3.small");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.t3.xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlT3Xlarge { get; } = new ResourceSpecInstanceType("ml.t3.xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.trn1.2xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlTrn12xlarge { get; } = new ResourceSpecInstanceType("ml.trn1.2xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.trn1.32xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlTrn132xlarge { get; } = new ResourceSpecInstanceType("ml.trn1.32xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum ml.trn1n.32xlarge
        /// </summary>
        public static ResourceSpecInstanceType MlTrn1n32xlarge { get; } = new ResourceSpecInstanceType("ml.trn1n.32xlarge");
        /// <summary>
        /// ResourceSpecInstanceType enum system
        /// </summary>
        public static ResourceSpecInstanceType System { get; } = new ResourceSpecInstanceType("system");

        public static bool operator ==(ResourceSpecInstanceType left, ResourceSpecInstanceType right) => left.Equals(right);
        public static bool operator !=(ResourceSpecInstanceType left, ResourceSpecInstanceType right) => !left.Equals(right);

        public static explicit operator string(ResourceSpecInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceSpecInstanceType other && Equals(other);
        public bool Equals(ResourceSpecInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ResourceType : IEquatable<ResourceType>
    {
        private readonly string _value;

        private ResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ResourceType enum EC2Instance
        /// </summary>
        public static ResourceType EC2Instance { get; } = new ResourceType("EC2Instance");
        /// <summary>
        /// ResourceType enum ManagedInstance
        /// </summary>
        public static ResourceType ManagedInstance { get; } = new ResourceType("ManagedInstance");

        public static bool operator ==(ResourceType left, ResourceType right) => left.Equals(right);
        public static bool operator !=(ResourceType left, ResourceType right) => !left.Equals(right);

        public static explicit operator string(ResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceType other && Equals(other);
        public bool Equals(ResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If ``Enabled``, the rule is currently being applied. If ``Disabled``, the rule is not currently being applied.
    /// </summary>
    [EnumType]
    public readonly struct RuleStatus : IEquatable<RuleStatus>
    {
        private readonly string _value;

        private RuleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RuleStatus enum Disabled
        /// </summary>
        public static RuleStatus Disabled { get; } = new RuleStatus("Disabled");
        /// <summary>
        /// RuleStatus enum Enabled
        /// </summary>
        public static RuleStatus Enabled { get; } = new RuleStatus("Enabled");

        public static bool operator ==(RuleStatus left, RuleStatus right) => left.Equals(right);
        public static bool operator !=(RuleStatus left, RuleStatus right) => !left.Equals(right);

        public static explicit operator string(RuleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleStatus other && Equals(other);
        public bool Equals(RuleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property generatedRulesType
    /// </summary>
    [EnumType]
    public readonly struct RulesSourceListGeneratedRulesType : IEquatable<RulesSourceListGeneratedRulesType>
    {
        private readonly string _value;

        private RulesSourceListGeneratedRulesType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RulesSourceListGeneratedRulesType enum ALLOWLIST
        /// </summary>
        public static RulesSourceListGeneratedRulesType ALLOWLIST { get; } = new RulesSourceListGeneratedRulesType("ALLOWLIST");
        /// <summary>
        /// RulesSourceListGeneratedRulesType enum DENYLIST
        /// </summary>
        public static RulesSourceListGeneratedRulesType DENYLIST { get; } = new RulesSourceListGeneratedRulesType("DENYLIST");

        public static bool operator ==(RulesSourceListGeneratedRulesType left, RulesSourceListGeneratedRulesType right) => left.Equals(right);
        public static bool operator !=(RulesSourceListGeneratedRulesType left, RulesSourceListGeneratedRulesType right) => !left.Equals(right);

        public static explicit operator string(RulesSourceListGeneratedRulesType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RulesSourceListGeneratedRulesType other && Equals(other);
        public bool Equals(RulesSourceListGeneratedRulesType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the runtime update mode.  +   *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.  +   *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.  +   *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).    *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
    /// </summary>
    [EnumType]
    public readonly struct RuntimeManagementConfigUpdateRuntimeOn : IEquatable<RuntimeManagementConfigUpdateRuntimeOn>
    {
        private readonly string _value;

        private RuntimeManagementConfigUpdateRuntimeOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RuntimeManagementConfigUpdateRuntimeOn enum Auto
        /// </summary>
        public static RuntimeManagementConfigUpdateRuntimeOn Auto { get; } = new RuntimeManagementConfigUpdateRuntimeOn("Auto");
        /// <summary>
        /// RuntimeManagementConfigUpdateRuntimeOn enum FunctionUpdate
        /// </summary>
        public static RuntimeManagementConfigUpdateRuntimeOn FunctionUpdate { get; } = new RuntimeManagementConfigUpdateRuntimeOn("FunctionUpdate");
        /// <summary>
        /// RuntimeManagementConfigUpdateRuntimeOn enum Manual
        /// </summary>
        public static RuntimeManagementConfigUpdateRuntimeOn Manual { get; } = new RuntimeManagementConfigUpdateRuntimeOn("Manual");

        public static bool operator ==(RuntimeManagementConfigUpdateRuntimeOn left, RuntimeManagementConfigUpdateRuntimeOn right) => left.Equals(right);
        public static bool operator !=(RuntimeManagementConfigUpdateRuntimeOn left, RuntimeManagementConfigUpdateRuntimeOn right) => !left.Equals(right);

        public static explicit operator string(RuntimeManagementConfigUpdateRuntimeOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuntimeManagementConfigUpdateRuntimeOn other && Equals(other);
        public bool Equals(RuntimeManagementConfigUpdateRuntimeOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SSEStatus : IEquatable<SSEStatus>
    {
        private readonly string _value;

        private SSEStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SSEStatus enum DISABLED
        /// </summary>
        public static SSEStatus DISABLED { get; } = new SSEStatus("DISABLED");
        /// <summary>
        /// SSEStatus enum DISABLING
        /// </summary>
        public static SSEStatus DISABLING { get; } = new SSEStatus("DISABLING");
        /// <summary>
        /// SSEStatus enum ENABLED
        /// </summary>
        public static SSEStatus ENABLED { get; } = new SSEStatus("ENABLED");
        /// <summary>
        /// SSEStatus enum ENABLING
        /// </summary>
        public static SSEStatus ENABLING { get; } = new SSEStatus("ENABLING");

        public static bool operator ==(SSEStatus left, SSEStatus right) => left.Equals(right);
        public static bool operator !=(SSEStatus left, SSEStatus right) => !left.Equals(right);

        public static explicit operator string(SSEStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSEStatus other && Equals(other);
        public bool Equals(SSEStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SSEType : IEquatable<SSEType>
    {
        private readonly string _value;

        private SSEType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SSEType enum none
        /// </summary>
        public static SSEType None { get; } = new SSEType("none");
        /// <summary>
        /// SSEType enum sse-ebs
        /// </summary>
        public static SSEType SseEbs { get; } = new SSEType("sse-ebs");
        /// <summary>
        /// SSEType enum sse-kms
        /// </summary>
        public static SSEType SseKms { get; } = new SSEType("sse-kms");

        public static bool operator ==(SSEType left, SSEType right) => left.Equals(right);
        public static bool operator !=(SSEType left, SSEType right) => !left.Equals(right);

        public static explicit operator string(SSEType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSEType other && Equals(other);
        public bool Equals(SSEType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ScaleDownBehavior : IEquatable<ScaleDownBehavior>
    {
        private readonly string _value;

        private ScaleDownBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ScaleDownBehavior enum TERMINATE_AT_INSTANCE_HOUR
        /// </summary>
        public static ScaleDownBehavior TERMINATE_AT_INSTANCE_HOUR { get; } = new ScaleDownBehavior("TERMINATE_AT_INSTANCE_HOUR");
        /// <summary>
        /// ScaleDownBehavior enum TERMINATE_AT_TASK_COMPLETION
        /// </summary>
        public static ScaleDownBehavior TERMINATE_AT_TASK_COMPLETION { get; } = new ScaleDownBehavior("TERMINATE_AT_TASK_COMPLETION");

        public static bool operator ==(ScaleDownBehavior left, ScaleDownBehavior right) => left.Equals(right);
        public static bool operator !=(ScaleDownBehavior left, ScaleDownBehavior right) => !left.Equals(right);

        public static explicit operator string(ScaleDownBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleDownBehavior other && Equals(other);
        public bool Equals(ScaleDownBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ScanStatus : IEquatable<ScanStatus>
    {
        private readonly string _value;

        private ScanStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ScanStatus enum ACTIVE
        /// </summary>
        public static ScanStatus ACTIVE { get; } = new ScanStatus("ACTIVE");
        /// <summary>
        /// ScanStatus enum COMPLETE
        /// </summary>
        public static ScanStatus COMPLETE { get; } = new ScanStatus("COMPLETE");
        /// <summary>
        /// ScanStatus enum FAILED
        /// </summary>
        public static ScanStatus FAILED { get; } = new ScanStatus("FAILED");
        /// <summary>
        /// ScanStatus enum FINDINGS_UNAVAILABLE
        /// </summary>
        public static ScanStatus FINDINGS_UNAVAILABLE { get; } = new ScanStatus("FINDINGS_UNAVAILABLE");
        /// <summary>
        /// ScanStatus enum IN_PROGRESS
        /// </summary>
        public static ScanStatus IN_PROGRESS { get; } = new ScanStatus("IN_PROGRESS");
        /// <summary>
        /// ScanStatus enum PENDING
        /// </summary>
        public static ScanStatus PENDING { get; } = new ScanStatus("PENDING");
        /// <summary>
        /// ScanStatus enum SCAN_ELIGIBILITY_EXPIRED
        /// </summary>
        public static ScanStatus SCAN_ELIGIBILITY_EXPIRED { get; } = new ScanStatus("SCAN_ELIGIBILITY_EXPIRED");
        /// <summary>
        /// ScanStatus enum UNSUPPORTED_IMAGE
        /// </summary>
        public static ScanStatus UNSUPPORTED_IMAGE { get; } = new ScanStatus("UNSUPPORTED_IMAGE");

        public static bool operator ==(ScanStatus left, ScanStatus right) => left.Equals(right);
        public static bool operator !=(ScanStatus left, ScanStatus right) => !left.Equals(right);

        public static explicit operator string(ScanStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScanStatus other && Equals(other);
        public bool Equals(ScanStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scheduling strategy to use for the service. For more information, see [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service scheduler strategies available:  +   ``REPLICA``-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types.  +   ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies.  Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types don't support the ``DAEMON`` scheduling strategy.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingStrategy : IEquatable<SchedulingStrategy>
    {
        private readonly string _value;

        private SchedulingStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SchedulingStrategy enum DAEMON
        /// </summary>
        public static SchedulingStrategy DAEMON { get; } = new SchedulingStrategy("DAEMON");
        /// <summary>
        /// SchedulingStrategy enum REPLICA
        /// </summary>
        public static SchedulingStrategy REPLICA { get; } = new SchedulingStrategy("REPLICA");

        public static bool operator ==(SchedulingStrategy left, SchedulingStrategy right) => left.Equals(right);
        public static bool operator !=(SchedulingStrategy left, SchedulingStrategy right) => !left.Equals(right);

        public static explicit operator string(SchedulingStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingStrategy other && Equals(other);
        public bool Equals(SchedulingStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Server-side encryption algorithm to use for the default encryption.
    /// </summary>
    [EnumType]
    public readonly struct ServerSideEncryptionByDefaultSSEAlgorithm : IEquatable<ServerSideEncryptionByDefaultSSEAlgorithm>
    {
        private readonly string _value;

        private ServerSideEncryptionByDefaultSSEAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ServerSideEncryptionByDefaultSSEAlgorithm enum AES256
        /// </summary>
        public static ServerSideEncryptionByDefaultSSEAlgorithm AES256 { get; } = new ServerSideEncryptionByDefaultSSEAlgorithm("AES256");
        /// <summary>
        /// ServerSideEncryptionByDefaultSSEAlgorithm enum aws:kms
        /// </summary>
        public static ServerSideEncryptionByDefaultSSEAlgorithm AwsKms { get; } = new ServerSideEncryptionByDefaultSSEAlgorithm("aws:kms");
        /// <summary>
        /// ServerSideEncryptionByDefaultSSEAlgorithm enum aws:kms:dsse
        /// </summary>
        public static ServerSideEncryptionByDefaultSSEAlgorithm AwsKmsDsse { get; } = new ServerSideEncryptionByDefaultSSEAlgorithm("aws:kms:dsse");

        public static bool operator ==(ServerSideEncryptionByDefaultSSEAlgorithm left, ServerSideEncryptionByDefaultSSEAlgorithm right) => left.Equals(right);
        public static bool operator !=(ServerSideEncryptionByDefaultSSEAlgorithm left, ServerSideEncryptionByDefaultSSEAlgorithm right) => !left.Equals(right);

        public static explicit operator string(ServerSideEncryptionByDefaultSSEAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerSideEncryptionByDefaultSSEAlgorithm other && Equals(other);
        public bool Equals(ServerSideEncryptionByDefaultSSEAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct ServerType : IEquatable<ServerType>
    {
        private readonly string _value;

        private ServerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// ServerType enum BITBUCKET
        /// </summary>
        public static ServerType BITBUCKET { get; } = new ServerType("BITBUCKET");
        /// <summary>
        /// ServerType enum GITHUB
        /// </summary>
        public static ServerType GITHUB { get; } = new ServerType("GITHUB");
        /// <summary>
        /// ServerType enum GITHUB_ENTERPRISE
        /// </summary>
        public static ServerType GITHUB_ENTERPRISE { get; } = new ServerType("GITHUB_ENTERPRISE");
        /// <summary>
        /// ServerType enum GITLAB
        /// </summary>
        public static ServerType GITLAB { get; } = new ServerType("GITLAB");
        /// <summary>
        /// ServerType enum GITLAB_SELF_MANAGED
        /// </summary>
        public static ServerType GITLAB_SELF_MANAGED { get; } = new ServerType("GITLAB_SELF_MANAGED");

        public static bool operator ==(ServerType left, ServerType right) => left.Equals(right);
        public static bool operator !=(ServerType left, ServerType right) => !left.Equals(right);

        public static explicit operator string(ServerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerType other && Equals(other);
        public bool Equals(ServerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SimpleCriterionKeyForJob : IEquatable<SimpleCriterionKeyForJob>
    {
        private readonly string _value;

        private SimpleCriterionKeyForJob(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SimpleCriterionKeyForJob enum ACCOUNT_ID
        /// </summary>
        public static SimpleCriterionKeyForJob ACCOUNT_ID { get; } = new SimpleCriterionKeyForJob("ACCOUNT_ID");
        /// <summary>
        /// SimpleCriterionKeyForJob enum S3_BUCKET_EFFECTIVE_PERMISSION
        /// </summary>
        public static SimpleCriterionKeyForJob S3_BUCKET_EFFECTIVE_PERMISSION { get; } = new SimpleCriterionKeyForJob("S3_BUCKET_EFFECTIVE_PERMISSION");
        /// <summary>
        /// SimpleCriterionKeyForJob enum S3_BUCKET_NAME
        /// </summary>
        public static SimpleCriterionKeyForJob S3_BUCKET_NAME { get; } = new SimpleCriterionKeyForJob("S3_BUCKET_NAME");
        /// <summary>
        /// SimpleCriterionKeyForJob enum S3_BUCKET_SHARED_ACCESS
        /// </summary>
        public static SimpleCriterionKeyForJob S3_BUCKET_SHARED_ACCESS { get; } = new SimpleCriterionKeyForJob("S3_BUCKET_SHARED_ACCESS");

        public static bool operator ==(SimpleCriterionKeyForJob left, SimpleCriterionKeyForJob right) => left.Equals(right);
        public static bool operator !=(SimpleCriterionKeyForJob left, SimpleCriterionKeyForJob right) => !left.Equals(right);

        public static explicit operator string(SimpleCriterionKeyForJob value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SimpleCriterionKeyForJob other && Equals(other);
        public bool Equals(SimpleCriterionKeyForJob other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
    /// </summary>
    [EnumType]
    public readonly struct SnapStartApplyOn : IEquatable<SnapStartApplyOn>
    {
        private readonly string _value;

        private SnapStartApplyOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SnapStartApplyOn enum None
        /// </summary>
        public static SnapStartApplyOn None { get; } = new SnapStartApplyOn("None");
        /// <summary>
        /// SnapStartApplyOn enum PublishedVersions
        /// </summary>
        public static SnapStartApplyOn PublishedVersions { get; } = new SnapStartApplyOn("PublishedVersions");

        public static bool operator ==(SnapStartApplyOn left, SnapStartApplyOn right) => left.Equals(right);
        public static bool operator !=(SnapStartApplyOn left, SnapStartApplyOn right) => !left.Equals(right);

        public static explicit operator string(SnapStartApplyOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapStartApplyOn other && Equals(other);
        public bool Equals(SnapStartApplyOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SnapshotState : IEquatable<SnapshotState>
    {
        private readonly string _value;

        private SnapshotState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SnapshotState enum completed
        /// </summary>
        public static SnapshotState Completed { get; } = new SnapshotState("completed");
        /// <summary>
        /// SnapshotState enum error
        /// </summary>
        public static SnapshotState Error { get; } = new SnapshotState("error");
        /// <summary>
        /// SnapshotState enum pending
        /// </summary>
        public static SnapshotState Pending { get; } = new SnapshotState("pending");
        /// <summary>
        /// SnapshotState enum recoverable
        /// </summary>
        public static SnapshotState Recoverable { get; } = new SnapshotState("recoverable");
        /// <summary>
        /// SnapshotState enum recovering
        /// </summary>
        public static SnapshotState Recovering { get; } = new SnapshotState("recovering");

        public static bool operator ==(SnapshotState left, SnapshotState right) => left.Equals(right);
        public static bool operator !=(SnapshotState left, SnapshotState right) => !left.Equals(right);

        public static explicit operator string(SnapshotState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotState other && Equals(other);
        public bool Equals(SnapshotState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SourceAuthType : IEquatable<SourceAuthType>
    {
        private readonly string _value;

        private SourceAuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SourceAuthType enum CODECONNECTIONS
        /// </summary>
        public static SourceAuthType CODECONNECTIONS { get; } = new SourceAuthType("CODECONNECTIONS");
        /// <summary>
        /// SourceAuthType enum OAUTH
        /// </summary>
        public static SourceAuthType OAUTH { get; } = new SourceAuthType("OAUTH");

        public static bool operator ==(SourceAuthType left, SourceAuthType right) => left.Equals(right);
        public static bool operator !=(SourceAuthType left, SourceAuthType right) => !left.Equals(right);

        public static explicit operator string(SourceAuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceAuthType other && Equals(other);
        public bool Equals(SourceAuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SourceType : IEquatable<SourceType>
    {
        private readonly string _value;

        private SourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SourceType enum AWS::EC2::Instance
        /// </summary>
        public static SourceType AWSEC2Instance { get; } = new SourceType("AWS::EC2::Instance");
        /// <summary>
        /// SourceType enum AWS::IoT::Thing
        /// </summary>
        public static SourceType AWSIoTThing { get; } = new SourceType("AWS::IoT::Thing");
        /// <summary>
        /// SourceType enum AWS::SSM::ManagedInstance
        /// </summary>
        public static SourceType AWSSSMManagedInstance { get; } = new SourceType("AWS::SSM::ManagedInstance");

        public static bool operator ==(SourceType left, SourceType right) => left.Equals(right);
        public static bool operator !=(SourceType left, SourceType right) => !left.Equals(right);

        public static explicit operator string(SourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceType other && Equals(other);
        public bool Equals(SourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether Amazon S3 replicates objects created with server-side encryption using an AWS KMS key stored in AWS Key Management Service.
    /// </summary>
    [EnumType]
    public readonly struct SseKmsEncryptedObjectsStatus : IEquatable<SseKmsEncryptedObjectsStatus>
    {
        private readonly string _value;

        private SseKmsEncryptedObjectsStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SseKmsEncryptedObjectsStatus enum Disabled
        /// </summary>
        public static SseKmsEncryptedObjectsStatus Disabled { get; } = new SseKmsEncryptedObjectsStatus("Disabled");
        /// <summary>
        /// SseKmsEncryptedObjectsStatus enum Enabled
        /// </summary>
        public static SseKmsEncryptedObjectsStatus Enabled { get; } = new SseKmsEncryptedObjectsStatus("Enabled");

        public static bool operator ==(SseKmsEncryptedObjectsStatus left, SseKmsEncryptedObjectsStatus right) => left.Equals(right);
        public static bool operator !=(SseKmsEncryptedObjectsStatus left, SseKmsEncryptedObjectsStatus right) => !left.Equals(right);

        public static explicit operator string(SseKmsEncryptedObjectsStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SseKmsEncryptedObjectsStatus other && Equals(other);
        public bool Equals(SseKmsEncryptedObjectsStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property stackStatus
    /// </summary>
    [EnumType]
    public readonly struct StackStatus : IEquatable<StackStatus>
    {
        private readonly string _value;

        private StackStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StackStatus enum CREATE_COMPLETE
        /// </summary>
        public static StackStatus CREATE_COMPLETE { get; } = new StackStatus("CREATE_COMPLETE");
        /// <summary>
        /// StackStatus enum CREATE_FAILED
        /// </summary>
        public static StackStatus CREATE_FAILED { get; } = new StackStatus("CREATE_FAILED");
        /// <summary>
        /// StackStatus enum CREATE_IN_PROGRESS
        /// </summary>
        public static StackStatus CREATE_IN_PROGRESS { get; } = new StackStatus("CREATE_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum DELETE_COMPLETE
        /// </summary>
        public static StackStatus DELETE_COMPLETE { get; } = new StackStatus("DELETE_COMPLETE");
        /// <summary>
        /// StackStatus enum DELETE_FAILED
        /// </summary>
        public static StackStatus DELETE_FAILED { get; } = new StackStatus("DELETE_FAILED");
        /// <summary>
        /// StackStatus enum DELETE_IN_PROGRESS
        /// </summary>
        public static StackStatus DELETE_IN_PROGRESS { get; } = new StackStatus("DELETE_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum IMPORT_COMPLETE
        /// </summary>
        public static StackStatus IMPORT_COMPLETE { get; } = new StackStatus("IMPORT_COMPLETE");
        /// <summary>
        /// StackStatus enum IMPORT_IN_PROGRESS
        /// </summary>
        public static StackStatus IMPORT_IN_PROGRESS { get; } = new StackStatus("IMPORT_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum IMPORT_ROLLBACK_COMPLETE
        /// </summary>
        public static StackStatus IMPORT_ROLLBACK_COMPLETE { get; } = new StackStatus("IMPORT_ROLLBACK_COMPLETE");
        /// <summary>
        /// StackStatus enum IMPORT_ROLLBACK_FAILED
        /// </summary>
        public static StackStatus IMPORT_ROLLBACK_FAILED { get; } = new StackStatus("IMPORT_ROLLBACK_FAILED");
        /// <summary>
        /// StackStatus enum IMPORT_ROLLBACK_IN_PROGRESS
        /// </summary>
        public static StackStatus IMPORT_ROLLBACK_IN_PROGRESS { get; } = new StackStatus("IMPORT_ROLLBACK_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum REVIEW_IN_PROGRESS
        /// </summary>
        public static StackStatus REVIEW_IN_PROGRESS { get; } = new StackStatus("REVIEW_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum ROLLBACK_COMPLETE
        /// </summary>
        public static StackStatus ROLLBACK_COMPLETE { get; } = new StackStatus("ROLLBACK_COMPLETE");
        /// <summary>
        /// StackStatus enum ROLLBACK_FAILED
        /// </summary>
        public static StackStatus ROLLBACK_FAILED { get; } = new StackStatus("ROLLBACK_FAILED");
        /// <summary>
        /// StackStatus enum ROLLBACK_IN_PROGRESS
        /// </summary>
        public static StackStatus ROLLBACK_IN_PROGRESS { get; } = new StackStatus("ROLLBACK_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum UPDATE_COMPLETE
        /// </summary>
        public static StackStatus UPDATE_COMPLETE { get; } = new StackStatus("UPDATE_COMPLETE");
        /// <summary>
        /// StackStatus enum UPDATE_COMPLETE_CLEANUP_IN_PROGRESS
        /// </summary>
        public static StackStatus UPDATE_COMPLETE_CLEANUP_IN_PROGRESS { get; } = new StackStatus("UPDATE_COMPLETE_CLEANUP_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum UPDATE_FAILED
        /// </summary>
        public static StackStatus UPDATE_FAILED { get; } = new StackStatus("UPDATE_FAILED");
        /// <summary>
        /// StackStatus enum UPDATE_IN_PROGRESS
        /// </summary>
        public static StackStatus UPDATE_IN_PROGRESS { get; } = new StackStatus("UPDATE_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum UPDATE_ROLLBACK_COMPLETE
        /// </summary>
        public static StackStatus UPDATE_ROLLBACK_COMPLETE { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE");
        /// <summary>
        /// StackStatus enum UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS
        /// </summary>
        public static StackStatus UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS");
        /// <summary>
        /// StackStatus enum UPDATE_ROLLBACK_FAILED
        /// </summary>
        public static StackStatus UPDATE_ROLLBACK_FAILED { get; } = new StackStatus("UPDATE_ROLLBACK_FAILED");
        /// <summary>
        /// StackStatus enum UPDATE_ROLLBACK_IN_PROGRESS
        /// </summary>
        public static StackStatus UPDATE_ROLLBACK_IN_PROGRESS { get; } = new StackStatus("UPDATE_ROLLBACK_IN_PROGRESS");

        public static bool operator ==(StackStatus left, StackStatus right) => left.Equals(right);
        public static bool operator !=(StackStatus left, StackStatus right) => !left.Equals(right);

        public static explicit operator string(StackStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackStatus other && Equals(other);
        public bool Equals(StackStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property ruleOrder
    /// </summary>
    [EnumType]
    public readonly struct StatefulEngineOptionsRuleOrder : IEquatable<StatefulEngineOptionsRuleOrder>
    {
        private readonly string _value;

        private StatefulEngineOptionsRuleOrder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatefulEngineOptionsRuleOrder enum DEFAULT_ACTION_ORDER
        /// </summary>
        public static StatefulEngineOptionsRuleOrder DEFAULT_ACTION_ORDER { get; } = new StatefulEngineOptionsRuleOrder("DEFAULT_ACTION_ORDER");
        /// <summary>
        /// StatefulEngineOptionsRuleOrder enum STRICT_ORDER
        /// </summary>
        public static StatefulEngineOptionsRuleOrder STRICT_ORDER { get; } = new StatefulEngineOptionsRuleOrder("STRICT_ORDER");

        public static bool operator ==(StatefulEngineOptionsRuleOrder left, StatefulEngineOptionsRuleOrder right) => left.Equals(right);
        public static bool operator !=(StatefulEngineOptionsRuleOrder left, StatefulEngineOptionsRuleOrder right) => !left.Equals(right);

        public static explicit operator string(StatefulEngineOptionsRuleOrder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatefulEngineOptionsRuleOrder other && Equals(other);
        public bool Equals(StatefulEngineOptionsRuleOrder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property streamExceptionPolicy
    /// </summary>
    [EnumType]
    public readonly struct StatefulEngineOptionsStreamExceptionPolicy : IEquatable<StatefulEngineOptionsStreamExceptionPolicy>
    {
        private readonly string _value;

        private StatefulEngineOptionsStreamExceptionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatefulEngineOptionsStreamExceptionPolicy enum CONTINUE
        /// </summary>
        public static StatefulEngineOptionsStreamExceptionPolicy CONTINUE { get; } = new StatefulEngineOptionsStreamExceptionPolicy("CONTINUE");
        /// <summary>
        /// StatefulEngineOptionsStreamExceptionPolicy enum DROP
        /// </summary>
        public static StatefulEngineOptionsStreamExceptionPolicy DROP { get; } = new StatefulEngineOptionsStreamExceptionPolicy("DROP");
        /// <summary>
        /// StatefulEngineOptionsStreamExceptionPolicy enum REJECT
        /// </summary>
        public static StatefulEngineOptionsStreamExceptionPolicy REJECT { get; } = new StatefulEngineOptionsStreamExceptionPolicy("REJECT");

        public static bool operator ==(StatefulEngineOptionsStreamExceptionPolicy left, StatefulEngineOptionsStreamExceptionPolicy right) => left.Equals(right);
        public static bool operator !=(StatefulEngineOptionsStreamExceptionPolicy left, StatefulEngineOptionsStreamExceptionPolicy right) => !left.Equals(right);

        public static explicit operator string(StatefulEngineOptionsStreamExceptionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatefulEngineOptionsStreamExceptionPolicy other && Equals(other);
        public bool Equals(StatefulEngineOptionsStreamExceptionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property action
    /// </summary>
    [EnumType]
    public readonly struct StatefulRuleAction : IEquatable<StatefulRuleAction>
    {
        private readonly string _value;

        private StatefulRuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatefulRuleAction enum ALERT
        /// </summary>
        public static StatefulRuleAction ALERT { get; } = new StatefulRuleAction("ALERT");
        /// <summary>
        /// StatefulRuleAction enum DROP
        /// </summary>
        public static StatefulRuleAction DROP { get; } = new StatefulRuleAction("DROP");
        /// <summary>
        /// StatefulRuleAction enum PASS
        /// </summary>
        public static StatefulRuleAction PASS { get; } = new StatefulRuleAction("PASS");
        /// <summary>
        /// StatefulRuleAction enum REJECT
        /// </summary>
        public static StatefulRuleAction REJECT { get; } = new StatefulRuleAction("REJECT");

        public static bool operator ==(StatefulRuleAction left, StatefulRuleAction right) => left.Equals(right);
        public static bool operator !=(StatefulRuleAction left, StatefulRuleAction right) => !left.Equals(right);

        public static explicit operator string(StatefulRuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatefulRuleAction other && Equals(other);
        public bool Equals(StatefulRuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property action
    /// </summary>
    [EnumType]
    public readonly struct StatefulRuleGroupOverrideAction : IEquatable<StatefulRuleGroupOverrideAction>
    {
        private readonly string _value;

        private StatefulRuleGroupOverrideAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatefulRuleGroupOverrideAction enum DROP_TO_ALERT
        /// </summary>
        public static StatefulRuleGroupOverrideAction DROP_TO_ALERT { get; } = new StatefulRuleGroupOverrideAction("DROP_TO_ALERT");

        public static bool operator ==(StatefulRuleGroupOverrideAction left, StatefulRuleGroupOverrideAction right) => left.Equals(right);
        public static bool operator !=(StatefulRuleGroupOverrideAction left, StatefulRuleGroupOverrideAction right) => !left.Equals(right);

        public static explicit operator string(StatefulRuleGroupOverrideAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatefulRuleGroupOverrideAction other && Equals(other);
        public bool Equals(StatefulRuleGroupOverrideAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property ruleOrder
    /// </summary>
    [EnumType]
    public readonly struct StatefulRuleOptionsRuleOrder : IEquatable<StatefulRuleOptionsRuleOrder>
    {
        private readonly string _value;

        private StatefulRuleOptionsRuleOrder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatefulRuleOptionsRuleOrder enum DEFAULT_ACTION_ORDER
        /// </summary>
        public static StatefulRuleOptionsRuleOrder DEFAULT_ACTION_ORDER { get; } = new StatefulRuleOptionsRuleOrder("DEFAULT_ACTION_ORDER");
        /// <summary>
        /// StatefulRuleOptionsRuleOrder enum STRICT_ORDER
        /// </summary>
        public static StatefulRuleOptionsRuleOrder STRICT_ORDER { get; } = new StatefulRuleOptionsRuleOrder("STRICT_ORDER");

        public static bool operator ==(StatefulRuleOptionsRuleOrder left, StatefulRuleOptionsRuleOrder right) => left.Equals(right);
        public static bool operator !=(StatefulRuleOptionsRuleOrder left, StatefulRuleOptionsRuleOrder right) => !left.Equals(right);

        public static explicit operator string(StatefulRuleOptionsRuleOrder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatefulRuleOptionsRuleOrder other && Equals(other);
        public bool Equals(StatefulRuleOptionsRuleOrder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the account in the organization.
    /// </summary>
    [EnumType]
    public readonly struct Status : IEquatable<Status>
    {
        private readonly string _value;

        private Status(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Status enum ACTIVE
        /// </summary>
        public static Status ACTIVE { get; } = new Status("ACTIVE");
        /// <summary>
        /// Status enum PENDING_CLOSURE
        /// </summary>
        public static Status PENDING_CLOSURE { get; } = new Status("PENDING_CLOSURE");
        /// <summary>
        /// Status enum SUSPENDED
        /// </summary>
        public static Status SUSPENDED { get; } = new Status("SUSPENDED");

        public static bool operator ==(Status left, Status right) => left.Equals(right);
        public static bool operator !=(Status left, Status right) => !left.Equals(right);

        public static explicit operator string(Status value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Status other && Equals(other);
        public bool Equals(Status other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct StatusName : IEquatable<StatusName>
    {
        private readonly string _value;

        private StatusName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StatusName enum reachability
        /// </summary>
        public static StatusName Reachability { get; } = new StatusName("reachability");

        public static bool operator ==(StatusName left, StatusName right) => left.Equals(right);
        public static bool operator !=(StatusName left, StatusName right) => !left.Equals(right);

        public static explicit operator string(StatusName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusName other && Equals(other);
        public bool Equals(StatusName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct StatusType : IEquatable<StatusType>
    {
        private readonly string _value;

        private StatusType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// statusType enum Active
        /// </summary>
        public static StatusType Active { get; } = new StatusType("Active");
        /// <summary>
        /// statusType enum Inactive
        /// </summary>
        public static StatusType Inactive { get; } = new StatusType("Inactive");

        public static bool operator ==(StatusType left, StatusType right) => left.Equals(right);
        public static bool operator !=(StatusType left, StatusType right) => !left.Equals(right);

        public static explicit operator string(StatusType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusType other && Equals(other);
        public bool Equals(StatusType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct StorageTier : IEquatable<StorageTier>
    {
        private readonly string _value;

        private StorageTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// StorageTier enum archive
        /// </summary>
        public static StorageTier Archive { get; } = new StorageTier("archive");
        /// <summary>
        /// StorageTier enum standard
        /// </summary>
        public static StorageTier Standard { get; } = new StorageTier("standard");

        public static bool operator ==(StorageTier left, StorageTier right) => left.Equals(right);
        public static bool operator !=(StorageTier left, StorageTier right) => !left.Equals(right);

        public static explicit operator string(StorageTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageTier other && Equals(other);
        public bool Equals(StorageTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct SummaryStatus : IEquatable<SummaryStatus>
    {
        private readonly string _value;

        private SummaryStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SummaryStatus enum impaired
        /// </summary>
        public static SummaryStatus Impaired { get; } = new SummaryStatus("impaired");
        /// <summary>
        /// SummaryStatus enum initializing
        /// </summary>
        public static SummaryStatus Initializing { get; } = new SummaryStatus("initializing");
        /// <summary>
        /// SummaryStatus enum insufficient-data
        /// </summary>
        public static SummaryStatus InsufficientData { get; } = new SummaryStatus("insufficient-data");
        /// <summary>
        /// SummaryStatus enum not-applicable
        /// </summary>
        public static SummaryStatus NotApplicable { get; } = new SummaryStatus("not-applicable");
        /// <summary>
        /// SummaryStatus enum ok
        /// </summary>
        public static SummaryStatus Ok { get; } = new SummaryStatus("ok");

        public static bool operator ==(SummaryStatus left, SummaryStatus right) => left.Equals(right);
        public static bool operator !=(SummaryStatus left, SummaryStatus right) => !left.Equals(right);

        public static explicit operator string(SummaryStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SummaryStatus other && Equals(other);
        public bool Equals(SummaryStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct TLSSecurityPolicy : IEquatable<TLSSecurityPolicy>
    {
        private readonly string _value;

        private TLSSecurityPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TLSSecurityPolicy enum Policy-Min-TLS-1-0-2019-07
        /// </summary>
        public static TLSSecurityPolicy PolicyMinTLS10201907 { get; } = new TLSSecurityPolicy("Policy-Min-TLS-1-0-2019-07");
        /// <summary>
        /// TLSSecurityPolicy enum Policy-Min-TLS-1-2-2019-07
        /// </summary>
        public static TLSSecurityPolicy PolicyMinTLS12201907 { get; } = new TLSSecurityPolicy("Policy-Min-TLS-1-2-2019-07");
        /// <summary>
        /// TLSSecurityPolicy enum Policy-Min-TLS-1-2-PFS-2023-10
        /// </summary>
        public static TLSSecurityPolicy PolicyMinTLS12PFS202310 { get; } = new TLSSecurityPolicy("Policy-Min-TLS-1-2-PFS-2023-10");

        public static bool operator ==(TLSSecurityPolicy left, TLSSecurityPolicy right) => left.Equals(right);
        public static bool operator !=(TLSSecurityPolicy left, TLSSecurityPolicy right) => !left.Equals(right);

        public static explicit operator string(TLSSecurityPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TLSSecurityPolicy other && Equals(other);
        public bool Equals(TLSSecurityPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct TargetHealthReasonEnum : IEquatable<TargetHealthReasonEnum>
    {
        private readonly string _value;

        private TargetHealthReasonEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TargetHealthReasonEnum enum Elb.InitialHealthChecking
        /// </summary>
        public static TargetHealthReasonEnum ElbInitialHealthChecking { get; } = new TargetHealthReasonEnum("Elb.InitialHealthChecking");
        /// <summary>
        /// TargetHealthReasonEnum enum Elb.InternalError
        /// </summary>
        public static TargetHealthReasonEnum ElbInternalError { get; } = new TargetHealthReasonEnum("Elb.InternalError");
        /// <summary>
        /// TargetHealthReasonEnum enum Elb.RegistrationInProgress
        /// </summary>
        public static TargetHealthReasonEnum ElbRegistrationInProgress { get; } = new TargetHealthReasonEnum("Elb.RegistrationInProgress");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.DeregistrationInProgress
        /// </summary>
        public static TargetHealthReasonEnum TargetDeregistrationInProgress { get; } = new TargetHealthReasonEnum("Target.DeregistrationInProgress");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.FailedHealthChecks
        /// </summary>
        public static TargetHealthReasonEnum TargetFailedHealthChecks { get; } = new TargetHealthReasonEnum("Target.FailedHealthChecks");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.HealthCheckDisabled
        /// </summary>
        public static TargetHealthReasonEnum TargetHealthCheckDisabled { get; } = new TargetHealthReasonEnum("Target.HealthCheckDisabled");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.InvalidState
        /// </summary>
        public static TargetHealthReasonEnum TargetInvalidState { get; } = new TargetHealthReasonEnum("Target.InvalidState");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.IpUnusable
        /// </summary>
        public static TargetHealthReasonEnum TargetIpUnusable { get; } = new TargetHealthReasonEnum("Target.IpUnusable");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.NotInUse
        /// </summary>
        public static TargetHealthReasonEnum TargetNotInUse { get; } = new TargetHealthReasonEnum("Target.NotInUse");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.NotRegistered
        /// </summary>
        public static TargetHealthReasonEnum TargetNotRegistered { get; } = new TargetHealthReasonEnum("Target.NotRegistered");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.ResponseCodeMismatch
        /// </summary>
        public static TargetHealthReasonEnum TargetResponseCodeMismatch { get; } = new TargetHealthReasonEnum("Target.ResponseCodeMismatch");
        /// <summary>
        /// TargetHealthReasonEnum enum Target.Timeout
        /// </summary>
        public static TargetHealthReasonEnum TargetTimeout { get; } = new TargetHealthReasonEnum("Target.Timeout");

        public static bool operator ==(TargetHealthReasonEnum left, TargetHealthReasonEnum right) => left.Equals(right);
        public static bool operator !=(TargetHealthReasonEnum left, TargetHealthReasonEnum right) => !left.Equals(right);

        public static explicit operator string(TargetHealthReasonEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetHealthReasonEnum other && Equals(other);
        public bool Equals(TargetHealthReasonEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct TargetHealthStateEnum : IEquatable<TargetHealthStateEnum>
    {
        private readonly string _value;

        private TargetHealthStateEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TargetHealthStateEnum enum draining
        /// </summary>
        public static TargetHealthStateEnum Draining { get; } = new TargetHealthStateEnum("draining");
        /// <summary>
        /// TargetHealthStateEnum enum healthy
        /// </summary>
        public static TargetHealthStateEnum Healthy { get; } = new TargetHealthStateEnum("healthy");
        /// <summary>
        /// TargetHealthStateEnum enum initial
        /// </summary>
        public static TargetHealthStateEnum Initial { get; } = new TargetHealthStateEnum("initial");
        /// <summary>
        /// TargetHealthStateEnum enum unavailable
        /// </summary>
        public static TargetHealthStateEnum Unavailable { get; } = new TargetHealthStateEnum("unavailable");
        /// <summary>
        /// TargetHealthStateEnum enum unhealthy
        /// </summary>
        public static TargetHealthStateEnum Unhealthy { get; } = new TargetHealthStateEnum("unhealthy");
        /// <summary>
        /// TargetHealthStateEnum enum unhealthy.draining
        /// </summary>
        public static TargetHealthStateEnum UnhealthyDraining { get; } = new TargetHealthStateEnum("unhealthy.draining");
        /// <summary>
        /// TargetHealthStateEnum enum unused
        /// </summary>
        public static TargetHealthStateEnum Unused { get; } = new TargetHealthStateEnum("unused");

        public static bool operator ==(TargetHealthStateEnum left, TargetHealthStateEnum right) => left.Equals(right);
        public static bool operator !=(TargetHealthStateEnum left, TargetHealthStateEnum right) => !left.Equals(right);

        public static explicit operator string(TargetHealthStateEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetHealthStateEnum other && Equals(other);
        public bool Equals(TargetHealthStateEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct Tenancy : IEquatable<Tenancy>
    {
        private readonly string _value;

        private Tenancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Tenancy enum dedicated
        /// </summary>
        public static Tenancy Dedicated { get; } = new Tenancy("dedicated");
        /// <summary>
        /// Tenancy enum default
        /// </summary>
        public static Tenancy Default { get; } = new Tenancy("default");
        /// <summary>
        /// Tenancy enum host
        /// </summary>
        public static Tenancy Host { get; } = new Tenancy("host");

        public static bool operator ==(Tenancy left, Tenancy right) => left.Equals(right);
        public static bool operator !=(Tenancy left, Tenancy right) => !left.Equals(right);

        public static explicit operator string(Tenancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Tenancy other && Equals(other);
        public bool Equals(Tenancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parameter tier.
    /// </summary>
    [EnumType]
    public readonly struct Tier : IEquatable<Tier>
    {
        private readonly string _value;

        private Tier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Tier enum Advanced
        /// </summary>
        public static Tier Advanced { get; } = new Tier("Advanced");
        /// <summary>
        /// Tier enum Intelligent-Tiering
        /// </summary>
        public static Tier IntelligentTiering { get; } = new Tier("Intelligent-Tiering");
        /// <summary>
        /// Tier enum Standard
        /// </summary>
        public static Tier Standard { get; } = new Tier("Standard");

        public static bool operator ==(Tier left, Tier right) => left.Equals(right);
        public static bool operator !=(Tier left, Tier right) => !left.Equals(right);

        public static explicit operator string(Tier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Tier other && Equals(other);
        public bool Equals(Tier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
    /// </summary>
    [EnumType]
    public readonly struct TieringAccessTier : IEquatable<TieringAccessTier>
    {
        private readonly string _value;

        private TieringAccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TieringAccessTier enum ARCHIVE_ACCESS
        /// </summary>
        public static TieringAccessTier ARCHIVE_ACCESS { get; } = new TieringAccessTier("ARCHIVE_ACCESS");
        /// <summary>
        /// TieringAccessTier enum DEEP_ARCHIVE_ACCESS
        /// </summary>
        public static TieringAccessTier DEEP_ARCHIVE_ACCESS { get; } = new TieringAccessTier("DEEP_ARCHIVE_ACCESS");

        public static bool operator ==(TieringAccessTier left, TieringAccessTier right) => left.Equals(right);
        public static bool operator !=(TieringAccessTier left, TieringAccessTier right) => !left.Equals(right);

        public static explicit operator string(TieringAccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TieringAccessTier other && Equals(other);
        public bool Equals(TieringAccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct TpmSupportValues : IEquatable<TpmSupportValues>
    {
        private readonly string _value;

        private TpmSupportValues(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TpmSupportValues enum v2.0
        /// </summary>
        public static TpmSupportValues V20 { get; } = new TpmSupportValues("v2.0");

        public static bool operator ==(TpmSupportValues left, TpmSupportValues right) => left.Equals(right);
        public static bool operator !=(TpmSupportValues left, TpmSupportValues right) => !left.Equals(right);

        public static explicit operator string(TpmSupportValues value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TpmSupportValues other && Equals(other);
        public bool Equals(TpmSupportValues other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tracing mode.
    /// </summary>
    [EnumType]
    public readonly struct TracingConfigMode : IEquatable<TracingConfigMode>
    {
        private readonly string _value;

        private TracingConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TracingConfigMode enum Active
        /// </summary>
        public static TracingConfigMode Active { get; } = new TracingConfigMode("Active");
        /// <summary>
        /// TracingConfigMode enum PassThrough
        /// </summary>
        public static TracingConfigMode PassThrough { get; } = new TracingConfigMode("PassThrough");

        public static bool operator ==(TracingConfigMode left, TracingConfigMode right) => left.Equals(right);
        public static bool operator !=(TracingConfigMode left, TracingConfigMode right) => !left.Equals(right);

        public static explicit operator string(TracingConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TracingConfigMode other && Equals(other);
        public bool Equals(TracingConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
    /// </summary>
    [EnumType]
    public readonly struct TrafficType : IEquatable<TrafficType>
    {
        private readonly string _value;

        private TrafficType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TrafficType enum ACCEPT
        /// </summary>
        public static TrafficType ACCEPT { get; } = new TrafficType("ACCEPT");
        /// <summary>
        /// TrafficType enum ALL
        /// </summary>
        public static TrafficType ALL { get; } = new TrafficType("ALL");
        /// <summary>
        /// TrafficType enum REJECT
        /// </summary>
        public static TrafficType REJECT { get; } = new TrafficType("REJECT");

        public static bool operator ==(TrafficType left, TrafficType right) => left.Equals(right);
        public static bool operator !=(TrafficType left, TrafficType right) => !left.Equals(right);

        public static explicit operator string(TrafficType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrafficType other && Equals(other);
        public bool Equals(TrafficType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The storage class to which you want the object to transition.
    /// </summary>
    [EnumType]
    public readonly struct TransitionStorageClass : IEquatable<TransitionStorageClass>
    {
        private readonly string _value;

        private TransitionStorageClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TransitionStorageClass enum DEEP_ARCHIVE
        /// </summary>
        public static TransitionStorageClass DEEP_ARCHIVE { get; } = new TransitionStorageClass("DEEP_ARCHIVE");
        /// <summary>
        /// TransitionStorageClass enum GLACIER
        /// </summary>
        public static TransitionStorageClass GLACIER { get; } = new TransitionStorageClass("GLACIER");
        /// <summary>
        /// TransitionStorageClass enum GLACIER_IR
        /// </summary>
        public static TransitionStorageClass GLACIER_IR { get; } = new TransitionStorageClass("GLACIER_IR");
        /// <summary>
        /// TransitionStorageClass enum INTELLIGENT_TIERING
        /// </summary>
        public static TransitionStorageClass INTELLIGENT_TIERING { get; } = new TransitionStorageClass("INTELLIGENT_TIERING");
        /// <summary>
        /// TransitionStorageClass enum ONEZONE_IA
        /// </summary>
        public static TransitionStorageClass ONEZONE_IA { get; } = new TransitionStorageClass("ONEZONE_IA");
        /// <summary>
        /// TransitionStorageClass enum STANDARD_IA
        /// </summary>
        public static TransitionStorageClass STANDARD_IA { get; } = new TransitionStorageClass("STANDARD_IA");

        public static bool operator ==(TransitionStorageClass left, TransitionStorageClass right) => left.Equals(right);
        public static bool operator !=(TransitionStorageClass left, TransitionStorageClass right) => !left.Equals(right);

        public static explicit operator string(TransitionStorageClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransitionStorageClass other && Equals(other);
        public bool Equals(TransitionStorageClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of parameter.
    /// </summary>
    [EnumType]
    public readonly struct Type : IEquatable<Type>
    {
        private readonly string _value;

        private Type(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Type enum String
        /// </summary>
        public static Type String { get; } = new Type("String");
        /// <summary>
        /// Type enum StringList
        /// </summary>
        public static Type StringList { get; } = new Type("StringList");

        public static bool operator ==(Type left, Type right) => left.Equals(right);
        public static bool operator !=(Type left, Type right) => !left.Equals(right);

        public static explicit operator string(Type value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Type other && Equals(other);
        public bool Equals(Type other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The versioning state of the bucket.
    /// </summary>
    [EnumType]
    public readonly struct VersioningConfigurationStatus : IEquatable<VersioningConfigurationStatus>
    {
        private readonly string _value;

        private VersioningConfigurationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VersioningConfigurationStatus enum Enabled
        /// </summary>
        public static VersioningConfigurationStatus Enabled { get; } = new VersioningConfigurationStatus("Enabled");
        /// <summary>
        /// VersioningConfigurationStatus enum Suspended
        /// </summary>
        public static VersioningConfigurationStatus Suspended { get; } = new VersioningConfigurationStatus("Suspended");

        public static bool operator ==(VersioningConfigurationStatus left, VersioningConfigurationStatus right) => left.Equals(right);
        public static bool operator !=(VersioningConfigurationStatus left, VersioningConfigurationStatus right) => !left.Equals(right);

        public static explicit operator string(VersioningConfigurationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersioningConfigurationStatus other && Equals(other);
        public bool Equals(VersioningConfigurationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct VirtualizationType : IEquatable<VirtualizationType>
    {
        private readonly string _value;

        private VirtualizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VirtualizationType enum hvm
        /// </summary>
        public static VirtualizationType Hvm { get; } = new VirtualizationType("hvm");
        /// <summary>
        /// VirtualizationType enum paravirtual
        /// </summary>
        public static VirtualizationType Paravirtual { get; } = new VirtualizationType("paravirtual");

        public static bool operator ==(VirtualizationType left, VirtualizationType right) => left.Equals(right);
        public static bool operator !=(VirtualizationType left, VirtualizationType right) => !left.Equals(right);

        public static explicit operator string(VirtualizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualizationType other && Equals(other);
        public bool Equals(VirtualizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct VolumeType : IEquatable<VolumeType>
    {
        private readonly string _value;

        private VolumeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VolumeType enum gp2
        /// </summary>
        public static VolumeType Gp2 { get; } = new VolumeType("gp2");
        /// <summary>
        /// VolumeType enum gp3
        /// </summary>
        public static VolumeType Gp3 { get; } = new VolumeType("gp3");
        /// <summary>
        /// VolumeType enum io1
        /// </summary>
        public static VolumeType Io1 { get; } = new VolumeType("io1");
        /// <summary>
        /// VolumeType enum standard
        /// </summary>
        public static VolumeType Standard { get; } = new VolumeType("standard");

        public static bool operator ==(VolumeType left, VolumeType right) => left.Equals(right);
        public static bool operator !=(VolumeType left, VolumeType right) => !left.Equals(right);

        public static explicit operator string(VolumeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VolumeType other && Equals(other);
        public bool Equals(VolumeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of endpoint. Default: Gateway
    /// </summary>
    [EnumType]
    public readonly struct VpcEndpointType : IEquatable<VpcEndpointType>
    {
        private readonly string _value;

        private VpcEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VpcEndpointType enum Gateway
        /// </summary>
        public static VpcEndpointType Gateway { get; } = new VpcEndpointType("Gateway");
        /// <summary>
        /// VpcEndpointType enum GatewayLoadBalancer
        /// </summary>
        public static VpcEndpointType GatewayLoadBalancer { get; } = new VpcEndpointType("GatewayLoadBalancer");
        /// <summary>
        /// VpcEndpointType enum Interface
        /// </summary>
        public static VpcEndpointType Interface { get; } = new VpcEndpointType("Interface");

        public static bool operator ==(VpcEndpointType left, VpcEndpointType right) => left.Equals(right);
        public static bool operator !=(VpcEndpointType left, VpcEndpointType right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointType other && Equals(other);
        public bool Equals(VpcEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct WebhookBuildType : IEquatable<WebhookBuildType>
    {
        private readonly string _value;

        private WebhookBuildType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// WebhookBuildType enum BUILD
        /// </summary>
        public static WebhookBuildType BUILD { get; } = new WebhookBuildType("BUILD");
        /// <summary>
        /// WebhookBuildType enum BUILD_BATCH
        /// </summary>
        public static WebhookBuildType BUILD_BATCH { get; } = new WebhookBuildType("BUILD_BATCH");

        public static bool operator ==(WebhookBuildType left, WebhookBuildType right) => left.Equals(right);
        public static bool operator !=(WebhookBuildType left, WebhookBuildType right) => !left.Equals(right);

        public static explicit operator string(WebhookBuildType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebhookBuildType other && Equals(other);
        public bool Equals(WebhookBuildType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Property value
    /// </summary>
    [EnumType]
    public readonly struct WebhookFilterType : IEquatable<WebhookFilterType>
    {
        private readonly string _value;

        private WebhookFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// WebhookFilterType enum ACTOR_ACCOUNT_ID
        /// </summary>
        public static WebhookFilterType ACTOR_ACCOUNT_ID { get; } = new WebhookFilterType("ACTOR_ACCOUNT_ID");
        /// <summary>
        /// WebhookFilterType enum BASE_REF
        /// </summary>
        public static WebhookFilterType BASE_REF { get; } = new WebhookFilterType("BASE_REF");
        /// <summary>
        /// WebhookFilterType enum COMMIT_MESSAGE
        /// </summary>
        public static WebhookFilterType COMMIT_MESSAGE { get; } = new WebhookFilterType("COMMIT_MESSAGE");
        /// <summary>
        /// WebhookFilterType enum EVENT
        /// </summary>
        public static WebhookFilterType EVENT { get; } = new WebhookFilterType("EVENT");
        /// <summary>
        /// WebhookFilterType enum FILE_PATH
        /// </summary>
        public static WebhookFilterType FILE_PATH { get; } = new WebhookFilterType("FILE_PATH");
        /// <summary>
        /// WebhookFilterType enum HEAD_REF
        /// </summary>
        public static WebhookFilterType HEAD_REF { get; } = new WebhookFilterType("HEAD_REF");
        /// <summary>
        /// WebhookFilterType enum RELEASE_NAME
        /// </summary>
        public static WebhookFilterType RELEASE_NAME { get; } = new WebhookFilterType("RELEASE_NAME");
        /// <summary>
        /// WebhookFilterType enum TAG_NAME
        /// </summary>
        public static WebhookFilterType TAG_NAME { get; } = new WebhookFilterType("TAG_NAME");
        /// <summary>
        /// WebhookFilterType enum WORKFLOW_NAME
        /// </summary>
        public static WebhookFilterType WORKFLOW_NAME { get; } = new WebhookFilterType("WORKFLOW_NAME");

        public static bool operator ==(WebhookFilterType left, WebhookFilterType right) => left.Equals(right);
        public static bool operator !=(WebhookFilterType left, WebhookFilterType right) => !left.Equals(right);

        public static explicit operator string(WebhookFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebhookFilterType other && Equals(other);
        public bool Equals(WebhookFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
