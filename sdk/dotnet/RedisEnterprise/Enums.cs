// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.RedisEnterprise
{
    /// <summary>
    /// This property can be Enabled/Disabled to allow or deny access with the current access keys. Can be updated even after database is created.
    /// </summary>
    [EnumType]
    public readonly struct AccessKeysAuthentication : IEquatable<AccessKeysAuthentication>
    {
        private readonly string _value;

        private AccessKeysAuthentication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessKeysAuthentication Disabled { get; } = new AccessKeysAuthentication("Disabled");
        public static AccessKeysAuthentication Enabled { get; } = new AccessKeysAuthentication("Enabled");

        public static bool operator ==(AccessKeysAuthentication left, AccessKeysAuthentication right) => left.Equals(right);
        public static bool operator !=(AccessKeysAuthentication left, AccessKeysAuthentication right) => !left.Equals(right);

        public static explicit operator string(AccessKeysAuthentication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessKeysAuthentication other && Equals(other);
        public bool Equals(AccessKeysAuthentication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets the frequency at which data is written to disk. Defaults to '1s', meaning 'every second'. Note that the 'always' setting is deprecated, because of its performance impact.
    /// </summary>
    [EnumType]
    public readonly struct AofFrequency : IEquatable<AofFrequency>
    {
        private readonly string _value;

        private AofFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AofFrequency AofFrequency_1s { get; } = new AofFrequency("1s");
        public static AofFrequency Always { get; } = new AofFrequency("always");

        public static bool operator ==(AofFrequency left, AofFrequency right) => left.Equals(right);
        public static bool operator !=(AofFrequency left, AofFrequency right) => !left.Equals(right);

        public static explicit operator string(AofFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AofFrequency other && Equals(other);
        public bool Equals(AofFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Clustering policy - default is OSSCluster. This property can be updated only if the current value is NoCluster. If the value is OSSCluster or EnterpriseCluster, it cannot be updated without deleting the database.
    /// </summary>
    [EnumType]
    public readonly struct ClusteringPolicy : IEquatable<ClusteringPolicy>
    {
        private readonly string _value;

        private ClusteringPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Enterprise clustering policy uses only the classic redis protocol, which does not support redis cluster commands.
        /// </summary>
        public static ClusteringPolicy EnterpriseCluster { get; } = new ClusteringPolicy("EnterpriseCluster");
        /// <summary>
        /// OSS clustering policy follows the redis cluster specification, and requires all clients to support redis clustering.
        /// </summary>
        public static ClusteringPolicy OSSCluster { get; } = new ClusteringPolicy("OSSCluster");
        /// <summary>
        /// The NoCluster policy is used for non-clustered Redis instances that do not require clustering features.
        /// </summary>
        public static ClusteringPolicy NoCluster { get; } = new ClusteringPolicy("NoCluster");

        public static bool operator ==(ClusteringPolicy left, ClusteringPolicy right) => left.Equals(right);
        public static bool operator !=(ClusteringPolicy left, ClusteringPolicy right) => !left.Equals(right);

        public static explicit operator string(ClusteringPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusteringPolicy other && Equals(other);
        public bool Equals(ClusteringPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Only userAssignedIdentity is supported in this API version; other types may be supported in the future
    /// </summary>
    [EnumType]
    public readonly struct CmkIdentityType : IEquatable<CmkIdentityType>
    {
        private readonly string _value;

        private CmkIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CmkIdentityType SystemAssignedIdentity { get; } = new CmkIdentityType("systemAssignedIdentity");
        public static CmkIdentityType UserAssignedIdentity { get; } = new CmkIdentityType("userAssignedIdentity");

        public static bool operator ==(CmkIdentityType left, CmkIdentityType right) => left.Equals(right);
        public static bool operator !=(CmkIdentityType left, CmkIdentityType right) => !left.Equals(right);

        public static explicit operator string(CmkIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CmkIdentityType other && Equals(other);
        public bool Equals(CmkIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Option to defer upgrade when newest version is released - default is NotDeferred. Learn more: https://aka.ms/redisversionupgrade
    /// </summary>
    [EnumType]
    public readonly struct DeferUpgradeSetting : IEquatable<DeferUpgradeSetting>
    {
        private readonly string _value;

        private DeferUpgradeSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeferUpgradeSetting Deferred { get; } = new DeferUpgradeSetting("Deferred");
        public static DeferUpgradeSetting NotDeferred { get; } = new DeferUpgradeSetting("NotDeferred");

        public static bool operator ==(DeferUpgradeSetting left, DeferUpgradeSetting right) => left.Equals(right);
        public static bool operator !=(DeferUpgradeSetting left, DeferUpgradeSetting right) => !left.Equals(right);

        public static explicit operator string(DeferUpgradeSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeferUpgradeSetting other && Equals(other);
        public bool Equals(DeferUpgradeSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Redis eviction policy - default is VolatileLRU
    /// </summary>
    [EnumType]
    public readonly struct EvictionPolicy : IEquatable<EvictionPolicy>
    {
        private readonly string _value;

        private EvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EvictionPolicy AllKeysLFU { get; } = new EvictionPolicy("AllKeysLFU");
        public static EvictionPolicy AllKeysLRU { get; } = new EvictionPolicy("AllKeysLRU");
        public static EvictionPolicy AllKeysRandom { get; } = new EvictionPolicy("AllKeysRandom");
        public static EvictionPolicy VolatileLRU { get; } = new EvictionPolicy("VolatileLRU");
        public static EvictionPolicy VolatileLFU { get; } = new EvictionPolicy("VolatileLFU");
        public static EvictionPolicy VolatileTTL { get; } = new EvictionPolicy("VolatileTTL");
        public static EvictionPolicy VolatileRandom { get; } = new EvictionPolicy("VolatileRandom");
        public static EvictionPolicy NoEviction { get; } = new EvictionPolicy("NoEviction");

        public static bool operator ==(EvictionPolicy left, EvictionPolicy right) => left.Equals(right);
        public static bool operator !=(EvictionPolicy left, EvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(EvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EvictionPolicy other && Equals(other);
        public bool Equals(EvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enabled by default. If highAvailability is disabled, the data set is not replicated. This affects the availability SLA, and increases the risk of data loss.
    /// </summary>
    [EnumType]
    public readonly struct HighAvailability : IEquatable<HighAvailability>
    {
        private readonly string _value;

        private HighAvailability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HighAvailability Enabled { get; } = new HighAvailability("Enabled");
        public static HighAvailability Disabled { get; } = new HighAvailability("Disabled");

        public static bool operator ==(HighAvailability left, HighAvailability right) => left.Equals(right);
        public static bool operator !=(HighAvailability left, HighAvailability right) => !left.Equals(right);

        public static explicit operator string(HighAvailability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HighAvailability other && Equals(other);
        public bool Equals(HighAvailability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned, UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether redis clients can connect using TLS-encrypted or plaintext redis protocols. Default is TLS-encrypted.
    /// </summary>
    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Protocol Encrypted { get; } = new Protocol("Encrypted");
        public static Protocol Plaintext { get; } = new Protocol("Plaintext");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets the frequency at which a snapshot of the database is created.
    /// </summary>
    [EnumType]
    public readonly struct RdbFrequency : IEquatable<RdbFrequency>
    {
        private readonly string _value;

        private RdbFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RdbFrequency RdbFrequency_1h { get; } = new RdbFrequency("1h");
        public static RdbFrequency RdbFrequency_6h { get; } = new RdbFrequency("6h");
        public static RdbFrequency RdbFrequency_12h { get; } = new RdbFrequency("12h");

        public static bool operator ==(RdbFrequency left, RdbFrequency right) => left.Equals(right);
        public static bool operator !=(RdbFrequency left, RdbFrequency right) => !left.Equals(right);

        public static explicit operator string(RdbFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RdbFrequency other && Equals(other);
        public bool Equals(RdbFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The level of Redis Enterprise cluster to deploy. Possible values: ('Balanced_B5', 'MemoryOptimized_M10', 'ComputeOptimized_X5', etc.). For more information on SKUs see the latest pricing documentation. Note that additional SKUs may become supported in the future.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuName Enterprise_E1 { get; } = new SkuName("Enterprise_E1");
        public static SkuName Enterprise_E5 { get; } = new SkuName("Enterprise_E5");
        public static SkuName Enterprise_E10 { get; } = new SkuName("Enterprise_E10");
        public static SkuName Enterprise_E20 { get; } = new SkuName("Enterprise_E20");
        public static SkuName Enterprise_E50 { get; } = new SkuName("Enterprise_E50");
        public static SkuName Enterprise_E100 { get; } = new SkuName("Enterprise_E100");
        public static SkuName Enterprise_E200 { get; } = new SkuName("Enterprise_E200");
        public static SkuName Enterprise_E400 { get; } = new SkuName("Enterprise_E400");
        public static SkuName EnterpriseFlash_F300 { get; } = new SkuName("EnterpriseFlash_F300");
        public static SkuName EnterpriseFlash_F700 { get; } = new SkuName("EnterpriseFlash_F700");
        public static SkuName EnterpriseFlash_F1500 { get; } = new SkuName("EnterpriseFlash_F1500");
        public static SkuName Balanced_B0 { get; } = new SkuName("Balanced_B0");
        public static SkuName Balanced_B1 { get; } = new SkuName("Balanced_B1");
        public static SkuName Balanced_B3 { get; } = new SkuName("Balanced_B3");
        public static SkuName Balanced_B5 { get; } = new SkuName("Balanced_B5");
        public static SkuName Balanced_B10 { get; } = new SkuName("Balanced_B10");
        public static SkuName Balanced_B20 { get; } = new SkuName("Balanced_B20");
        public static SkuName Balanced_B50 { get; } = new SkuName("Balanced_B50");
        public static SkuName Balanced_B100 { get; } = new SkuName("Balanced_B100");
        public static SkuName Balanced_B150 { get; } = new SkuName("Balanced_B150");
        public static SkuName Balanced_B250 { get; } = new SkuName("Balanced_B250");
        public static SkuName Balanced_B350 { get; } = new SkuName("Balanced_B350");
        public static SkuName Balanced_B500 { get; } = new SkuName("Balanced_B500");
        public static SkuName Balanced_B700 { get; } = new SkuName("Balanced_B700");
        public static SkuName Balanced_B1000 { get; } = new SkuName("Balanced_B1000");
        public static SkuName MemoryOptimized_M10 { get; } = new SkuName("MemoryOptimized_M10");
        public static SkuName MemoryOptimized_M20 { get; } = new SkuName("MemoryOptimized_M20");
        public static SkuName MemoryOptimized_M50 { get; } = new SkuName("MemoryOptimized_M50");
        public static SkuName MemoryOptimized_M100 { get; } = new SkuName("MemoryOptimized_M100");
        public static SkuName MemoryOptimized_M150 { get; } = new SkuName("MemoryOptimized_M150");
        public static SkuName MemoryOptimized_M250 { get; } = new SkuName("MemoryOptimized_M250");
        public static SkuName MemoryOptimized_M350 { get; } = new SkuName("MemoryOptimized_M350");
        public static SkuName MemoryOptimized_M500 { get; } = new SkuName("MemoryOptimized_M500");
        public static SkuName MemoryOptimized_M700 { get; } = new SkuName("MemoryOptimized_M700");
        public static SkuName MemoryOptimized_M1000 { get; } = new SkuName("MemoryOptimized_M1000");
        public static SkuName MemoryOptimized_M1500 { get; } = new SkuName("MemoryOptimized_M1500");
        public static SkuName MemoryOptimized_M2000 { get; } = new SkuName("MemoryOptimized_M2000");
        public static SkuName ComputeOptimized_X3 { get; } = new SkuName("ComputeOptimized_X3");
        public static SkuName ComputeOptimized_X5 { get; } = new SkuName("ComputeOptimized_X5");
        public static SkuName ComputeOptimized_X10 { get; } = new SkuName("ComputeOptimized_X10");
        public static SkuName ComputeOptimized_X20 { get; } = new SkuName("ComputeOptimized_X20");
        public static SkuName ComputeOptimized_X50 { get; } = new SkuName("ComputeOptimized_X50");
        public static SkuName ComputeOptimized_X100 { get; } = new SkuName("ComputeOptimized_X100");
        public static SkuName ComputeOptimized_X150 { get; } = new SkuName("ComputeOptimized_X150");
        public static SkuName ComputeOptimized_X250 { get; } = new SkuName("ComputeOptimized_X250");
        public static SkuName ComputeOptimized_X350 { get; } = new SkuName("ComputeOptimized_X350");
        public static SkuName ComputeOptimized_X500 { get; } = new SkuName("ComputeOptimized_X500");
        public static SkuName ComputeOptimized_X700 { get; } = new SkuName("ComputeOptimized_X700");
        public static SkuName FlashOptimized_A250 { get; } = new SkuName("FlashOptimized_A250");
        public static SkuName FlashOptimized_A500 { get; } = new SkuName("FlashOptimized_A500");
        public static SkuName FlashOptimized_A700 { get; } = new SkuName("FlashOptimized_A700");
        public static SkuName FlashOptimized_A1000 { get; } = new SkuName("FlashOptimized_A1000");
        public static SkuName FlashOptimized_A1500 { get; } = new SkuName("FlashOptimized_A1500");
        public static SkuName FlashOptimized_A2000 { get; } = new SkuName("FlashOptimized_A2000");
        public static SkuName FlashOptimized_A4500 { get; } = new SkuName("FlashOptimized_A4500");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The minimum TLS version for the cluster to support, e.g. '1.2'. Newer versions can be added in the future. Note that TLS 1.0 and TLS 1.1 are now completely obsolete -- you cannot use them. They are mentioned only for the sake of consistency with old API versions.
    /// </summary>
    [EnumType]
    public readonly struct TlsVersion : IEquatable<TlsVersion>
    {
        private readonly string _value;

        private TlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TlsVersion TlsVersion_1_0 { get; } = new TlsVersion("1.0");
        public static TlsVersion TlsVersion_1_1 { get; } = new TlsVersion("1.1");
        public static TlsVersion TlsVersion_1_2 { get; } = new TlsVersion("1.2");

        public static bool operator ==(TlsVersion left, TlsVersion right) => left.Equals(right);
        public static bool operator !=(TlsVersion left, TlsVersion right) => !left.Equals(right);

        public static explicit operator string(TlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsVersion other && Equals(other);
        public bool Equals(TlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
