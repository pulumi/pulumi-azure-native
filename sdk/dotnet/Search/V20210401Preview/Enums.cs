// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Search.V20210401Preview
{
    /// <summary>
    /// Describes what response the data plane API of a Search service would send for requests that failed authentication.
    /// </summary>
    [EnumType]
    public readonly struct AadAuthFailureMode : IEquatable<AadAuthFailureMode>
    {
        private readonly string _value;

        private AadAuthFailureMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that requests that failed authentication should be presented with an HTTP status code of 403 (Forbidden).
        /// </summary>
        public static AadAuthFailureMode Http403 { get; } = new AadAuthFailureMode("http403");
        /// <summary>
        /// Indicates that requests that failed authentication should be presented with an HTTP status code of 401 (Unauthorized) and present a Bearer Challenge.
        /// </summary>
        public static AadAuthFailureMode Http401WithBearerChallenge { get; } = new AadAuthFailureMode("http401WithBearerChallenge");

        public static bool operator ==(AadAuthFailureMode left, AadAuthFailureMode right) => left.Equals(right);
        public static bool operator !=(AadAuthFailureMode left, AadAuthFailureMode right) => !left.Equals(right);

        public static explicit operator string(AadAuthFailureMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AadAuthFailureMode other && Equals(other);
        public bool Equals(AadAuthFailureMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
    /// </summary>
    [EnumType]
    public readonly struct HostingMode : IEquatable<HostingMode>
    {
        private readonly string _value;

        private HostingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The limit on number of indexes is determined by the default limits for the SKU.
        /// </summary>
        public static HostingMode Default { get; } = new HostingMode("default");
        /// <summary>
        /// Only application for standard3 SKU, where the search service can have up to 1000 indexes.
        /// </summary>
        public static HostingMode HighDensity { get; } = new HostingMode("highDensity");

        public static bool operator ==(HostingMode left, HostingMode right) => left.Equals(right);
        public static bool operator !=(HostingMode left, HostingMode right) => !left.Equals(right);

        public static explicit operator string(HostingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HostingMode other && Equals(other);
        public bool Equals(HostingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an identity created by the system and a set of user assigned identities. The type 'None' will remove all identities from the service.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that any identity associated with the search service needs to be removed.
        /// </summary>
        public static IdentityType None { get; } = new IdentityType("None");
        /// <summary>
        /// Indicates that system-assigned identity for the search service will be enabled.
        /// </summary>
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        /// <summary>
        /// Indicates that one or more user assigned identities will be assigned to the search service.
        /// </summary>
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        /// <summary>
        /// Indicates that system-assigned identity for the search service will be enabled along with the assignment of one or more user assigned identities.
        /// </summary>
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned, UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This value can be set to 'enabled' to avoid breaking changes on existing customer resources and templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be the exclusive access method.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The search service is accessible from traffic originating from the public internet.
        /// </summary>
        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("enabled");
        /// <summary>
        /// The search service is not accessible from traffic originating from the public internet. Access is only permitted over approved private endpoint connections.
        /// </summary>
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Possible origins of inbound traffic that can bypass the rules defined in the 'ipRules' section.
    /// </summary>
    [EnumType]
    public readonly struct SearchBypass : IEquatable<SearchBypass>
    {
        private readonly string _value;

        private SearchBypass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that no origin can bypass the rules defined in the 'ipRules' section. This is the default.
        /// </summary>
        public static SearchBypass None { get; } = new SearchBypass("None");
        /// <summary>
        /// Indicates that requests originating from the Azure portal can bypass the rules defined in the 'ipRules' section.
        /// </summary>
        public static SearchBypass AzurePortal { get; } = new SearchBypass("AzurePortal");

        public static bool operator ==(SearchBypass left, SearchBypass right) => left.Equals(right);
        public static bool operator !=(SearchBypass left, SearchBypass right) => !left.Equals(right);

        public static explicit operator string(SearchBypass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SearchBypass other && Equals(other);
        public bool Equals(SearchBypass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A specific data exfiltration scenario that is disabled for the service.
    /// </summary>
    [EnumType]
    public readonly struct SearchDisabledDataExfiltrationOption : IEquatable<SearchDisabledDataExfiltrationOption>
    {
        private readonly string _value;

        private SearchDisabledDataExfiltrationOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that all data exfiltration scenarios are disabled.
        /// </summary>
        public static SearchDisabledDataExfiltrationOption All { get; } = new SearchDisabledDataExfiltrationOption("All");

        public static bool operator ==(SearchDisabledDataExfiltrationOption left, SearchDisabledDataExfiltrationOption right) => left.Equals(right);
        public static bool operator !=(SearchDisabledDataExfiltrationOption left, SearchDisabledDataExfiltrationOption right) => !left.Equals(right);

        public static explicit operator string(SearchDisabledDataExfiltrationOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SearchDisabledDataExfiltrationOption other && Equals(other);
        public bool Equals(SearchDisabledDataExfiltrationOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes how a search service should enforce having one or more non customer encrypted resources.
    /// </summary>
    [EnumType]
    public readonly struct SearchEncryptionWithCmk : IEquatable<SearchEncryptionWithCmk>
    {
        private readonly string _value;

        private SearchEncryptionWithCmk(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No enforcement will be made and the search service can have non customer encrypted resources.
        /// </summary>
        public static SearchEncryptionWithCmk Disabled { get; } = new SearchEncryptionWithCmk("Disabled");
        /// <summary>
        /// Search service will be marked as non-compliant if there are one or more non customer encrypted resources.
        /// </summary>
        public static SearchEncryptionWithCmk Enabled { get; } = new SearchEncryptionWithCmk("Enabled");
        /// <summary>
        /// Enforcement policy is not explicitly specified, with the behavior being the same as if it were set to 'Disabled'.
        /// </summary>
        public static SearchEncryptionWithCmk Unspecified { get; } = new SearchEncryptionWithCmk("Unspecified");

        public static bool operator ==(SearchEncryptionWithCmk left, SearchEncryptionWithCmk right) => left.Equals(right);
        public static bool operator !=(SearchEncryptionWithCmk left, SearchEncryptionWithCmk right) => !left.Equals(right);

        public static explicit operator string(SearchEncryptionWithCmk value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SearchEncryptionWithCmk other && Equals(other);
        public bool Equals(SearchEncryptionWithCmk other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets options that control the availability of semantic search. This configuration is only possible for certain Azure Cognitive Search SKUs in certain locations.
    /// </summary>
    [EnumType]
    public readonly struct SearchSemanticSearch : IEquatable<SearchSemanticSearch>
    {
        private readonly string _value;

        private SearchSemanticSearch(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that semantic search is disabled for the search service. This is the default.
        /// </summary>
        public static SearchSemanticSearch Disabled { get; } = new SearchSemanticSearch("disabled");
        /// <summary>
        /// Enables semantic search on a search service and indicates that it is to be used within the limits of the free tier. This would cap the volume of semantic search requests and is offered at no extra charge.
        /// </summary>
        public static SearchSemanticSearch Free { get; } = new SearchSemanticSearch("free");
        /// <summary>
        /// Enables semantic search on a search service as a billable feature, with higher throughput and volume of semantic search queries.
        /// </summary>
        public static SearchSemanticSearch Standard { get; } = new SearchSemanticSearch("standard");

        public static bool operator ==(SearchSemanticSearch left, SearchSemanticSearch right) => left.Equals(right);
        public static bool operator !=(SearchSemanticSearch left, SearchSemanticSearch right) => !left.Equals(right);

        public static explicit operator string(SearchSemanticSearch value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SearchSemanticSearch other && Equals(other);
        public bool Equals(SearchSemanticSearch other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard, but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity'). 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per partition, up to 12 partitions.'
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Free tier, with no SLA guarantees and a subset of features offered to paid tiers.
        /// </summary>
        public static SkuName Free { get; } = new SkuName("free");
        /// <summary>
        /// Paid tier dedicated service with up to 3 replicas.
        /// </summary>
        public static SkuName Basic { get; } = new SkuName("basic");
        /// <summary>
        /// Paid tier dedicated service with up to 12 partitions and 12 replicas.
        /// </summary>
        public static SkuName Standard { get; } = new SkuName("standard");
        /// <summary>
        /// Similar to 'standard', but with more capacity per search unit.
        /// </summary>
        public static SkuName Standard2 { get; } = new SkuName("standard2");
        /// <summary>
        ///  The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
        /// </summary>
        public static SkuName Standard3 { get; } = new SkuName("standard3");
        /// <summary>
        /// Paid tier dedicated service that supports 1TB per partition, up to 12 partitions.
        /// </summary>
        public static SkuName StorageOptimizedL1 { get; } = new SkuName("storage_optimized_l1");
        /// <summary>
        /// Paid tier dedicated service that supports 2TB per partition, up to 12 partitions.
        /// </summary>
        public static SkuName StorageOptimizedL2 { get; } = new SkuName("storage_optimized_l2");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
