// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ServiceFabric.V20240201Preview
{
    /// <summary>
    /// The network traffic is allowed or denied.
    /// </summary>
    [EnumType]
    public readonly struct Access : IEquatable<Access>
    {
        private readonly string _value;

        private Access(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Access Allow { get; } = new Access("allow");
        public static Access Deny { get; } = new Access("deny");

        public static bool operator ==(Access left, Access right) => left.Equals(right);
        public static bool operator !=(Access left, Access right) => !left.Equals(right);

        public static explicit operator string(Access value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Access other && Equals(other);
        public bool Equals(Access other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when **clusterUpgradeMode** is set to 'Automatic'.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpgradeCadence : IEquatable<ClusterUpgradeCadence>
    {
        private readonly string _value;

        private ClusterUpgradeCadence(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cluster upgrade starts immediately after a new version is rolled out. Recommended for Test/Dev clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave0 { get; } = new ClusterUpgradeCadence("Wave0");
        /// <summary>
        /// Cluster upgrade starts 7 days after a new version is rolled out. Recommended for Pre-prod clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave1 { get; } = new ClusterUpgradeCadence("Wave1");
        /// <summary>
        /// Cluster upgrade starts 14 days after a new version is rolled out. Recommended for Production clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave2 { get; } = new ClusterUpgradeCadence("Wave2");

        public static bool operator ==(ClusterUpgradeCadence left, ClusterUpgradeCadence right) => left.Equals(right);
        public static bool operator !=(ClusterUpgradeCadence left, ClusterUpgradeCadence right) => !left.Equals(right);

        public static explicit operator string(ClusterUpgradeCadence value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpgradeCadence other && Equals(other);
        public bool Equals(ClusterUpgradeCadence other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The upgrade mode of the cluster when new Service Fabric runtime version is available.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpgradeMode : IEquatable<ClusterUpgradeMode>
    {
        private readonly string _value;

        private ClusterUpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The cluster will be automatically upgraded to the latest Service Fabric runtime version, **clusterUpgradeCadence** will determine when the upgrade starts after the new version becomes available.
        /// </summary>
        public static ClusterUpgradeMode Automatic { get; } = new ClusterUpgradeMode("Automatic");
        /// <summary>
        /// The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
        /// </summary>
        public static ClusterUpgradeMode Manual { get; } = new ClusterUpgradeMode("Manual");

        public static bool operator ==(ClusterUpgradeMode left, ClusterUpgradeMode right) => left.Equals(right);
        public static bool operator !=(ClusterUpgradeMode left, ClusterUpgradeMode right) => !left.Equals(right);

        public static explicit operator string(ClusterUpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpgradeMode other && Equals(other);
        public bool Equals(ClusterUpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network security rule direction.
    /// </summary>
    [EnumType]
    public readonly struct Direction : IEquatable<Direction>
    {
        private readonly string _value;

        private Direction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Direction Inbound { get; } = new Direction("inbound");
        public static Direction Outbound { get; } = new Direction("outbound");

        public static bool operator ==(Direction left, Direction right) => left.Equals(right);
        public static bool operator !=(Direction left, Direction right) => !left.Equals(right);

        public static explicit operator string(Direction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Direction other && Equals(other);
        public bool Equals(Direction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Available cluster add-on features
    /// </summary>
    [EnumType]
    public readonly struct ManagedClusterAddOnFeature : IEquatable<ManagedClusterAddOnFeature>
    {
        private readonly string _value;

        private ManagedClusterAddOnFeature(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Dns service
        /// </summary>
        public static ManagedClusterAddOnFeature DnsService { get; } = new ManagedClusterAddOnFeature("DnsService");
        /// <summary>
        /// Backup and restore service
        /// </summary>
        public static ManagedClusterAddOnFeature BackupRestoreService { get; } = new ManagedClusterAddOnFeature("BackupRestoreService");
        /// <summary>
        /// Resource monitor service
        /// </summary>
        public static ManagedClusterAddOnFeature ResourceMonitorService { get; } = new ManagedClusterAddOnFeature("ResourceMonitorService");

        public static bool operator ==(ManagedClusterAddOnFeature left, ManagedClusterAddOnFeature right) => left.Equals(right);
        public static bool operator !=(ManagedClusterAddOnFeature left, ManagedClusterAddOnFeature right) => !left.Equals(right);

        public static explicit operator string(ManagedClusterAddOnFeature value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedClusterAddOnFeature other && Equals(other);
        public bool Equals(ManagedClusterAddOnFeature other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network protocol this rule applies to.
    /// </summary>
    [EnumType]
    public readonly struct NsgProtocol : IEquatable<NsgProtocol>
    {
        private readonly string _value;

        private NsgProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NsgProtocol Http { get; } = new NsgProtocol("http");
        public static NsgProtocol Https { get; } = new NsgProtocol("https");
        public static NsgProtocol Tcp { get; } = new NsgProtocol("tcp");
        public static NsgProtocol Udp { get; } = new NsgProtocol("udp");
        public static NsgProtocol Icmp { get; } = new NsgProtocol("icmp");
        public static NsgProtocol Ah { get; } = new NsgProtocol("ah");
        public static NsgProtocol Esp { get; } = new NsgProtocol("esp");

        public static bool operator ==(NsgProtocol left, NsgProtocol right) => left.Equals(right);
        public static bool operator !=(NsgProtocol left, NsgProtocol right) => !left.Equals(right);

        public static explicit operator string(NsgProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NsgProtocol other && Equals(other);
        public bool Equals(NsgProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable or Disable apply network policies on private end point in the subnet.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointNetworkPolicies : IEquatable<PrivateEndpointNetworkPolicies>
    {
        private readonly string _value;

        private PrivateEndpointNetworkPolicies(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointNetworkPolicies Enabled { get; } = new PrivateEndpointNetworkPolicies("enabled");
        public static PrivateEndpointNetworkPolicies Disabled { get; } = new PrivateEndpointNetworkPolicies("disabled");

        public static bool operator ==(PrivateEndpointNetworkPolicies left, PrivateEndpointNetworkPolicies right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointNetworkPolicies left, PrivateEndpointNetworkPolicies right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointNetworkPolicies value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointNetworkPolicies other && Equals(other);
        public bool Equals(PrivateEndpointNetworkPolicies other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable or Disable apply network policies on private link service in the subnet.
    /// </summary>
    [EnumType]
    public readonly struct PrivateLinkServiceNetworkPolicies : IEquatable<PrivateLinkServiceNetworkPolicies>
    {
        private readonly string _value;

        private PrivateLinkServiceNetworkPolicies(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateLinkServiceNetworkPolicies Enabled { get; } = new PrivateLinkServiceNetworkPolicies("enabled");
        public static PrivateLinkServiceNetworkPolicies Disabled { get; } = new PrivateLinkServiceNetworkPolicies("disabled");

        public static bool operator ==(PrivateLinkServiceNetworkPolicies left, PrivateLinkServiceNetworkPolicies right) => left.Equals(right);
        public static bool operator !=(PrivateLinkServiceNetworkPolicies left, PrivateLinkServiceNetworkPolicies right) => !left.Equals(right);

        public static explicit operator string(PrivateLinkServiceNetworkPolicies value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateLinkServiceNetworkPolicies other && Equals(other);
        public bool Equals(PrivateLinkServiceNetworkPolicies other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the reference to the load balancer probe used by the load balancing rule.
    /// </summary>
    [EnumType]
    public readonly struct ProbeProtocol : IEquatable<ProbeProtocol>
    {
        private readonly string _value;

        private ProbeProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProbeProtocol Tcp { get; } = new ProbeProtocol("tcp");
        public static ProbeProtocol Http { get; } = new ProbeProtocol("http");
        public static ProbeProtocol Https { get; } = new ProbeProtocol("https");

        public static bool operator ==(ProbeProtocol left, ProbeProtocol right) => left.Equals(right);
        public static bool operator !=(ProbeProtocol left, ProbeProtocol right) => !left.Equals(right);

        public static explicit operator string(ProbeProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProbeProtocol other && Equals(other);
        public bool Equals(ProbeProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The reference to the transport protocol used by the load balancing rule.
    /// </summary>
    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Protocol Tcp { get; } = new Protocol("tcp");
        public static Protocol Udp { get; } = new Protocol("udp");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sku Name.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Basic requires a minimum of 3 nodes and allows only 1 node type.
        /// </summary>
        public static SkuName Basic { get; } = new SkuName("Basic");
        /// <summary>
        /// Requires a minimum of 5 nodes and allows 1 or more node type.
        /// </summary>
        public static SkuName Standard { get; } = new SkuName("Standard");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the update mode for Cross Az clusters.
    /// </summary>
    [EnumType]
    public readonly struct ZonalUpdateMode : IEquatable<ZonalUpdateMode>
    {
        private readonly string _value;

        private ZonalUpdateMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The cluster will use 5 upgrade domains for Cross Az Node types.
        /// </summary>
        public static ZonalUpdateMode Standard { get; } = new ZonalUpdateMode("Standard");
        /// <summary>
        /// The cluster will use a maximum of 3 upgrade domains per zone instead of 5 for Cross Az Node types for faster deployments.
        /// </summary>
        public static ZonalUpdateMode Fast { get; } = new ZonalUpdateMode("Fast");

        public static bool operator ==(ZonalUpdateMode left, ZonalUpdateMode right) => left.Equals(right);
        public static bool operator !=(ZonalUpdateMode left, ZonalUpdateMode right) => !left.Equals(right);

        public static explicit operator string(ZonalUpdateMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZonalUpdateMode other && Equals(other);
        public bool Equals(ZonalUpdateMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
