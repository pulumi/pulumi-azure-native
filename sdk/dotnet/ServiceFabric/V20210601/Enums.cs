// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.ServiceFabric.V20210601
{
    /// <summary>
    /// The activation Mode of the service package
    /// </summary>
    [EnumType]
    public readonly struct ArmServicePackageActivationMode : IEquatable<ArmServicePackageActivationMode>
    {
        private readonly string _value;

        private ArmServicePackageActivationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the application package activation mode will use shared process.
        /// </summary>
        public static ArmServicePackageActivationMode SharedProcess { get; } = new ArmServicePackageActivationMode("SharedProcess");
        /// <summary>
        /// Indicates the application package activation mode will use exclusive process.
        /// </summary>
        public static ArmServicePackageActivationMode ExclusiveProcess { get; } = new ArmServicePackageActivationMode("ExclusiveProcess");

        public static bool operator ==(ArmServicePackageActivationMode left, ArmServicePackageActivationMode right) => left.Equals(right);
        public static bool operator !=(ArmServicePackageActivationMode left, ArmServicePackageActivationMode right) => !left.Equals(right);

        public static explicit operator string(ArmServicePackageActivationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArmServicePackageActivationMode other && Equals(other);
        public bool Equals(ArmServicePackageActivationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The activation Mode of the service package
    /// </summary>
    [EnumType]
    public readonly struct ArmUpgradeFailureAction : IEquatable<ArmUpgradeFailureAction>
    {
        private readonly string _value;

        private ArmUpgradeFailureAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that a rollback of the upgrade will be performed by Service Fabric if the upgrade fails.
        /// </summary>
        public static ArmUpgradeFailureAction Rollback { get; } = new ArmUpgradeFailureAction("Rollback");
        /// <summary>
        /// Indicates that a manual repair will need to be performed by the administrator if the upgrade fails. Service Fabric will not proceed to the next upgrade domain automatically.
        /// </summary>
        public static ArmUpgradeFailureAction Manual { get; } = new ArmUpgradeFailureAction("Manual");

        public static bool operator ==(ArmUpgradeFailureAction left, ArmUpgradeFailureAction right) => left.Equals(right);
        public static bool operator !=(ArmUpgradeFailureAction left, ArmUpgradeFailureAction right) => !left.Equals(right);

        public static explicit operator string(ArmUpgradeFailureAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArmUpgradeFailureAction other && Equals(other);
        public bool Equals(ArmUpgradeFailureAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when **upgradeMode** is set to 'Automatic'.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpgradeCadence : IEquatable<ClusterUpgradeCadence>
    {
        private readonly string _value;

        private ClusterUpgradeCadence(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cluster upgrade starts immediately after a new version is rolled out. Recommended for Test/Dev clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave0 { get; } = new ClusterUpgradeCadence("Wave0");
        /// <summary>
        /// Cluster upgrade starts 7 days after a new version is rolled out. Recommended for Pre-prod clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave1 { get; } = new ClusterUpgradeCadence("Wave1");
        /// <summary>
        /// Cluster upgrade starts 14 days after a new version is rolled out. Recommended for Production clusters.
        /// </summary>
        public static ClusterUpgradeCadence Wave2 { get; } = new ClusterUpgradeCadence("Wave2");

        public static bool operator ==(ClusterUpgradeCadence left, ClusterUpgradeCadence right) => left.Equals(right);
        public static bool operator !=(ClusterUpgradeCadence left, ClusterUpgradeCadence right) => !left.Equals(right);

        public static explicit operator string(ClusterUpgradeCadence value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpgradeCadence other && Equals(other);
        public bool Equals(ClusterUpgradeCadence other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of managed identity for the resource.
    /// </summary>
    [EnumType]
    public readonly struct ManagedIdentityType : IEquatable<ManagedIdentityType>
    {
        private readonly string _value;

        private ManagedIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that system assigned identity is associated with the resource.
        /// </summary>
        public static ManagedIdentityType SystemAssigned { get; } = new ManagedIdentityType("SystemAssigned");
        /// <summary>
        /// Indicates that user assigned identity is associated with the resource.
        /// </summary>
        public static ManagedIdentityType UserAssigned { get; } = new ManagedIdentityType("UserAssigned");
        /// <summary>
        /// Indicates that both system assigned and user assigned identity are associated with the resource.
        /// </summary>
        public static ManagedIdentityType SystemAssigned_UserAssigned { get; } = new ManagedIdentityType("SystemAssigned, UserAssigned");
        /// <summary>
        /// Indicates that no identity is associated with the resource.
        /// </summary>
        public static ManagedIdentityType None { get; } = new ManagedIdentityType("None");

        public static bool operator ==(ManagedIdentityType left, ManagedIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedIdentityType left, ManagedIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedIdentityType other && Equals(other);
        public bool Equals(ManagedIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the move cost for the service.
    /// </summary>
    [EnumType]
    public readonly struct MoveCost : IEquatable<MoveCost>
    {
        private readonly string _value;

        private MoveCost(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Zero move cost. This value is zero.
        /// </summary>
        public static MoveCost Zero { get; } = new MoveCost("Zero");
        /// <summary>
        /// Specifies the move cost of the service as Low. The value is 1.
        /// </summary>
        public static MoveCost Low { get; } = new MoveCost("Low");
        /// <summary>
        /// Specifies the move cost of the service as Medium. The value is 2.
        /// </summary>
        public static MoveCost Medium { get; } = new MoveCost("Medium");
        /// <summary>
        /// Specifies the move cost of the service as High. The value is 3.
        /// </summary>
        public static MoveCost High { get; } = new MoveCost("High");

        public static bool operator ==(MoveCost left, MoveCost right) => left.Equals(right);
        public static bool operator !=(MoveCost left, MoveCost right) => !left.Equals(right);

        public static explicit operator string(MoveCost value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MoveCost other && Equals(other);
        public bool Equals(MoveCost other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The category of notification.
    /// </summary>
    [EnumType]
    public readonly struct NotificationCategory : IEquatable<NotificationCategory>
    {
        private readonly string _value;

        private NotificationCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Notification will be regarding wave progress.
        /// </summary>
        public static NotificationCategory WaveProgress { get; } = new NotificationCategory("WaveProgress");

        public static bool operator ==(NotificationCategory left, NotificationCategory right) => left.Equals(right);
        public static bool operator !=(NotificationCategory left, NotificationCategory right) => !left.Equals(right);

        public static explicit operator string(NotificationCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NotificationCategory other && Equals(other);
        public bool Equals(NotificationCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The notification channel indicates the type of receivers subscribed to the notification, either user or subscription.
    /// </summary>
    [EnumType]
    public readonly struct NotificationChannel : IEquatable<NotificationChannel>
    {
        private readonly string _value;

        private NotificationChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// For email user receivers. In this case, the parameter receivers should be a list of email addresses that will receive the notifications.
        /// </summary>
        public static NotificationChannel EmailUser { get; } = new NotificationChannel("EmailUser");
        /// <summary>
        /// For subscription receivers. In this case, the parameter receivers should be a list of roles of the subscription for the cluster (eg. Owner, AccountAdmin, etc) that will receive the notifications.
        /// </summary>
        public static NotificationChannel EmailSubscription { get; } = new NotificationChannel("EmailSubscription");

        public static bool operator ==(NotificationChannel left, NotificationChannel right) => left.Equals(right);
        public static bool operator !=(NotificationChannel left, NotificationChannel right) => !left.Equals(right);

        public static explicit operator string(NotificationChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NotificationChannel other && Equals(other);
        public bool Equals(NotificationChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The level of notification.
    /// </summary>
    [EnumType]
    public readonly struct NotificationLevel : IEquatable<NotificationLevel>
    {
        private readonly string _value;

        private NotificationLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Receive only critical notifications.
        /// </summary>
        public static NotificationLevel Critical { get; } = new NotificationLevel("Critical");
        /// <summary>
        /// Receive all notifications.
        /// </summary>
        public static NotificationLevel All { get; } = new NotificationLevel("All");

        public static bool operator ==(NotificationLevel left, NotificationLevel right) => left.Equals(right);
        public static bool operator !=(NotificationLevel left, NotificationLevel right) => !left.Equals(right);

        public static explicit operator string(NotificationLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NotificationLevel other && Equals(other);
        public bool Equals(NotificationLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the service is partitioned.
    /// </summary>
    [EnumType]
    public readonly struct PartitionScheme : IEquatable<PartitionScheme>
    {
        private readonly string _value;

        private PartitionScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.
        /// </summary>
        public static PartitionScheme Invalid { get; } = new PartitionScheme("Invalid");
        /// <summary>
        /// Indicates that the partition is based on string names, and is a SingletonPartitionSchemeDescription object, The value is 1.
        /// </summary>
        public static PartitionScheme Singleton { get; } = new PartitionScheme("Singleton");
        /// <summary>
        /// Indicates that the partition is based on Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription object. The value is 2.
        /// </summary>
        public static PartitionScheme UniformInt64Range { get; } = new PartitionScheme("UniformInt64Range");
        /// <summary>
        /// Indicates that the partition is based on string names, and is a NamedPartitionSchemeDescription object. The value is 3
        /// </summary>
        public static PartitionScheme Named { get; } = new PartitionScheme("Named");

        public static bool operator ==(PartitionScheme left, PartitionScheme right) => left.Equals(right);
        public static bool operator !=(PartitionScheme left, PartitionScheme right) => !left.Equals(right);

        public static explicit operator string(PartitionScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PartitionScheme other && Equals(other);
        public bool Equals(PartitionScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and Monitored.
    /// </summary>
    [EnumType]
    public readonly struct RollingUpgradeMode : IEquatable<RollingUpgradeMode>
    {
        private readonly string _value;

        private RollingUpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type. The value is zero.
        /// </summary>
        public static RollingUpgradeMode Invalid { get; } = new RollingUpgradeMode("Invalid");
        /// <summary>
        /// The upgrade will proceed automatically without performing any health monitoring. The value is 1
        /// </summary>
        public static RollingUpgradeMode UnmonitoredAuto { get; } = new RollingUpgradeMode("UnmonitoredAuto");
        /// <summary>
        /// The upgrade will stop after completing each upgrade domain, giving the opportunity to manually monitor health before proceeding. The value is 2
        /// </summary>
        public static RollingUpgradeMode UnmonitoredManual { get; } = new RollingUpgradeMode("UnmonitoredManual");
        /// <summary>
        /// The upgrade will stop after completing each upgrade domain and automatically monitor health before proceeding. The value is 3
        /// </summary>
        public static RollingUpgradeMode Monitored { get; } = new RollingUpgradeMode("Monitored");

        public static bool operator ==(RollingUpgradeMode left, RollingUpgradeMode right) => left.Equals(right);
        public static bool operator !=(RollingUpgradeMode left, RollingUpgradeMode right) => !left.Equals(right);

        public static explicit operator string(RollingUpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RollingUpgradeMode other && Equals(other);
        public bool Equals(RollingUpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
    /// </summary>
    [EnumType]
    public readonly struct ServiceCorrelationScheme : IEquatable<ServiceCorrelationScheme>
    {
        private readonly string _value;

        private ServiceCorrelationScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An invalid correlation scheme. Cannot be used. The value is zero.
        /// </summary>
        public static ServiceCorrelationScheme Invalid { get; } = new ServiceCorrelationScheme("Invalid");
        /// <summary>
        /// Indicates that this service has an affinity relationship with another service. Provided for backwards compatibility, consider preferring the Aligned or NonAlignedAffinity options. The value is 1.
        /// </summary>
        public static ServiceCorrelationScheme Affinity { get; } = new ServiceCorrelationScheme("Affinity");
        /// <summary>
        /// Aligned affinity ensures that the primaries of the partitions of the affinitized services are collocated on the same nodes. This is the default and is the same as selecting the Affinity scheme. The value is 2.
        /// </summary>
        public static ServiceCorrelationScheme AlignedAffinity { get; } = new ServiceCorrelationScheme("AlignedAffinity");
        /// <summary>
        /// Non-Aligned affinity guarantees that all replicas of each service will be placed on the same nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will be collocated. The value is 3.
        /// </summary>
        public static ServiceCorrelationScheme NonAlignedAffinity { get; } = new ServiceCorrelationScheme("NonAlignedAffinity");

        public static bool operator ==(ServiceCorrelationScheme left, ServiceCorrelationScheme right) => left.Equals(right);
        public static bool operator !=(ServiceCorrelationScheme left, ServiceCorrelationScheme right) => !left.Equals(right);

        public static explicit operator string(ServiceCorrelationScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceCorrelationScheme other && Equals(other);
        public bool Equals(ServiceCorrelationScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of service (Stateless or Stateful).
    /// </summary>
    [EnumType]
    public readonly struct ServiceKind : IEquatable<ServiceKind>
    {
        private readonly string _value;

        private ServiceKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the service kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero.
        /// </summary>
        public static ServiceKind Invalid { get; } = new ServiceKind("Invalid");
        /// <summary>
        /// Does not use Service Fabric to make its state highly available or reliable. The value is 1.
        /// </summary>
        public static ServiceKind Stateless { get; } = new ServiceKind("Stateless");
        /// <summary>
        /// Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
        /// </summary>
        public static ServiceKind Stateful { get; } = new ServiceKind("Stateful");

        public static bool operator ==(ServiceKind left, ServiceKind right) => left.Equals(right);
        public static bool operator !=(ServiceKind left, ServiceKind right) => !left.Equals(right);

        public static explicit operator string(ServiceKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceKind other && Equals(other);
        public bool Equals(ServiceKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The service load metric relative weight, compared to other metrics configured for this service, as a number.
    /// </summary>
    [EnumType]
    public readonly struct ServiceLoadMetricWeight : IEquatable<ServiceLoadMetricWeight>
    {
        private readonly string _value;

        private ServiceLoadMetricWeight(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disables resource balancing for this metric. This value is zero.
        /// </summary>
        public static ServiceLoadMetricWeight Zero { get; } = new ServiceLoadMetricWeight("Zero");
        /// <summary>
        /// Specifies the metric weight of the service load as Low. The value is 1.
        /// </summary>
        public static ServiceLoadMetricWeight Low { get; } = new ServiceLoadMetricWeight("Low");
        /// <summary>
        /// Specifies the metric weight of the service load as Medium. The value is 2.
        /// </summary>
        public static ServiceLoadMetricWeight Medium { get; } = new ServiceLoadMetricWeight("Medium");
        /// <summary>
        /// Specifies the metric weight of the service load as High. The value is 3.
        /// </summary>
        public static ServiceLoadMetricWeight High { get; } = new ServiceLoadMetricWeight("High");

        public static bool operator ==(ServiceLoadMetricWeight left, ServiceLoadMetricWeight right) => left.Equals(right);
        public static bool operator !=(ServiceLoadMetricWeight left, ServiceLoadMetricWeight right) => !left.Equals(right);

        public static explicit operator string(ServiceLoadMetricWeight value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceLoadMetricWeight other && Equals(other);
        public bool Equals(ServiceLoadMetricWeight other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of placement policy for a service fabric service. Following are the possible values.
    /// </summary>
    [EnumType]
    public readonly struct ServicePlacementPolicyType : IEquatable<ServicePlacementPolicyType>
    {
        private readonly string _value;

        private ServicePlacementPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates the type of the placement policy is invalid. All Service Fabric enumerations have the invalid type. The value is zero.
        /// </summary>
        public static ServicePlacementPolicyType Invalid { get; } = new ServicePlacementPolicyType("Invalid");
        /// <summary>
        /// Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or upgrade domain cannot be used for placement of this service. The value is 1.
        /// </summary>
        public static ServicePlacementPolicyType InvalidDomain { get; } = new ServicePlacementPolicyType("InvalidDomain");
        /// <summary>
        /// Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the service must be placed in a specific domain. The value is 2.
        /// </summary>
        public static ServicePlacementPolicyType RequiredDomain { get; } = new ServicePlacementPolicyType("RequiredDomain");
        /// <summary>
        /// Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the Primary replica for the partitions of the service should be located in a particular domain as an optimization. The value is 3.
        /// </summary>
        public static ServicePlacementPolicyType PreferredPrimaryDomain { get; } = new ServicePlacementPolicyType("PreferredPrimaryDomain");
        /// <summary>
        /// Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will disallow placement of any two replicas from the same partition in the same domain at any time. The value is 4.
        /// </summary>
        public static ServicePlacementPolicyType RequiredDomainDistribution { get; } = new ServicePlacementPolicyType("RequiredDomainDistribution");
        /// <summary>
        /// Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all replicas of a particular partition of the service should be placed atomically. The value is 5.
        /// </summary>
        public static ServicePlacementPolicyType NonPartiallyPlaceService { get; } = new ServicePlacementPolicyType("NonPartiallyPlaceService");

        public static bool operator ==(ServicePlacementPolicyType left, ServicePlacementPolicyType right) => left.Equals(right);
        public static bool operator !=(ServicePlacementPolicyType left, ServicePlacementPolicyType right) => !left.Equals(right);

        public static explicit operator string(ServicePlacementPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServicePlacementPolicyType other && Equals(other);
        public bool Equals(ServicePlacementPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property controls the logical grouping of VMs in upgrade domains (UDs). This property can't be modified if a node type with multiple Availability Zones is already present in the cluster.
    /// </summary>
    [EnumType]
    public readonly struct SfZonalUpgradeMode : IEquatable<SfZonalUpgradeMode>
    {
        private readonly string _value;

        private SfZonalUpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VMs under the node type are grouped into UDs and ignore the zone info in five UDs. This setting causes UDs across all zones to be upgraded at the same time. This deployment mode is faster for upgrades, we don't recommend it because it goes against the SDP guidelines, which state that the updates should be applied to one zone at a time.
        /// </summary>
        public static SfZonalUpgradeMode Parallel { get; } = new SfZonalUpgradeMode("Parallel");
        /// <summary>
        /// If this value is omitted or set to Hierarchical, VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone. This update process is safer for the cluster and the user application.
        /// </summary>
        public static SfZonalUpgradeMode Hierarchical { get; } = new SfZonalUpgradeMode("Hierarchical");

        public static bool operator ==(SfZonalUpgradeMode left, SfZonalUpgradeMode right) => left.Equals(right);
        public static bool operator !=(SfZonalUpgradeMode left, SfZonalUpgradeMode right) => !left.Equals(right);

        public static explicit operator string(SfZonalUpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SfZonalUpgradeMode other && Equals(other);
        public bool Equals(SfZonalUpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The upgrade mode of the cluster when new Service Fabric runtime version is available.
    /// </summary>
    [EnumType]
    public readonly struct UpgradeMode : IEquatable<UpgradeMode>
    {
        private readonly string _value;

        private UpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The cluster will be automatically upgraded to the latest Service Fabric runtime version, **upgradeWave** will determine when the upgrade starts after the new version becomes available.
        /// </summary>
        public static UpgradeMode Automatic { get; } = new UpgradeMode("Automatic");
        /// <summary>
        /// The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
        /// </summary>
        public static UpgradeMode Manual { get; } = new UpgradeMode("Manual");

        public static bool operator ==(UpgradeMode left, UpgradeMode right) => left.Equals(right);
        public static bool operator !=(UpgradeMode left, UpgradeMode right) => !left.Equals(right);

        public static explicit operator string(UpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradeMode other && Equals(other);
        public bool Equals(UpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property defines the upgrade mode for the virtual machine scale set, it is mandatory if a node type with multiple Availability Zones is added.
    /// </summary>
    [EnumType]
    public readonly struct VmssZonalUpgradeMode : IEquatable<VmssZonalUpgradeMode>
    {
        private readonly string _value;

        private VmssZonalUpgradeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Updates will happen in all Availability Zones at once for the virtual machine scale sets.
        /// </summary>
        public static VmssZonalUpgradeMode Parallel { get; } = new VmssZonalUpgradeMode("Parallel");
        /// <summary>
        /// VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone.
        /// </summary>
        public static VmssZonalUpgradeMode Hierarchical { get; } = new VmssZonalUpgradeMode("Hierarchical");

        public static bool operator ==(VmssZonalUpgradeMode left, VmssZonalUpgradeMode right) => left.Equals(right);
        public static bool operator !=(VmssZonalUpgradeMode left, VmssZonalUpgradeMode right) => !left.Equals(right);

        public static explicit operator string(VmssZonalUpgradeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmssZonalUpgradeMode other && Equals(other);
        public bool Equals(VmssZonalUpgradeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
