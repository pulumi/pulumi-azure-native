// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.ServiceFabric.V20211101Preview
{
    /// <summary>
    /// Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
    /// </summary>
    [AzureNativeResourceType("azure-native:servicefabric/v20211101preview:NodeType")]
    public partial class NodeType : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Additional managed data disks.
        /// </summary>
        [Output("additionalDataDisks")]
        public Output<ImmutableArray<Outputs.VmssDataDiskResponse>> AdditionalDataDisks { get; private set; } = null!;

        /// <summary>
        /// The range of ports from which cluster assigned port to Service Fabric applications.
        /// </summary>
        [Output("applicationPorts")]
        public Output<Outputs.EndpointRangeDescriptionResponse?> ApplicationPorts { get; private set; } = null!;

        /// <summary>
        /// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
        /// </summary>
        [Output("capacities")]
        public Output<ImmutableDictionary<string, string>?> Capacities { get; private set; } = null!;

        /// <summary>
        /// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
        /// </summary>
        [Output("dataDiskLetter")]
        public Output<string?> DataDiskLetter { get; private set; } = null!;

        /// <summary>
        /// Disk size for the managed disk attached to the vms on the node type in GBs.
        /// </summary>
        [Output("dataDiskSizeGB")]
        public Output<int?> DataDiskSizeGB { get; private set; } = null!;

        /// <summary>
        /// Managed data disk type. Specifies the storage account type for the managed disk
        /// </summary>
        [Output("dataDiskType")]
        public Output<string?> DataDiskType { get; private set; } = null!;

        /// <summary>
        /// Specifies whether the network interface is accelerated networking-enabled.
        /// </summary>
        [Output("enableAcceleratedNetworking")]
        public Output<bool?> EnableAcceleratedNetworking { get; private set; } = null!;

        /// <summary>
        /// Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself. Default: The Encryption at host will be disabled unless this property is set to true for the resource.
        /// </summary>
        [Output("enableEncryptionAtHost")]
        public Output<bool?> EnableEncryptionAtHost { get; private set; } = null!;

        /// <summary>
        /// The range of ephemeral ports that nodes in this node type should be configured with.
        /// </summary>
        [Output("ephemeralPorts")]
        public Output<Outputs.EndpointRangeDescriptionResponse?> EphemeralPorts { get; private set; } = null!;

        /// <summary>
        /// Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This setting can only be specified for non-primary node types and can not be added or removed after the node type is created.
        /// </summary>
        [Output("frontendConfigurations")]
        public Output<ImmutableArray<Outputs.FrontendConfigurationResponse>> FrontendConfigurations { get; private set; } = null!;

        /// <summary>
        /// Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot be changed once the node type is created.
        /// </summary>
        [Output("isPrimary")]
        public Output<bool> IsPrimary { get; private set; } = null!;

        /// <summary>
        /// Indicates if the node type can only host Stateless workloads.
        /// </summary>
        [Output("isStateless")]
        public Output<bool?> IsStateless { get; private set; } = null!;

        /// <summary>
        /// Indicates if scale set associated with the node type can be composed of multiple placement groups.
        /// </summary>
        [Output("multiplePlacementGroups")]
        public Output<bool?> MultiplePlacementGroups { get; private set; } = null!;

        /// <summary>
        /// Azure resource name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The Network Security Rules for this node type. This setting can only be specified for node types that are configured with frontend configurations.
        /// </summary>
        [Output("networkSecurityRules")]
        public Output<ImmutableArray<Outputs.NetworkSecurityRuleResponse>> NetworkSecurityRules { get; private set; } = null!;

        /// <summary>
        /// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
        /// </summary>
        [Output("placementProperties")]
        public Output<ImmutableDictionary<string, string>?> PlacementProperties { get; private set; } = null!;

        /// <summary>
        /// The provisioning state of the node type resource.
        /// </summary>
        [Output("provisioningState")]
        public Output<string> ProvisioningState { get; private set; } = null!;

        /// <summary>
        /// The node type sku.
        /// </summary>
        [Output("sku")]
        public Output<Outputs.NodeTypeSkuResponse?> Sku { get; private set; } = null!;

        /// <summary>
        /// Metadata pertaining to creation and last modification of the resource.
        /// </summary>
        [Output("systemData")]
        public Output<Outputs.SystemDataResponse> SystemData { get; private set; } = null!;

        /// <summary>
        /// Azure resource tags.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// Azure resource type.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// Specifies whether the use public load balancer. If not specified and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
        /// </summary>
        [Output("useDefaultPublicLoadBalancer")]
        public Output<bool?> UseDefaultPublicLoadBalancer { get; private set; } = null!;

        /// <summary>
        /// Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for stateless node types.
        /// </summary>
        [Output("useTempDataDisk")]
        public Output<bool?> UseTempDataDisk { get; private set; } = null!;

        /// <summary>
        /// Set of extensions that should be installed onto the virtual machines.
        /// </summary>
        [Output("vmExtensions")]
        public Output<ImmutableArray<Outputs.VMSSExtensionResponse>> VmExtensions { get; private set; } = null!;

        /// <summary>
        /// The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer.
        /// </summary>
        [Output("vmImageOffer")]
        public Output<string?> VmImageOffer { get; private set; } = null!;

        /// <summary>
        /// The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer.
        /// </summary>
        [Output("vmImagePublisher")]
        public Output<string?> VmImagePublisher { get; private set; } = null!;

        /// <summary>
        /// The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
        /// </summary>
        [Output("vmImageSku")]
        public Output<string?> VmImageSku { get; private set; } = null!;

        /// <summary>
        /// The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
        /// </summary>
        [Output("vmImageVersion")]
        public Output<string?> VmImageVersion { get; private set; } = null!;

        /// <summary>
        /// The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:** &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not supported &lt;br /&gt; &gt;0 - Use for manual scale.
        /// </summary>
        [Output("vmInstanceCount")]
        public Output<int> VmInstanceCount { get; private set; } = null!;

        /// <summary>
        /// Identities to assign to the virtual machine scale set under the node type.
        /// </summary>
        [Output("vmManagedIdentity")]
        public Output<Outputs.VmManagedIdentityResponse?> VmManagedIdentity { get; private set; } = null!;

        /// <summary>
        /// The secrets to install in the virtual machines.
        /// </summary>
        [Output("vmSecrets")]
        public Output<ImmutableArray<Outputs.VaultSecretGroupResponse>> VmSecrets { get; private set; } = null!;

        /// <summary>
        /// The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example, Standard_D3.
        /// </summary>
        [Output("vmSize")]
        public Output<string?> VmSize { get; private set; } = null!;


        /// <summary>
        /// Create a NodeType resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public NodeType(string name, NodeTypeArgs args, CustomResourceOptions? options = null)
            : base("azure-native:servicefabric/v20211101preview:NodeType", name, args ?? new NodeTypeArgs(), MakeResourceOptions(options, ""))
        {
        }

        private NodeType(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("azure-native:servicefabric/v20211101preview:NodeType", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20200101preview:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20210101preview:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20210501:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20210701preview:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20210901privatepreview:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20220101:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20220201preview:NodeType"},
                    new global::Pulumi.Alias { Type = "azure-native:servicefabric/v20220601preview:NodeType"},
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing NodeType resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static NodeType Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new NodeType(name, id, options);
        }
    }

    public sealed class NodeTypeArgs : global::Pulumi.ResourceArgs
    {
        [Input("additionalDataDisks")]
        private InputList<Inputs.VmssDataDiskArgs>? _additionalDataDisks;

        /// <summary>
        /// Additional managed data disks.
        /// </summary>
        public InputList<Inputs.VmssDataDiskArgs> AdditionalDataDisks
        {
            get => _additionalDataDisks ?? (_additionalDataDisks = new InputList<Inputs.VmssDataDiskArgs>());
            set => _additionalDataDisks = value;
        }

        /// <summary>
        /// The range of ports from which cluster assigned port to Service Fabric applications.
        /// </summary>
        [Input("applicationPorts")]
        public Input<Inputs.EndpointRangeDescriptionArgs>? ApplicationPorts { get; set; }

        [Input("capacities")]
        private InputMap<string>? _capacities;

        /// <summary>
        /// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
        /// </summary>
        public InputMap<string> Capacities
        {
            get => _capacities ?? (_capacities = new InputMap<string>());
            set => _capacities = value;
        }

        /// <summary>
        /// The name of the cluster resource.
        /// </summary>
        [Input("clusterName", required: true)]
        public Input<string> ClusterName { get; set; } = null!;

        /// <summary>
        /// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
        /// </summary>
        [Input("dataDiskLetter")]
        public Input<string>? DataDiskLetter { get; set; }

        /// <summary>
        /// Disk size for the managed disk attached to the vms on the node type in GBs.
        /// </summary>
        [Input("dataDiskSizeGB")]
        public Input<int>? DataDiskSizeGB { get; set; }

        /// <summary>
        /// Managed data disk type. Specifies the storage account type for the managed disk
        /// </summary>
        [Input("dataDiskType")]
        public InputUnion<string, Pulumi.AzureNative.ServiceFabric.V20211101Preview.DiskType>? DataDiskType { get; set; }

        /// <summary>
        /// Specifies whether the network interface is accelerated networking-enabled.
        /// </summary>
        [Input("enableAcceleratedNetworking")]
        public Input<bool>? EnableAcceleratedNetworking { get; set; }

        /// <summary>
        /// Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself. Default: The Encryption at host will be disabled unless this property is set to true for the resource.
        /// </summary>
        [Input("enableEncryptionAtHost")]
        public Input<bool>? EnableEncryptionAtHost { get; set; }

        /// <summary>
        /// The range of ephemeral ports that nodes in this node type should be configured with.
        /// </summary>
        [Input("ephemeralPorts")]
        public Input<Inputs.EndpointRangeDescriptionArgs>? EphemeralPorts { get; set; }

        [Input("frontendConfigurations")]
        private InputList<Inputs.FrontendConfigurationArgs>? _frontendConfigurations;

        /// <summary>
        /// Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This setting can only be specified for non-primary node types and can not be added or removed after the node type is created.
        /// </summary>
        public InputList<Inputs.FrontendConfigurationArgs> FrontendConfigurations
        {
            get => _frontendConfigurations ?? (_frontendConfigurations = new InputList<Inputs.FrontendConfigurationArgs>());
            set => _frontendConfigurations = value;
        }

        /// <summary>
        /// Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot be changed once the node type is created.
        /// </summary>
        [Input("isPrimary", required: true)]
        public Input<bool> IsPrimary { get; set; } = null!;

        /// <summary>
        /// Indicates if the node type can only host Stateless workloads.
        /// </summary>
        [Input("isStateless")]
        public Input<bool>? IsStateless { get; set; }

        /// <summary>
        /// Indicates if scale set associated with the node type can be composed of multiple placement groups.
        /// </summary>
        [Input("multiplePlacementGroups")]
        public Input<bool>? MultiplePlacementGroups { get; set; }

        [Input("networkSecurityRules")]
        private InputList<Inputs.NetworkSecurityRuleArgs>? _networkSecurityRules;

        /// <summary>
        /// The Network Security Rules for this node type. This setting can only be specified for node types that are configured with frontend configurations.
        /// </summary>
        public InputList<Inputs.NetworkSecurityRuleArgs> NetworkSecurityRules
        {
            get => _networkSecurityRules ?? (_networkSecurityRules = new InputList<Inputs.NetworkSecurityRuleArgs>());
            set => _networkSecurityRules = value;
        }

        /// <summary>
        /// The name of the node type.
        /// </summary>
        [Input("nodeTypeName")]
        public Input<string>? NodeTypeName { get; set; }

        [Input("placementProperties")]
        private InputMap<string>? _placementProperties;

        /// <summary>
        /// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
        /// </summary>
        public InputMap<string> PlacementProperties
        {
            get => _placementProperties ?? (_placementProperties = new InputMap<string>());
            set => _placementProperties = value;
        }

        /// <summary>
        /// The name of the resource group.
        /// </summary>
        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        /// <summary>
        /// The node type sku.
        /// </summary>
        [Input("sku")]
        public Input<Inputs.NodeTypeSkuArgs>? Sku { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Azure resource tags.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Specifies whether the use public load balancer. If not specified and the node type doesn't have its own frontend configuration, it will be attached to the default load balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
        /// </summary>
        [Input("useDefaultPublicLoadBalancer")]
        public Input<bool>? UseDefaultPublicLoadBalancer { get; set; }

        /// <summary>
        /// Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for stateless node types.
        /// </summary>
        [Input("useTempDataDisk")]
        public Input<bool>? UseTempDataDisk { get; set; }

        [Input("vmExtensions")]
        private InputList<Inputs.VMSSExtensionArgs>? _vmExtensions;

        /// <summary>
        /// Set of extensions that should be installed onto the virtual machines.
        /// </summary>
        public InputList<Inputs.VMSSExtensionArgs> VmExtensions
        {
            get => _vmExtensions ?? (_vmExtensions = new InputList<Inputs.VMSSExtensionArgs>());
            set => _vmExtensions = value;
        }

        /// <summary>
        /// The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer.
        /// </summary>
        [Input("vmImageOffer")]
        public Input<string>? VmImageOffer { get; set; }

        /// <summary>
        /// The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer.
        /// </summary>
        [Input("vmImagePublisher")]
        public Input<string>? VmImagePublisher { get; set; }

        /// <summary>
        /// The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
        /// </summary>
        [Input("vmImageSku")]
        public Input<string>? VmImageSku { get; set; }

        /// <summary>
        /// The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
        /// </summary>
        [Input("vmImageVersion")]
        public Input<string>? VmImageVersion { get; set; }

        /// <summary>
        /// The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:** &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not supported &lt;br /&gt; &gt;0 - Use for manual scale.
        /// </summary>
        [Input("vmInstanceCount", required: true)]
        public Input<int> VmInstanceCount { get; set; } = null!;

        /// <summary>
        /// Identities to assign to the virtual machine scale set under the node type.
        /// </summary>
        [Input("vmManagedIdentity")]
        public Input<Inputs.VmManagedIdentityArgs>? VmManagedIdentity { get; set; }

        [Input("vmSecrets")]
        private InputList<Inputs.VaultSecretGroupArgs>? _vmSecrets;

        /// <summary>
        /// The secrets to install in the virtual machines.
        /// </summary>
        public InputList<Inputs.VaultSecretGroupArgs> VmSecrets
        {
            get => _vmSecrets ?? (_vmSecrets = new InputList<Inputs.VaultSecretGroupArgs>());
            set => _vmSecrets = value;
        }

        /// <summary>
        /// The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example, Standard_D3.
        /// </summary>
        [Input("vmSize")]
        public Input<string>? VmSize { get; set; }

        public NodeTypeArgs()
        {
            EnableEncryptionAtHost = false;
            IsStateless = false;
            MultiplePlacementGroups = false;
        }
        public static new NodeTypeArgs Empty => new NodeTypeArgs();
    }
}
