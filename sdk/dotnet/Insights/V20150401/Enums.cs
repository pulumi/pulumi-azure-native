// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.Insights.V20150401
{
    /// <summary>
    /// the operator that is used to compare the metric data and the threshold.
    /// </summary>
    [EnumType]
    public readonly struct ComparisonOperationType : IEquatable<ComparisonOperationType>
    {
        private readonly string _value;

        private ComparisonOperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComparisonOperationType EqualsValue { get; } = new ComparisonOperationType("Equals");
        public static ComparisonOperationType NotEquals { get; } = new ComparisonOperationType("NotEquals");
        public static ComparisonOperationType GreaterThan { get; } = new ComparisonOperationType("GreaterThan");
        public static ComparisonOperationType GreaterThanOrEqual { get; } = new ComparisonOperationType("GreaterThanOrEqual");
        public static ComparisonOperationType LessThan { get; } = new ComparisonOperationType("LessThan");
        public static ComparisonOperationType LessThanOrEqual { get; } = new ComparisonOperationType("LessThanOrEqual");

        public static bool operator ==(ComparisonOperationType left, ComparisonOperationType right) => left.Equals(right);
        public static bool operator !=(ComparisonOperationType left, ComparisonOperationType right) => !left.Equals(right);

        public static explicit operator string(ComparisonOperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComparisonOperationType other && Equals(other);
        public bool Equals(ComparisonOperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the metric statistic type. How the metrics from multiple instances are combined.
    /// </summary>
    [EnumType]
    public readonly struct MetricStatisticType : IEquatable<MetricStatisticType>
    {
        private readonly string _value;

        private MetricStatisticType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetricStatisticType Average { get; } = new MetricStatisticType("Average");
        public static MetricStatisticType Min { get; } = new MetricStatisticType("Min");
        public static MetricStatisticType Max { get; } = new MetricStatisticType("Max");
        public static MetricStatisticType Sum { get; } = new MetricStatisticType("Sum");

        public static bool operator ==(MetricStatisticType left, MetricStatisticType right) => left.Equals(right);
        public static bool operator !=(MetricStatisticType left, MetricStatisticType right) => !left.Equals(right);

        public static explicit operator string(MetricStatisticType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricStatisticType other && Equals(other);
        public bool Equals(MetricStatisticType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the operation associated with the notification and its value must be "scale"
    /// </summary>
    [EnumType]
    public readonly struct OperationType : IEquatable<OperationType>
    {
        private readonly string _value;

        private OperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperationType Scale { get; } = new OperationType("Scale");

        public static bool operator ==(OperationType left, OperationType right) => left.Equals(right);
        public static bool operator !=(OperationType left, OperationType right) => !left.Equals(right);

        public static explicit operator string(OperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationType other && Equals(other);
        public bool Equals(OperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
    /// </summary>
    [EnumType]
    public readonly struct RecurrenceFrequency : IEquatable<RecurrenceFrequency>
    {
        private readonly string _value;

        private RecurrenceFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecurrenceFrequency None { get; } = new RecurrenceFrequency("None");
        public static RecurrenceFrequency Second { get; } = new RecurrenceFrequency("Second");
        public static RecurrenceFrequency Minute { get; } = new RecurrenceFrequency("Minute");
        public static RecurrenceFrequency Hour { get; } = new RecurrenceFrequency("Hour");
        public static RecurrenceFrequency Day { get; } = new RecurrenceFrequency("Day");
        public static RecurrenceFrequency Week { get; } = new RecurrenceFrequency("Week");
        public static RecurrenceFrequency Month { get; } = new RecurrenceFrequency("Month");
        public static RecurrenceFrequency Year { get; } = new RecurrenceFrequency("Year");

        public static bool operator ==(RecurrenceFrequency left, RecurrenceFrequency right) => left.Equals(right);
        public static bool operator !=(RecurrenceFrequency left, RecurrenceFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurrenceFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurrenceFrequency other && Equals(other);
        public bool Equals(RecurrenceFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the scale direction. Whether the scaling action increases or decreases the number of instances.
    /// </summary>
    [EnumType]
    public readonly struct ScaleDirection : IEquatable<ScaleDirection>
    {
        private readonly string _value;

        private ScaleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleDirection None { get; } = new ScaleDirection("None");
        public static ScaleDirection Increase { get; } = new ScaleDirection("Increase");
        public static ScaleDirection Decrease { get; } = new ScaleDirection("Decrease");

        public static bool operator ==(ScaleDirection left, ScaleDirection right) => left.Equals(right);
        public static bool operator !=(ScaleDirection left, ScaleDirection right) => !left.Equals(right);

        public static explicit operator string(ScaleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleDirection other && Equals(other);
        public bool Equals(ScaleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
    /// </summary>
    [EnumType]
    public readonly struct ScaleRuleMetricDimensionOperationType : IEquatable<ScaleRuleMetricDimensionOperationType>
    {
        private readonly string _value;

        private ScaleRuleMetricDimensionOperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleRuleMetricDimensionOperationType EqualsValue { get; } = new ScaleRuleMetricDimensionOperationType("Equals");
        public static ScaleRuleMetricDimensionOperationType NotEquals { get; } = new ScaleRuleMetricDimensionOperationType("NotEquals");

        public static bool operator ==(ScaleRuleMetricDimensionOperationType left, ScaleRuleMetricDimensionOperationType right) => left.Equals(right);
        public static bool operator !=(ScaleRuleMetricDimensionOperationType left, ScaleRuleMetricDimensionOperationType right) => !left.Equals(right);

        public static explicit operator string(ScaleRuleMetricDimensionOperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleRuleMetricDimensionOperationType other && Equals(other);
        public bool Equals(ScaleRuleMetricDimensionOperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// the type of action that should occur when the scale rule fires.
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType ChangeCount { get; } = new ScaleType("ChangeCount");
        public static ScaleType PercentChangeCount { get; } = new ScaleType("PercentChangeCount");
        public static ScaleType ExactCount { get; } = new ScaleType("ExactCount");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
    /// </summary>
    [EnumType]
    public readonly struct TimeAggregationType : IEquatable<TimeAggregationType>
    {
        private readonly string _value;

        private TimeAggregationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TimeAggregationType Average { get; } = new TimeAggregationType("Average");
        public static TimeAggregationType Minimum { get; } = new TimeAggregationType("Minimum");
        public static TimeAggregationType Maximum { get; } = new TimeAggregationType("Maximum");
        public static TimeAggregationType Total { get; } = new TimeAggregationType("Total");
        public static TimeAggregationType Count { get; } = new TimeAggregationType("Count");
        public static TimeAggregationType Last { get; } = new TimeAggregationType("Last");

        public static bool operator ==(TimeAggregationType left, TimeAggregationType right) => left.Equals(right);
        public static bool operator !=(TimeAggregationType left, TimeAggregationType right) => !left.Equals(right);

        public static explicit operator string(TimeAggregationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeAggregationType other && Equals(other);
        public bool Equals(TimeAggregationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
