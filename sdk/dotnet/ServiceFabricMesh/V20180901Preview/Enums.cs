// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.ServiceFabricMesh.V20180901Preview
{
    /// <summary>
    /// Specifies the application-scoped volume kind.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationScopedVolumeKind : IEquatable<ApplicationScopedVolumeKind>
    {
        private readonly string _value;

        private ApplicationScopedVolumeKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Provides Service Fabric High Availability Volume Disk
        /// </summary>
        public static ApplicationScopedVolumeKind ServiceFabricVolumeDisk { get; } = new ApplicationScopedVolumeKind("ServiceFabricVolumeDisk");

        public static bool operator ==(ApplicationScopedVolumeKind left, ApplicationScopedVolumeKind right) => left.Equals(right);
        public static bool operator !=(ApplicationScopedVolumeKind left, ApplicationScopedVolumeKind right) => !left.Equals(right);

        public static explicit operator string(ApplicationScopedVolumeKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationScopedVolumeKind other && Equals(other);
        public bool Equals(ApplicationScopedVolumeKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of auto scaling mechanism.
    /// </summary>
    [EnumType]
    public readonly struct AutoScalingMechanismKind : IEquatable<AutoScalingMechanismKind>
    {
        private readonly string _value;

        private AutoScalingMechanismKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that scaling should be performed by adding or removing replicas.
        /// </summary>
        public static AutoScalingMechanismKind AddRemoveReplica { get; } = new AutoScalingMechanismKind("AddRemoveReplica");

        public static bool operator ==(AutoScalingMechanismKind left, AutoScalingMechanismKind right) => left.Equals(right);
        public static bool operator !=(AutoScalingMechanismKind left, AutoScalingMechanismKind right) => !left.Equals(right);

        public static explicit operator string(AutoScalingMechanismKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoScalingMechanismKind other && Equals(other);
        public bool Equals(AutoScalingMechanismKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of auto scaling metric
    /// </summary>
    [EnumType]
    public readonly struct AutoScalingMetricKind : IEquatable<AutoScalingMetricKind>
    {
        private readonly string _value;

        private AutoScalingMetricKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that the metric is one of resources, like cpu or memory.
        /// </summary>
        public static AutoScalingMetricKind Resource { get; } = new AutoScalingMetricKind("Resource");

        public static bool operator ==(AutoScalingMetricKind left, AutoScalingMetricKind right) => left.Equals(right);
        public static bool operator !=(AutoScalingMetricKind left, AutoScalingMetricKind right) => !left.Equals(right);

        public static explicit operator string(AutoScalingMetricKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoScalingMetricKind other && Equals(other);
        public bool Equals(AutoScalingMetricKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the resource.
    /// </summary>
    [EnumType]
    public readonly struct AutoScalingResourceMetricName : IEquatable<AutoScalingResourceMetricName>
    {
        private readonly string _value;

        private AutoScalingResourceMetricName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that the resource is CPU cores.
        /// </summary>
        public static AutoScalingResourceMetricName Cpu { get; } = new AutoScalingResourceMetricName("cpu");
        /// <summary>
        /// Indicates that the resource is memory in GB.
        /// </summary>
        public static AutoScalingResourceMetricName MemoryInGB { get; } = new AutoScalingResourceMetricName("memoryInGB");

        public static bool operator ==(AutoScalingResourceMetricName left, AutoScalingResourceMetricName right) => left.Equals(right);
        public static bool operator !=(AutoScalingResourceMetricName left, AutoScalingResourceMetricName right) => !left.Equals(right);

        public static explicit operator string(AutoScalingResourceMetricName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoScalingResourceMetricName other && Equals(other);
        public bool Equals(AutoScalingResourceMetricName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of auto scaling trigger
    /// </summary>
    [EnumType]
    public readonly struct AutoScalingTriggerKind : IEquatable<AutoScalingTriggerKind>
    {
        private readonly string _value;

        private AutoScalingTriggerKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that scaling should be performed based on average load of all replicas in the service.
        /// </summary>
        public static AutoScalingTriggerKind AverageLoad { get; } = new AutoScalingTriggerKind("AverageLoad");

        public static bool operator ==(AutoScalingTriggerKind left, AutoScalingTriggerKind right) => left.Equals(right);
        public static bool operator !=(AutoScalingTriggerKind left, AutoScalingTriggerKind right) => !left.Equals(right);

        public static explicit operator string(AutoScalingTriggerKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoScalingTriggerKind other && Equals(other);
        public bool Equals(AutoScalingTriggerKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of DiagnosticsSink.
    /// </summary>
    [EnumType]
    public readonly struct DiagnosticsSinkKind : IEquatable<DiagnosticsSinkKind>
    {
        private readonly string _value;

        private DiagnosticsSinkKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates an invalid sink kind. All Service Fabric enumerations have the invalid type.
        /// </summary>
        public static DiagnosticsSinkKind Invalid { get; } = new DiagnosticsSinkKind("Invalid");
        /// <summary>
        /// Diagnostics settings for Geneva.
        /// </summary>
        public static DiagnosticsSinkKind AzureInternalMonitoringPipeline { get; } = new DiagnosticsSinkKind("AzureInternalMonitoringPipeline");

        public static bool operator ==(DiagnosticsSinkKind left, DiagnosticsSinkKind right) => left.Equals(right);
        public static bool operator !=(DiagnosticsSinkKind left, DiagnosticsSinkKind right) => !left.Equals(right);

        public static explicit operator string(DiagnosticsSinkKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiagnosticsSinkKind other && Equals(other);
        public bool Equals(DiagnosticsSinkKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// how to match header value
    /// </summary>
    [EnumType]
    public readonly struct HeaderMatchType : IEquatable<HeaderMatchType>
    {
        private readonly string _value;

        private HeaderMatchType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HeaderMatchType Exact { get; } = new HeaderMatchType("exact");

        public static bool operator ==(HeaderMatchType left, HeaderMatchType right) => left.Equals(right);
        public static bool operator !=(HeaderMatchType left, HeaderMatchType right) => !left.Equals(right);

        public static explicit operator string(HeaderMatchType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HeaderMatchType other && Equals(other);
        public bool Equals(HeaderMatchType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of a Service Fabric container network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkKind : IEquatable<NetworkKind>
    {
        private readonly string _value;

        private NetworkKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates a container network local to a single Service Fabric cluster. The value is 1.
        /// </summary>
        public static NetworkKind Local { get; } = new NetworkKind("Local");

        public static bool operator ==(NetworkKind left, NetworkKind right) => left.Equals(right);
        public static bool operator !=(NetworkKind left, NetworkKind right) => !left.Equals(right);

        public static explicit operator string(NetworkKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkKind other && Equals(other);
        public bool Equals(NetworkKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operation system required by the code in service.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemType : IEquatable<OperatingSystemType>
    {
        private readonly string _value;

        private OperatingSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The required operating system is Linux.
        /// </summary>
        public static OperatingSystemType Linux { get; } = new OperatingSystemType("Linux");
        /// <summary>
        /// The required operating system is Windows.
        /// </summary>
        public static OperatingSystemType Windows { get; } = new OperatingSystemType("Windows");

        public static bool operator ==(OperatingSystemType left, OperatingSystemType right) => left.Equals(right);
        public static bool operator !=(OperatingSystemType left, OperatingSystemType right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemType other && Equals(other);
        public bool Equals(OperatingSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// how to match value in the Uri
    /// </summary>
    [EnumType]
    public readonly struct PathMatchType : IEquatable<PathMatchType>
    {
        private readonly string _value;

        private PathMatchType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PathMatchType Prefix { get; } = new PathMatchType("prefix");

        public static bool operator ==(PathMatchType left, PathMatchType right) => left.Equals(right);
        public static bool operator !=(PathMatchType left, PathMatchType right) => !left.Equals(right);

        public static explicit operator string(PathMatchType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PathMatchType other && Equals(other);
        public bool Equals(PathMatchType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes the kind of secret.
    /// </summary>
    [EnumType]
    public readonly struct SecretKind : IEquatable<SecretKind>
    {
        private readonly string _value;

        private SecretKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A simple secret resource whose plaintext value is provided by the user.
        /// </summary>
        public static SecretKind InlinedValue { get; } = new SecretKind("inlinedValue");

        public static bool operator ==(SecretKind left, SecretKind right) => left.Equals(right);
        public static bool operator !=(SecretKind left, SecretKind right) => !left.Equals(right);

        public static explicit operator string(SecretKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecretKind other && Equals(other);
        public bool Equals(SecretKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Volume size
    /// </summary>
    [EnumType]
    public readonly struct SizeTypes : IEquatable<SizeTypes>
    {
        private readonly string _value;

        private SizeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SizeTypes Small { get; } = new SizeTypes("Small");
        public static SizeTypes Medium { get; } = new SizeTypes("Medium");
        public static SizeTypes Large { get; } = new SizeTypes("Large");

        public static bool operator ==(SizeTypes left, SizeTypes right) => left.Equals(right);
        public static bool operator !=(SizeTypes left, SizeTypes right) => !left.Equals(right);

        public static explicit operator string(SizeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SizeTypes other && Equals(other);
        public bool Equals(SizeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provider of the volume.
    /// </summary>
    [EnumType]
    public readonly struct VolumeProvider : IEquatable<VolumeProvider>
    {
        private readonly string _value;

        private VolumeProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Provides volumes that are backed by Azure Files.
        /// </summary>
        public static VolumeProvider SFAzureFile { get; } = new VolumeProvider("SFAzureFile");

        public static bool operator ==(VolumeProvider left, VolumeProvider right) => left.Equals(right);
        public static bool operator !=(VolumeProvider left, VolumeProvider right) => !left.Equals(right);

        public static explicit operator string(VolumeProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VolumeProvider other && Equals(other);
        public bool Equals(VolumeProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
