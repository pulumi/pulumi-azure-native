// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.Storage.V20230101
{
    /// <summary>
    /// Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs storage account type.
    /// </summary>
    [EnumType]
    public readonly struct AccessTier : IEquatable<AccessTier>
    {
        private readonly string _value;

        private AccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessTier Hot { get; } = new AccessTier("Hot");
        public static AccessTier Cool { get; } = new AccessTier("Cool");
        public static AccessTier Premium { get; } = new AccessTier("Premium");

        public static bool operator ==(AccessTier left, AccessTier right) => left.Equals(right);
        public static bool operator !=(AccessTier left, AccessTier right) => !left.Equals(right);

        public static explicit operator string(AccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessTier other && Equals(other);
        public bool Equals(AccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted.
    /// </summary>
    [EnumType]
    public readonly struct AccountImmutabilityPolicyState : IEquatable<AccountImmutabilityPolicyState>
    {
        private readonly string _value;

        private AccountImmutabilityPolicyState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountImmutabilityPolicyState Unlocked { get; } = new AccountImmutabilityPolicyState("Unlocked");
        public static AccountImmutabilityPolicyState Locked { get; } = new AccountImmutabilityPolicyState("Locked");
        public static AccountImmutabilityPolicyState Disabled { get; } = new AccountImmutabilityPolicyState("Disabled");

        public static bool operator ==(AccountImmutabilityPolicyState left, AccountImmutabilityPolicyState right) => left.Equals(right);
        public static bool operator !=(AccountImmutabilityPolicyState left, AccountImmutabilityPolicyState right) => !left.Equals(right);

        public static explicit operator string(AccountImmutabilityPolicyState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountImmutabilityPolicyState other && Equals(other);
        public bool Equals(AccountImmutabilityPolicyState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the Active Directory account type for Azure Storage.
    /// </summary>
    [EnumType]
    public readonly struct AccountType : IEquatable<AccountType>
    {
        private readonly string _value;

        private AccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountType User { get; } = new AccountType("User");
        public static AccountType Computer { get; } = new AccountType("Computer");

        public static bool operator ==(AccountType left, AccountType right) => left.Equals(right);
        public static bool operator !=(AccountType left, AccountType right) => !left.Equals(right);

        public static explicit operator string(AccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountType other && Equals(other);
        public bool Equals(AccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action of virtual network rule.
    /// </summary>
    [EnumType]
    public readonly struct Action : IEquatable<Action>
    {
        private readonly string _value;

        private Action(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Action Allow { get; } = new Action("Allow");

        public static bool operator ==(Action left, Action right) => left.Equals(right);
        public static bool operator !=(Action left, Action right) => !left.Equals(right);

        public static explicit operator string(Action value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Action other && Equals(other);
        public bool Equals(Action other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.
    /// </summary>
    [EnumType]
    public readonly struct AllowedCopyScope : IEquatable<AllowedCopyScope>
    {
        private readonly string _value;

        private AllowedCopyScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllowedCopyScope PrivateLink { get; } = new AllowedCopyScope("PrivateLink");
        public static AllowedCopyScope AAD { get; } = new AllowedCopyScope("AAD");

        public static bool operator ==(AllowedCopyScope left, AllowedCopyScope right) => left.Equals(right);
        public static bool operator !=(AllowedCopyScope left, AllowedCopyScope right) => !left.Equals(right);

        public static explicit operator string(AllowedCopyScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllowedCopyScope other && Equals(other);
        public bool Equals(AllowedCopyScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct AllowedMethods : IEquatable<AllowedMethods>
    {
        private readonly string _value;

        private AllowedMethods(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllowedMethods DELETE { get; } = new AllowedMethods("DELETE");
        public static AllowedMethods GET { get; } = new AllowedMethods("GET");
        public static AllowedMethods HEAD { get; } = new AllowedMethods("HEAD");
        public static AllowedMethods MERGE { get; } = new AllowedMethods("MERGE");
        public static AllowedMethods POST { get; } = new AllowedMethods("POST");
        public static AllowedMethods OPTIONS { get; } = new AllowedMethods("OPTIONS");
        public static AllowedMethods PUT { get; } = new AllowedMethods("PUT");
        public static AllowedMethods PATCH { get; } = new AllowedMethods("PATCH");
        public static AllowedMethods CONNECT { get; } = new AllowedMethods("CONNECT");
        public static AllowedMethods TRACE { get; } = new AllowedMethods("TRACE");

        public static bool operator ==(AllowedMethods left, AllowedMethods right) => left.Equals(right);
        public static bool operator !=(AllowedMethods left, AllowedMethods right) => !left.Equals(right);

        public static explicit operator string(AllowedMethods value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllowedMethods other && Equals(other);
        public bool Equals(AllowedMethods other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
    /// </summary>
    [EnumType]
    public readonly struct Bypass : IEquatable<Bypass>
    {
        private readonly string _value;

        private Bypass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Bypass None { get; } = new Bypass("None");
        public static Bypass Logging { get; } = new Bypass("Logging");
        public static Bypass Metrics { get; } = new Bypass("Metrics");
        public static Bypass AzureServices { get; } = new Bypass("AzureServices");

        public static bool operator ==(Bypass left, Bypass right) => left.Equals(right);
        public static bool operator !=(Bypass left, Bypass right) => !left.Equals(right);

        public static explicit operator string(Bypass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Bypass other && Equals(other);
        public bool Equals(Bypass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the default action of allow or deny when no other rules match.
    /// </summary>
    [EnumType]
    public readonly struct DefaultAction : IEquatable<DefaultAction>
    {
        private readonly string _value;

        private DefaultAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultAction Allow { get; } = new DefaultAction("Allow");
        public static DefaultAction Deny { get; } = new DefaultAction("Deny");

        public static bool operator ==(DefaultAction left, DefaultAction right) => left.Equals(right);
        public static bool operator !=(DefaultAction left, DefaultAction right) => !left.Equals(right);

        public static explicit operator string(DefaultAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultAction other && Equals(other);
        public bool Equals(DefaultAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default share permission for users using Kerberos authentication if RBAC role is not assigned.
    /// </summary>
    [EnumType]
    public readonly struct DefaultSharePermission : IEquatable<DefaultSharePermission>
    {
        private readonly string _value;

        private DefaultSharePermission(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultSharePermission None { get; } = new DefaultSharePermission("None");
        public static DefaultSharePermission StorageFileDataSmbShareReader { get; } = new DefaultSharePermission("StorageFileDataSmbShareReader");
        public static DefaultSharePermission StorageFileDataSmbShareContributor { get; } = new DefaultSharePermission("StorageFileDataSmbShareContributor");
        public static DefaultSharePermission StorageFileDataSmbShareElevatedContributor { get; } = new DefaultSharePermission("StorageFileDataSmbShareElevatedContributor");

        public static bool operator ==(DefaultSharePermission left, DefaultSharePermission right) => left.Equals(right);
        public static bool operator !=(DefaultSharePermission left, DefaultSharePermission right) => !left.Equals(right);

        public static explicit operator string(DefaultSharePermission value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultSharePermission other && Equals(other);
        public bool Equals(DefaultSharePermission other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the directory service used. Note that this enum may be extended in the future.
    /// </summary>
    [EnumType]
    public readonly struct DirectoryServiceOptions : IEquatable<DirectoryServiceOptions>
    {
        private readonly string _value;

        private DirectoryServiceOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DirectoryServiceOptions None { get; } = new DirectoryServiceOptions("None");
        public static DirectoryServiceOptions AADDS { get; } = new DirectoryServiceOptions("AADDS");
        public static DirectoryServiceOptions AD { get; } = new DirectoryServiceOptions("AD");
        public static DirectoryServiceOptions AADKERB { get; } = new DirectoryServiceOptions("AADKERB");

        public static bool operator ==(DirectoryServiceOptions left, DirectoryServiceOptions right) => left.Equals(right);
        public static bool operator !=(DirectoryServiceOptions left, DirectoryServiceOptions right) => !left.Equals(right);

        public static explicit operator string(DirectoryServiceOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DirectoryServiceOptions other && Equals(other);
        public bool Equals(DirectoryServiceOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone identifier.
    /// </summary>
    [EnumType]
    public readonly struct DnsEndpointType : IEquatable<DnsEndpointType>
    {
        private readonly string _value;

        private DnsEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DnsEndpointType Standard { get; } = new DnsEndpointType("Standard");
        public static DnsEndpointType AzureDnsZone { get; } = new DnsEndpointType("AzureDnsZone");

        public static bool operator ==(DnsEndpointType left, DnsEndpointType right) => left.Equals(right);
        public static bool operator !=(DnsEndpointType left, DnsEndpointType right) => !left.Equals(right);

        public static explicit operator string(DnsEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DnsEndpointType other && Equals(other);
        public bool Equals(DnsEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The authentication protocol that is used for the file share. Can only be specified when creating a share.
    /// </summary>
    [EnumType]
    public readonly struct EnabledProtocols : IEquatable<EnabledProtocols>
    {
        private readonly string _value;

        private EnabledProtocols(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnabledProtocols SMB { get; } = new EnabledProtocols("SMB");
        public static EnabledProtocols NFS { get; } = new EnabledProtocols("NFS");

        public static bool operator ==(EnabledProtocols left, EnabledProtocols right) => left.Equals(right);
        public static bool operator !=(EnabledProtocols left, EnabledProtocols right) => !left.Equals(right);

        public static explicit operator string(EnabledProtocols value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnabledProtocols other && Equals(other);
        public bool Equals(EnabledProtocols other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provider for the encryption scope. Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionScopeSource : IEquatable<EncryptionScopeSource>
    {
        private readonly string _value;

        private EncryptionScopeSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionScopeSource Microsoft_Storage { get; } = new EncryptionScopeSource("Microsoft.Storage");
        public static EncryptionScopeSource Microsoft_KeyVault { get; } = new EncryptionScopeSource("Microsoft.KeyVault");

        public static bool operator ==(EncryptionScopeSource left, EncryptionScopeSource right) => left.Equals(right);
        public static bool operator !=(EncryptionScopeSource left, EncryptionScopeSource right) => !left.Equals(right);

        public static explicit operator string(EncryptionScopeSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionScopeSource other && Equals(other);
        public bool Equals(EncryptionScopeSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of the encryption scope. Possible values (case-insensitive):  Enabled, Disabled.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionScopeState : IEquatable<EncryptionScopeState>
    {
        private readonly string _value;

        private EncryptionScopeState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionScopeState Enabled { get; } = new EncryptionScopeState("Enabled");
        public static EncryptionScopeState Disabled { get; } = new EncryptionScopeState("Disabled");

        public static bool operator ==(EncryptionScopeState left, EncryptionScopeState right) => left.Equals(right);
        public static bool operator !=(EncryptionScopeState left, EncryptionScopeState right) => !left.Equals(right);

        public static explicit operator string(EncryptionScopeState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionScopeState other && Equals(other);
        public bool Equals(EncryptionScopeState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SAS expiration action. Can only be Log.
    /// </summary>
    [EnumType]
    public readonly struct ExpirationAction : IEquatable<ExpirationAction>
    {
        private readonly string _value;

        private ExpirationAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExpirationAction Log { get; } = new ExpirationAction("Log");

        public static bool operator ==(ExpirationAction left, ExpirationAction right) => left.Equals(right);
        public static bool operator !=(ExpirationAction left, ExpirationAction right) => !left.Equals(right);

        public static explicit operator string(ExpirationAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExpirationAction other && Equals(other);
        public bool Equals(ExpirationAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes EdgeZone { get; } = new ExtendedLocationTypes("EdgeZone");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is a required field, it specifies the format for the inventory files.
    /// </summary>
    [EnumType]
    public readonly struct Format : IEquatable<Format>
    {
        private readonly string _value;

        private Format(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Format Csv { get; } = new Format("Csv");
        public static Format Parquet { get; } = new Format("Parquet");

        public static bool operator ==(Format left, Format right) => left.Equals(right);
        public static bool operator !=(Format left, Format right) => !left.Equals(right);

        public static explicit operator string(Format value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Format other && Equals(other);
        public bool Equals(Format other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol permitted for a request made with the account SAS.
    /// </summary>
    [EnumType]
    public readonly struct HttpProtocol : IEquatable<HttpProtocol>
    {
        private readonly string _value;

        private HttpProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HttpProtocol Https_http { get; } = new HttpProtocol("https,http");
        public static HttpProtocol Https { get; } = new HttpProtocol("https");

        public static bool operator ==(HttpProtocol left, HttpProtocol right) => left.Equals(right);
        public static bool operator !=(HttpProtocol left, HttpProtocol right) => !left.Equals(right);

        public static explicit operator string(HttpProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpProtocol other && Equals(other);
        public bool Equals(HttpProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct IdentityType : IEquatable<IdentityType>
    {
        private readonly string _value;

        private IdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityType None { get; } = new IdentityType("None");
        public static IdentityType SystemAssigned { get; } = new IdentityType("SystemAssigned");
        public static IdentityType UserAssigned { get; } = new IdentityType("UserAssigned");
        public static IdentityType SystemAssigned_UserAssigned { get; } = new IdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(IdentityType left, IdentityType right) => left.Equals(right);
        public static bool operator !=(IdentityType left, IdentityType right) => !left.Equals(right);

        public static explicit operator string(IdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityType other && Equals(other);
        public bool Equals(IdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The valid value is Inventory
    /// </summary>
    [EnumType]
    public readonly struct InventoryRuleType : IEquatable<InventoryRuleType>
    {
        private readonly string _value;

        private InventoryRuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InventoryRuleType Inventory { get; } = new InventoryRuleType("Inventory");

        public static bool operator ==(InventoryRuleType left, InventoryRuleType right) => left.Equals(right);
        public static bool operator !=(InventoryRuleType left, InventoryRuleType right) => !left.Equals(right);

        public static explicit operator string(InventoryRuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InventoryRuleType other && Equals(other);
        public bool Equals(InventoryRuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
    /// </summary>
    [EnumType]
    public readonly struct KeySource : IEquatable<KeySource>
    {
        private readonly string _value;

        private KeySource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeySource Microsoft_Storage { get; } = new KeySource("Microsoft.Storage");
        public static KeySource Microsoft_Keyvault { get; } = new KeySource("Microsoft.Keyvault");

        public static bool operator ==(KeySource left, KeySource right) => left.Equals(right);
        public static bool operator !=(KeySource left, KeySource right) => !left.Equals(right);

        public static explicit operator string(KeySource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeySource other && Equals(other);
        public bool Equals(KeySource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
    /// </summary>
    [EnumType]
    public readonly struct KeyType : IEquatable<KeyType>
    {
        private readonly string _value;

        private KeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyType Service { get; } = new KeyType("Service");
        public static KeyType Account { get; } = new KeyType("Account");

        public static bool operator ==(KeyType left, KeyType right) => left.Equals(right);
        public static bool operator !=(KeyType left, KeyType right) => !left.Equals(right);

        public static explicit operator string(KeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyType other && Equals(other);
        public bool Equals(KeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Indicates the type of storage account.
    /// </summary>
    [EnumType]
    public readonly struct Kind : IEquatable<Kind>
    {
        private readonly string _value;

        private Kind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Kind Storage { get; } = new Kind("Storage");
        public static Kind StorageV2 { get; } = new Kind("StorageV2");
        public static Kind BlobStorage { get; } = new Kind("BlobStorage");
        public static Kind FileStorage { get; } = new Kind("FileStorage");
        public static Kind BlockBlobStorage { get; } = new Kind("BlockBlobStorage");

        public static bool operator ==(Kind left, Kind right) => left.Equals(right);
        public static bool operator !=(Kind left, Kind right) => !left.Equals(right);

        public static explicit operator string(Kind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Kind other && Equals(other);
        public bool Equals(Kind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
    /// </summary>
    [EnumType]
    public readonly struct LargeFileSharesState : IEquatable<LargeFileSharesState>
    {
        private readonly string _value;

        private LargeFileSharesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LargeFileSharesState Disabled { get; } = new LargeFileSharesState("Disabled");
        public static LargeFileSharesState Enabled { get; } = new LargeFileSharesState("Enabled");

        public static bool operator ==(LargeFileSharesState left, LargeFileSharesState right) => left.Equals(right);
        public static bool operator !=(LargeFileSharesState left, LargeFileSharesState right) => !left.Equals(right);

        public static explicit operator string(LargeFileSharesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LargeFileSharesState other && Equals(other);
        public bool Equals(LargeFileSharesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
    /// </summary>
    [EnumType]
    public readonly struct MinimumTlsVersion : IEquatable<MinimumTlsVersion>
    {
        private readonly string _value;

        private MinimumTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MinimumTlsVersion TLS1_0 { get; } = new MinimumTlsVersion("TLS1_0");
        public static MinimumTlsVersion TLS1_1 { get; } = new MinimumTlsVersion("TLS1_1");
        public static MinimumTlsVersion TLS1_2 { get; } = new MinimumTlsVersion("TLS1_2");

        public static bool operator ==(MinimumTlsVersion left, MinimumTlsVersion right) => left.Equals(right);
        public static bool operator !=(MinimumTlsVersion left, MinimumTlsVersion right) => !left.Equals(right);

        public static explicit operator string(MinimumTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MinimumTlsVersion other && Equals(other);
        public bool Equals(MinimumTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the policy. The valid value is AccessTimeTracking. This field is currently read only
    /// </summary>
    [EnumType]
    public readonly struct Name : IEquatable<Name>
    {
        private readonly string _value;

        private Name(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Name AccessTimeTracking { get; } = new Name("AccessTimeTracking");

        public static bool operator ==(Name left, Name right) => left.Equals(right);
        public static bool operator !=(Name left, Name right) => !left.Equals(right);

        public static explicit operator string(Name value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Name other && Equals(other);
        public bool Equals(Name other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is a required field. This field specifies the scope of the inventory created either at the blob or container level.
    /// </summary>
    [EnumType]
    public readonly struct ObjectType : IEquatable<ObjectType>
    {
        private readonly string _value;

        private ObjectType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ObjectType Blob { get; } = new ObjectType("Blob");
        public static ObjectType Container { get; } = new ObjectType("Container");

        public static bool operator ==(ObjectType left, ObjectType right) => left.Equals(right);
        public static bool operator !=(ObjectType left, ObjectType right) => !left.Equals(right);

        public static explicit operator string(ObjectType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ObjectType other && Equals(other);
        public bool Equals(ObjectType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The signed permissions for the service SAS. Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).
    /// </summary>
    [EnumType]
    public readonly struct Permissions : IEquatable<Permissions>
    {
        private readonly string _value;

        private Permissions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Permissions R { get; } = new Permissions("r");
        public static Permissions D { get; } = new Permissions("d");
        public static Permissions W { get; } = new Permissions("w");
        public static Permissions L { get; } = new Permissions("l");
        public static Permissions A { get; } = new Permissions("a");
        public static Permissions C { get; } = new Permissions("c");
        public static Permissions U { get; } = new Permissions("u");
        public static Permissions P { get; } = new Permissions("p");

        public static bool operator ==(Permissions left, Permissions right) => left.Equals(right);
        public static bool operator !=(Permissions left, Permissions right) => !left.Equals(right);

        public static explicit operator string(Permissions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Permissions other && Equals(other);
        public bool Equals(Permissions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether data in the container may be accessed publicly and the level of access.
    /// </summary>
    [EnumType]
    public readonly struct PublicAccess : IEquatable<PublicAccess>
    {
        private readonly string _value;

        private PublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicAccess Container { get; } = new PublicAccess("Container");
        public static PublicAccess Blob { get; } = new PublicAccess("Blob");
        public static PublicAccess None { get; } = new PublicAccess("None");

        public static bool operator ==(PublicAccess left, PublicAccess right) => left.Equals(right);
        public static bool operator !=(PublicAccess left, PublicAccess right) => !left.Equals(right);

        public static explicit operator string(PublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicAccess other && Equals(other);
        public bool Equals(PublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allow or disallow public network access to Storage Account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The property is for NFS share only. The default is NoRootSquash.
    /// </summary>
    [EnumType]
    public readonly struct RootSquashType : IEquatable<RootSquashType>
    {
        private readonly string _value;

        private RootSquashType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RootSquashType NoRootSquash { get; } = new RootSquashType("NoRootSquash");
        public static RootSquashType RootSquash { get; } = new RootSquashType("RootSquash");
        public static RootSquashType AllSquash { get; } = new RootSquashType("AllSquash");

        public static bool operator ==(RootSquashType left, RootSquashType right) => left.Equals(right);
        public static bool operator !=(RootSquashType left, RootSquashType right) => !left.Equals(right);

        public static explicit operator string(RootSquashType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RootSquashType other && Equals(other);
        public bool Equals(RootSquashType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Routing Choice defines the kind of network routing opted by the user.
    /// </summary>
    [EnumType]
    public readonly struct RoutingChoice : IEquatable<RoutingChoice>
    {
        private readonly string _value;

        private RoutingChoice(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutingChoice MicrosoftRouting { get; } = new RoutingChoice("MicrosoftRouting");
        public static RoutingChoice InternetRouting { get; } = new RoutingChoice("InternetRouting");

        public static bool operator ==(RoutingChoice left, RoutingChoice right) => left.Equals(right);
        public static bool operator !=(RoutingChoice left, RoutingChoice right) => !left.Equals(right);

        public static explicit operator string(RoutingChoice value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutingChoice other && Equals(other);
        public bool Equals(RoutingChoice other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The valid value is Lifecycle
    /// </summary>
    [EnumType]
    public readonly struct RuleType : IEquatable<RuleType>
    {
        private readonly string _value;

        private RuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleType Lifecycle { get; } = new RuleType("Lifecycle");

        public static bool operator ==(RuleType left, RuleType right) => left.Equals(right);
        public static bool operator !=(RuleType left, RuleType right) => !left.Equals(right);

        public static explicit operator string(RuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleType other && Equals(other);
        public bool Equals(RuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is a required field. This field is used to schedule an inventory formation.
    /// </summary>
    [EnumType]
    public readonly struct Schedule : IEquatable<Schedule>
    {
        private readonly string _value;

        private Schedule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Schedule Daily { get; } = new Schedule("Daily");
        public static Schedule Weekly { get; } = new Schedule("Weekly");

        public static bool operator ==(Schedule left, Schedule right) => left.Equals(right);
        public static bool operator !=(Schedule left, Schedule right) => !left.Equals(right);

        public static explicit operator string(Schedule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Schedule other && Equals(other);
        public bool Equals(Schedule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The signed services accessible with the account SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f).
    /// </summary>
    [EnumType]
    public readonly struct Services : IEquatable<Services>
    {
        private readonly string _value;

        private Services(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Services B { get; } = new Services("b");
        public static Services Q { get; } = new Services("q");
        public static Services T { get; } = new Services("t");
        public static Services F { get; } = new Services("f");

        public static bool operator ==(Services left, Services right) => left.Equals(right);
        public static bool operator !=(Services left, Services right) => !left.Equals(right);

        public static explicit operator string(Services value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Services other && Equals(other);
        public bool Equals(Services other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Access tier for specific share. GpV2 account can choose between TransactionOptimized (default), Hot, and Cool. FileStorage account can choose Premium.
    /// </summary>
    [EnumType]
    public readonly struct ShareAccessTier : IEquatable<ShareAccessTier>
    {
        private readonly string _value;

        private ShareAccessTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ShareAccessTier TransactionOptimized { get; } = new ShareAccessTier("TransactionOptimized");
        public static ShareAccessTier Hot { get; } = new ShareAccessTier("Hot");
        public static ShareAccessTier Cool { get; } = new ShareAccessTier("Cool");
        public static ShareAccessTier Premium { get; } = new ShareAccessTier("Premium");

        public static bool operator ==(ShareAccessTier left, ShareAccessTier right) => left.Equals(right);
        public static bool operator !=(ShareAccessTier left, ShareAccessTier right) => !left.Equals(right);

        public static explicit operator string(ShareAccessTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ShareAccessTier other && Equals(other);
        public bool Equals(ShareAccessTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The signed services accessible with the service SAS. Possible values include: Blob (b), Container (c), File (f), Share (s).
    /// </summary>
    [EnumType]
    public readonly struct SignedResource : IEquatable<SignedResource>
    {
        private readonly string _value;

        private SignedResource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SignedResource B { get; } = new SignedResource("b");
        public static SignedResource C { get; } = new SignedResource("c");
        public static SignedResource F { get; } = new SignedResource("f");
        public static SignedResource S { get; } = new SignedResource("s");

        public static bool operator ==(SignedResource left, SignedResource right) => left.Equals(right);
        public static bool operator !=(SignedResource left, SignedResource right) => !left.Equals(right);

        public static explicit operator string(SignedResource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SignedResource other && Equals(other);
        public bool Equals(SignedResource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The signed resource types that are accessible with the account SAS. Service (s): Access to service-level APIs; Container (c): Access to container-level APIs; Object (o): Access to object-level APIs for blobs, queue messages, table entities, and files.
    /// </summary>
    [EnumType]
    public readonly struct SignedResourceTypes : IEquatable<SignedResourceTypes>
    {
        private readonly string _value;

        private SignedResourceTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SignedResourceTypes S { get; } = new SignedResourceTypes("s");
        public static SignedResourceTypes C { get; } = new SignedResourceTypes("c");
        public static SignedResourceTypes O { get; } = new SignedResourceTypes("o");

        public static bool operator ==(SignedResourceTypes left, SignedResourceTypes right) => left.Equals(right);
        public static bool operator !=(SignedResourceTypes left, SignedResourceTypes right) => !left.Equals(right);

        public static explicit operator string(SignedResourceTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SignedResourceTypes other && Equals(other);
        public bool Equals(SignedResourceTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
    /// </summary>
    [EnumType]
    public readonly struct SkuName : IEquatable<SkuName>
    {
        private readonly string _value;

        private SkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuName Standard_LRS { get; } = new SkuName("Standard_LRS");
        public static SkuName Standard_GRS { get; } = new SkuName("Standard_GRS");
        public static SkuName Standard_RAGRS { get; } = new SkuName("Standard_RAGRS");
        public static SkuName Standard_ZRS { get; } = new SkuName("Standard_ZRS");
        public static SkuName Premium_LRS { get; } = new SkuName("Premium_LRS");
        public static SkuName Premium_ZRS { get; } = new SkuName("Premium_ZRS");
        public static SkuName Standard_GZRS { get; } = new SkuName("Standard_GZRS");
        public static SkuName Standard_RAGZRS { get; } = new SkuName("Standard_RAGZRS");

        public static bool operator ==(SkuName left, SkuName right) => left.Equals(right);
        public static bool operator !=(SkuName left, SkuName right) => !left.Equals(right);

        public static explicit operator string(SkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuName other && Equals(other);
        public bool Equals(SkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Gets the state of virtual network rule.
    /// </summary>
    [EnumType]
    public readonly struct State : IEquatable<State>
    {
        private readonly string _value;

        private State(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static State Provisioning { get; } = new State("Provisioning");
        public static State Deprovisioning { get; } = new State("Deprovisioning");
        public static State Succeeded { get; } = new State("Succeeded");
        public static State Failed { get; } = new State("Failed");
        public static State NetworkSourceDeleted { get; } = new State("NetworkSourceDeleted");

        public static bool operator ==(State left, State right) => left.Equals(right);
        public static bool operator !=(State left, State right) => !left.Equals(right);

        public static explicit operator string(State value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is State other && Equals(other);
        public bool Equals(State other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
