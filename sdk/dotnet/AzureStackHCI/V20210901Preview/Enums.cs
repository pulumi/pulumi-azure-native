// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.AzureStackHCI.V20210901Preview
{
    /// <summary>
    /// Datasource for the gallery image when provisioning with cloud-init [Azure, NoCloud]
    /// </summary>
    [EnumType]
    public readonly struct CloudInitDataSource : IEquatable<CloudInitDataSource>
    {
        private readonly string _value;

        private CloudInitDataSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CloudInitDataSource NoCloud { get; } = new CloudInitDataSource("NoCloud");
        public static CloudInitDataSource Azure { get; } = new CloudInitDataSource("Azure");

        public static bool operator ==(CloudInitDataSource left, CloudInitDataSource right) => left.Equals(right);
        public static bool operator !=(CloudInitDataSource left, CloudInitDataSource right) => !left.Equals(right);

        public static explicit operator string(CloudInitDataSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudInitDataSource other && Equals(other);
        public bool Equals(CloudInitDataSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity that last modified the resource.
    /// </summary>
    [EnumType]
    public readonly struct CreatedByType : IEquatable<CreatedByType>
    {
        private readonly string _value;

        private CreatedByType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CreatedByType User { get; } = new CreatedByType("User");
        public static CreatedByType Application { get; } = new CreatedByType("Application");
        public static CreatedByType ManagedIdentity { get; } = new CreatedByType("ManagedIdentity");
        public static CreatedByType Key { get; } = new CreatedByType("Key");

        public static bool operator ==(CreatedByType left, CreatedByType right) => left.Equals(right);
        public static bool operator !=(CreatedByType left, CreatedByType right) => !left.Equals(right);

        public static explicit operator string(CreatedByType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CreatedByType other && Equals(other);
        public bool Equals(CreatedByType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired level of diagnostic data emitted by the cluster.
    /// </summary>
    [EnumType]
    public readonly struct DiagnosticLevel : IEquatable<DiagnosticLevel>
    {
        private readonly string _value;

        private DiagnosticLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiagnosticLevel Off { get; } = new DiagnosticLevel("Off");
        public static DiagnosticLevel Basic { get; } = new DiagnosticLevel("Basic");
        public static DiagnosticLevel Enhanced { get; } = new DiagnosticLevel("Enhanced");

        public static bool operator ==(DiagnosticLevel left, DiagnosticLevel right) => left.Equals(right);
        public static bool operator !=(DiagnosticLevel left, DiagnosticLevel right) => !left.Equals(right);

        public static explicit operator string(DiagnosticLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiagnosticLevel other && Equals(other);
        public bool Equals(DiagnosticLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the actual VHD file [vhd, vhdx]
    /// </summary>
    [EnumType]
    public readonly struct DiskFileFormat : IEquatable<DiskFileFormat>
    {
        private readonly string _value;

        private DiskFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskFileFormat Vhdx { get; } = new DiskFileFormat("vhdx");
        public static DiskFileFormat Vhd { get; } = new DiskFileFormat("vhd");

        public static bool operator ==(DiskFileFormat left, DiskFileFormat right) => left.Equals(right);
        public static bool operator !=(DiskFileFormat left, DiskFileFormat right) => !left.Equals(right);

        public static explicit operator string(DiskFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskFileFormat other && Equals(other);
        public bool Equals(DiskFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes CustomLocation { get; } = new ExtendedLocationTypes("CustomLocation");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine [V1, V2]
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ip pool type
    /// </summary>
    [EnumType]
    public readonly struct IPPoolTypeEnum : IEquatable<IPPoolTypeEnum>
    {
        private readonly string _value;

        private IPPoolTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPPoolTypeEnum Vm { get; } = new IPPoolTypeEnum("vm");
        public static IPPoolTypeEnum Vippool { get; } = new IPPoolTypeEnum("vippool");

        public static bool operator ==(IPPoolTypeEnum left, IPPoolTypeEnum right) => left.Equals(right);
        public static bool operator !=(IPPoolTypeEnum left, IPPoolTypeEnum right) => !left.Equals(right);

        public static explicit operator string(IPPoolTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPPoolTypeEnum other && Equals(other);
        public bool Equals(IPPoolTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
    /// </summary>
    [EnumType]
    public readonly struct IpAllocationMethodEnum : IEquatable<IpAllocationMethodEnum>
    {
        private readonly string _value;

        private IpAllocationMethodEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpAllocationMethodEnum Dynamic { get; } = new IpAllocationMethodEnum("Dynamic");
        public static IpAllocationMethodEnum Static { get; } = new IpAllocationMethodEnum("Static");

        public static bool operator ==(IpAllocationMethodEnum left, IpAllocationMethodEnum right) => left.Equals(right);
        public static bool operator !=(IpAllocationMethodEnum left, IpAllocationMethodEnum right) => !left.Equals(right);

        public static explicit operator string(IpAllocationMethodEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpAllocationMethodEnum other && Equals(other);
        public bool Equals(IpAllocationMethodEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the network
    /// </summary>
    [EnumType]
    public readonly struct NetworkTypeEnum : IEquatable<NetworkTypeEnum>
    {
        private readonly string _value;

        private NetworkTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkTypeEnum NAT { get; } = new NetworkTypeEnum("NAT");
        public static NetworkTypeEnum Transparent { get; } = new NetworkTypeEnum("Transparent");
        public static NetworkTypeEnum L2Bridge { get; } = new NetworkTypeEnum("L2Bridge");
        public static NetworkTypeEnum L2Tunnel { get; } = new NetworkTypeEnum("L2Tunnel");
        public static NetworkTypeEnum ICS { get; } = new NetworkTypeEnum("ICS");
        public static NetworkTypeEnum Private { get; } = new NetworkTypeEnum("Private");
        public static NetworkTypeEnum Overlay { get; } = new NetworkTypeEnum("Overlay");
        public static NetworkTypeEnum Internal { get; } = new NetworkTypeEnum("Internal");
        public static NetworkTypeEnum Mirrored { get; } = new NetworkTypeEnum("Mirrored");

        public static bool operator ==(NetworkTypeEnum left, NetworkTypeEnum right) => left.Equals(right);
        public static bool operator !=(NetworkTypeEnum left, NetworkTypeEnum right) => !left.Equals(right);

        public static explicit operator string(NetworkTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkTypeEnum other && Equals(other);
        public bool Equals(NetworkTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// operating system type that the gallery image uses. Expected to be linux or windows
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// OsType - string specifying whether the OS is Linux or Windows
    /// </summary>
    [EnumType]
    public readonly struct OsTypeEnum : IEquatable<OsTypeEnum>
    {
        private readonly string _value;

        private OsTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsTypeEnum Linux { get; } = new OsTypeEnum("Linux");
        public static OsTypeEnum Windows { get; } = new OsTypeEnum("Windows");

        public static bool operator ==(OsTypeEnum left, OsTypeEnum right) => left.Equals(right);
        public static bool operator !=(OsTypeEnum left, OsTypeEnum right) => !left.Equals(right);

        public static explicit operator string(OsTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsTypeEnum other && Equals(other);
        public bool Equals(OsTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'Static', 'Dynamic'
    /// </summary>
    [EnumType]
    public readonly struct PrivateIPAllocationMethodEnum : IEquatable<PrivateIPAllocationMethodEnum>
    {
        private readonly string _value;

        private PrivateIPAllocationMethodEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateIPAllocationMethodEnum Dynamic { get; } = new PrivateIPAllocationMethodEnum("Dynamic");
        public static PrivateIPAllocationMethodEnum Static { get; } = new PrivateIPAllocationMethodEnum("Static");

        public static bool operator ==(PrivateIPAllocationMethodEnum left, PrivateIPAllocationMethodEnum right) => left.Equals(right);
        public static bool operator !=(PrivateIPAllocationMethodEnum left, PrivateIPAllocationMethodEnum right) => !left.Equals(right);

        public static explicit operator string(PrivateIPAllocationMethodEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateIPAllocationMethodEnum other && Equals(other);
        public bool Equals(PrivateIPAllocationMethodEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The guest agent provisioning action.
    /// </summary>
    [EnumType]
    public readonly struct ProvisioningAction : IEquatable<ProvisioningAction>
    {
        private readonly string _value;

        private ProvisioningAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ProvisioningAction Install { get; } = new ProvisioningAction("install");
        public static ProvisioningAction Uninstall { get; } = new ProvisioningAction("uninstall");
        public static ProvisioningAction Repair { get; } = new ProvisioningAction("repair");

        public static bool operator ==(ProvisioningAction left, ProvisioningAction right) => left.Equals(right);
        public static bool operator !=(ProvisioningAction left, ProvisioningAction right) => !left.Equals(right);

        public static explicit operator string(ProvisioningAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProvisioningAction other && Equals(other);
        public bool Equals(ProvisioningAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired state of Windows Server Subscription.
    /// </summary>
    [EnumType]
    public readonly struct WindowsServerSubscription : IEquatable<WindowsServerSubscription>
    {
        private readonly string _value;

        private WindowsServerSubscription(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WindowsServerSubscription Disabled { get; } = new WindowsServerSubscription("Disabled");
        public static WindowsServerSubscription Enabled { get; } = new WindowsServerSubscription("Enabled");

        public static bool operator ==(WindowsServerSubscription left, WindowsServerSubscription right) => left.Equals(right);
        public static bool operator !=(WindowsServerSubscription left, WindowsServerSubscription right) => !left.Equals(right);

        public static explicit operator string(WindowsServerSubscription value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsServerSubscription other && Equals(other);
        public bool Equals(WindowsServerSubscription other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
