// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.AzureStackHCI
{
    /// <summary>
    /// Indicates the way the update content can be downloaded.
    /// </summary>
    [EnumType]
    public readonly struct AvailabilityType : IEquatable<AvailabilityType>
    {
        private readonly string _value;

        private AvailabilityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AvailabilityType Local { get; } = new AvailabilityType("Local");
        public static AvailabilityType Online { get; } = new AvailabilityType("Online");
        public static AvailabilityType Notify { get; } = new AvailabilityType("Notify");

        public static bool operator ==(AvailabilityType left, AvailabilityType right) => left.Equals(right);
        public static bool operator !=(AvailabilityType left, AvailabilityType right) => !left.Equals(right);

        public static explicit operator string(AvailabilityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AvailabilityType other && Equals(other);
        public bool Equals(AvailabilityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Datasource for the gallery image when provisioning with cloud-init [NoCloud, Azure]
    /// </summary>
    [EnumType]
    public readonly struct CloudInitDataSource : IEquatable<CloudInitDataSource>
    {
        private readonly string _value;

        private CloudInitDataSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NoCloud is used as the datasource
        /// </summary>
        public static CloudInitDataSource NoCloud { get; } = new CloudInitDataSource("NoCloud");
        /// <summary>
        /// Azure is used as the datasource
        /// </summary>
        public static CloudInitDataSource Azure { get; } = new CloudInitDataSource("Azure");

        public static bool operator ==(CloudInitDataSource left, CloudInitDataSource right) => left.Equals(right);
        public static bool operator !=(CloudInitDataSource left, CloudInitDataSource right) => !left.Equals(right);

        public static explicit operator string(CloudInitDataSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudInitDataSource other && Equals(other);
        public bool Equals(CloudInitDataSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// WDAC Compliance Assignment
    /// </summary>
    [EnumType]
    public readonly struct ComplianceAssignmentType : IEquatable<ComplianceAssignmentType>
    {
        private readonly string _value;

        private ComplianceAssignmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Report on the state of the machine, but don't make changes.
        /// </summary>
        public static ComplianceAssignmentType Audit { get; } = new ComplianceAssignmentType("Audit");
        /// <summary>
        /// Applied to the machine. If it drifts, the local service inside the machine makes a correction at the next evaluation.
        /// </summary>
        public static ComplianceAssignmentType ApplyAndAutoCorrect { get; } = new ComplianceAssignmentType("ApplyAndAutoCorrect");

        public static bool operator ==(ComplianceAssignmentType left, ComplianceAssignmentType right) => left.Equals(right);
        public static bool operator !=(ComplianceAssignmentType left, ComplianceAssignmentType right) => !left.Equals(right);

        public static explicit operator string(ComplianceAssignmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComplianceAssignmentType other && Equals(other);
        public bool Equals(ComplianceAssignmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deployment mode to trigger job.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentMode : IEquatable<DeploymentMode>
    {
        private readonly string _value;

        private DeploymentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Validate ECE action deployment for a cluster.
        /// </summary>
        public static DeploymentMode Validate { get; } = new DeploymentMode("Validate");
        /// <summary>
        /// Deploy ECE action deployment for a cluster.
        /// </summary>
        public static DeploymentMode Deploy { get; } = new DeploymentMode("Deploy");

        public static bool operator ==(DeploymentMode left, DeploymentMode right) => left.Equals(right);
        public static bool operator !=(DeploymentMode left, DeploymentMode right) => !left.Equals(right);

        public static explicit operator string(DeploymentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentMode other && Equals(other);
        public bool Equals(DeploymentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Device kind to support polymorphic resource.
    /// </summary>
    [EnumType]
    public readonly struct DeviceKind : IEquatable<DeviceKind>
    {
        private readonly string _value;

        private DeviceKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Arc-enabled edge device with HCI OS.
        /// </summary>
        public static DeviceKind HCI { get; } = new DeviceKind("HCI");

        public static bool operator ==(DeviceKind left, DeviceKind right) => left.Equals(right);
        public static bool operator !=(DeviceKind left, DeviceKind right) => !left.Equals(right);

        public static explicit operator string(DeviceKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeviceKind other && Equals(other);
        public bool Equals(DeviceKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired level of diagnostic data emitted by the cluster.
    /// </summary>
    [EnumType]
    public readonly struct DiagnosticLevel : IEquatable<DiagnosticLevel>
    {
        private readonly string _value;

        private DiagnosticLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiagnosticLevel Off { get; } = new DiagnosticLevel("Off");
        public static DiagnosticLevel Basic { get; } = new DiagnosticLevel("Basic");
        public static DiagnosticLevel Enhanced { get; } = new DiagnosticLevel("Enhanced");

        public static bool operator ==(DiagnosticLevel left, DiagnosticLevel right) => left.Equals(right);
        public static bool operator !=(DiagnosticLevel left, DiagnosticLevel right) => !left.Equals(right);

        public static explicit operator string(DiagnosticLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiagnosticLevel other && Equals(other);
        public bool Equals(DiagnosticLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the actual VHD file [vhd, vhdx]
    /// </summary>
    [EnumType]
    public readonly struct DiskFileFormat : IEquatable<DiskFileFormat>
    {
        private readonly string _value;

        private DiskFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VHDX file format
        /// </summary>
        public static DiskFileFormat Vhdx { get; } = new DiskFileFormat("vhdx");
        /// <summary>
        /// VHD file format
        /// </summary>
        public static DiskFileFormat Vhd { get; } = new DiskFileFormat("vhd");

        public static bool operator ==(DiskFileFormat left, DiskFileFormat right) => left.Equals(right);
        public static bool operator !=(DiskFileFormat left, DiskFileFormat right) => !left.Equals(right);

        public static explicit operator string(DiskFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskFileFormat other && Equals(other);
        public bool Equals(DiskFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Secret name expected for Enterprise Cloud Engine (ECE) deployment.
    /// </summary>
    [EnumType]
    public readonly struct EceSecrets : IEquatable<EceSecrets>
    {
        private readonly string _value;

        private EceSecrets(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AzureStackLCMUserCredential used for LCM operations for AzureStackHCI cluster.
        /// </summary>
        public static EceSecrets AzureStackLCMUserCredential { get; } = new EceSecrets("AzureStackLCMUserCredential");
        /// <summary>
        /// DefaultARBApplication used to manage Azure Arc resource bridge (ARB) for AzureStackHCI cluster.
        /// </summary>
        public static EceSecrets DefaultARBApplication { get; } = new EceSecrets("DefaultARBApplication");
        /// <summary>
        /// LocalAdminCredential used for admin operations for AzureStackHCI cluster.
        /// </summary>
        public static EceSecrets LocalAdminCredential { get; } = new EceSecrets("LocalAdminCredential");
        /// <summary>
        /// WitnessStorageKey used for setting up a cloud witness for AzureStackHCI cluster.
        /// </summary>
        public static EceSecrets WitnessStorageKey { get; } = new EceSecrets("WitnessStorageKey");

        public static bool operator ==(EceSecrets left, EceSecrets right) => left.Equals(right);
        public static bool operator !=(EceSecrets left, EceSecrets right) => !left.Equals(right);

        public static explicit operator string(EceSecrets value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EceSecrets other && Equals(other);
        public bool Equals(EceSecrets other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Edge Solution type to support polymorphic resource.
    /// </summary>
    [EnumType]
    public readonly struct EdgeDeviceKind : IEquatable<EdgeDeviceKind>
    {
        private readonly string _value;

        private EdgeDeviceKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Arc-enabled edge device with HCI OS.
        /// </summary>
        public static EdgeDeviceKind HCI { get; } = new EdgeDeviceKind("HCI");

        public static bool operator ==(EdgeDeviceKind left, EdgeDeviceKind right) => left.Equals(right);
        public static bool operator !=(EdgeDeviceKind left, EdgeDeviceKind right) => !left.Equals(right);

        public static explicit operator string(EdgeDeviceKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EdgeDeviceKind other && Equals(other);
        public bool Equals(EdgeDeviceKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the extended location.
    /// </summary>
    [EnumType]
    public readonly struct ExtendedLocationTypes : IEquatable<ExtendedLocationTypes>
    {
        private readonly string _value;

        private ExtendedLocationTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExtendedLocationTypes CustomLocation { get; } = new ExtendedLocationTypes("CustomLocation");

        public static bool operator ==(ExtendedLocationTypes left, ExtendedLocationTypes right) => left.Equals(right);
        public static bool operator !=(ExtendedLocationTypes left, ExtendedLocationTypes right) => !left.Equals(right);

        public static explicit operator string(ExtendedLocationTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExtendedLocationTypes other && Equals(other);
        public bool Equals(ExtendedLocationTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// GPU assignment type
    /// </summary>
    [EnumType]
    public readonly struct GpuAssignmentTypeEnum : IEquatable<GpuAssignmentTypeEnum>
    {
        private readonly string _value;

        private GpuAssignmentTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Attach Graphics Processing Unit (GPU) using Discrete Device Assignment (DDA)
        /// </summary>
        public static GpuAssignmentTypeEnum GpuDDA { get; } = new GpuAssignmentTypeEnum("GpuDDA");
        /// <summary>
        /// Attach Graphics Processing Unit (GPU) using GPU Partitioning
        /// </summary>
        public static GpuAssignmentTypeEnum GpuP { get; } = new GpuAssignmentTypeEnum("GpuP");

        public static bool operator ==(GpuAssignmentTypeEnum left, GpuAssignmentTypeEnum right) => left.Equals(right);
        public static bool operator !=(GpuAssignmentTypeEnum left, GpuAssignmentTypeEnum right) => !left.Equals(right);

        public static explicit operator string(GpuAssignmentTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GpuAssignmentTypeEnum other && Equals(other);
        public bool Equals(GpuAssignmentTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Job Type to support polymorphic resource.
    /// </summary>
    [EnumType]
    public readonly struct HciEdgeDeviceJobType : IEquatable<HciEdgeDeviceJobType>
    {
        private readonly string _value;

        private HciEdgeDeviceJobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Job to collect logs from the device.
        /// </summary>
        public static HciEdgeDeviceJobType CollectLog { get; } = new HciEdgeDeviceJobType("CollectLog");
        /// <summary>
        /// Job to provide remote support to the device.
        /// </summary>
        public static HciEdgeDeviceJobType RemoteSupport { get; } = new HciEdgeDeviceJobType("RemoteSupport");

        public static bool operator ==(HciEdgeDeviceJobType left, HciEdgeDeviceJobType right) => left.Equals(right);
        public static bool operator !=(HciEdgeDeviceJobType left, HciEdgeDeviceJobType right) => !left.Equals(right);

        public static explicit operator string(HciEdgeDeviceJobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HciEdgeDeviceJobType other && Equals(other);
        public bool Equals(HciEdgeDeviceJobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The hypervisor generation of the Virtual Machine [V1, V2]
    /// </summary>
    [EnumType]
    public readonly struct HyperVGeneration : IEquatable<HyperVGeneration>
    {
        private readonly string _value;

        private HyperVGeneration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Generation 1 (V1) hypervisor
        /// </summary>
        public static HyperVGeneration V1 { get; } = new HyperVGeneration("V1");
        /// <summary>
        /// Generation 2 (V2) hypervisor
        /// </summary>
        public static HyperVGeneration V2 { get; } = new HyperVGeneration("V2");

        public static bool operator ==(HyperVGeneration left, HyperVGeneration right) => left.Equals(right);
        public static bool operator !=(HyperVGeneration left, HyperVGeneration right) => !left.Equals(right);

        public static explicit operator string(HyperVGeneration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HyperVGeneration other && Equals(other);
        public bool Equals(HyperVGeneration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the IP Pool [vm, vippool]
    /// </summary>
    [EnumType]
    public readonly struct IPPoolTypeEnum : IEquatable<IPPoolTypeEnum>
    {
        private readonly string _value;

        private IPPoolTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Virtual Machine IP Pool
        /// </summary>
        public static IPPoolTypeEnum Vm { get; } = new IPPoolTypeEnum("vm");
        /// <summary>
        /// VIP Pool
        /// </summary>
        public static IPPoolTypeEnum Vippool { get; } = new IPPoolTypeEnum("vippool");

        public static bool operator ==(IPPoolTypeEnum left, IPPoolTypeEnum right) => left.Equals(right);
        public static bool operator !=(IPPoolTypeEnum left, IPPoolTypeEnum right) => !left.Equals(right);

        public static explicit operator string(IPPoolTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPPoolTypeEnum other && Equals(other);
        public bool Equals(IPPoolTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'
    /// </summary>
    [EnumType]
    public readonly struct IpAllocationMethodEnum : IEquatable<IpAllocationMethodEnum>
    {
        private readonly string _value;

        private IpAllocationMethodEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpAllocationMethodEnum Dynamic { get; } = new IpAllocationMethodEnum("Dynamic");
        public static IpAllocationMethodEnum Static { get; } = new IpAllocationMethodEnum("Static");

        public static bool operator ==(IpAllocationMethodEnum left, IpAllocationMethodEnum right) => left.Equals(right);
        public static bool operator !=(IpAllocationMethodEnum left, IpAllocationMethodEnum right) => !left.Equals(right);

        public static explicit operator string(IpAllocationMethodEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpAllocationMethodEnum other && Equals(other);
        public bool Equals(IpAllocationMethodEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the network
    /// </summary>
    [EnumType]
    public readonly struct NetworkTypeEnum : IEquatable<NetworkTypeEnum>
    {
        private readonly string _value;

        private NetworkTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkTypeEnum NAT { get; } = new NetworkTypeEnum("NAT");
        public static NetworkTypeEnum Transparent { get; } = new NetworkTypeEnum("Transparent");
        public static NetworkTypeEnum L2Bridge { get; } = new NetworkTypeEnum("L2Bridge");
        public static NetworkTypeEnum L2Tunnel { get; } = new NetworkTypeEnum("L2Tunnel");
        public static NetworkTypeEnum ICS { get; } = new NetworkTypeEnum("ICS");
        public static NetworkTypeEnum Private { get; } = new NetworkTypeEnum("Private");
        public static NetworkTypeEnum Overlay { get; } = new NetworkTypeEnum("Overlay");
        public static NetworkTypeEnum Internal { get; } = new NetworkTypeEnum("Internal");
        public static NetworkTypeEnum Mirrored { get; } = new NetworkTypeEnum("Mirrored");

        public static bool operator ==(NetworkTypeEnum left, NetworkTypeEnum right) => left.Equals(right);
        public static bool operator !=(NetworkTypeEnum left, NetworkTypeEnum right) => !left.Equals(right);

        public static explicit operator string(NetworkTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkTypeEnum other && Equals(other);
        public bool Equals(NetworkTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. Possible values are: Windows, Linux.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Windows operating system
        /// </summary>
        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        /// <summary>
        /// Linux operating system
        /// </summary>
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The intended operation for a cluster.
    /// </summary>
    [EnumType]
    public readonly struct OperationType : IEquatable<OperationType>
    {
        private readonly string _value;

        private OperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cluster provisioning operation.
        /// </summary>
        public static OperationType ClusterProvisioning { get; } = new OperationType("ClusterProvisioning");
        /// <summary>
        /// Cluster upgrade operation.
        /// </summary>
        public static OperationType ClusterUpgrade { get; } = new OperationType("ClusterUpgrade");

        public static bool operator ==(OperationType left, OperationType right) => left.Equals(right);
        public static bool operator !=(OperationType left, OperationType right) => !left.Equals(right);

        public static explicit operator string(OperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperationType other && Equals(other);
        public bool Equals(OperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// OsType - string specifying whether the OS is Linux or Windows
    /// </summary>
    [EnumType]
    public readonly struct OsTypeEnum : IEquatable<OsTypeEnum>
    {
        private readonly string _value;

        private OsTypeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsTypeEnum Linux { get; } = new OsTypeEnum("Linux");
        public static OsTypeEnum Windows { get; } = new OsTypeEnum("Windows");

        public static bool operator ==(OsTypeEnum left, OsTypeEnum right) => left.Equals(right);
        public static bool operator !=(OsTypeEnum left, OsTypeEnum right) => !left.Equals(right);

        public static explicit operator string(OsTypeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsTypeEnum other && Equals(other);
        public bool Equals(OsTypeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The guest agent provisioning action.
    /// </summary>
    [EnumType]
    public readonly struct ProvisioningAction : IEquatable<ProvisioningAction>
    {
        private readonly string _value;

        private ProvisioningAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Install guest agent
        /// </summary>
        public static ProvisioningAction Install { get; } = new ProvisioningAction("install");
        /// <summary>
        /// Uninstall guest agent
        /// </summary>
        public static ProvisioningAction Uninstall { get; } = new ProvisioningAction("uninstall");
        /// <summary>
        /// Repair guest agent
        /// </summary>
        public static ProvisioningAction Repair { get; } = new ProvisioningAction("repair");

        public static bool operator ==(ProvisioningAction left, ProvisioningAction right) => left.Equals(right);
        public static bool operator !=(ProvisioningAction left, ProvisioningAction right) => !left.Equals(right);

        public static explicit operator string(ProvisioningAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProvisioningAction other && Equals(other);
        public bool Equals(ProvisioningAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Remote support access level.
    /// </summary>
    [EnumType]
    public readonly struct RemoteSupportAccessLevel : IEquatable<RemoteSupportAccessLevel>
    {
        private readonly string _value;

        private RemoteSupportAccessLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No remote support access is granted.
        /// </summary>
        public static RemoteSupportAccessLevel None { get; } = new RemoteSupportAccessLevel("None");
        /// <summary>
        /// Access is limited to diagnostics information only.
        /// </summary>
        public static RemoteSupportAccessLevel Diagnostics { get; } = new RemoteSupportAccessLevel("Diagnostics");
        /// <summary>
        /// Access includes diagnostics information and the ability to perform repairs.
        /// </summary>
        public static RemoteSupportAccessLevel DiagnosticsAndRepair { get; } = new RemoteSupportAccessLevel("DiagnosticsAndRepair");

        public static bool operator ==(RemoteSupportAccessLevel left, RemoteSupportAccessLevel right) => left.Equals(right);
        public static bool operator !=(RemoteSupportAccessLevel left, RemoteSupportAccessLevel right) => !left.Equals(right);

        public static explicit operator string(RemoteSupportAccessLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteSupportAccessLevel other && Equals(other);
        public bool Equals(RemoteSupportAccessLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Remote support type.
    /// </summary>
    [EnumType]
    public readonly struct RemoteSupportType : IEquatable<RemoteSupportType>
    {
        private readonly string _value;

        private RemoteSupportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Enables remote support for the edge device.
        /// </summary>
        public static RemoteSupportType Enable { get; } = new RemoteSupportType("Enable");
        /// <summary>
        /// Revokes previously granted remote support access for the edge device.
        /// </summary>
        public static RemoteSupportType Revoke { get; } = new RemoteSupportType("Revoke");

        public static bool operator ==(RemoteSupportType left, RemoteSupportType right) => left.Equals(right);
        public static bool operator !=(RemoteSupportType left, RemoteSupportType right) => !left.Equals(right);

        public static explicit operator string(RemoteSupportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteSupportType other && Equals(other);
        public bool Equals(RemoteSupportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the EncryptionType of the managed disk. It is set to NonPersistedTPM for not persisting firmware state in the VMGuestState blob. NOTE: It can be set for only Confidential VMs.
    /// </summary>
    [EnumType]
    public readonly struct SecurityEncryptionType : IEquatable<SecurityEncryptionType>
    {
        private readonly string _value;

        private SecurityEncryptionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Non-persisted TPM encryption type
        /// </summary>
        public static SecurityEncryptionType NonPersistedTPM { get; } = new SecurityEncryptionType("NonPersistedTPM");

        public static bool operator ==(SecurityEncryptionType left, SecurityEncryptionType right) => left.Equals(right);
        public static bool operator !=(SecurityEncryptionType left, SecurityEncryptionType right) => !left.Equals(right);

        public static explicit operator string(SecurityEncryptionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityEncryptionType other && Equals(other);
        public bool Equals(SecurityEncryptionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network traffic is allowed or denied.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleAccess : IEquatable<SecurityRuleAccess>
    {
        private readonly string _value;

        private SecurityRuleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Network traffic is allowed
        /// </summary>
        public static SecurityRuleAccess Allow { get; } = new SecurityRuleAccess("Allow");
        /// <summary>
        /// Network traffic is denied
        /// </summary>
        public static SecurityRuleAccess Deny { get; } = new SecurityRuleAccess("Deny");

        public static bool operator ==(SecurityRuleAccess left, SecurityRuleAccess right) => left.Equals(right);
        public static bool operator !=(SecurityRuleAccess left, SecurityRuleAccess right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleAccess other && Equals(other);
        public bool Equals(SecurityRuleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleDirection : IEquatable<SecurityRuleDirection>
    {
        private readonly string _value;

        private SecurityRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Rule is evaluated on incoming traffic
        /// </summary>
        public static SecurityRuleDirection Inbound { get; } = new SecurityRuleDirection("Inbound");
        /// <summary>
        /// Rule is evaluated on outgoing traffic
        /// </summary>
        public static SecurityRuleDirection Outbound { get; } = new SecurityRuleDirection("Outbound");

        public static bool operator ==(SecurityRuleDirection left, SecurityRuleDirection right) => left.Equals(right);
        public static bool operator !=(SecurityRuleDirection left, SecurityRuleDirection right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleDirection other && Equals(other);
        public bool Equals(SecurityRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Network protocol this rule applies to.
    /// </summary>
    [EnumType]
    public readonly struct SecurityRuleProtocol : IEquatable<SecurityRuleProtocol>
    {
        private readonly string _value;

        private SecurityRuleProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Transmission Control Protocol
        /// </summary>
        public static SecurityRuleProtocol Tcp { get; } = new SecurityRuleProtocol("Tcp");
        /// <summary>
        /// User Datagram Protocol
        /// </summary>
        public static SecurityRuleProtocol Udp { get; } = new SecurityRuleProtocol("Udp");
        /// <summary>
        /// Internet Control Message Protocol
        /// </summary>
        public static SecurityRuleProtocol Icmp { get; } = new SecurityRuleProtocol("Icmp");
        /// <summary>
        /// Wildcard rule for all protocols
        /// </summary>
        public static SecurityRuleProtocol Asterisk { get; } = new SecurityRuleProtocol("*");

        public static bool operator ==(SecurityRuleProtocol left, SecurityRuleProtocol right) => left.Equals(right);
        public static bool operator !=(SecurityRuleProtocol left, SecurityRuleProtocol right) => !left.Equals(right);

        public static explicit operator string(SecurityRuleProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityRuleProtocol other && Equals(other);
        public bool Equals(SecurityRuleProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the SecurityType of the virtual machine. EnableTPM and SecureBootEnabled must be set to true for SecurityType to function.
    /// </summary>
    [EnumType]
    public readonly struct SecurityTypes : IEquatable<SecurityTypes>
    {
        private readonly string _value;

        private SecurityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Trusted Launch security type
        /// </summary>
        public static SecurityTypes TrustedLaunch { get; } = new SecurityTypes("TrustedLaunch");
        /// <summary>
        /// Confidential VM security type
        /// </summary>
        public static SecurityTypes ConfidentialVM { get; } = new SecurityTypes("ConfidentialVM");

        public static bool operator ==(SecurityTypes left, SecurityTypes right) => left.Equals(right);
        public static bool operator !=(SecurityTypes left, SecurityTypes right) => !left.Equals(right);

        public static explicit operator string(SecurityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityTypes other && Equals(other);
        public bool Equals(SecurityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the service.
    /// </summary>
    [EnumType]
    public readonly struct ServiceName : IEquatable<ServiceName>
    {
        private readonly string _value;

        private ServiceName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceName WAC { get; } = new ServiceName("WAC");

        public static bool operator ==(ServiceName left, ServiceName right) => left.Equals(right);
        public static bool operator !=(ServiceName left, ServiceName right) => !left.Equals(right);

        public static explicit operator string(ServiceName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceName other && Equals(other);
        public bool Equals(ServiceName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Customer Intent for Software Assurance Benefit.
    /// </summary>
    [EnumType]
    public readonly struct SoftwareAssuranceIntent : IEquatable<SoftwareAssuranceIntent>
    {
        private readonly string _value;

        private SoftwareAssuranceIntent(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SoftwareAssuranceIntent Enable { get; } = new SoftwareAssuranceIntent("Enable");
        public static SoftwareAssuranceIntent Disable { get; } = new SoftwareAssuranceIntent("Disable");

        public static bool operator ==(SoftwareAssuranceIntent left, SoftwareAssuranceIntent right) => left.Equals(right);
        public static bool operator !=(SoftwareAssuranceIntent left, SoftwareAssuranceIntent right) => !left.Equals(right);

        public static explicit operator string(SoftwareAssuranceIntent value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoftwareAssuranceIntent other && Equals(other);
        public bool Equals(SoftwareAssuranceIntent other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the update as it relates to this stamp.
    /// </summary>
    [EnumType]
    public readonly struct State : IEquatable<State>
    {
        private readonly string _value;

        private State(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static State HasPrerequisite { get; } = new State("HasPrerequisite");
        public static State Obsolete { get; } = new State("Obsolete");
        public static State Ready { get; } = new State("Ready");
        public static State NotApplicableBecauseAnotherUpdateIsInProgress { get; } = new State("NotApplicableBecauseAnotherUpdateIsInProgress");
        public static State Preparing { get; } = new State("Preparing");
        public static State Installing { get; } = new State("Installing");
        public static State Installed { get; } = new State("Installed");
        public static State PreparationFailed { get; } = new State("PreparationFailed");
        public static State InstallationFailed { get; } = new State("InstallationFailed");
        public static State Invalid { get; } = new State("Invalid");
        public static State Recalled { get; } = new State("Recalled");
        public static State Downloading { get; } = new State("Downloading");
        public static State DownloadFailed { get; } = new State("DownloadFailed");
        public static State HealthChecking { get; } = new State("HealthChecking");
        public static State HealthCheckFailed { get; } = new State("HealthCheckFailed");
        public static State ReadyToInstall { get; } = new State("ReadyToInstall");
        public static State ScanInProgress { get; } = new State("ScanInProgress");
        public static State ScanFailed { get; } = new State("ScanFailed");
        public static State AdditionalContentRequired { get; } = new State("AdditionalContentRequired");

        public static bool operator ==(State left, State right) => left.Equals(right);
        public static bool operator !=(State left, State right) => !left.Equals(right);

        public static explicit operator string(State value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is State other && Equals(other);
        public bool Equals(State other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the update run.
    /// </summary>
    [EnumType]
    public readonly struct UpdateRunPropertiesState : IEquatable<UpdateRunPropertiesState>
    {
        private readonly string _value;

        private UpdateRunPropertiesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UpdateRunPropertiesState Unknown { get; } = new UpdateRunPropertiesState("Unknown");
        public static UpdateRunPropertiesState Succeeded { get; } = new UpdateRunPropertiesState("Succeeded");
        public static UpdateRunPropertiesState InProgress { get; } = new UpdateRunPropertiesState("InProgress");
        public static UpdateRunPropertiesState Failed { get; } = new UpdateRunPropertiesState("Failed");

        public static bool operator ==(UpdateRunPropertiesState left, UpdateRunPropertiesState right) => left.Equals(right);
        public static bool operator !=(UpdateRunPropertiesState left, UpdateRunPropertiesState right) => !left.Equals(right);

        public static explicit operator string(UpdateRunPropertiesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpdateRunPropertiesState other && Equals(other);
        public bool Equals(UpdateRunPropertiesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Overall update state of the stamp.
    /// </summary>
    [EnumType]
    public readonly struct UpdateSummariesPropertiesState : IEquatable<UpdateSummariesPropertiesState>
    {
        private readonly string _value;

        private UpdateSummariesPropertiesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UpdateSummariesPropertiesState Unknown { get; } = new UpdateSummariesPropertiesState("Unknown");
        public static UpdateSummariesPropertiesState AppliedSuccessfully { get; } = new UpdateSummariesPropertiesState("AppliedSuccessfully");
        public static UpdateSummariesPropertiesState UpdateAvailable { get; } = new UpdateSummariesPropertiesState("UpdateAvailable");
        public static UpdateSummariesPropertiesState UpdateInProgress { get; } = new UpdateSummariesPropertiesState("UpdateInProgress");
        public static UpdateSummariesPropertiesState UpdateFailed { get; } = new UpdateSummariesPropertiesState("UpdateFailed");
        public static UpdateSummariesPropertiesState NeedsAttention { get; } = new UpdateSummariesPropertiesState("NeedsAttention");
        public static UpdateSummariesPropertiesState PreparationInProgress { get; } = new UpdateSummariesPropertiesState("PreparationInProgress");
        public static UpdateSummariesPropertiesState PreparationFailed { get; } = new UpdateSummariesPropertiesState("PreparationFailed");

        public static bool operator ==(UpdateSummariesPropertiesState left, UpdateSummariesPropertiesState right) => left.Equals(right);
        public static bool operator !=(UpdateSummariesPropertiesState left, UpdateSummariesPropertiesState right) => !left.Equals(right);

        public static explicit operator string(UpdateSummariesPropertiesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpdateSummariesPropertiesState other && Equals(other);
        public bool Equals(UpdateSummariesPropertiesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum of VM Sizes
    /// </summary>
    [EnumType]
    public readonly struct VmSizeEnum : IEquatable<VmSizeEnum>
    {
        private readonly string _value;

        private VmSizeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default virtual machine size
        /// </summary>
        public static VmSizeEnum Default { get; } = new VmSizeEnum("Default");
        /// <summary>
        /// Standard A2 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_A2_v2 { get; } = new VmSizeEnum("Standard_A2_v2");
        /// <summary>
        /// Standard A4 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_A4_v2 { get; } = new VmSizeEnum("Standard_A4_v2");
        /// <summary>
        /// Standard D2s v3 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_D2s_v3 { get; } = new VmSizeEnum("Standard_D2s_v3");
        /// <summary>
        /// Standard D4s v3 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_D4s_v3 { get; } = new VmSizeEnum("Standard_D4s_v3");
        /// <summary>
        /// Standard D8s v3 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_D8s_v3 { get; } = new VmSizeEnum("Standard_D8s_v3");
        /// <summary>
        /// Standard D16s v3 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_D16s_v3 { get; } = new VmSizeEnum("Standard_D16s_v3");
        /// <summary>
        /// Standard D32s v3 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_D32s_v3 { get; } = new VmSizeEnum("Standard_D32s_v3");
        /// <summary>
        /// Standard DS2 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_DS2_v2 { get; } = new VmSizeEnum("Standard_DS2_v2");
        /// <summary>
        /// Standard DS3 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_DS3_v2 { get; } = new VmSizeEnum("Standard_DS3_v2");
        /// <summary>
        /// Standard DS4 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_DS4_v2 { get; } = new VmSizeEnum("Standard_DS4_v2");
        /// <summary>
        /// Standard DS5 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_DS5_v2 { get; } = new VmSizeEnum("Standard_DS5_v2");
        /// <summary>
        /// Standard DS13 v2 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_DS13_v2 { get; } = new VmSizeEnum("Standard_DS13_v2");
        /// <summary>
        /// Standard K8S v1 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_K8S_v1 { get; } = new VmSizeEnum("Standard_K8S_v1");
        /// <summary>
        /// Standard K8S2 v1 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_K8S2_v1 { get; } = new VmSizeEnum("Standard_K8S2_v1");
        /// <summary>
        /// Standard K8S3 v1 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_K8S3_v1 { get; } = new VmSizeEnum("Standard_K8S3_v1");
        /// <summary>
        /// Standard K8S4 v1 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_K8S4_v1 { get; } = new VmSizeEnum("Standard_K8S4_v1");
        /// <summary>
        /// Standard NK6 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_NK6 { get; } = new VmSizeEnum("Standard_NK6");
        /// <summary>
        /// Standard NK12 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_NK12 { get; } = new VmSizeEnum("Standard_NK12");
        /// <summary>
        /// Standard NV6 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_NV6 { get; } = new VmSizeEnum("Standard_NV6");
        /// <summary>
        /// Standard NV12 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_NV12 { get; } = new VmSizeEnum("Standard_NV12");
        /// <summary>
        /// Standard K8S5 v1 virtual machine size
        /// </summary>
        public static VmSizeEnum Standard_K8S5_v1 { get; } = new VmSizeEnum("Standard_K8S5_v1");
        /// <summary>
        /// Custom virtual machine size
        /// </summary>
        public static VmSizeEnum Custom { get; } = new VmSizeEnum("Custom");

        public static bool operator ==(VmSizeEnum left, VmSizeEnum right) => left.Equals(right);
        public static bool operator !=(VmSizeEnum left, VmSizeEnum right) => !left.Equals(right);

        public static explicit operator string(VmSizeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmSizeEnum other && Equals(other);
        public bool Equals(VmSizeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired state of Windows Server Subscription.
    /// </summary>
    [EnumType]
    public readonly struct WindowsServerSubscription : IEquatable<WindowsServerSubscription>
    {
        private readonly string _value;

        private WindowsServerSubscription(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WindowsServerSubscription Disabled { get; } = new WindowsServerSubscription("Disabled");
        public static WindowsServerSubscription Enabled { get; } = new WindowsServerSubscription("Enabled");

        public static bool operator ==(WindowsServerSubscription left, WindowsServerSubscription right) => left.Equals(right);
        public static bool operator !=(WindowsServerSubscription left, WindowsServerSubscription right) => !left.Equals(right);

        public static explicit operator string(WindowsServerSubscription value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsServerSubscription other && Equals(other);
        public bool Equals(WindowsServerSubscription other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
