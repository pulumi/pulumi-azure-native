// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNextGen.Batch.V20170901
{
    /// <summary>
    /// pool - specifies that the task runs as the common auto user account which is created on every node in a pool. task - specifies that the service should create a new user for the task. The default value is task.
    /// </summary>
    [EnumType]
    public readonly struct AutoUserScope : IEquatable<AutoUserScope>
    {
        private readonly string _value;

        private AutoUserScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoUserScope Task { get; } = new AutoUserScope("Task");
        public static AutoUserScope Pool { get; } = new AutoUserScope("Pool");

        public static bool operator ==(AutoUserScope left, AutoUserScope right) => left.Equals(right);
        public static bool operator !=(AutoUserScope left, AutoUserScope right) => !left.Equals(right);

        public static explicit operator string(AutoUserScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoUserScope other && Equals(other);
        public bool Equals(AutoUserScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default value is none.
    /// </summary>
    [EnumType]
    public readonly struct CachingType : IEquatable<CachingType>
    {
        private readonly string _value;

        private CachingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CachingType None { get; } = new CachingType("None");
        public static CachingType ReadOnly { get; } = new CachingType("ReadOnly");
        public static CachingType ReadWrite { get; } = new CachingType("ReadWrite");

        public static bool operator ==(CachingType left, CachingType right) => left.Equals(right);
        public static bool operator !=(CachingType left, CachingType right) => !left.Equals(right);

        public static explicit operator string(CachingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CachingType other && Equals(other);
        public bool Equals(CachingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the certificate - either Pfx or Cer. If omitted, the default is Pfx.
    /// </summary>
    [EnumType]
    public readonly struct CertificateFormat : IEquatable<CertificateFormat>
    {
        private readonly string _value;

        private CertificateFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CertificateFormat Pfx { get; } = new CertificateFormat("Pfx");
        public static CertificateFormat Cer { get; } = new CertificateFormat("Cer");

        public static bool operator ==(CertificateFormat left, CertificateFormat right) => left.Equals(right);
        public static bool operator !=(CertificateFormat left, CertificateFormat right) => !left.Equals(right);

        public static explicit operator string(CertificateFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateFormat other && Equals(other);
        public bool Equals(CertificateFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default value is currentUser. This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of 'remoteUser', a 'certs' directory is created in the user's home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
    /// </summary>
    [EnumType]
    public readonly struct CertificateStoreLocation : IEquatable<CertificateStoreLocation>
    {
        private readonly string _value;

        private CertificateStoreLocation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CertificateStoreLocation CurrentUser { get; } = new CertificateStoreLocation("CurrentUser");
        public static CertificateStoreLocation LocalMachine { get; } = new CertificateStoreLocation("LocalMachine");

        public static bool operator ==(CertificateStoreLocation left, CertificateStoreLocation right) => left.Equals(right);
        public static bool operator !=(CertificateStoreLocation left, CertificateStoreLocation right) => !left.Equals(right);

        public static explicit operator string(CertificateStoreLocation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateStoreLocation other && Equals(other);
        public bool Equals(CertificateStoreLocation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CertificateVisibility : IEquatable<CertificateVisibility>
    {
        private readonly string _value;

        private CertificateVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CertificateVisibility StartTask { get; } = new CertificateVisibility("StartTask");
        public static CertificateVisibility Task { get; } = new CertificateVisibility("Task");
        public static CertificateVisibility RemoteUser { get; } = new CertificateVisibility("RemoteUser");

        public static bool operator ==(CertificateVisibility left, CertificateVisibility right) => left.Equals(right);
        public static bool operator !=(CertificateVisibility left, CertificateVisibility right) => !left.Equals(right);

        public static explicit operator string(CertificateVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateVisibility other && Equals(other);
        public bool Equals(CertificateVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If omitted, the default value is Requeue.
    /// </summary>
    [EnumType]
    public readonly struct ComputeNodeDeallocationOption : IEquatable<ComputeNodeDeallocationOption>
    {
        private readonly string _value;

        private ComputeNodeDeallocationOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeNodeDeallocationOption Requeue { get; } = new ComputeNodeDeallocationOption("Requeue");
        public static ComputeNodeDeallocationOption Terminate { get; } = new ComputeNodeDeallocationOption("Terminate");
        public static ComputeNodeDeallocationOption TaskCompletion { get; } = new ComputeNodeDeallocationOption("TaskCompletion");
        public static ComputeNodeDeallocationOption RetainedData { get; } = new ComputeNodeDeallocationOption("RetainedData");

        public static bool operator ==(ComputeNodeDeallocationOption left, ComputeNodeDeallocationOption right) => left.Equals(right);
        public static bool operator !=(ComputeNodeDeallocationOption left, ComputeNodeDeallocationOption right) => !left.Equals(right);

        public static explicit operator string(ComputeNodeDeallocationOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeNodeDeallocationOption other && Equals(other);
        public bool Equals(ComputeNodeDeallocationOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ComputeNodeFillType : IEquatable<ComputeNodeFillType>
    {
        private readonly string _value;

        private ComputeNodeFillType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeNodeFillType Spread { get; } = new ComputeNodeFillType("Spread");
        public static ComputeNodeFillType Pack { get; } = new ComputeNodeFillType("Pack");

        public static bool operator ==(ComputeNodeFillType left, ComputeNodeFillType right) => left.Equals(right);
        public static bool operator !=(ComputeNodeFillType left, ComputeNodeFillType right) => !left.Equals(right);

        public static explicit operator string(ComputeNodeFillType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeNodeFillType other && Equals(other);
        public bool Equals(ComputeNodeFillType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// nonAdmin - The auto user is a standard user without elevated access. admin - The auto user is a user with elevated access and operates with full Administrator permissions. The default value is nonAdmin.
    /// </summary>
    [EnumType]
    public readonly struct ElevationLevel : IEquatable<ElevationLevel>
    {
        private readonly string _value;

        private ElevationLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ElevationLevel NonAdmin { get; } = new ElevationLevel("NonAdmin");
        public static ElevationLevel Admin { get; } = new ElevationLevel("Admin");

        public static bool operator ==(ElevationLevel left, ElevationLevel right) => left.Equals(right);
        public static bool operator !=(ElevationLevel left, ElevationLevel right) => !left.Equals(right);

        public static explicit operator string(ElevationLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ElevationLevel other && Equals(other);
        public bool Equals(ElevationLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct InboundEndpointProtocol : IEquatable<InboundEndpointProtocol>
    {
        private readonly string _value;

        private InboundEndpointProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InboundEndpointProtocol TCP { get; } = new InboundEndpointProtocol("TCP");
        public static InboundEndpointProtocol UDP { get; } = new InboundEndpointProtocol("UDP");

        public static bool operator ==(InboundEndpointProtocol left, InboundEndpointProtocol right) => left.Equals(right);
        public static bool operator !=(InboundEndpointProtocol left, InboundEndpointProtocol right) => !left.Equals(right);

        public static explicit operator string(InboundEndpointProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InboundEndpointProtocol other && Equals(other);
        public bool Equals(InboundEndpointProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. If not specified, this value defaults to 'Disabled'.
    /// </summary>
    [EnumType]
    public readonly struct InterNodeCommunicationState : IEquatable<InterNodeCommunicationState>
    {
        private readonly string _value;

        private InterNodeCommunicationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterNodeCommunicationState Enabled { get; } = new InterNodeCommunicationState("Enabled");
        public static InterNodeCommunicationState Disabled { get; } = new InterNodeCommunicationState("Disabled");

        public static bool operator ==(InterNodeCommunicationState left, InterNodeCommunicationState right) => left.Equals(right);
        public static bool operator !=(InterNodeCommunicationState left, InterNodeCommunicationState right) => !left.Equals(right);

        public static explicit operator string(InterNodeCommunicationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterNodeCommunicationState other && Equals(other);
        public bool Equals(InterNodeCommunicationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkSecurityGroupRuleAccess : IEquatable<NetworkSecurityGroupRuleAccess>
    {
        private readonly string _value;

        private NetworkSecurityGroupRuleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkSecurityGroupRuleAccess Allow { get; } = new NetworkSecurityGroupRuleAccess("Allow");
        public static NetworkSecurityGroupRuleAccess Deny { get; } = new NetworkSecurityGroupRuleAccess("Deny");

        public static bool operator ==(NetworkSecurityGroupRuleAccess left, NetworkSecurityGroupRuleAccess right) => left.Equals(right);
        public static bool operator !=(NetworkSecurityGroupRuleAccess left, NetworkSecurityGroupRuleAccess right) => !left.Equals(right);

        public static explicit operator string(NetworkSecurityGroupRuleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkSecurityGroupRuleAccess other && Equals(other);
        public bool Equals(NetworkSecurityGroupRuleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pool allocation mode also affects how clients may authenticate to the Batch Service API. If the mode is BatchService, clients may authenticate using access keys or Azure Active Directory. If the mode is UserSubscription, clients must use Azure Active Directory. The default is BatchService.
    /// </summary>
    [EnumType]
    public readonly struct PoolAllocationMode : IEquatable<PoolAllocationMode>
    {
        private readonly string _value;

        private PoolAllocationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PoolAllocationMode BatchService { get; } = new PoolAllocationMode("BatchService");
        public static PoolAllocationMode UserSubscription { get; } = new PoolAllocationMode("UserSubscription");

        public static bool operator ==(PoolAllocationMode left, PoolAllocationMode right) => left.Equals(right);
        public static bool operator !=(PoolAllocationMode left, PoolAllocationMode right) => !left.Equals(right);

        public static explicit operator string(PoolAllocationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PoolAllocationMode other && Equals(other);
        public bool Equals(PoolAllocationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If omitted, the default is "Standard_LRS". Values are:
    /// 
    ///  Standard_LRS - The data disk should use standard locally redundant storage.
    ///  Premium_LRS - The data disk should use premium locally redundant storage.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountType : IEquatable<StorageAccountType>
    {
        private readonly string _value;

        private StorageAccountType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StorageAccountType Standard_LRS { get; } = new StorageAccountType("Standard_LRS");
        public static StorageAccountType Premium_LRS { get; } = new StorageAccountType("Premium_LRS");

        public static bool operator ==(StorageAccountType left, StorageAccountType right) => left.Equals(right);
        public static bool operator !=(StorageAccountType left, StorageAccountType right) => !left.Equals(right);

        public static explicit operator string(StorageAccountType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountType other && Equals(other);
        public bool Equals(StorageAccountType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
