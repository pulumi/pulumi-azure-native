// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.AzureFleet.V20231101Preview
{
    /// <summary>
    /// Specifies the caching requirements. Possible values are: **None,**
    /// **ReadOnly,** **ReadWrite.** The default values are: **None for Standard
    /// storage. ReadOnly for Premium storage.**
    /// </summary>
    [EnumType]
    public readonly struct CachingTypes : IEquatable<CachingTypes>
    {
        private readonly string _value;

        private CachingTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 'None' is default for Standard Storage
        /// </summary>
        public static CachingTypes None { get; } = new CachingTypes("None");
        /// <summary>
        /// 'ReadOnly' is default for Premium Storage
        /// </summary>
        public static CachingTypes ReadOnly { get; } = new CachingTypes("ReadOnly");
        /// <summary>
        /// 'ReadWrite' is default for OS Disk
        /// </summary>
        public static CachingTypes ReadWrite { get; } = new CachingTypes("ReadWrite");

        public static bool operator ==(CachingTypes left, CachingTypes right) => left.Equals(right);
        public static bool operator !=(CachingTypes left, CachingTypes right) => !left.Equals(right);

        public static explicit operator string(CachingTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CachingTypes other && Equals(other);
        public bool Equals(CachingTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The component name. Currently, the only allowable value is
    /// Microsoft-Windows-Shell-Setup.
    /// </summary>
    [EnumType]
    public readonly struct ComponentName : IEquatable<ComponentName>
    {
        private readonly string _value;

        private ComponentName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComponentName Microsoft_Windows_Shell_Setup { get; } = new ComponentName("Microsoft-Windows-Shell-Setup");

        public static bool operator ==(ComponentName left, ComponentName right) => left.Equals(right);
        public static bool operator !=(ComponentName left, ComponentName right) => !left.Equals(right);

        public static explicit operator string(ComponentName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComponentName other && Equals(other);
        public bool Equals(ComponentName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify what happens to the public IP when the VM is deleted
    /// </summary>
    [EnumType]
    public readonly struct DeleteOptions : IEquatable<DeleteOptions>
    {
        private readonly string _value;

        private DeleteOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Delete Option
        /// </summary>
        public static DeleteOptions Delete { get; } = new DeleteOptions("Delete");
        /// <summary>
        /// Detach Option
        /// </summary>
        public static DeleteOptions Detach { get; } = new DeleteOptions("Detach");

        public static bool operator ==(DeleteOptions left, DeleteOptions right) => left.Equals(right);
        public static bool operator !=(DeleteOptions left, DeleteOptions right) => !left.Equals(right);

        public static explicit operator string(DeleteOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeleteOptions other && Equals(other);
        public bool Equals(DeleteOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk settings for operating system disk.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskOptions : IEquatable<DiffDiskOptions>
    {
        private readonly string _value;

        private DiffDiskOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Local Option.
        /// </summary>
        public static DiffDiskOptions Local { get; } = new DiffDiskOptions("Local");

        public static bool operator ==(DiffDiskOptions left, DiffDiskOptions right) => left.Equals(right);
        public static bool operator !=(DiffDiskOptions left, DiffDiskOptions right) => !left.Equals(right);

        public static explicit operator string(DiffDiskOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskOptions other && Equals(other);
        public bool Equals(DiffDiskOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the ephemeral disk placement for operating system disk. Possible
    /// values are: **CacheDisk,** **ResourceDisk.** The defaulting behavior is:
    /// **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk**
    /// is used. Refer to the VM size documentation for Windows VM at
    /// https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at
    /// https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM
    /// sizes exposes a cache disk.
    /// </summary>
    [EnumType]
    public readonly struct DiffDiskPlacement : IEquatable<DiffDiskPlacement>
    {
        private readonly string _value;

        private DiffDiskPlacement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CacheDisk option.
        /// </summary>
        public static DiffDiskPlacement CacheDisk { get; } = new DiffDiskPlacement("CacheDisk");
        /// <summary>
        /// Resource Disk option.
        /// </summary>
        public static DiffDiskPlacement ResourceDisk { get; } = new DiffDiskPlacement("ResourceDisk");
        /// <summary>
        /// NvmeDisk option.
        /// </summary>
        public static DiffDiskPlacement NvmeDisk { get; } = new DiffDiskPlacement("NvmeDisk");

        public static bool operator ==(DiffDiskPlacement left, DiffDiskPlacement right) => left.Equals(right);
        public static bool operator !=(DiffDiskPlacement left, DiffDiskPlacement right) => !left.Equals(right);

        public static explicit operator string(DiffDiskPlacement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiffDiskPlacement other && Equals(other);
        public bool Equals(DiffDiskPlacement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk controller type configured for the virtual machines in the scale set. Minimum api-version: 2022-08-01
    /// </summary>
    [EnumType]
    public readonly struct DiskControllerTypes : IEquatable<DiskControllerTypes>
    {
        private readonly string _value;

        private DiskControllerTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SCSI disk type
        /// </summary>
        public static DiskControllerTypes SCSI { get; } = new DiskControllerTypes("SCSI");
        /// <summary>
        /// NVMe disk type
        /// </summary>
        public static DiskControllerTypes NVMe { get; } = new DiskControllerTypes("NVMe");

        public static bool operator ==(DiskControllerTypes left, DiskControllerTypes right) => left.Equals(right);
        public static bool operator !=(DiskControllerTypes left, DiskControllerTypes right) => !left.Equals(right);

        public static explicit operator string(DiskControllerTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskControllerTypes other && Equals(other);
        public bool Equals(DiskControllerTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the virtual machines in the scale set should be created. The only
    /// allowed value is: **FromImage.** This value is used when you are using an image
    /// to create the virtual machine. If you are using a platform image, you also use
    /// the imageReference element described above. If you are using a marketplace
    /// image, you  also use the plan element previously described.
    /// </summary>
    [EnumType]
    public readonly struct DiskCreateOptionTypes : IEquatable<DiskCreateOptionTypes>
    {
        private readonly string _value;

        private DiskCreateOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This value is used when you are using an image to create the virtual machine.
        /// If you are using a platform image, you also use the imageReference element
        /// described above. If you are using a marketplace image, you also use the
        /// plan element previously described.
        /// </summary>
        public static DiskCreateOptionTypes FromImage { get; } = new DiskCreateOptionTypes("FromImage");
        /// <summary>
        /// This value is used when creating an empty data disk.
        /// </summary>
        public static DiskCreateOptionTypes Empty { get; } = new DiskCreateOptionTypes("Empty");
        /// <summary>
        /// This value is used when you are using a specialized disk to create the virtual machine.
        /// </summary>
        public static DiskCreateOptionTypes Attach { get; } = new DiskCreateOptionTypes("Attach");
        /// <summary>
        /// This value is used to create a data disk from a snapshot or another disk.
        /// </summary>
        public static DiskCreateOptionTypes Copy { get; } = new DiskCreateOptionTypes("Copy");
        /// <summary>
        /// This value is used to create a data disk from a disk restore point.
        /// </summary>
        public static DiskCreateOptionTypes Restore { get; } = new DiskCreateOptionTypes("Restore");

        public static bool operator ==(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskCreateOptionTypes left, DiskCreateOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskCreateOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskCreateOptionTypes other && Equals(other);
        public bool Equals(DiskCreateOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion
    /// (This feature is available for VMSS with Flexible OrchestrationMode only).
    /// &lt;br&gt;&lt;br&gt; Possible values: &lt;br&gt;&lt;br&gt; **Delete** If this value is used, the OS
    /// disk is deleted when VMSS Flex VM is deleted.&lt;br&gt;&lt;br&gt; **Detach** If this value
    /// is used, the OS disk is retained after VMSS Flex VM is deleted. &lt;br&gt;&lt;br&gt; The
    /// default value is set to **Delete**. For an Ephemeral OS Disk, the default value
    /// is set to **Delete**. User cannot change the delete option for Ephemeral OS
    /// Disk.
    /// </summary>
    [EnumType]
    public readonly struct DiskDeleteOptionTypes : IEquatable<DiskDeleteOptionTypes>
    {
        private readonly string _value;

        private DiskDeleteOptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If this value is used, the managed disk is deleted when VM gets deleted.
        /// </summary>
        public static DiskDeleteOptionTypes Delete { get; } = new DiskDeleteOptionTypes("Delete");
        /// <summary>
        /// If this value is used, the managed disk is retained after VM gets deleted.
        /// </summary>
        public static DiskDeleteOptionTypes Detach { get; } = new DiskDeleteOptionTypes("Detach");

        public static bool operator ==(DiskDeleteOptionTypes left, DiskDeleteOptionTypes right) => left.Equals(right);
        public static bool operator !=(DiskDeleteOptionTypes left, DiskDeleteOptionTypes right) => !left.Equals(right);

        public static explicit operator string(DiskDeleteOptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskDeleteOptionTypes other && Equals(other);
        public bool Equals(DiskDeleteOptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Domain name label scope.The concatenation of the hashed domain name label
    /// that generated according to the policy from domain name label scope and vm
    /// index will be the domain name labels of the PublicIPAddress resources that will
    /// be created
    /// </summary>
    [EnumType]
    public readonly struct DomainNameLabelScopeTypes : IEquatable<DomainNameLabelScopeTypes>
    {
        private readonly string _value;

        private DomainNameLabelScopeTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TenantReuse type
        /// </summary>
        public static DomainNameLabelScopeTypes TenantReuse { get; } = new DomainNameLabelScopeTypes("TenantReuse");
        /// <summary>
        /// SubscriptionReuse type
        /// </summary>
        public static DomainNameLabelScopeTypes SubscriptionReuse { get; } = new DomainNameLabelScopeTypes("SubscriptionReuse");
        /// <summary>
        /// ResourceGroupReuse type
        /// </summary>
        public static DomainNameLabelScopeTypes ResourceGroupReuse { get; } = new DomainNameLabelScopeTypes("ResourceGroupReuse");
        /// <summary>
        /// NoReuse type
        /// </summary>
        public static DomainNameLabelScopeTypes NoReuse { get; } = new DomainNameLabelScopeTypes("NoReuse");

        public static bool operator ==(DomainNameLabelScopeTypes left, DomainNameLabelScopeTypes right) => left.Equals(right);
        public static bool operator !=(DomainNameLabelScopeTypes left, DomainNameLabelScopeTypes right) => !left.Equals(right);

        public static explicit operator string(DomainNameLabelScopeTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainNameLabelScopeTypes other && Equals(other);
        public bool Equals(DomainNameLabelScopeTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Eviction Policy to follow when evicting Spot VMs.
    /// </summary>
    [EnumType]
    public readonly struct EvictionPolicy : IEquatable<EvictionPolicy>
    {
        private readonly string _value;

        private EvictionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// When evicted, the Spot VM will be deleted and the corresponding capacity will be updated to reflect this.
        /// </summary>
        public static EvictionPolicy Delete { get; } = new EvictionPolicy("Delete");
        /// <summary>
        /// When evicted, the Spot VM will be deallocated/stopped
        /// </summary>
        public static EvictionPolicy Deallocate { get; } = new EvictionPolicy("Deallocate");

        public static bool operator ==(EvictionPolicy left, EvictionPolicy right) => left.Equals(right);
        public static bool operator !=(EvictionPolicy left, EvictionPolicy right) => !left.Equals(right);

        public static explicit operator string(EvictionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EvictionPolicy other && Equals(other);
        public bool Equals(EvictionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Available from Api-Version 2019-07-01 onwards, it represents whether the
    /// specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible
    /// values are: 'IPv4' and 'IPv6'.
    /// </summary>
    [EnumType]
    public readonly struct IPVersion : IEquatable<IPVersion>
    {
        private readonly string _value;

        private IPVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// IPv4 version
        /// </summary>
        public static IPVersion IPv4 { get; } = new IPVersion("IPv4");
        /// <summary>
        /// IPv6 version
        /// </summary>
        public static IPVersion IPv6 { get; } = new IPVersion("IPv6");

        public static bool operator ==(IPVersion left, IPVersion right) => left.Equals(right);
        public static bool operator !=(IPVersion left, IPVersion right) => !left.Equals(right);

        public static explicit operator string(IPVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPVersion other && Equals(other);
        public bool Equals(IPVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual
    /// machine.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - You
    /// control the timing of patch assessments on a virtual machine. &lt;br /&gt;&lt;br /&gt;
    /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
    /// The property provisionVMAgent must be true.
    /// </summary>
    [EnumType]
    public readonly struct LinuxPatchAssessmentMode : IEquatable<LinuxPatchAssessmentMode>
    {
        private readonly string _value;

        private LinuxPatchAssessmentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// You control the timing of patch assessments on a virtual machine.
        /// </summary>
        public static LinuxPatchAssessmentMode ImageDefault { get; } = new LinuxPatchAssessmentMode("ImageDefault");
        /// <summary>
        /// The platform will trigger periodic patch assessments.The property provisionVMAgent must be true.
        /// </summary>
        public static LinuxPatchAssessmentMode AutomaticByPlatform { get; } = new LinuxPatchAssessmentMode("AutomaticByPlatform");

        public static bool operator ==(LinuxPatchAssessmentMode left, LinuxPatchAssessmentMode right) => left.Equals(right);
        public static bool operator !=(LinuxPatchAssessmentMode left, LinuxPatchAssessmentMode right) => !left.Equals(right);

        public static explicit operator string(LinuxPatchAssessmentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxPatchAssessmentMode other && Equals(other);
        public bool Equals(LinuxPatchAssessmentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the reboot setting for all AutomaticByPlatform patch installation
    /// operations.
    /// </summary>
    [EnumType]
    public readonly struct LinuxVMGuestPatchAutomaticByPlatformRebootSetting : IEquatable<LinuxVMGuestPatchAutomaticByPlatformRebootSetting>
    {
        private readonly string _value;

        private LinuxVMGuestPatchAutomaticByPlatformRebootSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Reboot setting
        /// </summary>
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Unknown { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Unknown");
        /// <summary>
        /// IfRequired Reboot setting
        /// </summary>
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting IfRequired { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("IfRequired");
        /// <summary>
        /// Never Reboot setting
        /// </summary>
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Never { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Never");
        /// <summary>
        /// Always Reboot setting
        /// </summary>
        public static LinuxVMGuestPatchAutomaticByPlatformRebootSetting Always { get; } = new LinuxVMGuestPatchAutomaticByPlatformRebootSetting("Always");

        public static bool operator ==(LinuxVMGuestPatchAutomaticByPlatformRebootSetting left, LinuxVMGuestPatchAutomaticByPlatformRebootSetting right) => left.Equals(right);
        public static bool operator !=(LinuxVMGuestPatchAutomaticByPlatformRebootSetting left, LinuxVMGuestPatchAutomaticByPlatformRebootSetting right) => !left.Equals(right);

        public static explicit operator string(LinuxVMGuestPatchAutomaticByPlatformRebootSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxVMGuestPatchAutomaticByPlatformRebootSetting other && Equals(other);
        public bool Equals(LinuxVMGuestPatchAutomaticByPlatformRebootSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
    /// machines associated to virtual machine scale set with OrchestrationMode as
    /// Flexible.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - The
    /// virtual machine's default patching configuration is used. &lt;br /&gt;&lt;br /&gt;
    /// **AutomaticByPlatform** - The virtual machine will be automatically updated by
    /// the platform. The property provisionVMAgent must be true
    /// </summary>
    [EnumType]
    public readonly struct LinuxVMGuestPatchMode : IEquatable<LinuxVMGuestPatchMode>
    {
        private readonly string _value;

        private LinuxVMGuestPatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The virtual machine's default patching configuration is used.
        /// </summary>
        public static LinuxVMGuestPatchMode ImageDefault { get; } = new LinuxVMGuestPatchMode("ImageDefault");
        /// <summary>
        /// The virtual machine will be automatically updated by the platform. The property provisionVMAgent must be true.
        /// </summary>
        public static LinuxVMGuestPatchMode AutomaticByPlatform { get; } = new LinuxVMGuestPatchMode("AutomaticByPlatform");

        public static bool operator ==(LinuxVMGuestPatchMode left, LinuxVMGuestPatchMode right) => left.Equals(right);
        public static bool operator !=(LinuxVMGuestPatchMode left, LinuxVMGuestPatchMode right) => !left.Equals(right);

        public static explicit operator string(LinuxVMGuestPatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxVMGuestPatchMode other && Equals(other);
        public bool Equals(LinuxVMGuestPatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode that ProxyAgent will execute on if the feature is enabled.
    /// ProxyAgent will start to audit or monitor but not enforce access control over
    /// requests to host endpoints in Audit mode, while in Enforce mode it will enforce
    /// access control. The default value is Enforce mode.
    /// </summary>
    [EnumType]
    public readonly struct Mode : IEquatable<Mode>
    {
        private readonly string _value;

        private Mode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Audit Mode
        /// </summary>
        public static Mode Audit { get; } = new Mode("Audit");
        /// <summary>
        /// Enforce Mode
        /// </summary>
        public static Mode Enforce { get; } = new Mode("Enforce");

        public static bool operator ==(Mode left, Mode right) => left.Equals(right);
        public static bool operator !=(Mode left, Mode right) => !left.Equals(right);

        public static explicit operator string(Mode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Mode other && Equals(other);
        public bool Equals(Mode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// specifies the Microsoft.Network API version used when creating networking
    /// resources in the Network Interface Configurations for Virtual Machine Scale Set
    /// with orchestration mode 'Flexible'
    /// </summary>
    [EnumType]
    public readonly struct NetworkApiVersion : IEquatable<NetworkApiVersion>
    {
        private readonly string _value;

        private NetworkApiVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Initial version supported. Later versions are supported as well.
        /// </summary>
        public static NetworkApiVersion V2020_11_01 { get; } = new NetworkApiVersion("2020-11-01");

        public static bool operator ==(NetworkApiVersion left, NetworkApiVersion right) => left.Equals(right);
        public static bool operator !=(NetworkApiVersion left, NetworkApiVersion right) => !left.Equals(right);

        public static explicit operator string(NetworkApiVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkApiVersion other && Equals(other);
        public bool Equals(NetworkApiVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the Auxiliary mode is enabled for the Network Interface
    /// resource.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceAuxiliaryMode : IEquatable<NetworkInterfaceAuxiliaryMode>
    {
        private readonly string _value;

        private NetworkInterfaceAuxiliaryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// None Mode
        /// </summary>
        public static NetworkInterfaceAuxiliaryMode None { get; } = new NetworkInterfaceAuxiliaryMode("None");
        /// <summary>
        /// AcceleratedConnections Mode
        /// </summary>
        public static NetworkInterfaceAuxiliaryMode AcceleratedConnections { get; } = new NetworkInterfaceAuxiliaryMode("AcceleratedConnections");
        /// <summary>
        /// Floating Mode
        /// </summary>
        public static NetworkInterfaceAuxiliaryMode Floating { get; } = new NetworkInterfaceAuxiliaryMode("Floating");

        public static bool operator ==(NetworkInterfaceAuxiliaryMode left, NetworkInterfaceAuxiliaryMode right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceAuxiliaryMode left, NetworkInterfaceAuxiliaryMode right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceAuxiliaryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceAuxiliaryMode other && Equals(other);
        public bool Equals(NetworkInterfaceAuxiliaryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether the Auxiliary sku is enabled for the Network Interface
    /// resource.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceAuxiliarySku : IEquatable<NetworkInterfaceAuxiliarySku>
    {
        private readonly string _value;

        private NetworkInterfaceAuxiliarySku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// no sku
        /// </summary>
        public static NetworkInterfaceAuxiliarySku None { get; } = new NetworkInterfaceAuxiliarySku("None");
        /// <summary>
        /// A1 sku
        /// </summary>
        public static NetworkInterfaceAuxiliarySku A1 { get; } = new NetworkInterfaceAuxiliarySku("A1");
        /// <summary>
        /// A2 sku
        /// </summary>
        public static NetworkInterfaceAuxiliarySku A2 { get; } = new NetworkInterfaceAuxiliarySku("A2");
        /// <summary>
        /// A4 sku
        /// </summary>
        public static NetworkInterfaceAuxiliarySku A4 { get; } = new NetworkInterfaceAuxiliarySku("A4");
        /// <summary>
        /// A8 sku
        /// </summary>
        public static NetworkInterfaceAuxiliarySku A8 { get; } = new NetworkInterfaceAuxiliarySku("A8");

        public static bool operator ==(NetworkInterfaceAuxiliarySku left, NetworkInterfaceAuxiliarySku right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceAuxiliarySku left, NetworkInterfaceAuxiliarySku right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceAuxiliarySku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceAuxiliarySku other && Equals(other);
        public bool Equals(NetworkInterfaceAuxiliarySku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This property allows you to specify the type of the OS that is included in the
    /// disk if creating a VM from user-image or a specialized VHD. Possible values
    /// are: **Windows,** **Linux.**
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemTypes : IEquatable<OperatingSystemTypes>
    {
        private readonly string _value;

        private OperatingSystemTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Windows OS type
        /// </summary>
        public static OperatingSystemTypes Windows { get; } = new OperatingSystemTypes("Windows");
        /// <summary>
        /// Linux OS type
        /// </summary>
        public static OperatingSystemTypes Linux { get; } = new OperatingSystemTypes("Linux");

        public static bool operator ==(OperatingSystemTypes left, OperatingSystemTypes right) => left.Equals(right);
        public static bool operator !=(OperatingSystemTypes left, OperatingSystemTypes right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemTypes other && Equals(other);
        public bool Equals(OperatingSystemTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pass name. Currently, the only allowable value is OobeSystem.
    /// </summary>
    [EnumType]
    public readonly struct PassName : IEquatable<PassName>
    {
        private readonly string _value;

        private PassName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PassName OobeSystem { get; } = new PassName("OobeSystem");

        public static bool operator ==(PassName left, PassName right) => left.Equals(right);
        public static bool operator !=(PassName left, PassName right) => !left.Equals(right);

        public static explicit operator string(PassName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PassName other && Equals(other);
        public bool Equals(PassName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the protocol of WinRM listener. Possible values are: **http,**
    /// **https.**
    /// </summary>
    [EnumType]
    public readonly struct ProtocolTypes : IEquatable<ProtocolTypes>
    {
        private readonly string _value;

        private ProtocolTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Http protocol
        /// </summary>
        public static ProtocolTypes Http { get; } = new ProtocolTypes("Http");
        /// <summary>
        /// Https protocol
        /// </summary>
        public static ProtocolTypes Https { get; } = new ProtocolTypes("Https");

        public static bool operator ==(ProtocolTypes left, ProtocolTypes right) => left.Equals(right);
        public static bool operator !=(ProtocolTypes left, ProtocolTypes right) => !left.Equals(right);

        public static explicit operator string(ProtocolTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProtocolTypes other && Equals(other);
        public bool Equals(ProtocolTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify public IP sku name
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAddressSkuName : IEquatable<PublicIPAddressSkuName>
    {
        private readonly string _value;

        private PublicIPAddressSkuName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Basic sku name
        /// </summary>
        public static PublicIPAddressSkuName Basic { get; } = new PublicIPAddressSkuName("Basic");
        /// <summary>
        /// Standard sku name
        /// </summary>
        public static PublicIPAddressSkuName Standard { get; } = new PublicIPAddressSkuName("Standard");

        public static bool operator ==(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => left.Equals(right);
        public static bool operator !=(PublicIPAddressSkuName left, PublicIPAddressSkuName right) => !left.Equals(right);

        public static explicit operator string(PublicIPAddressSkuName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAddressSkuName other && Equals(other);
        public bool Equals(PublicIPAddressSkuName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify public IP sku tier
    /// </summary>
    [EnumType]
    public readonly struct PublicIPAddressSkuTier : IEquatable<PublicIPAddressSkuTier>
    {
        private readonly string _value;

        private PublicIPAddressSkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Regional sku tier
        /// </summary>
        public static PublicIPAddressSkuTier Regional { get; } = new PublicIPAddressSkuTier("Regional");
        /// <summary>
        /// Global sku tier
        /// </summary>
        public static PublicIPAddressSkuTier Global { get; } = new PublicIPAddressSkuTier("Global");

        public static bool operator ==(PublicIPAddressSkuTier left, PublicIPAddressSkuTier right) => left.Equals(right);
        public static bool operator !=(PublicIPAddressSkuTier left, PublicIPAddressSkuTier right) => !left.Equals(right);

        public static explicit operator string(PublicIPAddressSkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicIPAddressSkuTier other && Equals(other);
        public bool Equals(PublicIPAddressSkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allocation strategy to follow when determining the VM sizes distribution for Regular VMs.
    /// </summary>
    [EnumType]
    public readonly struct RegularPriorityAllocationStrategy : IEquatable<RegularPriorityAllocationStrategy>
    {
        private readonly string _value;

        private RegularPriorityAllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default. VM sizes distribution will be determined to optimize for price.
        /// </summary>
        public static RegularPriorityAllocationStrategy LowestPrice { get; } = new RegularPriorityAllocationStrategy("LowestPrice");

        public static bool operator ==(RegularPriorityAllocationStrategy left, RegularPriorityAllocationStrategy right) => left.Equals(right);
        public static bool operator !=(RegularPriorityAllocationStrategy left, RegularPriorityAllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(RegularPriorityAllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegularPriorityAllocationStrategy other && Equals(other);
        public bool Equals(RegularPriorityAllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the EncryptionType of the managed disk. It is set to
    /// DiskWithVMGuestState for encryption of the managed disk along with VMGuestState
    /// blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and
    /// NonPersistedTPM for not persisting firmware state in the VMGuestState blob..
    /// **Note:** It can be set for only Confidential VMs.
    /// </summary>
    [EnumType]
    public readonly struct SecurityEncryptionTypes : IEquatable<SecurityEncryptionTypes>
    {
        private readonly string _value;

        private SecurityEncryptionTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EncryptionType of the managed disk is set to VMGuestStateOnly for encryption
        /// of just the VMGuestState blob.
        /// </summary>
        public static SecurityEncryptionTypes VMGuestStateOnly { get; } = new SecurityEncryptionTypes("VMGuestStateOnly");
        /// <summary>
        /// EncryptionType of the managed disk is set to DiskWithVMGuestState for encryption
        /// of the managed disk along with VMGuestState blob.
        /// </summary>
        public static SecurityEncryptionTypes DiskWithVMGuestState { get; } = new SecurityEncryptionTypes("DiskWithVMGuestState");
        /// <summary>
        /// EncryptionType of the managed disk is set to NonPersistedTPM for not persisting
        /// firmware state in the VMGuestState blob.
        /// </summary>
        public static SecurityEncryptionTypes NonPersistedTPM { get; } = new SecurityEncryptionTypes("NonPersistedTPM");

        public static bool operator ==(SecurityEncryptionTypes left, SecurityEncryptionTypes right) => left.Equals(right);
        public static bool operator !=(SecurityEncryptionTypes left, SecurityEncryptionTypes right) => !left.Equals(right);

        public static explicit operator string(SecurityEncryptionTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityEncryptionTypes other && Equals(other);
        public bool Equals(SecurityEncryptionTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the SecurityType of the virtual machine. It has to be set to any
    /// specified value to enable UefiSettings. The default behavior is: UefiSettings
    /// will not be enabled unless this property is set.
    /// </summary>
    [EnumType]
    public readonly struct SecurityTypes : IEquatable<SecurityTypes>
    {
        private readonly string _value;

        private SecurityTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TrustedLaunch security type
        /// </summary>
        public static SecurityTypes TrustedLaunch { get; } = new SecurityTypes("TrustedLaunch");
        /// <summary>
        /// ConfidentialVM security type
        /// </summary>
        public static SecurityTypes ConfidentialVM { get; } = new SecurityTypes("ConfidentialVM");

        public static bool operator ==(SecurityTypes left, SecurityTypes right) => left.Equals(right);
        public static bool operator !=(SecurityTypes left, SecurityTypes right) => !left.Equals(right);

        public static explicit operator string(SecurityTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityTypes other && Equals(other);
        public bool Equals(SecurityTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the name of the setting to which the content applies. Possible values
    /// are: FirstLogonCommands and AutoLogon.
    /// </summary>
    [EnumType]
    public readonly struct SettingNames : IEquatable<SettingNames>
    {
        private readonly string _value;

        private SettingNames(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AutoLogon setting
        /// </summary>
        public static SettingNames AutoLogon { get; } = new SettingNames("AutoLogon");
        /// <summary>
        /// FirstLogonCommands setting
        /// </summary>
        public static SettingNames FirstLogonCommands { get; } = new SettingNames("FirstLogonCommands");

        public static bool operator ==(SettingNames left, SettingNames right) => left.Equals(right);
        public static bool operator !=(SettingNames left, SettingNames right) => !left.Equals(right);

        public static explicit operator string(SettingNames value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingNames other && Equals(other);
        public bool Equals(SettingNames other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Allocation strategy to follow when determining the VM sizes distribution for Spot VMs.
    /// </summary>
    [EnumType]
    public readonly struct SpotAllocationStrategy : IEquatable<SpotAllocationStrategy>
    {
        private readonly string _value;

        private SpotAllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default. VM sizes distribution will be determined to optimize for both price and capacity.
        /// </summary>
        public static SpotAllocationStrategy PriceCapacityOptimized { get; } = new SpotAllocationStrategy("PriceCapacityOptimized");
        /// <summary>
        /// VM sizes distribution will be determined to optimize for price. Note: Capacity will still be considered here but will be given much less weight.
        /// </summary>
        public static SpotAllocationStrategy LowestPrice { get; } = new SpotAllocationStrategy("LowestPrice");
        /// <summary>
        /// VM sizes distribution will be determined to optimize for capacity.
        /// </summary>
        public static SpotAllocationStrategy CapacityOptimized { get; } = new SpotAllocationStrategy("CapacityOptimized");

        public static bool operator ==(SpotAllocationStrategy left, SpotAllocationStrategy right) => left.Equals(right);
        public static bool operator !=(SpotAllocationStrategy left, SpotAllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(SpotAllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotAllocationStrategy other && Equals(other);
        public bool Equals(SpotAllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can
    /// only be used with data disks, it cannot be used with OS Disk.
    /// </summary>
    [EnumType]
    public readonly struct StorageAccountTypes : IEquatable<StorageAccountTypes>
    {
        private readonly string _value;

        private StorageAccountTypes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard_LRS option.
        /// </summary>
        public static StorageAccountTypes Standard_LRS { get; } = new StorageAccountTypes("Standard_LRS");
        /// <summary>
        /// Premium_LRS option.
        /// </summary>
        public static StorageAccountTypes Premium_LRS { get; } = new StorageAccountTypes("Premium_LRS");
        /// <summary>
        /// StandardSSD_LRS option.
        /// </summary>
        public static StorageAccountTypes StandardSSD_LRS { get; } = new StorageAccountTypes("StandardSSD_LRS");
        /// <summary>
        /// UltraSSD_LRS option.
        /// </summary>
        public static StorageAccountTypes UltraSSD_LRS { get; } = new StorageAccountTypes("UltraSSD_LRS");
        /// <summary>
        /// Premium_ZRS option.
        /// </summary>
        public static StorageAccountTypes Premium_ZRS { get; } = new StorageAccountTypes("Premium_ZRS");
        /// <summary>
        /// StandardSSD_ZRS option.
        /// </summary>
        public static StorageAccountTypes StandardSSD_ZRS { get; } = new StorageAccountTypes("StandardSSD_ZRS");
        /// <summary>
        /// PremiumV2_LRS option.
        /// </summary>
        public static StorageAccountTypes PremiumV2_LRS { get; } = new StorageAccountTypes("PremiumV2_LRS");

        public static bool operator ==(StorageAccountTypes left, StorageAccountTypes right) => left.Equals(right);
        public static bool operator !=(StorageAccountTypes left, StorageAccountTypes right) => !left.Equals(right);

        public static explicit operator string(StorageAccountTypes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StorageAccountTypes other && Equals(other);
        public bool Equals(StorageAccountTypes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest patch assessment for the IaaS virtual
    /// machine.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **ImageDefault** - You
    /// control the timing of patch assessments on a virtual machine.&lt;br /&gt;&lt;br /&gt;
    /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
    /// The property provisionVMAgent must be true.
    /// </summary>
    [EnumType]
    public readonly struct WindowsPatchAssessmentMode : IEquatable<WindowsPatchAssessmentMode>
    {
        private readonly string _value;

        private WindowsPatchAssessmentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// You control the timing of patch assessments on a virtual machine.
        /// </summary>
        public static WindowsPatchAssessmentMode ImageDefault { get; } = new WindowsPatchAssessmentMode("ImageDefault");
        /// <summary>
        /// The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
        /// </summary>
        public static WindowsPatchAssessmentMode AutomaticByPlatform { get; } = new WindowsPatchAssessmentMode("AutomaticByPlatform");

        public static bool operator ==(WindowsPatchAssessmentMode left, WindowsPatchAssessmentMode right) => left.Equals(right);
        public static bool operator !=(WindowsPatchAssessmentMode left, WindowsPatchAssessmentMode right) => !left.Equals(right);

        public static explicit operator string(WindowsPatchAssessmentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsPatchAssessmentMode other && Equals(other);
        public bool Equals(WindowsPatchAssessmentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the reboot setting for all AutomaticByPlatform patch installation
    /// operations.
    /// </summary>
    [EnumType]
    public readonly struct WindowsVMGuestPatchAutomaticByPlatformRebootSetting : IEquatable<WindowsVMGuestPatchAutomaticByPlatformRebootSetting>
    {
        private readonly string _value;

        private WindowsVMGuestPatchAutomaticByPlatformRebootSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Reboot setting
        /// </summary>
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Unknown { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Unknown");
        /// <summary>
        /// IfRequired Reboot setting
        /// </summary>
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting IfRequired { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("IfRequired");
        /// <summary>
        /// Never Reboot setting
        /// </summary>
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Never { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Never");
        /// <summary>
        /// Always Reboot setting
        /// </summary>
        public static WindowsVMGuestPatchAutomaticByPlatformRebootSetting Always { get; } = new WindowsVMGuestPatchAutomaticByPlatformRebootSetting("Always");

        public static bool operator ==(WindowsVMGuestPatchAutomaticByPlatformRebootSetting left, WindowsVMGuestPatchAutomaticByPlatformRebootSetting right) => left.Equals(right);
        public static bool operator !=(WindowsVMGuestPatchAutomaticByPlatformRebootSetting left, WindowsVMGuestPatchAutomaticByPlatformRebootSetting right) => !left.Equals(right);

        public static explicit operator string(WindowsVMGuestPatchAutomaticByPlatformRebootSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsVMGuestPatchAutomaticByPlatformRebootSetting other && Equals(other);
        public bool Equals(WindowsVMGuestPatchAutomaticByPlatformRebootSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
    /// machines associated to virtual machine scale set with OrchestrationMode as
    /// Flexible.&lt;br /&gt;&lt;br /&gt; Possible values are:&lt;br /&gt;&lt;br /&gt; **Manual** - You
    /// control the application of patches to a virtual machine. You do this by
    /// applying patches manually inside the VM. In this mode, automatic updates are
    /// disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
    /// false&lt;br /&gt;&lt;br /&gt; **AutomaticByOS** - The virtual machine will automatically be
    /// updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
    /// must be true. &lt;br /&gt;&lt;br /&gt; **AutomaticByPlatform** - the virtual machine will
    /// automatically updated by the platform. The properties provisionVMAgent and
    /// WindowsConfiguration.enableAutomaticUpdates must be true
    /// </summary>
    [EnumType]
    public readonly struct WindowsVMGuestPatchMode : IEquatable<WindowsVMGuestPatchMode>
    {
        private readonly string _value;

        private WindowsVMGuestPatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// You control the application of patches to a virtual machine.
        /// You do this by applying patches manually inside the VM. In this mode,
        /// automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates
        /// must be false
        /// </summary>
        public static WindowsVMGuestPatchMode Manual { get; } = new WindowsVMGuestPatchMode("Manual");
        /// <summary>
        /// The virtual machine will automatically be updated by the OS.
        /// The property WindowsConfiguration.enableAutomaticUpdates must be true.
        /// </summary>
        public static WindowsVMGuestPatchMode AutomaticByOS { get; } = new WindowsVMGuestPatchMode("AutomaticByOS");
        /// <summary>
        /// The virtual machine will automatically updated by the platform. The properties
        /// provisionVMAgent and WindowsConfiguration.enableAutomaticUpdates must be true.
        /// </summary>
        public static WindowsVMGuestPatchMode AutomaticByPlatform { get; } = new WindowsVMGuestPatchMode("AutomaticByPlatform");

        public static bool operator ==(WindowsVMGuestPatchMode left, WindowsVMGuestPatchMode right) => left.Equals(right);
        public static bool operator !=(WindowsVMGuestPatchMode left, WindowsVMGuestPatchMode right) => !left.Equals(right);

        public static explicit operator string(WindowsVMGuestPatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsVMGuestPatchMode other && Equals(other);
        public bool Equals(WindowsVMGuestPatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
