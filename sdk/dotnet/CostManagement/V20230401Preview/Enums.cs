// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.CostManagement.V20230401Preview
{
    /// <summary>
    /// Show costs accumulated over time.
    /// </summary>
    [EnumType]
    public readonly struct AccumulatedType : IEquatable<AccumulatedType>
    {
        private readonly string _value;

        private AccumulatedType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccumulatedType @True { get; } = new AccumulatedType("true");
        public static AccumulatedType @False { get; } = new AccumulatedType("false");

        public static bool operator ==(AccumulatedType left, AccumulatedType right) => left.Equals(right);
        public static bool operator !=(AccumulatedType left, AccumulatedType right) => !left.Equals(right);

        public static explicit operator string(AccumulatedType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccumulatedType other && Equals(other);
        public bool Equals(AccumulatedType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The comparison operator.
    /// 
    ///  Supported for CategoryType(s): Cost, ReservationUtilization.
    /// 
    ///  Supported operators for **CategoryType: Cost**
    /// - GreaterThan
    /// - GreaterThanOrEqualTo
    /// 
    ///  Supported operators for **CategoryType: ReservationUtilization**
    /// - LessThan
    /// </summary>
    [EnumType]
    public readonly struct BudgetNotificationOperatorType : IEquatable<BudgetNotificationOperatorType>
    {
        private readonly string _value;

        private BudgetNotificationOperatorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Notification will be triggered if the evaluated cost is the same as threshold value. Note: It’s not recommended to use this OperatorType as there’s low chance of cost being exactly the same as threshold value, leading to missing of your alert. This OperatorType will be deprecated in future.
        /// 
        ///  Supported for CategoryType(s): Cost.
        /// </summary>
        public static BudgetNotificationOperatorType EqualTo { get; } = new BudgetNotificationOperatorType("EqualTo");
        /// <summary>
        /// Notification will be triggered if the evaluated cost is greater than the threshold value. Note: This is the recommended OperatorType while configuring Budget Alert.
        /// 
        ///  Supported for CategoryType(s): Cost.
        /// </summary>
        public static BudgetNotificationOperatorType GreaterThan { get; } = new BudgetNotificationOperatorType("GreaterThan");
        /// <summary>
        /// Notification will be triggered if the evaluated cost is greater than or equal to the threshold value.
        /// 
        ///  Supported for CategoryType(s): Cost.
        /// </summary>
        public static BudgetNotificationOperatorType GreaterThanOrEqualTo { get; } = new BudgetNotificationOperatorType("GreaterThanOrEqualTo");
        /// <summary>
        /// Notification will be triggered if any Reservations in the scope of the Reservation Utilization Alert Rule have a utilization less than the threshold percentage.
        /// 
        ///  Supported for CategoryType(s): ReservationUtilization.
        /// </summary>
        public static BudgetNotificationOperatorType LessThan { get; } = new BudgetNotificationOperatorType("LessThan");

        public static bool operator ==(BudgetNotificationOperatorType left, BudgetNotificationOperatorType right) => left.Equals(right);
        public static bool operator !=(BudgetNotificationOperatorType left, BudgetNotificationOperatorType right) => !left.Equals(right);

        public static explicit operator string(BudgetNotificationOperatorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BudgetNotificationOperatorType other && Equals(other);
        public bool Equals(BudgetNotificationOperatorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator to use for comparison.
    /// </summary>
    [EnumType]
    public readonly struct BudgetOperatorType : IEquatable<BudgetOperatorType>
    {
        private readonly string _value;

        private BudgetOperatorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BudgetOperatorType In { get; } = new BudgetOperatorType("In");

        public static bool operator ==(BudgetOperatorType left, BudgetOperatorType right) => left.Equals(right);
        public static bool operator !=(BudgetOperatorType left, BudgetOperatorType right) => !left.Equals(right);

        public static explicit operator string(BudgetOperatorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BudgetOperatorType other && Equals(other);
        public bool Equals(BudgetOperatorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The category of the budget.
    /// - 'Cost' defines a Budget.
    /// - 'ReservationUtilization' defines a Reservation Utilization Alert Rule.
    /// </summary>
    [EnumType]
    public readonly struct CategoryType : IEquatable<CategoryType>
    {
        private readonly string _value;

        private CategoryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A Budget that evaluates monetary cost of Azure resources against an amount, and alerts based on a configured notification threshold.
        /// </summary>
        public static CategoryType Cost { get; } = new CategoryType("Cost");
        /// <summary>
        /// An Alert Rule that evaluates the utilization percentage of Azure Reservations, and alerts based on a configured notification threshold.
        /// </summary>
        public static CategoryType ReservationUtilization { get; } = new CategoryType("ReservationUtilization");

        public static bool operator ==(CategoryType left, CategoryType right) => left.Equals(right);
        public static bool operator !=(CategoryType left, CategoryType right) => !left.Equals(right);

        public static explicit operator string(CategoryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CategoryType other && Equals(other);
        public bool Equals(CategoryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Chart type of the main view in Cost Analysis. Required.
    /// </summary>
    [EnumType]
    public readonly struct ChartType : IEquatable<ChartType>
    {
        private readonly string _value;

        private ChartType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChartType Area { get; } = new ChartType("Area");
        public static ChartType Line { get; } = new ChartType("Line");
        public static ChartType StackedColumn { get; } = new ChartType("StackedColumn");
        public static ChartType GroupedColumn { get; } = new ChartType("GroupedColumn");
        public static ChartType Table { get; } = new ChartType("Table");

        public static bool operator ==(ChartType left, ChartType right) => left.Equals(right);
        public static bool operator !=(ChartType left, ChartType right) => !left.Equals(right);

        public static explicit operator string(ChartType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChartType other && Equals(other);
        public bool Equals(ChartType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Language in which the recipient will receive the notification, 
    /// 
    ///  Supported for CategoryType(s): Cost, ReservationUtilization.
    /// </summary>
    [EnumType]
    public readonly struct CultureCode : IEquatable<CultureCode>
    {
        private readonly string _value;

        private CultureCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CultureCode En_us { get; } = new CultureCode("en-us");
        public static CultureCode Ja_jp { get; } = new CultureCode("ja-jp");
        public static CultureCode Zh_cn { get; } = new CultureCode("zh-cn");
        public static CultureCode De_de { get; } = new CultureCode("de-de");
        public static CultureCode Es_es { get; } = new CultureCode("es-es");
        public static CultureCode Fr_fr { get; } = new CultureCode("fr-fr");
        public static CultureCode It_it { get; } = new CultureCode("it-it");
        public static CultureCode Ko_kr { get; } = new CultureCode("ko-kr");
        public static CultureCode Pt_br { get; } = new CultureCode("pt-br");
        public static CultureCode Ru_ru { get; } = new CultureCode("ru-ru");
        public static CultureCode Zh_tw { get; } = new CultureCode("zh-tw");
        public static CultureCode Cs_cz { get; } = new CultureCode("cs-cz");
        public static CultureCode Pl_pl { get; } = new CultureCode("pl-pl");
        public static CultureCode Tr_tr { get; } = new CultureCode("tr-tr");
        public static CultureCode Da_dk { get; } = new CultureCode("da-dk");
        public static CultureCode En_gb { get; } = new CultureCode("en-gb");
        public static CultureCode Hu_hu { get; } = new CultureCode("hu-hu");
        public static CultureCode Nb_no { get; } = new CultureCode("nb-no");
        public static CultureCode Nl_nl { get; } = new CultureCode("nl-nl");
        public static CultureCode Pt_pt { get; } = new CultureCode("pt-pt");
        public static CultureCode Sv_se { get; } = new CultureCode("sv-se");

        public static bool operator ==(CultureCode left, CultureCode right) => left.Equals(right);
        public static bool operator !=(CultureCode left, CultureCode right) => !left.Equals(right);

        public static explicit operator string(CultureCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CultureCode other && Equals(other);
        public bool Equals(CultureCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Days of Week.
    /// </summary>
    [EnumType]
    public readonly struct DaysOfWeek : IEquatable<DaysOfWeek>
    {
        private readonly string _value;

        private DaysOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DaysOfWeek Monday { get; } = new DaysOfWeek("Monday");
        public static DaysOfWeek Tuesday { get; } = new DaysOfWeek("Tuesday");
        public static DaysOfWeek Wednesday { get; } = new DaysOfWeek("Wednesday");
        public static DaysOfWeek Thursday { get; } = new DaysOfWeek("Thursday");
        public static DaysOfWeek Friday { get; } = new DaysOfWeek("Friday");
        public static DaysOfWeek Saturday { get; } = new DaysOfWeek("Saturday");
        public static DaysOfWeek Sunday { get; } = new DaysOfWeek("Sunday");

        public static bool operator ==(DaysOfWeek left, DaysOfWeek right) => left.Equals(right);
        public static bool operator !=(DaysOfWeek left, DaysOfWeek right) => !left.Equals(right);

        public static explicit operator string(DaysOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DaysOfWeek other && Equals(other);
        public bool Equals(DaysOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do not yet provide data for charges or amortization for service reservations.
    /// </summary>
    [EnumType]
    public readonly struct ExportType : IEquatable<ExportType>
    {
        private readonly string _value;

        private ExportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExportType Usage { get; } = new ExportType("Usage");
        public static ExportType ActualCost { get; } = new ExportType("ActualCost");
        public static ExportType AmortizedCost { get; } = new ExportType("AmortizedCost");

        public static bool operator ==(ExportType left, ExportType right) => left.Equals(right);
        public static bool operator !=(ExportType left, ExportType right) => !left.Equals(right);

        public static explicit operator string(ExportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExportType other && Equals(other);
        public bool Equals(ExportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Destination of the view data. Currently only CSV format is supported.
    /// </summary>
    [EnumType]
    public readonly struct FileFormat : IEquatable<FileFormat>
    {
        private readonly string _value;

        private FileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FileFormat Csv { get; } = new FileFormat("Csv");

        public static bool operator ==(FileFormat left, FileFormat right) => left.Equals(right);
        public static bool operator !=(FileFormat left, FileFormat right) => !left.Equals(right);

        public static explicit operator string(FileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileFormat other && Equals(other);
        public bool Equals(FileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the export being delivered. Currently only 'Csv' is supported.
    /// </summary>
    [EnumType]
    public readonly struct FormatType : IEquatable<FormatType>
    {
        private readonly string _value;

        private FormatType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FormatType Csv { get; } = new FormatType("Csv");

        public static bool operator ==(FormatType left, FormatType right) => left.Equals(right);
        public static bool operator !=(FormatType left, FormatType right) => !left.Equals(right);

        public static explicit operator string(FormatType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FormatType other && Equals(other);
        public bool Equals(FormatType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Frequency of a notification. Represents how long the notification will be silent after triggering an alert for a threshold breach. If not specified, the frequency will be set by default based on the timeGrain (Weekly when timeGrain: Last7Days, Monthly when timeGrain: Last30Days).
    /// 
    ///  Supported for CategoryType(s): ReservationUtilization.
    /// </summary>
    [EnumType]
    public readonly struct Frequency : IEquatable<Frequency>
    {
        private readonly string _value;

        private Frequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// After the threshold breaches and an Alert is fired, no further alerts will be sent until the next calendar day.
        /// </summary>
        public static Frequency Daily { get; } = new Frequency("Daily");
        /// <summary>
        /// After the threshold breaches and an Alert is fired, no further alerts will be sent for 7 calendar days.
        /// </summary>
        public static Frequency Weekly { get; } = new Frequency("Weekly");
        /// <summary>
        /// After the threshold breaches and an Alert is fired, no further alerts will be sent for 30 calendar days.
        /// </summary>
        public static Frequency Monthly { get; } = new Frequency("Monthly");

        public static bool operator ==(Frequency left, Frequency right) => left.Equals(right);
        public static bool operator !=(Frequency left, Frequency right) => !left.Equals(right);

        public static explicit operator string(Frequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Frequency other && Equals(other);
        public bool Equals(Frequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The name of the aggregation function to use.
    /// </summary>
    [EnumType]
    public readonly struct FunctionType : IEquatable<FunctionType>
    {
        private readonly string _value;

        private FunctionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionType Sum { get; } = new FunctionType("Sum");

        public static bool operator ==(FunctionType left, FunctionType right) => left.Equals(right);
        public static bool operator !=(FunctionType left, FunctionType right) => !left.Equals(right);

        public static explicit operator string(FunctionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionType other && Equals(other);
        public bool Equals(FunctionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The granularity of rows in the export. Currently only 'Daily' is supported.
    /// </summary>
    [EnumType]
    public readonly struct GranularityType : IEquatable<GranularityType>
    {
        private readonly string _value;

        private GranularityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GranularityType Daily { get; } = new GranularityType("Daily");

        public static bool operator ==(GranularityType left, GranularityType right) => left.Equals(right);
        public static bool operator !=(GranularityType left, GranularityType right) => !left.Equals(right);

        public static explicit operator string(GranularityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GranularityType other && Equals(other);
        public bool Equals(GranularityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// KPI type (Forecast, Budget).
    /// </summary>
    [EnumType]
    public readonly struct KpiTypeType : IEquatable<KpiTypeType>
    {
        private readonly string _value;

        private KpiTypeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KpiTypeType Forecast { get; } = new KpiTypeType("Forecast");
        public static KpiTypeType Budget { get; } = new KpiTypeType("Budget");

        public static bool operator ==(KpiTypeType left, KpiTypeType right) => left.Equals(right);
        public static bool operator !=(KpiTypeType left, KpiTypeType right) => !left.Equals(right);

        public static explicit operator string(KpiTypeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KpiTypeType other && Equals(other);
        public bool Equals(KpiTypeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Metric to use when displaying costs.
    /// </summary>
    [EnumType]
    public readonly struct MetricType : IEquatable<MetricType>
    {
        private readonly string _value;

        private MetricType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetricType ActualCost { get; } = new MetricType("ActualCost");
        public static MetricType AmortizedCost { get; } = new MetricType("AmortizedCost");
        public static MetricType AHUB { get; } = new MetricType("AHUB");

        public static bool operator ==(MetricType left, MetricType right) => left.Equals(right);
        public static bool operator !=(MetricType left, MetricType right) => !left.Equals(right);

        public static explicit operator string(MetricType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricType other && Equals(other);
        public bool Equals(MetricType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator to use for comparison.
    /// </summary>
    [EnumType]
    public readonly struct OperatorType : IEquatable<OperatorType>
    {
        private readonly string _value;

        private OperatorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatorType In { get; } = new OperatorType("In");
        public static OperatorType Contains { get; } = new OperatorType("Contains");

        public static bool operator ==(OperatorType left, OperatorType right) => left.Equals(right);
        public static bool operator !=(OperatorType left, OperatorType right) => !left.Equals(right);

        public static explicit operator string(OperatorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatorType other && Equals(other);
        public bool Equals(OperatorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data type to show in view.
    /// </summary>
    [EnumType]
    public readonly struct PivotTypeType : IEquatable<PivotTypeType>
    {
        private readonly string _value;

        private PivotTypeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PivotTypeType Dimension { get; } = new PivotTypeType("Dimension");
        public static PivotTypeType TagKey { get; } = new PivotTypeType("TagKey");

        public static bool operator ==(PivotTypeType left, PivotTypeType right) => left.Equals(right);
        public static bool operator !=(PivotTypeType left, PivotTypeType right) => !left.Equals(right);

        public static explicit operator string(PivotTypeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PivotTypeType other && Equals(other);
        public bool Equals(PivotTypeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Has type of the column to group.
    /// </summary>
    [EnumType]
    public readonly struct QueryColumnType : IEquatable<QueryColumnType>
    {
        private readonly string _value;

        private QueryColumnType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The tag associated with the cost data.
        /// </summary>
        public static QueryColumnType TagKey { get; } = new QueryColumnType("TagKey");
        /// <summary>
        /// The dimension of cost data.
        /// </summary>
        public static QueryColumnType Dimension { get; } = new QueryColumnType("Dimension");

        public static bool operator ==(QueryColumnType left, QueryColumnType right) => left.Equals(right);
        public static bool operator !=(QueryColumnType left, QueryColumnType right) => !left.Equals(right);

        public static explicit operator string(QueryColumnType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is QueryColumnType other && Equals(other);
        public bool Equals(QueryColumnType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The schedule recurrence.
    /// </summary>
    [EnumType]
    public readonly struct RecurrenceType : IEquatable<RecurrenceType>
    {
        private readonly string _value;

        private RecurrenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecurrenceType Daily { get; } = new RecurrenceType("Daily");
        public static RecurrenceType Weekly { get; } = new RecurrenceType("Weekly");
        public static RecurrenceType Monthly { get; } = new RecurrenceType("Monthly");
        public static RecurrenceType Annually { get; } = new RecurrenceType("Annually");

        public static bool operator ==(RecurrenceType left, RecurrenceType right) => left.Equals(right);
        public static bool operator !=(RecurrenceType left, RecurrenceType right) => !left.Equals(right);

        public static explicit operator string(RecurrenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurrenceType other && Equals(other);
        public bool Equals(RecurrenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of sort.
    /// </summary>
    [EnumType]
    public readonly struct ReportConfigSortingType : IEquatable<ReportConfigSortingType>
    {
        private readonly string _value;

        private ReportConfigSortingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReportConfigSortingType Ascending { get; } = new ReportConfigSortingType("Ascending");
        public static ReportConfigSortingType Descending { get; } = new ReportConfigSortingType("Descending");

        public static bool operator ==(ReportConfigSortingType left, ReportConfigSortingType right) => left.Equals(right);
        public static bool operator !=(ReportConfigSortingType left, ReportConfigSortingType right) => !left.Equals(right);

        public static explicit operator string(ReportConfigSortingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportConfigSortingType other && Equals(other);
        public bool Equals(ReportConfigSortingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The granularity of rows in the report.
    /// </summary>
    [EnumType]
    public readonly struct ReportGranularityType : IEquatable<ReportGranularityType>
    {
        private readonly string _value;

        private ReportGranularityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReportGranularityType Daily { get; } = new ReportGranularityType("Daily");
        public static ReportGranularityType Monthly { get; } = new ReportGranularityType("Monthly");

        public static bool operator ==(ReportGranularityType left, ReportGranularityType right) => left.Equals(right);
        public static bool operator !=(ReportGranularityType left, ReportGranularityType right) => !left.Equals(right);

        public static explicit operator string(ReportGranularityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportGranularityType other && Equals(other);
        public bool Equals(ReportGranularityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The time frame for pulling data for the report. If custom, then a specific time period must be provided.
    /// </summary>
    [EnumType]
    public readonly struct ReportTimeframeType : IEquatable<ReportTimeframeType>
    {
        private readonly string _value;

        private ReportTimeframeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReportTimeframeType WeekToDate { get; } = new ReportTimeframeType("WeekToDate");
        public static ReportTimeframeType MonthToDate { get; } = new ReportTimeframeType("MonthToDate");
        public static ReportTimeframeType YearToDate { get; } = new ReportTimeframeType("YearToDate");
        public static ReportTimeframeType Custom { get; } = new ReportTimeframeType("Custom");

        public static bool operator ==(ReportTimeframeType left, ReportTimeframeType right) => left.Equals(right);
        public static bool operator !=(ReportTimeframeType left, ReportTimeframeType right) => !left.Equals(right);

        public static explicit operator string(ReportTimeframeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportTimeframeType other && Equals(other);
        public bool Equals(ReportTimeframeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the report. Usage represents actual usage, forecast represents forecasted data and UsageAndForecast represents both usage and forecasted data. Actual usage and forecasted data can be differentiated based on dates.
    /// </summary>
    [EnumType]
    public readonly struct ReportType : IEquatable<ReportType>
    {
        private readonly string _value;

        private ReportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReportType Usage { get; } = new ReportType("Usage");

        public static bool operator ==(ReportType left, ReportType right) => left.Equals(right);
        public static bool operator !=(ReportType left, ReportType right) => !left.Equals(right);

        public static explicit operator string(ReportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportType other && Equals(other);
        public bool Equals(ReportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Frequency of the schedule.
    /// </summary>
    [EnumType]
    public readonly struct ScheduleFrequency : IEquatable<ScheduleFrequency>
    {
        private readonly string _value;

        private ScheduleFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cost analysis data will be emailed every day.
        /// </summary>
        public static ScheduleFrequency Daily { get; } = new ScheduleFrequency("Daily");
        /// <summary>
        /// Cost analysis data will be emailed every week.
        /// </summary>
        public static ScheduleFrequency Weekly { get; } = new ScheduleFrequency("Weekly");
        /// <summary>
        /// Cost analysis data will be emailed every month.
        /// </summary>
        public static ScheduleFrequency Monthly { get; } = new ScheduleFrequency("Monthly");

        public static bool operator ==(ScheduleFrequency left, ScheduleFrequency right) => left.Equals(right);
        public static bool operator !=(ScheduleFrequency left, ScheduleFrequency right) => !left.Equals(right);

        public static explicit operator string(ScheduleFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduleFrequency other && Equals(other);
        public bool Equals(ScheduleFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Kind of the scheduled action.
    /// </summary>
    [EnumType]
    public readonly struct ScheduledActionKind : IEquatable<ScheduledActionKind>
    {
        private readonly string _value;

        private ScheduledActionKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Cost analysis data will be emailed.
        /// </summary>
        public static ScheduledActionKind Email { get; } = new ScheduledActionKind("Email");
        /// <summary>
        /// Cost anomaly information will be emailed. Available only on subscription scope at daily frequency. If no anomaly is detected on the resource, an email won't be sent.
        /// </summary>
        public static ScheduledActionKind InsightAlert { get; } = new ScheduledActionKind("InsightAlert");

        public static bool operator ==(ScheduledActionKind left, ScheduledActionKind right) => left.Equals(right);
        public static bool operator !=(ScheduledActionKind left, ScheduledActionKind right) => !left.Equals(right);

        public static explicit operator string(ScheduledActionKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduledActionKind other && Equals(other);
        public bool Equals(ScheduledActionKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Status of the scheduled action.
    /// </summary>
    [EnumType]
    public readonly struct ScheduledActionStatus : IEquatable<ScheduledActionStatus>
    {
        private readonly string _value;

        private ScheduledActionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Scheduled action is saved but will not be run.
        /// </summary>
        public static ScheduledActionStatus Disabled { get; } = new ScheduledActionStatus("Disabled");
        /// <summary>
        /// Scheduled action is saved and will be run.
        /// </summary>
        public static ScheduledActionStatus Enabled { get; } = new ScheduledActionStatus("Enabled");
        /// <summary>
        /// Scheduled action is expired.
        /// </summary>
        public static ScheduledActionStatus Expired { get; } = new ScheduledActionStatus("Expired");

        public static bool operator ==(ScheduledActionStatus left, ScheduledActionStatus right) => left.Equals(right);
        public static bool operator !=(ScheduledActionStatus left, ScheduledActionStatus right) => !left.Equals(right);

        public static explicit operator string(ScheduledActionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduledActionStatus other && Equals(other);
        public bool Equals(ScheduledActionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the export's schedule. If 'Inactive', the export's schedule is paused.
    /// </summary>
    [EnumType]
    public readonly struct StatusType : IEquatable<StatusType>
    {
        private readonly string _value;

        private StatusType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StatusType Active { get; } = new StatusType("Active");
        public static StatusType Inactive { get; } = new StatusType("Inactive");

        public static bool operator ==(StatusType left, StatusType right) => left.Equals(right);
        public static bool operator !=(StatusType left, StatusType right) => !left.Equals(right);

        public static explicit operator string(StatusType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusType other && Equals(other);
        public bool Equals(StatusType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (either system assigned, or none).
    /// </summary>
    [EnumType]
    public readonly struct SystemAssignedServiceIdentityType : IEquatable<SystemAssignedServiceIdentityType>
    {
        private readonly string _value;

        private SystemAssignedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SystemAssignedServiceIdentityType None { get; } = new SystemAssignedServiceIdentityType("None");
        public static SystemAssignedServiceIdentityType SystemAssigned { get; } = new SystemAssignedServiceIdentityType("SystemAssigned");

        public static bool operator ==(SystemAssignedServiceIdentityType left, SystemAssignedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(SystemAssignedServiceIdentityType left, SystemAssignedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(SystemAssignedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SystemAssignedServiceIdentityType other && Equals(other);
        public bool Equals(SystemAssignedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of threshold.
    /// 
    ///  Supported for CategoryType(s): Cost.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdType : IEquatable<ThresholdType>
    {
        private readonly string _value;

        private ThresholdType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Actual costs budget alerts notify when the actual accrued cost exceeds the allocated budget.
        /// </summary>
        public static ThresholdType Actual { get; } = new ThresholdType("Actual");
        /// <summary>
        /// Forecasted costs budget alerts provide advanced notification that your spending trends are likely to exceed your allocated budget, as it relies on forecasted cost predictions.
        /// </summary>
        public static ThresholdType Forecasted { get; } = new ThresholdType("Forecasted");

        public static bool operator ==(ThresholdType left, ThresholdType right) => left.Equals(right);
        public static bool operator !=(ThresholdType left, ThresholdType right) => !left.Equals(right);

        public static explicit operator string(ThresholdType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdType other && Equals(other);
        public bool Equals(ThresholdType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The time covered by a budget. Tracking of the amount will be reset based on the time grain.
    /// 
    /// Supported for CategoryType(s): Cost, ReservationUtilization.
    /// 
    ///  Supported timeGrainTypes for **CategoryType: Cost**
    /// 
    /// - Monthly
    /// - Quarterly
    /// - Annually
    /// - BillingMonth*
    /// - BillingQuarter*
    /// - BillingAnnual*
    /// 
    ///   *only supported for Web Direct customers.
    /// 
    ///  Supported timeGrainTypes for **CategoryType: ReservationUtilization**
    /// - Last7Days
    /// - Last30Days
    /// 
    ///  Required for CategoryType(s): Cost, ReservationUtilization.
    /// </summary>
    [EnumType]
    public readonly struct TimeGrainType : IEquatable<TimeGrainType>
    {
        private readonly string _value;

        private TimeGrainType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The budget will track costs in the current calendar month against the amount.
        /// 
        ///  Supported for CategoryType: Cost only.
        /// </summary>
        public static TimeGrainType Monthly { get; } = new TimeGrainType("Monthly");
        /// <summary>
        /// The budget will track costs in the current calendar quarter against the amount.
        /// 
        ///  Supported for CategoryType: Cost only.
        /// </summary>
        public static TimeGrainType Quarterly { get; } = new TimeGrainType("Quarterly");
        /// <summary>
        /// The budget will track costs in the current calendar year against the amount.
        /// 
        ///  Supported for CategoryType: Cost only.
        /// </summary>
        public static TimeGrainType Annually { get; } = new TimeGrainType("Annually");
        /// <summary>
        /// The budget will track costs in the current billing month against the amount.
        /// 
        ///  Supported for CategoryType: Cost and Web Direct customers only.
        /// </summary>
        public static TimeGrainType BillingMonth { get; } = new TimeGrainType("BillingMonth");
        /// <summary>
        /// The budget will track costs in the current billing quarter against the amount.
        /// 
        ///  Supported for CategoryType: Cost and Web Direct customers only.
        /// </summary>
        public static TimeGrainType BillingQuarter { get; } = new TimeGrainType("BillingQuarter");
        /// <summary>
        /// The budget will track costs in the current billing year against the amount.
        /// 
        ///  Supported for CategoryType: Cost and Web Direct customers only.
        /// </summary>
        public static TimeGrainType BillingAnnual { get; } = new TimeGrainType("BillingAnnual");
        /// <summary>
        /// The Reservation Utilization Alert Rule will evaluate reservations based on their 7-Day utilization percentage.
        /// 
        ///  Supported for CategoryType: ReservationUtilization only.
        /// </summary>
        public static TimeGrainType Last7Days { get; } = new TimeGrainType("Last7Days");
        /// <summary>
        /// The Reservation Utilization Alert Rule will evaluate reservations based on their 30-Day utilization percentage.
        /// 
        ///  Supported for CategoryType: ReservationUtilization only.
        /// </summary>
        public static TimeGrainType Last30Days { get; } = new TimeGrainType("Last30Days");

        public static bool operator ==(TimeGrainType left, TimeGrainType right) => left.Equals(right);
        public static bool operator !=(TimeGrainType left, TimeGrainType right) => !left.Equals(right);

        public static explicit operator string(TimeGrainType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeGrainType other && Equals(other);
        public bool Equals(TimeGrainType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The time frame for pulling data for the export. If custom, then a specific time period must be provided.
    /// </summary>
    [EnumType]
    public readonly struct TimeframeType : IEquatable<TimeframeType>
    {
        private readonly string _value;

        private TimeframeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TimeframeType MonthToDate { get; } = new TimeframeType("MonthToDate");
        public static TimeframeType BillingMonthToDate { get; } = new TimeframeType("BillingMonthToDate");
        public static TimeframeType TheLastMonth { get; } = new TimeframeType("TheLastMonth");
        public static TimeframeType TheLastBillingMonth { get; } = new TimeframeType("TheLastBillingMonth");
        public static TimeframeType WeekToDate { get; } = new TimeframeType("WeekToDate");
        public static TimeframeType Custom { get; } = new TimeframeType("Custom");

        public static bool operator ==(TimeframeType left, TimeframeType right) => left.Equals(right);
        public static bool operator !=(TimeframeType left, TimeframeType right) => !left.Equals(right);

        public static explicit operator string(TimeframeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeframeType other && Equals(other);
        public bool Equals(TimeframeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Weeks of month.
    /// </summary>
    [EnumType]
    public readonly struct WeeksOfMonth : IEquatable<WeeksOfMonth>
    {
        private readonly string _value;

        private WeeksOfMonth(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WeeksOfMonth First { get; } = new WeeksOfMonth("First");
        public static WeeksOfMonth Second { get; } = new WeeksOfMonth("Second");
        public static WeeksOfMonth Third { get; } = new WeeksOfMonth("Third");
        public static WeeksOfMonth Fourth { get; } = new WeeksOfMonth("Fourth");
        public static WeeksOfMonth Last { get; } = new WeeksOfMonth("Last");

        public static bool operator ==(WeeksOfMonth left, WeeksOfMonth right) => left.Equals(right);
        public static bool operator !=(WeeksOfMonth left, WeeksOfMonth right) => !left.Equals(right);

        public static explicit operator string(WeeksOfMonth value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeeksOfMonth other && Equals(other);
        public bool Equals(WeeksOfMonth other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
