// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.MachineLearningServices.V20220501
{
    /// <summary>
    /// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationSharingPolicy : IEquatable<ApplicationSharingPolicy>
    {
        private readonly string _value;

        private ApplicationSharingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationSharingPolicy Personal { get; } = new ApplicationSharingPolicy("Personal");
        public static ApplicationSharingPolicy Shared { get; } = new ApplicationSharingPolicy("Shared");

        public static bool operator ==(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => left.Equals(right);
        public static bool operator !=(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => !left.Equals(right);

        public static explicit operator string(ApplicationSharingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationSharingPolicy other && Equals(other);
        public bool Equals(ApplicationSharingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logging level for batch inference operation.
    /// </summary>
    [EnumType]
    public readonly struct BatchLoggingLevel : IEquatable<BatchLoggingLevel>
    {
        private readonly string _value;

        private BatchLoggingLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchLoggingLevel Info { get; } = new BatchLoggingLevel("Info");
        public static BatchLoggingLevel Warning { get; } = new BatchLoggingLevel("Warning");
        public static BatchLoggingLevel Debug { get; } = new BatchLoggingLevel("Debug");

        public static bool operator ==(BatchLoggingLevel left, BatchLoggingLevel right) => left.Equals(right);
        public static bool operator !=(BatchLoggingLevel left, BatchLoggingLevel right) => !left.Equals(right);

        public static explicit operator string(BatchLoggingLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchLoggingLevel other && Equals(other);
        public bool Equals(BatchLoggingLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how the output will be organized.
    /// </summary>
    [EnumType]
    public readonly struct BatchOutputAction : IEquatable<BatchOutputAction>
    {
        private readonly string _value;

        private BatchOutputAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchOutputAction SummaryOnly { get; } = new BatchOutputAction("SummaryOnly");
        public static BatchOutputAction AppendRow { get; } = new BatchOutputAction("AppendRow");

        public static bool operator ==(BatchOutputAction left, BatchOutputAction right) => left.Equals(right);
        public static bool operator !=(BatchOutputAction left, BatchOutputAction right) => !left.Equals(right);

        public static explicit operator string(BatchOutputAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchOutputAction other && Equals(other);
        public bool Equals(BatchOutputAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Intended usage of the cluster
    /// </summary>
    [EnumType]
    public readonly struct ClusterPurpose : IEquatable<ClusterPurpose>
    {
        private readonly string _value;

        private ClusterPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterPurpose FastProd { get; } = new ClusterPurpose("FastProd");
        public static ClusterPurpose DenseProd { get; } = new ClusterPurpose("DenseProd");
        public static ClusterPurpose DevTest { get; } = new ClusterPurpose("DevTest");

        public static bool operator ==(ClusterPurpose left, ClusterPurpose right) => left.Equals(right);
        public static bool operator !=(ClusterPurpose left, ClusterPurpose right) => !left.Equals(right);

        public static explicit operator string(ClusterPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterPurpose other && Equals(other);
        public bool Equals(ClusterPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Compute Instance Authorization type. Available values are personal (default).
    /// </summary>
    [EnumType]
    public readonly struct ComputeInstanceAuthorizationType : IEquatable<ComputeInstanceAuthorizationType>
    {
        private readonly string _value;

        private ComputeInstanceAuthorizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeInstanceAuthorizationType Personal { get; } = new ComputeInstanceAuthorizationType("personal");

        public static bool operator ==(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => left.Equals(right);
        public static bool operator !=(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => !left.Equals(right);

        public static explicit operator string(ComputeInstanceAuthorizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeInstanceAuthorizationType other && Equals(other);
        public bool Equals(ComputeInstanceAuthorizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compute
    /// </summary>
    [EnumType]
    public readonly struct ComputeType : IEquatable<ComputeType>
    {
        private readonly string _value;

        private ComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeType AKS { get; } = new ComputeType("AKS");
        public static ComputeType Kubernetes { get; } = new ComputeType("Kubernetes");
        public static ComputeType AmlCompute { get; } = new ComputeType("AmlCompute");
        public static ComputeType ComputeInstance { get; } = new ComputeType("ComputeInstance");
        public static ComputeType DataFactory { get; } = new ComputeType("DataFactory");
        public static ComputeType VirtualMachine { get; } = new ComputeType("VirtualMachine");
        public static ComputeType HDInsight { get; } = new ComputeType("HDInsight");
        public static ComputeType Databricks { get; } = new ComputeType("Databricks");
        public static ComputeType DataLakeAnalytics { get; } = new ComputeType("DataLakeAnalytics");
        public static ComputeType SynapseSpark { get; } = new ComputeType("SynapseSpark");

        public static bool operator ==(ComputeType left, ComputeType right) => left.Equals(right);
        public static bool operator !=(ComputeType left, ComputeType right) => !left.Equals(right);

        public static explicit operator string(ComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeType other && Equals(other);
        public bool Equals(ComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Authentication type of the connection target
    /// </summary>
    [EnumType]
    public readonly struct ConnectionAuthType : IEquatable<ConnectionAuthType>
    {
        private readonly string _value;

        private ConnectionAuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionAuthType PAT { get; } = new ConnectionAuthType("PAT");
        public static ConnectionAuthType ManagedIdentity { get; } = new ConnectionAuthType("ManagedIdentity");
        public static ConnectionAuthType UsernamePassword { get; } = new ConnectionAuthType("UsernamePassword");
        public static ConnectionAuthType None { get; } = new ConnectionAuthType("None");
        public static ConnectionAuthType SAS { get; } = new ConnectionAuthType("SAS");

        public static bool operator ==(ConnectionAuthType left, ConnectionAuthType right) => left.Equals(right);
        public static bool operator !=(ConnectionAuthType left, ConnectionAuthType right) => !left.Equals(right);

        public static explicit operator string(ConnectionAuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionAuthType other && Equals(other);
        public bool Equals(ConnectionAuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Category of the connection
    /// </summary>
    [EnumType]
    public readonly struct ConnectionCategory : IEquatable<ConnectionCategory>
    {
        private readonly string _value;

        private ConnectionCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionCategory PythonFeed { get; } = new ConnectionCategory("PythonFeed");
        public static ConnectionCategory ContainerRegistry { get; } = new ConnectionCategory("ContainerRegistry");
        public static ConnectionCategory Git { get; } = new ConnectionCategory("Git");

        public static bool operator ==(ConnectionCategory left, ConnectionCategory right) => left.Equals(right);
        public static bool operator !=(ConnectionCategory left, ConnectionCategory right) => !left.Equals(right);

        public static explicit operator string(ConnectionCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionCategory other && Equals(other);
        public bool Equals(ConnectionCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of container to retrieve logs from.
    /// </summary>
    [EnumType]
    public readonly struct ContainerType : IEquatable<ContainerType>
    {
        private readonly string _value;

        private ContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerType StorageInitializer { get; } = new ContainerType("StorageInitializer");
        public static ContainerType InferenceServer { get; } = new ContainerType("InferenceServer");

        public static bool operator ==(ContainerType left, ContainerType right) => left.Equals(right);
        public static bool operator !=(ContainerType left, ContainerType right) => !left.Equals(right);

        public static explicit operator string(ContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerType other && Equals(other);
        public bool Equals(ContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct CredentialsType : IEquatable<CredentialsType>
    {
        private readonly string _value;

        private CredentialsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CredentialsType AccountKey { get; } = new CredentialsType("AccountKey");
        public static CredentialsType Certificate { get; } = new CredentialsType("Certificate");
        public static CredentialsType None { get; } = new CredentialsType("None");
        public static CredentialsType Sas { get; } = new CredentialsType("Sas");
        public static CredentialsType ServicePrincipal { get; } = new CredentialsType("ServicePrincipal");

        public static bool operator ==(CredentialsType left, CredentialsType right) => left.Equals(right);
        public static bool operator !=(CredentialsType left, CredentialsType right) => !left.Equals(right);

        public static explicit operator string(CredentialsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CredentialsType other && Equals(other);
        public bool Equals(CredentialsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of data.
    /// </summary>
    [EnumType]
    public readonly struct DataType : IEquatable<DataType>
    {
        private readonly string _value;

        private DataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataType Uri_file { get; } = new DataType("uri_file");
        public static DataType Uri_folder { get; } = new DataType("uri_folder");
        public static DataType Mltable { get; } = new DataType("mltable");

        public static bool operator ==(DataType left, DataType right) => left.Equals(right);
        public static bool operator !=(DataType left, DataType right) => !left.Equals(right);

        public static explicit operator string(DataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataType other && Equals(other);
        public bool Equals(DataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Storage type backing the datastore.
    /// </summary>
    [EnumType]
    public readonly struct DatastoreType : IEquatable<DatastoreType>
    {
        private readonly string _value;

        private DatastoreType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatastoreType AzureBlob { get; } = new DatastoreType("AzureBlob");
        public static DatastoreType AzureDataLakeGen1 { get; } = new DatastoreType("AzureDataLakeGen1");
        public static DatastoreType AzureDataLakeGen2 { get; } = new DatastoreType("AzureDataLakeGen2");
        public static DatastoreType AzureFile { get; } = new DatastoreType("AzureFile");

        public static bool operator ==(DatastoreType left, DatastoreType right) => left.Equals(right);
        public static bool operator !=(DatastoreType left, DatastoreType right) => !left.Equals(right);

        public static explicit operator string(DatastoreType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatastoreType other && Equals(other);
        public bool Equals(DatastoreType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of distribution framework.
    /// </summary>
    [EnumType]
    public readonly struct DistributionType : IEquatable<DistributionType>
    {
        private readonly string _value;

        private DistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionType PyTorch { get; } = new DistributionType("PyTorch");
        public static DistributionType TensorFlow { get; } = new DistributionType("TensorFlow");
        public static DistributionType Mpi { get; } = new DistributionType("Mpi");

        public static bool operator ==(DistributionType left, DistributionType right) => left.Equals(right);
        public static bool operator !=(DistributionType left, DistributionType right) => !left.Equals(right);

        public static explicit operator string(DistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionType other && Equals(other);
        public bool Equals(DistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Name of policy configuration
    /// </summary>
    [EnumType]
    public readonly struct EarlyTerminationPolicyType : IEquatable<EarlyTerminationPolicyType>
    {
        private readonly string _value;

        private EarlyTerminationPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EarlyTerminationPolicyType Bandit { get; } = new EarlyTerminationPolicyType("Bandit");
        public static EarlyTerminationPolicyType MedianStopping { get; } = new EarlyTerminationPolicyType("MedianStopping");
        public static EarlyTerminationPolicyType TruncationSelection { get; } = new EarlyTerminationPolicyType("TruncationSelection");

        public static bool operator ==(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => left.Equals(right);
        public static bool operator !=(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => !left.Equals(right);

        public static explicit operator string(EarlyTerminationPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EarlyTerminationPolicyType other && Equals(other);
        public bool Equals(EarlyTerminationPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not the encryption is enabled for the workspace.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionStatus : IEquatable<EncryptionStatus>
    {
        private readonly string _value;

        private EncryptionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionStatus Enabled { get; } = new EncryptionStatus("Enabled");
        public static EncryptionStatus Disabled { get; } = new EncryptionStatus("Disabled");

        public static bool operator ==(EncryptionStatus left, EncryptionStatus right) => left.Equals(right);
        public static bool operator !=(EncryptionStatus left, EncryptionStatus right) => !left.Equals(right);

        public static explicit operator string(EncryptionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionStatus other && Equals(other);
        public bool Equals(EncryptionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
    /// </summary>
    [EnumType]
    public readonly struct EndpointAuthMode : IEquatable<EndpointAuthMode>
    {
        private readonly string _value;

        private EndpointAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointAuthMode AMLToken { get; } = new EndpointAuthMode("AMLToken");
        public static EndpointAuthMode Key { get; } = new EndpointAuthMode("Key");
        public static EndpointAuthMode AADToken { get; } = new EndpointAuthMode("AADToken");

        public static bool operator ==(EndpointAuthMode left, EndpointAuthMode right) => left.Equals(right);
        public static bool operator !=(EndpointAuthMode left, EndpointAuthMode right) => !left.Equals(right);

        public static explicit operator string(EndpointAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointAuthMode other && Equals(other);
        public bool Equals(EndpointAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The compute type of the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct EndpointComputeType : IEquatable<EndpointComputeType>
    {
        private readonly string _value;

        private EndpointComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointComputeType Managed { get; } = new EndpointComputeType("Managed");
        public static EndpointComputeType Kubernetes { get; } = new EndpointComputeType("Kubernetes");
        public static EndpointComputeType AzureMLCompute { get; } = new EndpointComputeType("AzureMLCompute");

        public static bool operator ==(EndpointComputeType left, EndpointComputeType right) => left.Equals(right);
        public static bool operator !=(EndpointComputeType left, EndpointComputeType right) => !left.Equals(right);

        public static explicit operator string(EndpointComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointComputeType other && Equals(other);
        public bool Equals(EndpointComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Defines supported metric goals for hyperparameter tuning
    /// </summary>
    [EnumType]
    public readonly struct Goal : IEquatable<Goal>
    {
        private readonly string _value;

        private Goal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Goal Minimize { get; } = new Goal("Minimize");
        public static Goal Maximize { get; } = new Goal("Maximize");

        public static bool operator ==(Goal left, Goal right) => left.Equals(right);
        public static bool operator !=(Goal left, Goal right) => !left.Equals(right);

        public static explicit operator string(Goal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Goal other && Equals(other);
        public bool Equals(Goal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of identity framework.
    /// </summary>
    [EnumType]
    public readonly struct IdentityConfigurationType : IEquatable<IdentityConfigurationType>
    {
        private readonly string _value;

        private IdentityConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityConfigurationType Managed { get; } = new IdentityConfigurationType("Managed");
        public static IdentityConfigurationType AMLToken { get; } = new IdentityConfigurationType("AMLToken");
        public static IdentityConfigurationType UserIdentity { get; } = new IdentityConfigurationType("UserIdentity");

        public static bool operator ==(IdentityConfigurationType left, IdentityConfigurationType right) => left.Equals(right);
        public static bool operator !=(IdentityConfigurationType left, IdentityConfigurationType right) => !left.Equals(right);

        public static explicit operator string(IdentityConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityConfigurationType other && Equals(other);
        public bool Equals(IdentityConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Input Asset Delivery Mode.
    /// </summary>
    [EnumType]
    public readonly struct InputDeliveryMode : IEquatable<InputDeliveryMode>
    {
        private readonly string _value;

        private InputDeliveryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InputDeliveryMode ReadOnlyMount { get; } = new InputDeliveryMode("ReadOnlyMount");
        public static InputDeliveryMode ReadWriteMount { get; } = new InputDeliveryMode("ReadWriteMount");
        public static InputDeliveryMode Download { get; } = new InputDeliveryMode("Download");
        public static InputDeliveryMode Direct { get; } = new InputDeliveryMode("Direct");
        public static InputDeliveryMode EvalMount { get; } = new InputDeliveryMode("EvalMount");
        public static InputDeliveryMode EvalDownload { get; } = new InputDeliveryMode("EvalDownload");

        public static bool operator ==(InputDeliveryMode left, InputDeliveryMode right) => left.Equals(right);
        public static bool operator !=(InputDeliveryMode left, InputDeliveryMode right) => !left.Equals(right);

        public static explicit operator string(InputDeliveryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InputDeliveryMode other && Equals(other);
        public bool Equals(InputDeliveryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobInputType : IEquatable<JobInputType>
    {
        private readonly string _value;

        private JobInputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobInputType Literal { get; } = new JobInputType("literal");
        public static JobInputType Uri_file { get; } = new JobInputType("uri_file");
        public static JobInputType Uri_folder { get; } = new JobInputType("uri_folder");
        public static JobInputType Mltable { get; } = new JobInputType("mltable");
        public static JobInputType Custom_model { get; } = new JobInputType("custom_model");
        public static JobInputType Mlflow_model { get; } = new JobInputType("mlflow_model");
        public static JobInputType Triton_model { get; } = new JobInputType("triton_model");

        public static bool operator ==(JobInputType left, JobInputType right) => left.Equals(right);
        public static bool operator !=(JobInputType left, JobInputType right) => !left.Equals(right);

        public static explicit operator string(JobInputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobInputType other && Equals(other);
        public bool Equals(JobInputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] JobLimit type.
    /// </summary>
    [EnumType]
    public readonly struct JobLimitsType : IEquatable<JobLimitsType>
    {
        private readonly string _value;

        private JobLimitsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobLimitsType Command { get; } = new JobLimitsType("Command");
        public static JobLimitsType Sweep { get; } = new JobLimitsType("Sweep");

        public static bool operator ==(JobLimitsType left, JobLimitsType right) => left.Equals(right);
        public static bool operator !=(JobLimitsType left, JobLimitsType right) => !left.Equals(right);

        public static explicit operator string(JobLimitsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobLimitsType other && Equals(other);
        public bool Equals(JobLimitsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobOutputType : IEquatable<JobOutputType>
    {
        private readonly string _value;

        private JobOutputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobOutputType Uri_file { get; } = new JobOutputType("uri_file");
        public static JobOutputType Uri_folder { get; } = new JobOutputType("uri_folder");
        public static JobOutputType Mltable { get; } = new JobOutputType("mltable");
        public static JobOutputType Custom_model { get; } = new JobOutputType("custom_model");
        public static JobOutputType Mlflow_model { get; } = new JobOutputType("mlflow_model");
        public static JobOutputType Triton_model { get; } = new JobOutputType("triton_model");

        public static bool operator ==(JobOutputType left, JobOutputType right) => left.Equals(right);
        public static bool operator !=(JobOutputType left, JobOutputType right) => !left.Equals(right);

        public static explicit operator string(JobOutputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobOutputType other && Equals(other);
        public bool Equals(JobOutputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        private JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobType Command { get; } = new JobType("Command");
        public static JobType Sweep { get; } = new JobType("Sweep");
        public static JobType Pipeline { get; } = new JobType("Pipeline");

        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);

        public static explicit operator string(JobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobType other && Equals(other);
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load Balancer Type
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancerType PublicIp { get; } = new LoadBalancerType("PublicIp");
        public static LoadBalancerType InternalLoadBalancer { get; } = new LoadBalancerType("InternalLoadBalancer");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS type of the environment.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemType : IEquatable<OperatingSystemType>
    {
        private readonly string _value;

        private OperatingSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemType Linux { get; } = new OperatingSystemType("Linux");
        public static OperatingSystemType Windows { get; } = new OperatingSystemType("Windows");

        public static bool operator ==(OperatingSystemType left, OperatingSystemType right) => left.Equals(right);
        public static bool operator !=(OperatingSystemType left, OperatingSystemType right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemType other && Equals(other);
        public bool Equals(OperatingSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compute OS Type
    /// </summary>
    [EnumType]
    public readonly struct OsType : IEquatable<OsType>
    {
        private readonly string _value;

        private OsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsType Linux { get; } = new OsType("Linux");
        public static OsType Windows { get; } = new OsType("Windows");

        public static bool operator ==(OsType left, OsType right) => left.Equals(right);
        public static bool operator !=(OsType left, OsType right) => !left.Equals(right);

        public static explicit operator string(OsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsType other && Equals(other);
        public bool Equals(OsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output Asset Delivery Mode.
    /// </summary>
    [EnumType]
    public readonly struct OutputDeliveryMode : IEquatable<OutputDeliveryMode>
    {
        private readonly string _value;

        private OutputDeliveryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OutputDeliveryMode ReadWriteMount { get; } = new OutputDeliveryMode("ReadWriteMount");
        public static OutputDeliveryMode Upload { get; } = new OutputDeliveryMode("Upload");

        public static bool operator ==(OutputDeliveryMode left, OutputDeliveryMode right) => left.Equals(right);
        public static bool operator !=(OutputDeliveryMode left, OutputDeliveryMode right) => !left.Equals(right);

        public static explicit operator string(OutputDeliveryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OutputDeliveryMode other && Equals(other);
        public bool Equals(OutputDeliveryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");
        public static PrivateEndpointServiceConnectionStatus Disconnected { get; } = new PrivateEndpointServiceConnectionStatus("Disconnected");
        public static PrivateEndpointServiceConnectionStatus Timeout { get; } = new PrivateEndpointServiceConnectionStatus("Timeout");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether requests from Public Network are allowed.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccess : IEquatable<PublicNetworkAccess>
    {
        private readonly string _value;

        private PublicNetworkAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccess Enabled { get; } = new PublicNetworkAccess("Enabled");
        public static PublicNetworkAccess Disabled { get; } = new PublicNetworkAccess("Disabled");

        public static bool operator ==(PublicNetworkAccess left, PublicNetworkAccess right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccess left, PublicNetworkAccess right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccess other && Equals(other);
        public bool Equals(PublicNetworkAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specific type of random algorithm
    /// </summary>
    [EnumType]
    public readonly struct RandomSamplingAlgorithmRule : IEquatable<RandomSamplingAlgorithmRule>
    {
        private readonly string _value;

        private RandomSamplingAlgorithmRule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RandomSamplingAlgorithmRule Random { get; } = new RandomSamplingAlgorithmRule("Random");
        public static RandomSamplingAlgorithmRule Sobol { get; } = new RandomSamplingAlgorithmRule("Sobol");

        public static bool operator ==(RandomSamplingAlgorithmRule left, RandomSamplingAlgorithmRule right) => left.Equals(right);
        public static bool operator !=(RandomSamplingAlgorithmRule left, RandomSamplingAlgorithmRule right) => !left.Equals(right);

        public static explicit operator string(RandomSamplingAlgorithmRule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RandomSamplingAlgorithmRule other && Equals(other);
        public bool Equals(RandomSamplingAlgorithmRule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of asset reference.
    /// </summary>
    [EnumType]
    public readonly struct ReferenceType : IEquatable<ReferenceType>
    {
        private readonly string _value;

        private ReferenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReferenceType Id { get; } = new ReferenceType("Id");
        public static ReferenceType DataPath { get; } = new ReferenceType("DataPath");
        public static ReferenceType OutputPath { get; } = new ReferenceType("OutputPath");

        public static bool operator ==(ReferenceType left, ReferenceType right) => left.Equals(right);
        public static bool operator !=(ReferenceType left, ReferenceType right) => !left.Equals(right);

        public static explicit operator string(ReferenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReferenceType other && Equals(other);
        public bool Equals(ReferenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct RemoteLoginPortPublicAccess : IEquatable<RemoteLoginPortPublicAccess>
    {
        private readonly string _value;

        private RemoteLoginPortPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteLoginPortPublicAccess Enabled { get; } = new RemoteLoginPortPublicAccess("Enabled");
        public static RemoteLoginPortPublicAccess Disabled { get; } = new RemoteLoginPortPublicAccess("Disabled");
        public static RemoteLoginPortPublicAccess NotSpecified { get; } = new RemoteLoginPortPublicAccess("NotSpecified");

        public static bool operator ==(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => left.Equals(right);
        public static bool operator !=(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => !left.Equals(right);

        public static explicit operator string(RemoteLoginPortPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteLoginPortPublicAccess other && Equals(other);
        public bool Equals(RemoteLoginPortPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The algorithm used for generating hyperparameter values, along with configuration properties
    /// </summary>
    [EnumType]
    public readonly struct SamplingAlgorithmType : IEquatable<SamplingAlgorithmType>
    {
        private readonly string _value;

        private SamplingAlgorithmType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SamplingAlgorithmType Grid { get; } = new SamplingAlgorithmType("Grid");
        public static SamplingAlgorithmType Random { get; } = new SamplingAlgorithmType("Random");
        public static SamplingAlgorithmType Bayesian { get; } = new SamplingAlgorithmType("Bayesian");

        public static bool operator ==(SamplingAlgorithmType left, SamplingAlgorithmType right) => left.Equals(right);
        public static bool operator !=(SamplingAlgorithmType left, SamplingAlgorithmType right) => !left.Equals(right);

        public static explicit operator string(SamplingAlgorithmType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SamplingAlgorithmType other && Equals(other);
        public bool Equals(SamplingAlgorithmType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of deployment scaling algorithm
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType Default { get; } = new ScaleType("Default");
        public static ScaleType TargetUtilization { get; } = new ScaleType("TargetUtilization");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct SecretsType : IEquatable<SecretsType>
    {
        private readonly string _value;

        private SecretsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecretsType AccountKey { get; } = new SecretsType("AccountKey");
        public static SecretsType Certificate { get; } = new SecretsType("Certificate");
        public static SecretsType Sas { get; } = new SecretsType("Sas");
        public static SecretsType ServicePrincipal { get; } = new SecretsType("ServicePrincipal");

        public static bool operator ==(SecretsType left, SecretsType right) => left.Equals(right);
        public static bool operator !=(SecretsType left, SecretsType right) => !left.Equals(right);

        public static explicit operator string(SecretsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecretsType other && Equals(other);
        public bool Equals(SecretsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates which identity to use to authenticate service data access to customer's storage.
    /// </summary>
    [EnumType]
    public readonly struct ServiceDataAccessAuthIdentity : IEquatable<ServiceDataAccessAuthIdentity>
    {
        private readonly string _value;

        private ServiceDataAccessAuthIdentity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use any identity for service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity None { get; } = new ServiceDataAccessAuthIdentity("None");
        /// <summary>
        /// Use the system assigned managed identity of the Workspace to authenticate service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity WorkspaceSystemAssignedIdentity { get; } = new ServiceDataAccessAuthIdentity("WorkspaceSystemAssignedIdentity");
        /// <summary>
        /// Use the user assigned managed identity of the Workspace to authenticate service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity WorkspaceUserAssignedIdentity { get; } = new ServiceDataAccessAuthIdentity("WorkspaceUserAssignedIdentity");

        public static bool operator ==(ServiceDataAccessAuthIdentity left, ServiceDataAccessAuthIdentity right) => left.Equals(right);
        public static bool operator !=(ServiceDataAccessAuthIdentity left, ServiceDataAccessAuthIdentity right) => !left.Equals(right);

        public static explicit operator string(ServiceDataAccessAuthIdentity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDataAccessAuthIdentity other && Equals(other);
        public bool Equals(ServiceDataAccessAuthIdentity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
    /// </summary>
    [EnumType]
    public readonly struct SkuTier : IEquatable<SkuTier>
    {
        private readonly string _value;

        private SkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuTier Free { get; } = new SkuTier("Free");
        public static SkuTier Basic { get; } = new SkuTier("Basic");
        public static SkuTier Standard { get; } = new SkuTier("Standard");
        public static SkuTier Premium { get; } = new SkuTier("Premium");

        public static bool operator ==(SkuTier left, SkuTier right) => left.Equals(right);
        public static bool operator !=(SkuTier left, SkuTier right) => !left.Equals(right);

        public static explicit operator string(SkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuTier other && Equals(other);
        public bool Equals(SkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
    /// </summary>
    [EnumType]
    public readonly struct SshPublicAccess : IEquatable<SshPublicAccess>
    {
        private readonly string _value;

        private SshPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SshPublicAccess Enabled { get; } = new SshPublicAccess("Enabled");
        public static SshPublicAccess Disabled { get; } = new SshPublicAccess("Disabled");

        public static bool operator ==(SshPublicAccess left, SshPublicAccess right) => left.Equals(right);
        public static bool operator !=(SshPublicAccess left, SshPublicAccess right) => !left.Equals(right);

        public static explicit operator string(SshPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SshPublicAccess other && Equals(other);
        public bool Equals(SshPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable or disable ssl for scoring
    /// </summary>
    [EnumType]
    public readonly struct SslConfigStatus : IEquatable<SslConfigStatus>
    {
        private readonly string _value;

        private SslConfigStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslConfigStatus Disabled { get; } = new SslConfigStatus("Disabled");
        public static SslConfigStatus Enabled { get; } = new SslConfigStatus("Enabled");
        public static SslConfigStatus Auto { get; } = new SslConfigStatus("Auto");

        public static bool operator ==(SslConfigStatus left, SslConfigStatus right) => left.Equals(right);
        public static bool operator !=(SslConfigStatus left, SslConfigStatus right) => !left.Equals(right);

        public static explicit operator string(SslConfigStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslConfigStatus other && Equals(other);
        public bool Equals(SslConfigStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// format for the workspace connection value
    /// </summary>
    [EnumType]
    public readonly struct ValueFormat : IEquatable<ValueFormat>
    {
        private readonly string _value;

        private ValueFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValueFormat JSON { get; } = new ValueFormat("JSON");

        public static bool operator ==(ValueFormat left, ValueFormat right) => left.Equals(right);
        public static bool operator !=(ValueFormat left, ValueFormat right) => !left.Equals(right);

        public static explicit operator string(ValueFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValueFormat other && Equals(other);
        public bool Equals(ValueFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Virtual Machine priority
    /// </summary>
    [EnumType]
    public readonly struct VmPriority : IEquatable<VmPriority>
    {
        private readonly string _value;

        private VmPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VmPriority Dedicated { get; } = new VmPriority("Dedicated");
        public static VmPriority LowPriority { get; } = new VmPriority("LowPriority");

        public static bool operator ==(VmPriority left, VmPriority right) => left.Equals(right);
        public static bool operator !=(VmPriority left, VmPriority right) => !left.Equals(right);

        public static explicit operator string(VmPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmPriority other && Equals(other);
        public bool Equals(VmPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
