// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.MachineLearningServices.V20210301Preview
{
    /// <summary>
    /// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationSharingPolicy : IEquatable<ApplicationSharingPolicy>
    {
        private readonly string _value;

        private ApplicationSharingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationSharingPolicy Personal { get; } = new ApplicationSharingPolicy("Personal");
        public static ApplicationSharingPolicy Shared { get; } = new ApplicationSharingPolicy("Shared");

        public static bool operator ==(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => left.Equals(right);
        public static bool operator !=(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => !left.Equals(right);

        public static explicit operator string(ApplicationSharingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationSharingPolicy other && Equals(other);
        public bool Equals(ApplicationSharingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logging level for batch inference operation.
    /// </summary>
    [EnumType]
    public readonly struct BatchLoggingLevel : IEquatable<BatchLoggingLevel>
    {
        private readonly string _value;

        private BatchLoggingLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchLoggingLevel Info { get; } = new BatchLoggingLevel("Info");
        public static BatchLoggingLevel Warning { get; } = new BatchLoggingLevel("Warning");
        public static BatchLoggingLevel Debug { get; } = new BatchLoggingLevel("Debug");

        public static bool operator ==(BatchLoggingLevel left, BatchLoggingLevel right) => left.Equals(right);
        public static bool operator !=(BatchLoggingLevel left, BatchLoggingLevel right) => !left.Equals(right);

        public static explicit operator string(BatchLoggingLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchLoggingLevel other && Equals(other);
        public bool Equals(BatchLoggingLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how the output will be organized.
    /// </summary>
    [EnumType]
    public readonly struct BatchOutputAction : IEquatable<BatchOutputAction>
    {
        private readonly string _value;

        private BatchOutputAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchOutputAction SummaryOnly { get; } = new BatchOutputAction("SummaryOnly");
        public static BatchOutputAction AppendRow { get; } = new BatchOutputAction("AppendRow");

        public static bool operator ==(BatchOutputAction left, BatchOutputAction right) => left.Equals(right);
        public static bool operator !=(BatchOutputAction left, BatchOutputAction right) => !left.Equals(right);

        public static explicit operator string(BatchOutputAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchOutputAction other && Equals(other);
        public bool Equals(BatchOutputAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Intended usage of the cluster
    /// </summary>
    [EnumType]
    public readonly struct ClusterPurpose : IEquatable<ClusterPurpose>
    {
        private readonly string _value;

        private ClusterPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterPurpose FastProd { get; } = new ClusterPurpose("FastProd");
        public static ClusterPurpose DenseProd { get; } = new ClusterPurpose("DenseProd");
        public static ClusterPurpose DevTest { get; } = new ClusterPurpose("DevTest");

        public static bool operator ==(ClusterPurpose left, ClusterPurpose right) => left.Equals(right);
        public static bool operator !=(ClusterPurpose left, ClusterPurpose right) => !left.Equals(right);

        public static explicit operator string(ClusterPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterPurpose other && Equals(other);
        public bool Equals(ClusterPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Compute Instance Authorization type. Available values are personal (default).
    /// </summary>
    [EnumType]
    public readonly struct ComputeInstanceAuthorizationType : IEquatable<ComputeInstanceAuthorizationType>
    {
        private readonly string _value;

        private ComputeInstanceAuthorizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeInstanceAuthorizationType Personal { get; } = new ComputeInstanceAuthorizationType("personal");

        public static bool operator ==(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => left.Equals(right);
        public static bool operator !=(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => !left.Equals(right);

        public static explicit operator string(ComputeInstanceAuthorizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeInstanceAuthorizationType other && Equals(other);
        public bool Equals(ComputeInstanceAuthorizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The compute power action.
    /// </summary>
    [EnumType]
    public readonly struct ComputePowerAction : IEquatable<ComputePowerAction>
    {
        private readonly string _value;

        private ComputePowerAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputePowerAction Start { get; } = new ComputePowerAction("Start");
        public static ComputePowerAction Stop { get; } = new ComputePowerAction("Stop");

        public static bool operator ==(ComputePowerAction left, ComputePowerAction right) => left.Equals(right);
        public static bool operator !=(ComputePowerAction left, ComputePowerAction right) => !left.Equals(right);

        public static explicit operator string(ComputePowerAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputePowerAction other && Equals(other);
        public bool Equals(ComputePowerAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compute
    /// </summary>
    [EnumType]
    public readonly struct ComputeType : IEquatable<ComputeType>
    {
        private readonly string _value;

        private ComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeType AKS { get; } = new ComputeType("AKS");
        public static ComputeType AmlCompute { get; } = new ComputeType("AmlCompute");
        public static ComputeType ComputeInstance { get; } = new ComputeType("ComputeInstance");
        public static ComputeType DataFactory { get; } = new ComputeType("DataFactory");
        public static ComputeType VirtualMachine { get; } = new ComputeType("VirtualMachine");
        public static ComputeType HDInsight { get; } = new ComputeType("HDInsight");
        public static ComputeType Databricks { get; } = new ComputeType("Databricks");
        public static ComputeType DataLakeAnalytics { get; } = new ComputeType("DataLakeAnalytics");
        public static ComputeType SynapseSpark { get; } = new ComputeType("SynapseSpark");

        public static bool operator ==(ComputeType left, ComputeType right) => left.Equals(right);
        public static bool operator !=(ComputeType left, ComputeType right) => !left.Equals(right);

        public static explicit operator string(ComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeType other && Equals(other);
        public bool Equals(ComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of container to retrieve logs from.
    /// </summary>
    [EnumType]
    public readonly struct ContainerType : IEquatable<ContainerType>
    {
        private readonly string _value;

        private ContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerType StorageInitializer { get; } = new ContainerType("StorageInitializer");
        public static ContainerType InferenceServer { get; } = new ContainerType("InferenceServer");

        public static bool operator ==(ContainerType left, ContainerType right) => left.Equals(right);
        public static bool operator !=(ContainerType left, ContainerType right) => !left.Equals(right);

        public static explicit operator string(ContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerType other && Equals(other);
        public bool Equals(ContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Storage type backing the datastore.
    /// </summary>
    [EnumType]
    public readonly struct ContentsType : IEquatable<ContentsType>
    {
        private readonly string _value;

        private ContentsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContentsType AzureBlob { get; } = new ContentsType("AzureBlob");
        public static ContentsType AzureDataLakeGen1 { get; } = new ContentsType("AzureDataLakeGen1");
        public static ContentsType AzureDataLakeGen2 { get; } = new ContentsType("AzureDataLakeGen2");
        public static ContentsType AzureFile { get; } = new ContentsType("AzureFile");
        public static ContentsType AzureMySql { get; } = new ContentsType("AzureMySql");
        public static ContentsType AzurePostgreSql { get; } = new ContentsType("AzurePostgreSql");
        public static ContentsType AzureSqlDatabase { get; } = new ContentsType("AzureSqlDatabase");
        public static ContentsType GlusterFs { get; } = new ContentsType("GlusterFs");

        public static bool operator ==(ContentsType left, ContentsType right) => left.Equals(right);
        public static bool operator !=(ContentsType left, ContentsType right) => !left.Equals(right);

        public static explicit operator string(ContentsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentsType other && Equals(other);
        public bool Equals(ContentsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct CredentialsType : IEquatable<CredentialsType>
    {
        private readonly string _value;

        private CredentialsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CredentialsType AccountKey { get; } = new CredentialsType("AccountKey");
        public static CredentialsType Certificate { get; } = new CredentialsType("Certificate");
        public static CredentialsType None { get; } = new CredentialsType("None");
        public static CredentialsType Sas { get; } = new CredentialsType("Sas");
        public static CredentialsType ServicePrincipal { get; } = new CredentialsType("ServicePrincipal");
        public static CredentialsType SqlAdmin { get; } = new CredentialsType("SqlAdmin");

        public static bool operator ==(CredentialsType left, CredentialsType right) => left.Equals(right);
        public static bool operator !=(CredentialsType left, CredentialsType right) => !left.Equals(right);

        public static explicit operator string(CredentialsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CredentialsType other && Equals(other);
        public bool Equals(CredentialsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mechanism for data movement to datastore.
    /// </summary>
    [EnumType]
    public readonly struct DataBindingMode : IEquatable<DataBindingMode>
    {
        private readonly string _value;

        private DataBindingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataBindingMode Mount { get; } = new DataBindingMode("Mount");
        public static DataBindingMode Download { get; } = new DataBindingMode("Download");
        public static DataBindingMode Upload { get; } = new DataBindingMode("Upload");
        public static DataBindingMode ReadOnlyMount { get; } = new DataBindingMode("ReadOnlyMount");
        public static DataBindingMode ReadWriteMount { get; } = new DataBindingMode("ReadWriteMount");
        public static DataBindingMode Direct { get; } = new DataBindingMode("Direct");
        public static DataBindingMode EvalMount { get; } = new DataBindingMode("EvalMount");
        public static DataBindingMode EvalDownload { get; } = new DataBindingMode("EvalDownload");

        public static bool operator ==(DataBindingMode left, DataBindingMode right) => left.Equals(right);
        public static bool operator !=(DataBindingMode left, DataBindingMode right) => !left.Equals(right);

        public static explicit operator string(DataBindingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataBindingMode other && Equals(other);
        public bool Equals(DataBindingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Format of dataset.
    /// </summary>
    [EnumType]
    public readonly struct DatasetType : IEquatable<DatasetType>
    {
        private readonly string _value;

        private DatasetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatasetType Simple { get; } = new DatasetType("Simple");
        public static DatasetType Dataflow { get; } = new DatasetType("Dataflow");

        public static bool operator ==(DatasetType left, DatasetType right) => left.Equals(right);
        public static bool operator !=(DatasetType left, DatasetType right) => !left.Equals(right);

        public static explicit operator string(DatasetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetType other && Equals(other);
        public bool Equals(DatasetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DaysOfWeek : IEquatable<DaysOfWeek>
    {
        private readonly string _value;

        private DaysOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DaysOfWeek Sunday { get; } = new DaysOfWeek("Sunday");
        public static DaysOfWeek Monday { get; } = new DaysOfWeek("Monday");
        public static DaysOfWeek Tuesday { get; } = new DaysOfWeek("Tuesday");
        public static DaysOfWeek Wednesday { get; } = new DaysOfWeek("Wednesday");
        public static DaysOfWeek Thursday { get; } = new DaysOfWeek("Thursday");
        public static DaysOfWeek Friday { get; } = new DaysOfWeek("Friday");
        public static DaysOfWeek Saturday { get; } = new DaysOfWeek("Saturday");

        public static bool operator ==(DaysOfWeek left, DaysOfWeek right) => left.Equals(right);
        public static bool operator !=(DaysOfWeek left, DaysOfWeek right) => !left.Equals(right);

        public static explicit operator string(DaysOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DaysOfWeek other && Equals(other);
        public bool Equals(DaysOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of distribution framework.
    /// </summary>
    [EnumType]
    public readonly struct DistributionType : IEquatable<DistributionType>
    {
        private readonly string _value;

        private DistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionType PyTorch { get; } = new DistributionType("PyTorch");
        public static DistributionType TensorFlow { get; } = new DistributionType("TensorFlow");
        public static DistributionType Mpi { get; } = new DistributionType("Mpi");

        public static bool operator ==(DistributionType left, DistributionType right) => left.Equals(right);
        public static bool operator !=(DistributionType left, DistributionType right) => !left.Equals(right);

        public static explicit operator string(DistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionType other && Equals(other);
        public bool Equals(DistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Docker specification must be either Build or Image
    /// </summary>
    [EnumType]
    public readonly struct DockerSpecificationType : IEquatable<DockerSpecificationType>
    {
        private readonly string _value;

        private DockerSpecificationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DockerSpecificationType Build { get; } = new DockerSpecificationType("Build");
        public static DockerSpecificationType Image { get; } = new DockerSpecificationType("Image");

        public static bool operator ==(DockerSpecificationType left, DockerSpecificationType right) => left.Equals(right);
        public static bool operator !=(DockerSpecificationType left, DockerSpecificationType right) => !left.Equals(right);

        public static explicit operator string(DockerSpecificationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DockerSpecificationType other && Equals(other);
        public bool Equals(DockerSpecificationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Name of policy configuration
    /// </summary>
    [EnumType]
    public readonly struct EarlyTerminationPolicyType : IEquatable<EarlyTerminationPolicyType>
    {
        private readonly string _value;

        private EarlyTerminationPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EarlyTerminationPolicyType Bandit { get; } = new EarlyTerminationPolicyType("Bandit");
        public static EarlyTerminationPolicyType MedianStopping { get; } = new EarlyTerminationPolicyType("MedianStopping");
        public static EarlyTerminationPolicyType TruncationSelection { get; } = new EarlyTerminationPolicyType("TruncationSelection");

        public static bool operator ==(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => left.Equals(right);
        public static bool operator !=(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => !left.Equals(right);

        public static explicit operator string(EarlyTerminationPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EarlyTerminationPolicyType other && Equals(other);
        public bool Equals(EarlyTerminationPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not the encryption is enabled for the workspace.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionStatus : IEquatable<EncryptionStatus>
    {
        private readonly string _value;

        private EncryptionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionStatus Enabled { get; } = new EncryptionStatus("Enabled");
        public static EncryptionStatus Disabled { get; } = new EncryptionStatus("Disabled");

        public static bool operator ==(EncryptionStatus left, EncryptionStatus right) => left.Equals(right);
        public static bool operator !=(EncryptionStatus left, EncryptionStatus right) => !left.Equals(right);

        public static explicit operator string(EncryptionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionStatus other && Equals(other);
        public bool Equals(EncryptionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Inference endpoint authentication mode type
    /// </summary>
    [EnumType]
    public readonly struct EndpointAuthMode : IEquatable<EndpointAuthMode>
    {
        private readonly string _value;

        private EndpointAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointAuthMode AMLToken { get; } = new EndpointAuthMode("AMLToken");
        public static EndpointAuthMode Key { get; } = new EndpointAuthMode("Key");
        public static EndpointAuthMode AADToken { get; } = new EndpointAuthMode("AADToken");

        public static bool operator ==(EndpointAuthMode left, EndpointAuthMode right) => left.Equals(right);
        public static bool operator !=(EndpointAuthMode left, EndpointAuthMode right) => !left.Equals(right);

        public static explicit operator string(EndpointAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointAuthMode other && Equals(other);
        public bool Equals(EndpointAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The compute type of the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct EndpointComputeType : IEquatable<EndpointComputeType>
    {
        private readonly string _value;

        private EndpointComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointComputeType Managed { get; } = new EndpointComputeType("Managed");
        public static EndpointComputeType K8S { get; } = new EndpointComputeType("K8S");
        public static EndpointComputeType AzureMLCompute { get; } = new EndpointComputeType("AzureMLCompute");

        public static bool operator ==(EndpointComputeType left, EndpointComputeType right) => left.Equals(right);
        public static bool operator !=(EndpointComputeType left, EndpointComputeType right) => !left.Equals(right);

        public static explicit operator string(EndpointComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointComputeType other && Equals(other);
        public bool Equals(EndpointComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Defines supported metric goals for hyperparameter tuning
    /// </summary>
    [EnumType]
    public readonly struct Goal : IEquatable<Goal>
    {
        private readonly string _value;

        private Goal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Goal Minimize { get; } = new Goal("Minimize");
        public static Goal Maximize { get; } = new Goal("Maximize");

        public static bool operator ==(Goal left, Goal right) => left.Equals(right);
        public static bool operator !=(Goal left, Goal right) => !left.Equals(right);

        public static explicit operator string(Goal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Goal other && Equals(other);
        public bool Equals(Goal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of identity framework.
    /// </summary>
    [EnumType]
    public readonly struct IdentityConfigurationType : IEquatable<IdentityConfigurationType>
    {
        private readonly string _value;

        private IdentityConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityConfigurationType Managed { get; } = new IdentityConfigurationType("Managed");
        public static IdentityConfigurationType AMLToken { get; } = new IdentityConfigurationType("AMLToken");

        public static bool operator ==(IdentityConfigurationType left, IdentityConfigurationType right) => left.Equals(right);
        public static bool operator !=(IdentityConfigurationType left, IdentityConfigurationType right) => !left.Equals(right);

        public static explicit operator string(IdentityConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityConfigurationType other && Equals(other);
        public bool Equals(IdentityConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Annotation type of image labeling job.
    /// </summary>
    [EnumType]
    public readonly struct ImageAnnotationType : IEquatable<ImageAnnotationType>
    {
        private readonly string _value;

        private ImageAnnotationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageAnnotationType Classification { get; } = new ImageAnnotationType("Classification");
        public static ImageAnnotationType BoundingBox { get; } = new ImageAnnotationType("BoundingBox");
        public static ImageAnnotationType InstanceSegmentation { get; } = new ImageAnnotationType("InstanceSegmentation");

        public static bool operator ==(ImageAnnotationType left, ImageAnnotationType right) => left.Equals(right);
        public static bool operator !=(ImageAnnotationType left, ImageAnnotationType right) => !left.Equals(right);

        public static explicit operator string(ImageAnnotationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageAnnotationType other && Equals(other);
        public bool Equals(ImageAnnotationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job. This field should always be set to "Labeling".
    /// </summary>
    [EnumType]
    public readonly struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        private JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobType Command { get; } = new JobType("Command");
        public static JobType Sweep { get; } = new JobType("Sweep");
        public static JobType Labeling { get; } = new JobType("Labeling");

        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);

        public static explicit operator string(JobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobType other && Equals(other);
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load Balancer Type
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancerType PublicIp { get; } = new LoadBalancerType("PublicIp");
        public static LoadBalancerType InternalLoadBalancer { get; } = new LoadBalancerType("InternalLoadBalancer");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Media type of the job.
    /// </summary>
    [EnumType]
    public readonly struct MediaType : IEquatable<MediaType>
    {
        private readonly string _value;

        private MediaType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MediaType Image { get; } = new MediaType("Image");
        public static MediaType Text { get; } = new MediaType("Text");

        public static bool operator ==(MediaType left, MediaType right) => left.Equals(right);
        public static bool operator !=(MediaType left, MediaType right) => !left.Equals(right);

        public static explicit operator string(MediaType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MediaType other && Equals(other);
        public bool Equals(MediaType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS type the Environment.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemType : IEquatable<OperatingSystemType>
    {
        private readonly string _value;

        private OperatingSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemType Linux { get; } = new OperatingSystemType("Linux");
        public static OperatingSystemType Windows { get; } = new OperatingSystemType("Windows");

        public static bool operator ==(OperatingSystemType left, OperatingSystemType right) => left.Equals(right);
        public static bool operator !=(OperatingSystemType left, OperatingSystemType right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemType other && Equals(other);
        public bool Equals(OperatingSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the linked service.
    /// </summary>
    [EnumType]
    public readonly struct OriginType : IEquatable<OriginType>
    {
        private readonly string _value;

        private OriginType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OriginType Synapse { get; } = new OriginType("Synapse");

        public static bool operator ==(OriginType left, OriginType right) => left.Equals(right);
        public static bool operator !=(OriginType left, OriginType right) => !left.Equals(right);

        public static explicit operator string(OriginType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OriginType other && Equals(other);
        public bool Equals(OriginType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compute OS Type
    /// </summary>
    [EnumType]
    public readonly struct OsType : IEquatable<OsType>
    {
        private readonly string _value;

        private OsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsType Linux { get; } = new OsType("Linux");
        public static OsType Windows { get; } = new OsType("Windows");

        public static bool operator ==(OsType left, OsType right) => left.Equals(right);
        public static bool operator !=(OsType left, OsType right) => !left.Equals(right);

        public static explicit operator string(OsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsType other && Equals(other);
        public bool Equals(OsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");
        public static PrivateEndpointServiceConnectionStatus Disconnected { get; } = new PrivateEndpointServiceConnectionStatus("Disconnected");
        public static PrivateEndpointServiceConnectionStatus Timeout { get; } = new PrivateEndpointServiceConnectionStatus("Timeout");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The recurrence frequency.
    /// </summary>
    [EnumType]
    public readonly struct RecurrenceFrequency : IEquatable<RecurrenceFrequency>
    {
        private readonly string _value;

        private RecurrenceFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecurrenceFrequency NotSpecified { get; } = new RecurrenceFrequency("NotSpecified");
        public static RecurrenceFrequency Second { get; } = new RecurrenceFrequency("Second");
        public static RecurrenceFrequency Minute { get; } = new RecurrenceFrequency("Minute");
        public static RecurrenceFrequency Hour { get; } = new RecurrenceFrequency("Hour");
        public static RecurrenceFrequency Day { get; } = new RecurrenceFrequency("Day");
        public static RecurrenceFrequency Week { get; } = new RecurrenceFrequency("Week");
        public static RecurrenceFrequency Month { get; } = new RecurrenceFrequency("Month");
        public static RecurrenceFrequency Year { get; } = new RecurrenceFrequency("Year");

        public static bool operator ==(RecurrenceFrequency left, RecurrenceFrequency right) => left.Equals(right);
        public static bool operator !=(RecurrenceFrequency left, RecurrenceFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurrenceFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurrenceFrequency other && Equals(other);
        public bool Equals(RecurrenceFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of asset reference.
    /// </summary>
    [EnumType]
    public readonly struct ReferenceType : IEquatable<ReferenceType>
    {
        private readonly string _value;

        private ReferenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReferenceType Id { get; } = new ReferenceType("Id");
        public static ReferenceType DataPath { get; } = new ReferenceType("DataPath");
        public static ReferenceType OutputPath { get; } = new ReferenceType("OutputPath");

        public static bool operator ==(ReferenceType left, ReferenceType right) => left.Equals(right);
        public static bool operator !=(ReferenceType left, ReferenceType right) => !left.Equals(right);

        public static explicit operator string(ReferenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReferenceType other && Equals(other);
        public bool Equals(ReferenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct RemoteLoginPortPublicAccess : IEquatable<RemoteLoginPortPublicAccess>
    {
        private readonly string _value;

        private RemoteLoginPortPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteLoginPortPublicAccess Enabled { get; } = new RemoteLoginPortPublicAccess("Enabled");
        public static RemoteLoginPortPublicAccess Disabled { get; } = new RemoteLoginPortPublicAccess("Disabled");
        public static RemoteLoginPortPublicAccess NotSpecified { get; } = new RemoteLoginPortPublicAccess("NotSpecified");

        public static bool operator ==(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => left.Equals(right);
        public static bool operator !=(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => !left.Equals(right);

        public static explicit operator string(RemoteLoginPortPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteLoginPortPublicAccess other && Equals(other);
        public bool Equals(RemoteLoginPortPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines values for a ResourceIdentity's type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityAssignment : IEquatable<ResourceIdentityAssignment>
    {
        private readonly string _value;

        private ResourceIdentityAssignment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityAssignment SystemAssigned { get; } = new ResourceIdentityAssignment("SystemAssigned");
        public static ResourceIdentityAssignment UserAssigned { get; } = new ResourceIdentityAssignment("UserAssigned");
        public static ResourceIdentityAssignment SystemAssigned_UserAssigned { get; } = new ResourceIdentityAssignment("SystemAssigned,UserAssigned");
        public static ResourceIdentityAssignment None { get; } = new ResourceIdentityAssignment("None");

        public static bool operator ==(ResourceIdentityAssignment left, ResourceIdentityAssignment right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityAssignment left, ResourceIdentityAssignment right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityAssignment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityAssignment other && Equals(other);
        public bool Equals(ResourceIdentityAssignment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        public static ResourceIdentityType SystemAssigned_UserAssigned { get; } = new ResourceIdentityType("SystemAssigned,UserAssigned");
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of the hyperparameter sampling algorithms
    /// </summary>
    [EnumType]
    public readonly struct SamplingAlgorithm : IEquatable<SamplingAlgorithm>
    {
        private readonly string _value;

        private SamplingAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SamplingAlgorithm Grid { get; } = new SamplingAlgorithm("Grid");
        public static SamplingAlgorithm Random { get; } = new SamplingAlgorithm("Random");
        public static SamplingAlgorithm Bayesian { get; } = new SamplingAlgorithm("Bayesian");

        public static bool operator ==(SamplingAlgorithm left, SamplingAlgorithm right) => left.Equals(right);
        public static bool operator !=(SamplingAlgorithm left, SamplingAlgorithm right) => !left.Equals(right);

        public static explicit operator string(SamplingAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SamplingAlgorithm other && Equals(other);
        public bool Equals(SamplingAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of deployment scaling algorithm
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType Auto { get; } = new ScaleType("Auto");
        public static ScaleType Manual { get; } = new ScaleType("Manual");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The schedule status.
    /// </summary>
    [EnumType]
    public readonly struct ScheduleStatus : IEquatable<ScheduleStatus>
    {
        private readonly string _value;

        private ScheduleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScheduleStatus Enabled { get; } = new ScheduleStatus("Enabled");
        public static ScheduleStatus Disabled { get; } = new ScheduleStatus("Disabled");

        public static bool operator ==(ScheduleStatus left, ScheduleStatus right) => left.Equals(right);
        public static bool operator !=(ScheduleStatus left, ScheduleStatus right) => !left.Equals(right);

        public static explicit operator string(ScheduleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduleStatus other && Equals(other);
        public bool Equals(ScheduleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct SecretsType : IEquatable<SecretsType>
    {
        private readonly string _value;

        private SecretsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecretsType AccountKey { get; } = new SecretsType("AccountKey");
        public static SecretsType Certificate { get; } = new SecretsType("Certificate");
        public static SecretsType None { get; } = new SecretsType("None");
        public static SecretsType Sas { get; } = new SecretsType("Sas");
        public static SecretsType ServicePrincipal { get; } = new SecretsType("ServicePrincipal");
        public static SecretsType SqlAdmin { get; } = new SecretsType("SqlAdmin");

        public static bool operator ==(SecretsType left, SecretsType right) => left.Equals(right);
        public static bool operator !=(SecretsType left, SecretsType right) => !left.Equals(right);

        public static explicit operator string(SecretsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecretsType other && Equals(other);
        public bool Equals(SecretsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
    /// </summary>
    [EnumType]
    public readonly struct SshPublicAccess : IEquatable<SshPublicAccess>
    {
        private readonly string _value;

        private SshPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SshPublicAccess Enabled { get; } = new SshPublicAccess("Enabled");
        public static SshPublicAccess Disabled { get; } = new SshPublicAccess("Disabled");

        public static bool operator ==(SshPublicAccess left, SshPublicAccess right) => left.Equals(right);
        public static bool operator !=(SshPublicAccess left, SshPublicAccess right) => !left.Equals(right);

        public static explicit operator string(SshPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SshPublicAccess other && Equals(other);
        public bool Equals(SshPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Annotation type of text labeling job.
    /// </summary>
    [EnumType]
    public readonly struct TextAnnotationType : IEquatable<TextAnnotationType>
    {
        private readonly string _value;

        private TextAnnotationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TextAnnotationType Classification { get; } = new TextAnnotationType("Classification");

        public static bool operator ==(TextAnnotationType left, TextAnnotationType right) => left.Equals(right);
        public static bool operator !=(TextAnnotationType left, TextAnnotationType right) => !left.Equals(right);

        public static explicit operator string(TextAnnotationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextAnnotationType other && Equals(other);
        public bool Equals(TextAnnotationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The schedule trigger type.
    /// </summary>
    [EnumType]
    public readonly struct TriggerType : IEquatable<TriggerType>
    {
        private readonly string _value;

        private TriggerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TriggerType Recurrence { get; } = new TriggerType("Recurrence");
        public static TriggerType Cron { get; } = new TriggerType("Cron");

        public static bool operator ==(TriggerType left, TriggerType right) => left.Equals(right);
        public static bool operator !=(TriggerType left, TriggerType right) => !left.Equals(right);

        public static explicit operator string(TriggerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggerType other && Equals(other);
        public bool Equals(TriggerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// format for the workspace connection value
    /// </summary>
    [EnumType]
    public readonly struct ValueFormat : IEquatable<ValueFormat>
    {
        private readonly string _value;

        private ValueFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValueFormat JSON { get; } = new ValueFormat("JSON");

        public static bool operator ==(ValueFormat left, ValueFormat right) => left.Equals(right);
        public static bool operator !=(ValueFormat left, ValueFormat right) => !left.Equals(right);

        public static explicit operator string(ValueFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValueFormat other && Equals(other);
        public bool Equals(ValueFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Virtual Machine priority
    /// </summary>
    [EnumType]
    public readonly struct VmPriority : IEquatable<VmPriority>
    {
        private readonly string _value;

        private VmPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VmPriority Dedicated { get; } = new VmPriority("Dedicated");
        public static VmPriority LowPriority { get; } = new VmPriority("LowPriority");

        public static bool operator ==(VmPriority left, VmPriority right) => left.Equals(right);
        public static bool operator !=(VmPriority left, VmPriority right) => !left.Equals(right);

        public static explicit operator string(VmPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmPriority other && Equals(other);
        public bool Equals(VmPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
