// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.MachineLearningServices.V20241001Preview
{
    /// <summary>
    /// Level at which content is filtered.
    /// </summary>
    [EnumType]
    public readonly struct AllowedContentLevel : IEquatable<AllowedContentLevel>
    {
        private readonly string _value;

        private AllowedContentLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllowedContentLevel Low { get; } = new AllowedContentLevel("Low");
        public static AllowedContentLevel Medium { get; } = new AllowedContentLevel("Medium");
        public static AllowedContentLevel High { get; } = new AllowedContentLevel("High");

        public static bool operator ==(AllowedContentLevel left, AllowedContentLevel right) => left.Equals(right);
        public static bool operator !=(AllowedContentLevel left, AllowedContentLevel right) => !left.Equals(right);

        public static explicit operator string(AllowedContentLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllowedContentLevel other && Equals(other);
        public bool Equals(AllowedContentLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationSharingPolicy : IEquatable<ApplicationSharingPolicy>
    {
        private readonly string _value;

        private ApplicationSharingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationSharingPolicy Personal { get; } = new ApplicationSharingPolicy("Personal");
        public static ApplicationSharingPolicy Shared { get; } = new ApplicationSharingPolicy("Shared");

        public static bool operator ==(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => left.Equals(right);
        public static bool operator !=(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => !left.Equals(right);

        public static explicit operator string(ApplicationSharingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationSharingPolicy other && Equals(other);
        public bool Equals(ApplicationSharingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Authentication mode for the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct AuthMode : IEquatable<AuthMode>
    {
        private readonly string _value;

        private AuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthMode AAD { get; } = new AuthMode("AAD");

        public static bool operator ==(AuthMode left, AuthMode right) => left.Equals(right);
        public static bool operator !=(AuthMode left, AuthMode right) => !left.Equals(right);

        public static explicit operator string(AuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthMode other && Equals(other);
        public bool Equals(AuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines if image needs to be rebuilt based on base image changes.
    /// </summary>
    [EnumType]
    public readonly struct AutoRebuildSetting : IEquatable<AutoRebuildSetting>
    {
        private readonly string _value;

        private AutoRebuildSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoRebuildSetting Disabled { get; } = new AutoRebuildSetting("Disabled");
        public static AutoRebuildSetting OnBaseImageUpdate { get; } = new AutoRebuildSetting("OnBaseImageUpdate");

        public static bool operator ==(AutoRebuildSetting left, AutoRebuildSetting right) => left.Equals(right);
        public static bool operator !=(AutoRebuildSetting left, AutoRebuildSetting right) => !left.Equals(right);

        public static explicit operator string(AutoRebuildSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoRebuildSetting other && Equals(other);
        public bool Equals(AutoRebuildSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The type of the deployment
    /// </summary>
    [EnumType]
    public readonly struct BatchDeploymentConfigurationType : IEquatable<BatchDeploymentConfigurationType>
    {
        private readonly string _value;

        private BatchDeploymentConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchDeploymentConfigurationType Model { get; } = new BatchDeploymentConfigurationType("Model");
        public static BatchDeploymentConfigurationType PipelineComponent { get; } = new BatchDeploymentConfigurationType("PipelineComponent");

        public static bool operator ==(BatchDeploymentConfigurationType left, BatchDeploymentConfigurationType right) => left.Equals(right);
        public static bool operator !=(BatchDeploymentConfigurationType left, BatchDeploymentConfigurationType right) => !left.Equals(right);

        public static explicit operator string(BatchDeploymentConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchDeploymentConfigurationType other && Equals(other);
        public bool Equals(BatchDeploymentConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logging level for batch inference operation.
    /// </summary>
    [EnumType]
    public readonly struct BatchLoggingLevel : IEquatable<BatchLoggingLevel>
    {
        private readonly string _value;

        private BatchLoggingLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchLoggingLevel Info { get; } = new BatchLoggingLevel("Info");
        public static BatchLoggingLevel Warning { get; } = new BatchLoggingLevel("Warning");
        public static BatchLoggingLevel Debug { get; } = new BatchLoggingLevel("Debug");

        public static bool operator ==(BatchLoggingLevel left, BatchLoggingLevel right) => left.Equals(right);
        public static bool operator !=(BatchLoggingLevel left, BatchLoggingLevel right) => !left.Equals(right);

        public static explicit operator string(BatchLoggingLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchLoggingLevel other && Equals(other);
        public bool Equals(BatchLoggingLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how the output will be organized.
    /// </summary>
    [EnumType]
    public readonly struct BatchOutputAction : IEquatable<BatchOutputAction>
    {
        private readonly string _value;

        private BatchOutputAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchOutputAction SummaryOnly { get; } = new BatchOutputAction("SummaryOnly");
        public static BatchOutputAction AppendRow { get; } = new BatchOutputAction("AppendRow");

        public static bool operator ==(BatchOutputAction left, BatchOutputAction right) => left.Equals(right);
        public static bool operator !=(BatchOutputAction left, BatchOutputAction right) => !left.Equals(right);

        public static explicit operator string(BatchOutputAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchOutputAction other && Equals(other);
        public bool Equals(BatchOutputAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum for all classification models supported by AutoML.
    /// </summary>
    [EnumType]
    public readonly struct BlockedTransformers : IEquatable<BlockedTransformers>
    {
        private readonly string _value;

        private BlockedTransformers(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Target encoding for text data.
        /// </summary>
        public static BlockedTransformers TextTargetEncoder { get; } = new BlockedTransformers("TextTargetEncoder");
        /// <summary>
        /// Ohe hot encoding creates a binary feature transformation.
        /// </summary>
        public static BlockedTransformers OneHotEncoder { get; } = new BlockedTransformers("OneHotEncoder");
        /// <summary>
        /// Target encoding for categorical data.
        /// </summary>
        public static BlockedTransformers CatTargetEncoder { get; } = new BlockedTransformers("CatTargetEncoder");
        /// <summary>
        /// Tf-Idf stands for, term-frequency times inverse document-frequency. This is a common term weighting scheme for identifying information from documents.
        /// </summary>
        public static BlockedTransformers TfIdf { get; } = new BlockedTransformers("TfIdf");
        /// <summary>
        /// Weight of Evidence encoding is a technique used to encode categorical variables. It uses the natural log of the P(1)/P(0) to create weights.
        /// </summary>
        public static BlockedTransformers WoETargetEncoder { get; } = new BlockedTransformers("WoETargetEncoder");
        /// <summary>
        /// Label encoder converts labels/categorical variables in a numerical form.
        /// </summary>
        public static BlockedTransformers LabelEncoder { get; } = new BlockedTransformers("LabelEncoder");
        /// <summary>
        /// Word embedding helps represents words or phrases as a vector, or a series of numbers.
        /// </summary>
        public static BlockedTransformers WordEmbedding { get; } = new BlockedTransformers("WordEmbedding");
        /// <summary>
        /// Naive Bayes is a classified that is used for classification of discrete features that are categorically distributed.
        /// </summary>
        public static BlockedTransformers NaiveBayes { get; } = new BlockedTransformers("NaiveBayes");
        /// <summary>
        /// Count Vectorizer converts a collection of text documents to a matrix of token counts.
        /// </summary>
        public static BlockedTransformers CountVectorizer { get; } = new BlockedTransformers("CountVectorizer");
        /// <summary>
        /// Hashing One Hot Encoder can turn categorical variables into a limited number of new features. This is often used for high-cardinality categorical features.
        /// </summary>
        public static BlockedTransformers HashOneHotEncoder { get; } = new BlockedTransformers("HashOneHotEncoder");

        public static bool operator ==(BlockedTransformers left, BlockedTransformers right) => left.Equals(right);
        public static bool operator !=(BlockedTransformers left, BlockedTransformers right) => !left.Equals(right);

        public static explicit operator string(BlockedTransformers value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BlockedTransformers other && Equals(other);
        public bool Equals(BlockedTransformers other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Kind of this capability host.
    /// </summary>
    [EnumType]
    public readonly struct CapabilityHostKind : IEquatable<CapabilityHostKind>
    {
        private readonly string _value;

        private CapabilityHostKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapabilityHostKind Agents { get; } = new CapabilityHostKind("Agents");

        public static bool operator ==(CapabilityHostKind left, CapabilityHostKind right) => left.Equals(right);
        public static bool operator !=(CapabilityHostKind left, CapabilityHostKind right) => !left.Equals(right);

        public static explicit operator string(CapabilityHostKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapabilityHostKind other && Equals(other);
        public bool Equals(CapabilityHostKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The categorical data drift metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct CategoricalDataDriftMetric : IEquatable<CategoricalDataDriftMetric>
    {
        private readonly string _value;

        private CategoricalDataDriftMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Jensen Shannon Distance (JSD) metric.
        /// </summary>
        public static CategoricalDataDriftMetric JensenShannonDistance { get; } = new CategoricalDataDriftMetric("JensenShannonDistance");
        /// <summary>
        /// The Population Stability Index (PSI) metric.
        /// </summary>
        public static CategoricalDataDriftMetric PopulationStabilityIndex { get; } = new CategoricalDataDriftMetric("PopulationStabilityIndex");
        /// <summary>
        /// The Pearsons Chi Squared Test metric.
        /// </summary>
        public static CategoricalDataDriftMetric PearsonsChiSquaredTest { get; } = new CategoricalDataDriftMetric("PearsonsChiSquaredTest");

        public static bool operator ==(CategoricalDataDriftMetric left, CategoricalDataDriftMetric right) => left.Equals(right);
        public static bool operator !=(CategoricalDataDriftMetric left, CategoricalDataDriftMetric right) => !left.Equals(right);

        public static explicit operator string(CategoricalDataDriftMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CategoricalDataDriftMetric other && Equals(other);
        public bool Equals(CategoricalDataDriftMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The categorical data quality metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct CategoricalDataQualityMetric : IEquatable<CategoricalDataQualityMetric>
    {
        private readonly string _value;

        private CategoricalDataQualityMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Calculates the rate of null values.
        /// </summary>
        public static CategoricalDataQualityMetric NullValueRate { get; } = new CategoricalDataQualityMetric("NullValueRate");
        /// <summary>
        /// Calculates the rate of data type errors.
        /// </summary>
        public static CategoricalDataQualityMetric DataTypeErrorRate { get; } = new CategoricalDataQualityMetric("DataTypeErrorRate");
        /// <summary>
        /// Calculates the rate values are out of bounds.
        /// </summary>
        public static CategoricalDataQualityMetric OutOfBoundsRate { get; } = new CategoricalDataQualityMetric("OutOfBoundsRate");

        public static bool operator ==(CategoricalDataQualityMetric left, CategoricalDataQualityMetric right) => left.Equals(right);
        public static bool operator !=(CategoricalDataQualityMetric left, CategoricalDataQualityMetric right) => !left.Equals(right);

        public static explicit operator string(CategoricalDataQualityMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CategoricalDataQualityMetric other && Equals(other);
        public bool Equals(CategoricalDataQualityMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The categorical prediction drift metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct CategoricalPredictionDriftMetric : IEquatable<CategoricalPredictionDriftMetric>
    {
        private readonly string _value;

        private CategoricalPredictionDriftMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Jensen Shannon Distance (JSD) metric.
        /// </summary>
        public static CategoricalPredictionDriftMetric JensenShannonDistance { get; } = new CategoricalPredictionDriftMetric("JensenShannonDistance");
        /// <summary>
        /// The Population Stability Index (PSI) metric.
        /// </summary>
        public static CategoricalPredictionDriftMetric PopulationStabilityIndex { get; } = new CategoricalPredictionDriftMetric("PopulationStabilityIndex");
        /// <summary>
        /// The Pearsons Chi Squared Test metric.
        /// </summary>
        public static CategoricalPredictionDriftMetric PearsonsChiSquaredTest { get; } = new CategoricalPredictionDriftMetric("PearsonsChiSquaredTest");

        public static bool operator ==(CategoricalPredictionDriftMetric left, CategoricalPredictionDriftMetric right) => left.Equals(right);
        public static bool operator !=(CategoricalPredictionDriftMetric left, CategoricalPredictionDriftMetric right) => !left.Equals(right);

        public static explicit operator string(CategoricalPredictionDriftMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CategoricalPredictionDriftMetric other && Equals(other);
        public bool Equals(CategoricalPredictionDriftMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum for all classification models supported by AutoML.
    /// </summary>
    [EnumType]
    public readonly struct ClassificationModels : IEquatable<ClassificationModels>
    {
        private readonly string _value;

        private ClassificationModels(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Logistic regression is a fundamental classification technique.
        /// It belongs to the group of linear classifiers and is somewhat similar to polynomial and linear regression.
        /// Logistic regression is fast and relatively uncomplicated, and it's convenient for you to interpret the results.
        /// Although it's essentially a method for binary classification, it can also be applied to multiclass problems.
        /// </summary>
        public static ClassificationModels LogisticRegression { get; } = new ClassificationModels("LogisticRegression");
        /// <summary>
        /// SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
        /// to find the model parameters that correspond to the best fit between predicted and actual outputs.
        /// </summary>
        public static ClassificationModels SGD { get; } = new ClassificationModels("SGD");
        /// <summary>
        /// The multinomial Naive Bayes classifier is suitable for classification with discrete features (e.g., word counts for text classification).
        /// The multinomial distribution normally requires integer feature counts. However, in practice, fractional counts such as tf-idf may also work.
        /// </summary>
        public static ClassificationModels MultinomialNaiveBayes { get; } = new ClassificationModels("MultinomialNaiveBayes");
        /// <summary>
        /// Naive Bayes classifier for multivariate Bernoulli models.
        /// </summary>
        public static ClassificationModels BernoulliNaiveBayes { get; } = new ClassificationModels("BernoulliNaiveBayes");
        /// <summary>
        /// A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
        /// After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
        /// </summary>
        public static ClassificationModels SVM { get; } = new ClassificationModels("SVM");
        /// <summary>
        /// A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
        /// After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
        /// Linear SVM performs best when input data is linear, i.e., data can be easily classified by drawing the straight line between classified values on a plotted graph.
        /// </summary>
        public static ClassificationModels LinearSVM { get; } = new ClassificationModels("LinearSVM");
        /// <summary>
        /// K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
        /// which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
        /// </summary>
        public static ClassificationModels KNN { get; } = new ClassificationModels("KNN");
        /// <summary>
        /// Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
        /// The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
        /// </summary>
        public static ClassificationModels DecisionTree { get; } = new ClassificationModels("DecisionTree");
        /// <summary>
        /// Random forest is a supervised learning algorithm.
        /// The "forest" it builds, is an ensemble of decision trees, usually trained with the "bagging" method.
        /// The general idea of the bagging method is that a combination of learning models increases the overall result.
        /// </summary>
        public static ClassificationModels RandomForest { get; } = new ClassificationModels("RandomForest");
        /// <summary>
        /// Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
        /// </summary>
        public static ClassificationModels ExtremeRandomTrees { get; } = new ClassificationModels("ExtremeRandomTrees");
        /// <summary>
        /// LightGBM is a gradient boosting framework that uses tree based learning algorithms.
        /// </summary>
        public static ClassificationModels LightGBM { get; } = new ClassificationModels("LightGBM");
        /// <summary>
        /// The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
        /// </summary>
        public static ClassificationModels GradientBoosting { get; } = new ClassificationModels("GradientBoosting");
        /// <summary>
        /// XGBoost: Extreme Gradient Boosting Algorithm. This algorithm is used for structured data where target column values can be divided into distinct class values.
        /// </summary>
        public static ClassificationModels XGBoostClassifier { get; } = new ClassificationModels("XGBoostClassifier");

        public static bool operator ==(ClassificationModels left, ClassificationModels right) => left.Equals(right);
        public static bool operator !=(ClassificationModels left, ClassificationModels right) => !left.Equals(right);

        public static explicit operator string(ClassificationModels value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClassificationModels other && Equals(other);
        public bool Equals(ClassificationModels other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric to optimize for this task.
    /// </summary>
    [EnumType]
    public readonly struct ClassificationMultilabelPrimaryMetrics : IEquatable<ClassificationMultilabelPrimaryMetrics>
    {
        private readonly string _value;

        private ClassificationMultilabelPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AUC is the Area under the curve.
        /// This metric represents arithmetic mean of the score for each class,
        /// weighted by the number of true instances in each class.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics AUCWeighted { get; } = new ClassificationMultilabelPrimaryMetrics("AUCWeighted");
        /// <summary>
        /// Accuracy is the ratio of predictions that exactly match the true class labels.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics Accuracy { get; } = new ClassificationMultilabelPrimaryMetrics("Accuracy");
        /// <summary>
        /// Normalized macro recall is recall macro-averaged and normalized, so that random
        /// performance has a score of 0, and perfect performance has a score of 1.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics NormMacroRecall { get; } = new ClassificationMultilabelPrimaryMetrics("NormMacroRecall");
        /// <summary>
        /// The arithmetic mean of the average precision score for each class, weighted by
        /// the number of true instances in each class.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics AveragePrecisionScoreWeighted { get; } = new ClassificationMultilabelPrimaryMetrics("AveragePrecisionScoreWeighted");
        /// <summary>
        /// The arithmetic mean of precision for each class, weighted by number of true instances in each class.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics PrecisionScoreWeighted { get; } = new ClassificationMultilabelPrimaryMetrics("PrecisionScoreWeighted");
        /// <summary>
        /// Intersection Over Union. Intersection of predictions divided by union of predictions.
        /// </summary>
        public static ClassificationMultilabelPrimaryMetrics IOU { get; } = new ClassificationMultilabelPrimaryMetrics("IOU");

        public static bool operator ==(ClassificationMultilabelPrimaryMetrics left, ClassificationMultilabelPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(ClassificationMultilabelPrimaryMetrics left, ClassificationMultilabelPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(ClassificationMultilabelPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClassificationMultilabelPrimaryMetrics other && Equals(other);
        public bool Equals(ClassificationMultilabelPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric for Text-Classification task.
    /// </summary>
    [EnumType]
    public readonly struct ClassificationPrimaryMetrics : IEquatable<ClassificationPrimaryMetrics>
    {
        private readonly string _value;

        private ClassificationPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// AUC is the Area under the curve.
        /// This metric represents arithmetic mean of the score for each class,
        /// weighted by the number of true instances in each class.
        /// </summary>
        public static ClassificationPrimaryMetrics AUCWeighted { get; } = new ClassificationPrimaryMetrics("AUCWeighted");
        /// <summary>
        /// Accuracy is the ratio of predictions that exactly match the true class labels.
        /// </summary>
        public static ClassificationPrimaryMetrics Accuracy { get; } = new ClassificationPrimaryMetrics("Accuracy");
        /// <summary>
        /// Normalized macro recall is recall macro-averaged and normalized, so that random
        /// performance has a score of 0, and perfect performance has a score of 1.
        /// </summary>
        public static ClassificationPrimaryMetrics NormMacroRecall { get; } = new ClassificationPrimaryMetrics("NormMacroRecall");
        /// <summary>
        /// The arithmetic mean of the average precision score for each class, weighted by
        /// the number of true instances in each class.
        /// </summary>
        public static ClassificationPrimaryMetrics AveragePrecisionScoreWeighted { get; } = new ClassificationPrimaryMetrics("AveragePrecisionScoreWeighted");
        /// <summary>
        /// The arithmetic mean of precision for each class, weighted by number of true instances in each class.
        /// </summary>
        public static ClassificationPrimaryMetrics PrecisionScoreWeighted { get; } = new ClassificationPrimaryMetrics("PrecisionScoreWeighted");

        public static bool operator ==(ClassificationPrimaryMetrics left, ClassificationPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(ClassificationPrimaryMetrics left, ClassificationPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(ClassificationPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClassificationPrimaryMetrics other && Equals(other);
        public bool Equals(ClassificationPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Intended usage of the cluster
    /// </summary>
    [EnumType]
    public readonly struct ClusterPurpose : IEquatable<ClusterPurpose>
    {
        private readonly string _value;

        private ClusterPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterPurpose FastProd { get; } = new ClusterPurpose("FastProd");
        public static ClusterPurpose DenseProd { get; } = new ClusterPurpose("DenseProd");
        public static ClusterPurpose DevTest { get; } = new ClusterPurpose("DevTest");

        public static bool operator ==(ClusterPurpose left, ClusterPurpose right) => left.Equals(right);
        public static bool operator !=(ClusterPurpose left, ClusterPurpose right) => !left.Equals(right);

        public static explicit operator string(ClusterPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterPurpose other && Equals(other);
        public bool Equals(ClusterPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Compute Instance Authorization type. Available values are personal (default).
    /// </summary>
    [EnumType]
    public readonly struct ComputeInstanceAuthorizationType : IEquatable<ComputeInstanceAuthorizationType>
    {
        private readonly string _value;

        private ComputeInstanceAuthorizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeInstanceAuthorizationType Personal { get; } = new ComputeInstanceAuthorizationType("personal");

        public static bool operator ==(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => left.Equals(right);
        public static bool operator !=(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => !left.Equals(right);

        public static explicit operator string(ComputeInstanceAuthorizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeInstanceAuthorizationType other && Equals(other);
        public bool Equals(ComputeInstanceAuthorizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The compute power action.
    /// </summary>
    [EnumType]
    public readonly struct ComputePowerAction : IEquatable<ComputePowerAction>
    {
        private readonly string _value;

        private ComputePowerAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputePowerAction Start { get; } = new ComputePowerAction("Start");
        public static ComputePowerAction Stop { get; } = new ComputePowerAction("Stop");

        public static bool operator ==(ComputePowerAction left, ComputePowerAction right) => left.Equals(right);
        public static bool operator !=(ComputePowerAction left, ComputePowerAction right) => !left.Equals(right);

        public static explicit operator string(ComputePowerAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputePowerAction other && Equals(other);
        public bool Equals(ComputePowerAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The frequency to trigger schedule.
    /// </summary>
    [EnumType]
    public readonly struct ComputeRecurrenceFrequency : IEquatable<ComputeRecurrenceFrequency>
    {
        private readonly string _value;

        private ComputeRecurrenceFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Minute frequency
        /// </summary>
        public static ComputeRecurrenceFrequency Minute { get; } = new ComputeRecurrenceFrequency("Minute");
        /// <summary>
        /// Hour frequency
        /// </summary>
        public static ComputeRecurrenceFrequency Hour { get; } = new ComputeRecurrenceFrequency("Hour");
        /// <summary>
        /// Day frequency
        /// </summary>
        public static ComputeRecurrenceFrequency Day { get; } = new ComputeRecurrenceFrequency("Day");
        /// <summary>
        /// Week frequency
        /// </summary>
        public static ComputeRecurrenceFrequency Week { get; } = new ComputeRecurrenceFrequency("Week");
        /// <summary>
        /// Month frequency
        /// </summary>
        public static ComputeRecurrenceFrequency Month { get; } = new ComputeRecurrenceFrequency("Month");

        public static bool operator ==(ComputeRecurrenceFrequency left, ComputeRecurrenceFrequency right) => left.Equals(right);
        public static bool operator !=(ComputeRecurrenceFrequency left, ComputeRecurrenceFrequency right) => !left.Equals(right);

        public static explicit operator string(ComputeRecurrenceFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeRecurrenceFrequency other && Equals(other);
        public bool Equals(ComputeRecurrenceFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The schedule trigger type.
    /// </summary>
    [EnumType]
    public readonly struct ComputeTriggerType : IEquatable<ComputeTriggerType>
    {
        private readonly string _value;

        private ComputeTriggerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeTriggerType Recurrence { get; } = new ComputeTriggerType("Recurrence");
        public static ComputeTriggerType Cron { get; } = new ComputeTriggerType("Cron");

        public static bool operator ==(ComputeTriggerType left, ComputeTriggerType right) => left.Equals(right);
        public static bool operator !=(ComputeTriggerType left, ComputeTriggerType right) => !left.Equals(right);

        public static explicit operator string(ComputeTriggerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeTriggerType other && Equals(other);
        public bool Equals(ComputeTriggerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compute
    /// </summary>
    [EnumType]
    public readonly struct ComputeType : IEquatable<ComputeType>
    {
        private readonly string _value;

        private ComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeType AKS { get; } = new ComputeType("AKS");
        public static ComputeType Kubernetes { get; } = new ComputeType("Kubernetes");
        public static ComputeType AmlCompute { get; } = new ComputeType("AmlCompute");
        public static ComputeType ComputeInstance { get; } = new ComputeType("ComputeInstance");
        public static ComputeType DataFactory { get; } = new ComputeType("DataFactory");
        public static ComputeType VirtualMachine { get; } = new ComputeType("VirtualMachine");
        public static ComputeType HDInsight { get; } = new ComputeType("HDInsight");
        public static ComputeType Databricks { get; } = new ComputeType("Databricks");
        public static ComputeType DataLakeAnalytics { get; } = new ComputeType("DataLakeAnalytics");
        public static ComputeType SynapseSpark { get; } = new ComputeType("SynapseSpark");

        public static bool operator ==(ComputeType left, ComputeType right) => left.Equals(right);
        public static bool operator !=(ComputeType left, ComputeType right) => !left.Equals(right);

        public static explicit operator string(ComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeType other && Equals(other);
        public bool Equals(ComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum of weekday
    /// </summary>
    [EnumType]
    public readonly struct ComputeWeekDay : IEquatable<ComputeWeekDay>
    {
        private readonly string _value;

        private ComputeWeekDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Monday weekday
        /// </summary>
        public static ComputeWeekDay Monday { get; } = new ComputeWeekDay("Monday");
        /// <summary>
        /// Tuesday weekday
        /// </summary>
        public static ComputeWeekDay Tuesday { get; } = new ComputeWeekDay("Tuesday");
        /// <summary>
        /// Wednesday weekday
        /// </summary>
        public static ComputeWeekDay Wednesday { get; } = new ComputeWeekDay("Wednesday");
        /// <summary>
        /// Thursday weekday
        /// </summary>
        public static ComputeWeekDay Thursday { get; } = new ComputeWeekDay("Thursday");
        /// <summary>
        /// Friday weekday
        /// </summary>
        public static ComputeWeekDay Friday { get; } = new ComputeWeekDay("Friday");
        /// <summary>
        /// Saturday weekday
        /// </summary>
        public static ComputeWeekDay Saturday { get; } = new ComputeWeekDay("Saturday");
        /// <summary>
        /// Sunday weekday
        /// </summary>
        public static ComputeWeekDay Sunday { get; } = new ComputeWeekDay("Sunday");

        public static bool operator ==(ComputeWeekDay left, ComputeWeekDay right) => left.Equals(right);
        public static bool operator !=(ComputeWeekDay left, ComputeWeekDay right) => !left.Equals(right);

        public static explicit operator string(ComputeWeekDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeWeekDay other && Equals(other);
        public bool Equals(ComputeWeekDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Authentication type of the connection target
    /// </summary>
    [EnumType]
    public readonly struct ConnectionAuthType : IEquatable<ConnectionAuthType>
    {
        private readonly string _value;

        private ConnectionAuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionAuthType PAT { get; } = new ConnectionAuthType("PAT");
        public static ConnectionAuthType ManagedIdentity { get; } = new ConnectionAuthType("ManagedIdentity");
        public static ConnectionAuthType UsernamePassword { get; } = new ConnectionAuthType("UsernamePassword");
        public static ConnectionAuthType None { get; } = new ConnectionAuthType("None");
        public static ConnectionAuthType SAS { get; } = new ConnectionAuthType("SAS");
        public static ConnectionAuthType AccountKey { get; } = new ConnectionAuthType("AccountKey");
        public static ConnectionAuthType ServicePrincipal { get; } = new ConnectionAuthType("ServicePrincipal");
        public static ConnectionAuthType AccessKey { get; } = new ConnectionAuthType("AccessKey");
        public static ConnectionAuthType ApiKey { get; } = new ConnectionAuthType("ApiKey");
        public static ConnectionAuthType CustomKeys { get; } = new ConnectionAuthType("CustomKeys");
        public static ConnectionAuthType OAuth2 { get; } = new ConnectionAuthType("OAuth2");
        public static ConnectionAuthType AAD { get; } = new ConnectionAuthType("AAD");

        public static bool operator ==(ConnectionAuthType left, ConnectionAuthType right) => left.Equals(right);
        public static bool operator !=(ConnectionAuthType left, ConnectionAuthType right) => !left.Equals(right);

        public static explicit operator string(ConnectionAuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionAuthType other && Equals(other);
        public bool Equals(ConnectionAuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Category of the connection
    /// </summary>
    [EnumType]
    public readonly struct ConnectionCategory : IEquatable<ConnectionCategory>
    {
        private readonly string _value;

        private ConnectionCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionCategory PythonFeed { get; } = new ConnectionCategory("PythonFeed");
        public static ConnectionCategory ContainerRegistry { get; } = new ConnectionCategory("ContainerRegistry");
        public static ConnectionCategory Git { get; } = new ConnectionCategory("Git");
        public static ConnectionCategory S3 { get; } = new ConnectionCategory("S3");
        public static ConnectionCategory Snowflake { get; } = new ConnectionCategory("Snowflake");
        public static ConnectionCategory AzureSqlDb { get; } = new ConnectionCategory("AzureSqlDb");
        public static ConnectionCategory AzureSynapseAnalytics { get; } = new ConnectionCategory("AzureSynapseAnalytics");
        public static ConnectionCategory AzureMySqlDb { get; } = new ConnectionCategory("AzureMySqlDb");
        public static ConnectionCategory AzurePostgresDb { get; } = new ConnectionCategory("AzurePostgresDb");
        public static ConnectionCategory ADLSGen2 { get; } = new ConnectionCategory("ADLSGen2");
        public static ConnectionCategory Redis { get; } = new ConnectionCategory("Redis");
        public static ConnectionCategory ApiKey { get; } = new ConnectionCategory("ApiKey");
        public static ConnectionCategory AzureOpenAI { get; } = new ConnectionCategory("AzureOpenAI");
        public static ConnectionCategory AIServices { get; } = new ConnectionCategory("AIServices");
        public static ConnectionCategory CognitiveSearch { get; } = new ConnectionCategory("CognitiveSearch");
        public static ConnectionCategory CognitiveService { get; } = new ConnectionCategory("CognitiveService");
        public static ConnectionCategory CustomKeys { get; } = new ConnectionCategory("CustomKeys");
        public static ConnectionCategory AzureBlob { get; } = new ConnectionCategory("AzureBlob");
        public static ConnectionCategory AzureOneLake { get; } = new ConnectionCategory("AzureOneLake");
        public static ConnectionCategory CosmosDb { get; } = new ConnectionCategory("CosmosDb");
        public static ConnectionCategory CosmosDbMongoDbApi { get; } = new ConnectionCategory("CosmosDbMongoDbApi");
        public static ConnectionCategory AzureDataExplorer { get; } = new ConnectionCategory("AzureDataExplorer");
        public static ConnectionCategory AzureMariaDb { get; } = new ConnectionCategory("AzureMariaDb");
        public static ConnectionCategory AzureDatabricksDeltaLake { get; } = new ConnectionCategory("AzureDatabricksDeltaLake");
        public static ConnectionCategory AzureSqlMi { get; } = new ConnectionCategory("AzureSqlMi");
        public static ConnectionCategory AzureTableStorage { get; } = new ConnectionCategory("AzureTableStorage");
        public static ConnectionCategory AmazonRdsForOracle { get; } = new ConnectionCategory("AmazonRdsForOracle");
        public static ConnectionCategory AmazonRdsForSqlServer { get; } = new ConnectionCategory("AmazonRdsForSqlServer");
        public static ConnectionCategory AmazonRedshift { get; } = new ConnectionCategory("AmazonRedshift");
        public static ConnectionCategory Db2 { get; } = new ConnectionCategory("Db2");
        public static ConnectionCategory Drill { get; } = new ConnectionCategory("Drill");
        public static ConnectionCategory GoogleBigQuery { get; } = new ConnectionCategory("GoogleBigQuery");
        public static ConnectionCategory Greenplum { get; } = new ConnectionCategory("Greenplum");
        public static ConnectionCategory Hbase { get; } = new ConnectionCategory("Hbase");
        public static ConnectionCategory Hive { get; } = new ConnectionCategory("Hive");
        public static ConnectionCategory Impala { get; } = new ConnectionCategory("Impala");
        public static ConnectionCategory Informix { get; } = new ConnectionCategory("Informix");
        public static ConnectionCategory MariaDb { get; } = new ConnectionCategory("MariaDb");
        public static ConnectionCategory MicrosoftAccess { get; } = new ConnectionCategory("MicrosoftAccess");
        public static ConnectionCategory MySql { get; } = new ConnectionCategory("MySql");
        public static ConnectionCategory Netezza { get; } = new ConnectionCategory("Netezza");
        public static ConnectionCategory Oracle { get; } = new ConnectionCategory("Oracle");
        public static ConnectionCategory Phoenix { get; } = new ConnectionCategory("Phoenix");
        public static ConnectionCategory PostgreSql { get; } = new ConnectionCategory("PostgreSql");
        public static ConnectionCategory Presto { get; } = new ConnectionCategory("Presto");
        public static ConnectionCategory SapOpenHub { get; } = new ConnectionCategory("SapOpenHub");
        public static ConnectionCategory SapBw { get; } = new ConnectionCategory("SapBw");
        public static ConnectionCategory SapHana { get; } = new ConnectionCategory("SapHana");
        public static ConnectionCategory SapTable { get; } = new ConnectionCategory("SapTable");
        public static ConnectionCategory Spark { get; } = new ConnectionCategory("Spark");
        public static ConnectionCategory SqlServer { get; } = new ConnectionCategory("SqlServer");
        public static ConnectionCategory Sybase { get; } = new ConnectionCategory("Sybase");
        public static ConnectionCategory Teradata { get; } = new ConnectionCategory("Teradata");
        public static ConnectionCategory Vertica { get; } = new ConnectionCategory("Vertica");
        public static ConnectionCategory Pinecone { get; } = new ConnectionCategory("Pinecone");
        public static ConnectionCategory Cassandra { get; } = new ConnectionCategory("Cassandra");
        public static ConnectionCategory Couchbase { get; } = new ConnectionCategory("Couchbase");
        public static ConnectionCategory MongoDbV2 { get; } = new ConnectionCategory("MongoDbV2");
        public static ConnectionCategory MongoDbAtlas { get; } = new ConnectionCategory("MongoDbAtlas");
        public static ConnectionCategory AmazonS3Compatible { get; } = new ConnectionCategory("AmazonS3Compatible");
        public static ConnectionCategory FileServer { get; } = new ConnectionCategory("FileServer");
        public static ConnectionCategory FtpServer { get; } = new ConnectionCategory("FtpServer");
        public static ConnectionCategory GoogleCloudStorage { get; } = new ConnectionCategory("GoogleCloudStorage");
        public static ConnectionCategory Hdfs { get; } = new ConnectionCategory("Hdfs");
        public static ConnectionCategory OracleCloudStorage { get; } = new ConnectionCategory("OracleCloudStorage");
        public static ConnectionCategory Sftp { get; } = new ConnectionCategory("Sftp");
        public static ConnectionCategory GenericHttp { get; } = new ConnectionCategory("GenericHttp");
        public static ConnectionCategory ODataRest { get; } = new ConnectionCategory("ODataRest");
        public static ConnectionCategory Odbc { get; } = new ConnectionCategory("Odbc");
        public static ConnectionCategory GenericRest { get; } = new ConnectionCategory("GenericRest");
        public static ConnectionCategory AmazonMws { get; } = new ConnectionCategory("AmazonMws");
        public static ConnectionCategory Concur { get; } = new ConnectionCategory("Concur");
        public static ConnectionCategory Dynamics { get; } = new ConnectionCategory("Dynamics");
        public static ConnectionCategory DynamicsAx { get; } = new ConnectionCategory("DynamicsAx");
        public static ConnectionCategory DynamicsCrm { get; } = new ConnectionCategory("DynamicsCrm");
        public static ConnectionCategory GoogleAdWords { get; } = new ConnectionCategory("GoogleAdWords");
        public static ConnectionCategory Hubspot { get; } = new ConnectionCategory("Hubspot");
        public static ConnectionCategory Jira { get; } = new ConnectionCategory("Jira");
        public static ConnectionCategory Magento { get; } = new ConnectionCategory("Magento");
        public static ConnectionCategory Marketo { get; } = new ConnectionCategory("Marketo");
        public static ConnectionCategory Office365 { get; } = new ConnectionCategory("Office365");
        public static ConnectionCategory Eloqua { get; } = new ConnectionCategory("Eloqua");
        public static ConnectionCategory Responsys { get; } = new ConnectionCategory("Responsys");
        public static ConnectionCategory OracleServiceCloud { get; } = new ConnectionCategory("OracleServiceCloud");
        public static ConnectionCategory PayPal { get; } = new ConnectionCategory("PayPal");
        public static ConnectionCategory QuickBooks { get; } = new ConnectionCategory("QuickBooks");
        public static ConnectionCategory Salesforce { get; } = new ConnectionCategory("Salesforce");
        public static ConnectionCategory SalesforceServiceCloud { get; } = new ConnectionCategory("SalesforceServiceCloud");
        public static ConnectionCategory SalesforceMarketingCloud { get; } = new ConnectionCategory("SalesforceMarketingCloud");
        public static ConnectionCategory SapCloudForCustomer { get; } = new ConnectionCategory("SapCloudForCustomer");
        public static ConnectionCategory SapEcc { get; } = new ConnectionCategory("SapEcc");
        public static ConnectionCategory ServiceNow { get; } = new ConnectionCategory("ServiceNow");
        public static ConnectionCategory SharePointOnlineList { get; } = new ConnectionCategory("SharePointOnlineList");
        public static ConnectionCategory Shopify { get; } = new ConnectionCategory("Shopify");
        public static ConnectionCategory Square { get; } = new ConnectionCategory("Square");
        public static ConnectionCategory WebTable { get; } = new ConnectionCategory("WebTable");
        public static ConnectionCategory Xero { get; } = new ConnectionCategory("Xero");
        public static ConnectionCategory Zoho { get; } = new ConnectionCategory("Zoho");
        public static ConnectionCategory GenericContainerRegistry { get; } = new ConnectionCategory("GenericContainerRegistry");
        public static ConnectionCategory Elasticsearch { get; } = new ConnectionCategory("Elasticsearch");
        public static ConnectionCategory OpenAI { get; } = new ConnectionCategory("OpenAI");
        public static ConnectionCategory Serp { get; } = new ConnectionCategory("Serp");
        public static ConnectionCategory BingLLMSearch { get; } = new ConnectionCategory("BingLLMSearch");
        public static ConnectionCategory Serverless { get; } = new ConnectionCategory("Serverless");
        public static ConnectionCategory ManagedOnlineEndpoint { get; } = new ConnectionCategory("ManagedOnlineEndpoint");

        public static bool operator ==(ConnectionCategory left, ConnectionCategory right) => left.Equals(right);
        public static bool operator !=(ConnectionCategory left, ConnectionCategory right) => !left.Equals(right);

        public static explicit operator string(ConnectionCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionCategory other && Equals(other);
        public bool Equals(ConnectionCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of container to retrieve logs from.
    /// </summary>
    [EnumType]
    public readonly struct ContainerType : IEquatable<ContainerType>
    {
        private readonly string _value;

        private ContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerType StorageInitializer { get; } = new ContainerType("StorageInitializer");
        public static ContainerType InferenceServer { get; } = new ContainerType("InferenceServer");

        public static bool operator ==(ContainerType left, ContainerType right) => left.Equals(right);
        public static bool operator !=(ContainerType left, ContainerType right) => !left.Equals(right);

        public static explicit operator string(ContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerType other && Equals(other);
        public bool Equals(ContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the status of content safety.
    /// </summary>
    [EnumType]
    public readonly struct ContentSafetyStatus : IEquatable<ContentSafetyStatus>
    {
        private readonly string _value;

        private ContentSafetyStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContentSafetyStatus Enabled { get; } = new ContentSafetyStatus("Enabled");
        public static ContentSafetyStatus Disabled { get; } = new ContentSafetyStatus("Disabled");

        public static bool operator ==(ContentSafetyStatus left, ContentSafetyStatus right) => left.Equals(right);
        public static bool operator !=(ContentSafetyStatus left, ContentSafetyStatus right) => !left.Equals(right);

        public static explicit operator string(ContentSafetyStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentSafetyStatus other && Equals(other);
        public bool Equals(ContentSafetyStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct CredentialsType : IEquatable<CredentialsType>
    {
        private readonly string _value;

        private CredentialsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CredentialsType AccountKey { get; } = new CredentialsType("AccountKey");
        public static CredentialsType Certificate { get; } = new CredentialsType("Certificate");
        public static CredentialsType None { get; } = new CredentialsType("None");
        public static CredentialsType Sas { get; } = new CredentialsType("Sas");
        public static CredentialsType ServicePrincipal { get; } = new CredentialsType("ServicePrincipal");

        public static bool operator ==(CredentialsType left, CredentialsType right) => left.Equals(right);
        public static bool operator !=(CredentialsType left, CredentialsType right) => !left.Equals(right);

        public static explicit operator string(CredentialsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CredentialsType other && Equals(other);
        public bool Equals(CredentialsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable or disable data collection.
    /// </summary>
    [EnumType]
    public readonly struct DataCollectionMode : IEquatable<DataCollectionMode>
    {
        private readonly string _value;

        private DataCollectionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataCollectionMode Enabled { get; } = new DataCollectionMode("Enabled");
        public static DataCollectionMode Disabled { get; } = new DataCollectionMode("Disabled");

        public static bool operator ==(DataCollectionMode left, DataCollectionMode right) => left.Equals(right);
        public static bool operator !=(DataCollectionMode left, DataCollectionMode right) => !left.Equals(right);

        public static explicit operator string(DataCollectionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataCollectionMode other && Equals(other);
        public bool Equals(DataCollectionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of data.
    /// </summary>
    [EnumType]
    public readonly struct DataType : IEquatable<DataType>
    {
        private readonly string _value;

        private DataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataType Uri_file { get; } = new DataType("uri_file");
        public static DataType Uri_folder { get; } = new DataType("uri_folder");
        public static DataType Mltable { get; } = new DataType("mltable");

        public static bool operator ==(DataType left, DataType right) => left.Equals(right);
        public static bool operator !=(DataType left, DataType right) => !left.Equals(right);

        public static explicit operator string(DataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataType other && Equals(other);
        public bool Equals(DataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Storage type backing the datastore.
    /// </summary>
    [EnumType]
    public readonly struct DatastoreType : IEquatable<DatastoreType>
    {
        private readonly string _value;

        private DatastoreType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatastoreType AzureBlob { get; } = new DatastoreType("AzureBlob");
        public static DatastoreType AzureDataLakeGen1 { get; } = new DatastoreType("AzureDataLakeGen1");
        public static DatastoreType AzureDataLakeGen2 { get; } = new DatastoreType("AzureDataLakeGen2");
        public static DatastoreType AzureFile { get; } = new DatastoreType("AzureFile");
        public static DatastoreType OneLake { get; } = new DatastoreType("OneLake");

        public static bool operator ==(DatastoreType left, DatastoreType right) => left.Equals(right);
        public static bool operator !=(DatastoreType left, DatastoreType right) => !left.Equals(right);

        public static explicit operator string(DatastoreType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatastoreType other && Equals(other);
        public bool Equals(DatastoreType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated.
    /// </summary>
    [EnumType]
    public readonly struct DefaultActionType : IEquatable<DefaultActionType>
    {
        private readonly string _value;

        private DefaultActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DefaultActionType Deny { get; } = new DefaultActionType("Deny");
        public static DefaultActionType Allow { get; } = new DefaultActionType("Allow");

        public static bool operator ==(DefaultActionType left, DefaultActionType right) => left.Equals(right);
        public static bool operator !=(DefaultActionType left, DefaultActionType right) => !left.Equals(right);

        public static explicit operator string(DefaultActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DefaultActionType other && Equals(other);
        public bool Equals(DefaultActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deployment model version upgrade option.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentModelVersionUpgradeOption : IEquatable<DeploymentModelVersionUpgradeOption>
    {
        private readonly string _value;

        private DeploymentModelVersionUpgradeOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeploymentModelVersionUpgradeOption OnceNewDefaultVersionAvailable { get; } = new DeploymentModelVersionUpgradeOption("OnceNewDefaultVersionAvailable");
        public static DeploymentModelVersionUpgradeOption OnceCurrentVersionExpired { get; } = new DeploymentModelVersionUpgradeOption("OnceCurrentVersionExpired");
        public static DeploymentModelVersionUpgradeOption NoAutoUpgrade { get; } = new DeploymentModelVersionUpgradeOption("NoAutoUpgrade");

        public static bool operator ==(DeploymentModelVersionUpgradeOption left, DeploymentModelVersionUpgradeOption right) => left.Equals(right);
        public static bool operator !=(DeploymentModelVersionUpgradeOption left, DeploymentModelVersionUpgradeOption right) => !left.Equals(right);

        public static explicit operator string(DeploymentModelVersionUpgradeOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentModelVersionUpgradeOption other && Equals(other);
        public bool Equals(DeploymentModelVersionUpgradeOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of distribution framework.
    /// </summary>
    [EnumType]
    public readonly struct DistributionType : IEquatable<DistributionType>
    {
        private readonly string _value;

        private DistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionType PyTorch { get; } = new DistributionType("PyTorch");
        public static DistributionType TensorFlow { get; } = new DistributionType("TensorFlow");
        public static DistributionType Mpi { get; } = new DistributionType("Mpi");

        public static bool operator ==(DistributionType left, DistributionType right) => left.Equals(right);
        public static bool operator !=(DistributionType left, DistributionType right) => !left.Equals(right);

        public static explicit operator string(DistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionType other && Equals(other);
        public bool Equals(DistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Name of policy configuration
    /// </summary>
    [EnumType]
    public readonly struct EarlyTerminationPolicyType : IEquatable<EarlyTerminationPolicyType>
    {
        private readonly string _value;

        private EarlyTerminationPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EarlyTerminationPolicyType Bandit { get; } = new EarlyTerminationPolicyType("Bandit");
        public static EarlyTerminationPolicyType MedianStopping { get; } = new EarlyTerminationPolicyType("MedianStopping");
        public static EarlyTerminationPolicyType TruncationSelection { get; } = new EarlyTerminationPolicyType("TruncationSelection");

        public static bool operator ==(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => left.Equals(right);
        public static bool operator !=(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => !left.Equals(right);

        public static explicit operator string(EarlyTerminationPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EarlyTerminationPolicyType other && Equals(other);
        public bool Equals(EarlyTerminationPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
    /// </summary>
    [EnumType]
    public readonly struct EgressPublicNetworkAccessType : IEquatable<EgressPublicNetworkAccessType>
    {
        private readonly string _value;

        private EgressPublicNetworkAccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EgressPublicNetworkAccessType Enabled { get; } = new EgressPublicNetworkAccessType("Enabled");
        public static EgressPublicNetworkAccessType Disabled { get; } = new EgressPublicNetworkAccessType("Disabled");

        public static bool operator ==(EgressPublicNetworkAccessType left, EgressPublicNetworkAccessType right) => left.Equals(right);
        public static bool operator !=(EgressPublicNetworkAccessType left, EgressPublicNetworkAccessType right) => !left.Equals(right);

        public static explicit operator string(EgressPublicNetworkAccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EgressPublicNetworkAccessType other && Equals(other);
        public bool Equals(EgressPublicNetworkAccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum to determine the email notification type.
    /// </summary>
    [EnumType]
    public readonly struct EmailNotificationEnableType : IEquatable<EmailNotificationEnableType>
    {
        private readonly string _value;

        private EmailNotificationEnableType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EmailNotificationEnableType JobCompleted { get; } = new EmailNotificationEnableType("JobCompleted");
        public static EmailNotificationEnableType JobFailed { get; } = new EmailNotificationEnableType("JobFailed");
        public static EmailNotificationEnableType JobCancelled { get; } = new EmailNotificationEnableType("JobCancelled");

        public static bool operator ==(EmailNotificationEnableType left, EmailNotificationEnableType right) => left.Equals(right);
        public static bool operator !=(EmailNotificationEnableType left, EmailNotificationEnableType right) => !left.Equals(right);

        public static explicit operator string(EmailNotificationEnableType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EmailNotificationEnableType other && Equals(other);
        public bool Equals(EmailNotificationEnableType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not the encryption is enabled for the workspace.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionStatus : IEquatable<EncryptionStatus>
    {
        private readonly string _value;

        private EncryptionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionStatus Enabled { get; } = new EncryptionStatus("Enabled");
        public static EncryptionStatus Disabled { get; } = new EncryptionStatus("Disabled");

        public static bool operator ==(EncryptionStatus left, EncryptionStatus right) => left.Equals(right);
        public static bool operator !=(EncryptionStatus left, EncryptionStatus right) => !left.Equals(right);

        public static explicit operator string(EncryptionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionStatus other && Equals(other);
        public bool Equals(EncryptionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
    /// </summary>
    [EnumType]
    public readonly struct EndpointAuthMode : IEquatable<EndpointAuthMode>
    {
        private readonly string _value;

        private EndpointAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointAuthMode AMLToken { get; } = new EndpointAuthMode("AMLToken");
        public static EndpointAuthMode Key { get; } = new EndpointAuthMode("Key");
        public static EndpointAuthMode AADToken { get; } = new EndpointAuthMode("AADToken");

        public static bool operator ==(EndpointAuthMode left, EndpointAuthMode right) => left.Equals(right);
        public static bool operator !=(EndpointAuthMode left, EndpointAuthMode right) => !left.Equals(right);

        public static explicit operator string(EndpointAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointAuthMode other && Equals(other);
        public bool Equals(EndpointAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The compute type of the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct EndpointComputeType : IEquatable<EndpointComputeType>
    {
        private readonly string _value;

        private EndpointComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointComputeType Managed { get; } = new EndpointComputeType("Managed");
        public static EndpointComputeType Kubernetes { get; } = new EndpointComputeType("Kubernetes");
        public static EndpointComputeType AzureMLCompute { get; } = new EndpointComputeType("AzureMLCompute");

        public static bool operator ==(EndpointComputeType left, EndpointComputeType right) => left.Equals(right);
        public static bool operator !=(EndpointComputeType left, EndpointComputeType right) => !left.Equals(right);

        public static explicit operator string(EndpointComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointComputeType other && Equals(other);
        public bool Equals(EndpointComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Connection status of the service consumer with the service provider
    /// Possible state transitions
    /// Pending -&gt; Approved (Service provider approves the connection request)
    /// Pending -&gt; Rejected (Service provider rejects the connection request)
    /// Pending -&gt; Disconnected (Service provider deletes the connection)
    /// Approved -&gt; Rejected (Service provider rejects the approved connection)
    /// Approved -&gt; Disconnected (Service provider deletes the connection)
    /// Rejected -&gt; Pending (Service consumer re-initiates the connection request that was rejected)
    /// Rejected -&gt; Disconnected (Service provider deletes the connection)
    /// </summary>
    [EnumType]
    public readonly struct EndpointServiceConnectionStatus : IEquatable<EndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private EndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointServiceConnectionStatus Approved { get; } = new EndpointServiceConnectionStatus("Approved");
        public static EndpointServiceConnectionStatus Pending { get; } = new EndpointServiceConnectionStatus("Pending");
        public static EndpointServiceConnectionStatus Rejected { get; } = new EndpointServiceConnectionStatus("Rejected");
        public static EndpointServiceConnectionStatus Disconnected { get; } = new EndpointServiceConnectionStatus("Disconnected");
        public static EndpointServiceConnectionStatus Timeout { get; } = new EndpointServiceConnectionStatus("Timeout");

        public static bool operator ==(EndpointServiceConnectionStatus left, EndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(EndpointServiceConnectionStatus left, EndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(EndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(EndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the Environment Variable. Possible values are: local - For local variable
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentVariableType : IEquatable<EnvironmentVariableType>
    {
        private readonly string _value;

        private EnvironmentVariableType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EnvironmentVariableType Local { get; } = new EnvironmentVariableType("local");

        public static bool operator ==(EnvironmentVariableType left, EnvironmentVariableType right) => left.Equals(right);
        public static bool operator !=(EnvironmentVariableType left, EnvironmentVariableType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentVariableType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentVariableType other && Equals(other);
        public bool Equals(EnvironmentVariableType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The feature attribution metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct FeatureAttributionMetric : IEquatable<FeatureAttributionMetric>
    {
        private readonly string _value;

        private FeatureAttributionMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Normalized Discounted Cumulative Gain metric.
        /// </summary>
        public static FeatureAttributionMetric NormalizedDiscountedCumulativeGain { get; } = new FeatureAttributionMetric("NormalizedDiscountedCumulativeGain");

        public static bool operator ==(FeatureAttributionMetric left, FeatureAttributionMetric right) => left.Equals(right);
        public static bool operator !=(FeatureAttributionMetric left, FeatureAttributionMetric right) => !left.Equals(right);

        public static explicit operator string(FeatureAttributionMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeatureAttributionMetric other && Equals(other);
        public bool Equals(FeatureAttributionMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the data type
    /// </summary>
    [EnumType]
    public readonly struct FeatureDataType : IEquatable<FeatureDataType>
    {
        private readonly string _value;

        private FeatureDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FeatureDataType String { get; } = new FeatureDataType("String");
        public static FeatureDataType Integer { get; } = new FeatureDataType("Integer");
        public static FeatureDataType Long { get; } = new FeatureDataType("Long");
        public static FeatureDataType Float { get; } = new FeatureDataType("Float");
        public static FeatureDataType Double { get; } = new FeatureDataType("Double");
        public static FeatureDataType Binary { get; } = new FeatureDataType("Binary");
        public static FeatureDataType Datetime { get; } = new FeatureDataType("Datetime");
        public static FeatureDataType Boolean { get; } = new FeatureDataType("Boolean");

        public static bool operator ==(FeatureDataType left, FeatureDataType right) => left.Equals(right);
        public static bool operator !=(FeatureDataType left, FeatureDataType right) => !left.Equals(right);

        public static explicit operator string(FeatureDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeatureDataType other && Equals(other);
        public bool Equals(FeatureDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode of operation for computing feature importance.
    /// </summary>
    [EnumType]
    public readonly struct FeatureImportanceMode : IEquatable<FeatureImportanceMode>
    {
        private readonly string _value;

        private FeatureImportanceMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disables computing feature importance within a signal.
        /// </summary>
        public static FeatureImportanceMode Disabled { get; } = new FeatureImportanceMode("Disabled");
        /// <summary>
        /// Enables computing feature importance within a signal.
        /// </summary>
        public static FeatureImportanceMode Enabled { get; } = new FeatureImportanceMode("Enabled");

        public static bool operator ==(FeatureImportanceMode left, FeatureImportanceMode right) => left.Equals(right);
        public static bool operator !=(FeatureImportanceMode left, FeatureImportanceMode right) => !left.Equals(right);

        public static explicit operator string(FeatureImportanceMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeatureImportanceMode other && Equals(other);
        public bool Equals(FeatureImportanceMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Flag for generating lags for the numeric features with 'auto' or null.
    /// </summary>
    [EnumType]
    public readonly struct FeatureLags : IEquatable<FeatureLags>
    {
        private readonly string _value;

        private FeatureLags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No feature lags generated.
        /// </summary>
        public static FeatureLags None { get; } = new FeatureLags("None");
        /// <summary>
        /// System auto-generates feature lags.
        /// </summary>
        public static FeatureLags Auto { get; } = new FeatureLags("Auto");

        public static bool operator ==(FeatureLags left, FeatureLags right) => left.Equals(right);
        public static bool operator !=(FeatureLags left, FeatureLags right) => !left.Equals(right);

        public static explicit operator string(FeatureLags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeatureLags other && Equals(other);
        public bool Equals(FeatureLags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
    /// If 'Off' is selected then no featurization is done.
    /// If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
    /// </summary>
    [EnumType]
    public readonly struct FeaturizationMode : IEquatable<FeaturizationMode>
    {
        private readonly string _value;

        private FeaturizationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Auto mode, system performs featurization without any custom featurization inputs.
        /// </summary>
        public static FeaturizationMode Auto { get; } = new FeaturizationMode("Auto");
        /// <summary>
        /// Custom featurization.
        /// </summary>
        public static FeaturizationMode Custom { get; } = new FeaturizationMode("Custom");
        /// <summary>
        /// Featurization off. 'Forecasting' task cannot use this value.
        /// </summary>
        public static FeaturizationMode Off { get; } = new FeaturizationMode("Off");

        public static bool operator ==(FeaturizationMode left, FeaturizationMode right) => left.Equals(right);
        public static bool operator !=(FeaturizationMode left, FeaturizationMode right) => !left.Equals(right);

        public static explicit operator string(FeaturizationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FeaturizationMode other && Equals(other);
        public bool Equals(FeaturizationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Fine tuning task type.
    /// </summary>
    [EnumType]
    public readonly struct FineTuningTaskType : IEquatable<FineTuningTaskType>
    {
        private readonly string _value;

        private FineTuningTaskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FineTuningTaskType ChatCompletion { get; } = new FineTuningTaskType("ChatCompletion");
        public static FineTuningTaskType TextCompletion { get; } = new FineTuningTaskType("TextCompletion");
        public static FineTuningTaskType TextClassification { get; } = new FineTuningTaskType("TextClassification");
        public static FineTuningTaskType QuestionAnswering { get; } = new FineTuningTaskType("QuestionAnswering");
        public static FineTuningTaskType TextSummarization { get; } = new FineTuningTaskType("TextSummarization");
        public static FineTuningTaskType TokenClassification { get; } = new FineTuningTaskType("TokenClassification");
        public static FineTuningTaskType TextTranslation { get; } = new FineTuningTaskType("TextTranslation");
        public static FineTuningTaskType ImageClassification { get; } = new FineTuningTaskType("ImageClassification");
        public static FineTuningTaskType ImageInstanceSegmentation { get; } = new FineTuningTaskType("ImageInstanceSegmentation");
        public static FineTuningTaskType ImageObjectDetection { get; } = new FineTuningTaskType("ImageObjectDetection");
        public static FineTuningTaskType VideoMultiObjectTracking { get; } = new FineTuningTaskType("VideoMultiObjectTracking");

        public static bool operator ==(FineTuningTaskType left, FineTuningTaskType right) => left.Equals(right);
        public static bool operator !=(FineTuningTaskType left, FineTuningTaskType right) => !left.Equals(right);

        public static explicit operator string(FineTuningTaskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FineTuningTaskType other && Equals(other);
        public bool Equals(FineTuningTaskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Firewall Sku used for FQDN Rules
    /// </summary>
    [EnumType]
    public readonly struct FirewallSku : IEquatable<FirewallSku>
    {
        private readonly string _value;

        private FirewallSku(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallSku Standard { get; } = new FirewallSku("Standard");
        public static FirewallSku Basic { get; } = new FirewallSku("Basic");

        public static bool operator ==(FirewallSku left, FirewallSku right) => left.Equals(right);
        public static bool operator !=(FirewallSku left, FirewallSku right) => !left.Equals(right);

        public static explicit operator string(FirewallSku value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallSku other && Equals(other);
        public bool Equals(FirewallSku other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Set forecast horizon value selection mode.
    /// </summary>
    [EnumType]
    public readonly struct ForecastHorizonMode : IEquatable<ForecastHorizonMode>
    {
        private readonly string _value;

        private ForecastHorizonMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Forecast horizon to be determined automatically.
        /// </summary>
        public static ForecastHorizonMode Auto { get; } = new ForecastHorizonMode("Auto");
        /// <summary>
        /// Use the custom forecast horizon.
        /// </summary>
        public static ForecastHorizonMode Custom { get; } = new ForecastHorizonMode("Custom");

        public static bool operator ==(ForecastHorizonMode left, ForecastHorizonMode right) => left.Equals(right);
        public static bool operator !=(ForecastHorizonMode left, ForecastHorizonMode right) => !left.Equals(right);

        public static explicit operator string(ForecastHorizonMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForecastHorizonMode other && Equals(other);
        public bool Equals(ForecastHorizonMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum for all forecasting models supported by AutoML.
    /// </summary>
    [EnumType]
    public readonly struct ForecastingModels : IEquatable<ForecastingModels>
    {
        private readonly string _value;

        private ForecastingModels(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Auto-Autoregressive Integrated Moving Average (ARIMA) model uses time-series data and statistical analysis to interpret the data and make future predictions.
        /// This model aims to explain data by using time series data on its past values and uses linear regression to make predictions.
        /// </summary>
        public static ForecastingModels AutoArima { get; } = new ForecastingModels("AutoArima");
        /// <summary>
        /// Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects.
        /// It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.
        /// </summary>
        public static ForecastingModels Prophet { get; } = new ForecastingModels("Prophet");
        /// <summary>
        /// The Naive forecasting model makes predictions by carrying forward the latest target value for each time-series in the training data.
        /// </summary>
        public static ForecastingModels Naive { get; } = new ForecastingModels("Naive");
        /// <summary>
        /// The Seasonal Naive forecasting model makes predictions by carrying forward the latest season of target values for each time-series in the training data.
        /// </summary>
        public static ForecastingModels SeasonalNaive { get; } = new ForecastingModels("SeasonalNaive");
        /// <summary>
        /// The Average forecasting model makes predictions by carrying forward the average of the target values for each time-series in the training data.
        /// </summary>
        public static ForecastingModels Average { get; } = new ForecastingModels("Average");
        /// <summary>
        /// The Seasonal Average forecasting model makes predictions by carrying forward the average value of the latest season of data for each time-series in the training data.
        /// </summary>
        public static ForecastingModels SeasonalAverage { get; } = new ForecastingModels("SeasonalAverage");
        /// <summary>
        /// Exponential smoothing is a time series forecasting method for univariate data that can be extended to support data with a systematic trend or seasonal component.
        /// </summary>
        public static ForecastingModels ExponentialSmoothing { get; } = new ForecastingModels("ExponentialSmoothing");
        /// <summary>
        /// An Autoregressive Integrated Moving Average with Explanatory Variable (ARIMAX) model can be viewed as a multiple regression model with one or more autoregressive (AR) terms and/or one or more moving average (MA) terms.
        /// This method is suitable for forecasting when data is stationary/non stationary, and multivariate with any type of data pattern, i.e., level/trend /seasonality/cyclicity.
        /// </summary>
        public static ForecastingModels Arimax { get; } = new ForecastingModels("Arimax");
        /// <summary>
        /// TCNForecaster: Temporal Convolutional Networks Forecaster. //TODO: Ask forecasting team for brief intro.
        /// </summary>
        public static ForecastingModels TCNForecaster { get; } = new ForecastingModels("TCNForecaster");
        /// <summary>
        /// Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions.
        /// </summary>
        public static ForecastingModels ElasticNet { get; } = new ForecastingModels("ElasticNet");
        /// <summary>
        /// The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
        /// </summary>
        public static ForecastingModels GradientBoosting { get; } = new ForecastingModels("GradientBoosting");
        /// <summary>
        /// Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
        /// The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
        /// </summary>
        public static ForecastingModels DecisionTree { get; } = new ForecastingModels("DecisionTree");
        /// <summary>
        /// K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
        /// which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
        /// </summary>
        public static ForecastingModels KNN { get; } = new ForecastingModels("KNN");
        /// <summary>
        /// Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer.
        /// </summary>
        public static ForecastingModels LassoLars { get; } = new ForecastingModels("LassoLars");
        /// <summary>
        /// SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
        /// to find the model parameters that correspond to the best fit between predicted and actual outputs.
        /// It's an inexact but powerful technique.
        /// </summary>
        public static ForecastingModels SGD { get; } = new ForecastingModels("SGD");
        /// <summary>
        /// Random forest is a supervised learning algorithm.
        /// The "forest" it builds, is an ensemble of decision trees, usually trained with the "bagging" method.
        /// The general idea of the bagging method is that a combination of learning models increases the overall result.
        /// </summary>
        public static ForecastingModels RandomForest { get; } = new ForecastingModels("RandomForest");
        /// <summary>
        /// Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
        /// </summary>
        public static ForecastingModels ExtremeRandomTrees { get; } = new ForecastingModels("ExtremeRandomTrees");
        /// <summary>
        /// LightGBM is a gradient boosting framework that uses tree based learning algorithms.
        /// </summary>
        public static ForecastingModels LightGBM { get; } = new ForecastingModels("LightGBM");
        /// <summary>
        /// XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners.
        /// </summary>
        public static ForecastingModels XGBoostRegressor { get; } = new ForecastingModels("XGBoostRegressor");

        public static bool operator ==(ForecastingModels left, ForecastingModels right) => left.Equals(right);
        public static bool operator !=(ForecastingModels left, ForecastingModels right) => !left.Equals(right);

        public static explicit operator string(ForecastingModels value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForecastingModels other && Equals(other);
        public bool Equals(ForecastingModels other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric for forecasting task.
    /// </summary>
    [EnumType]
    public readonly struct ForecastingPrimaryMetrics : IEquatable<ForecastingPrimaryMetrics>
    {
        private readonly string _value;

        private ForecastingPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Spearman's rank coefficient of correlation is a non-parametric measure of rank correlation.
        /// </summary>
        public static ForecastingPrimaryMetrics SpearmanCorrelation { get; } = new ForecastingPrimaryMetrics("SpearmanCorrelation");
        /// <summary>
        /// The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales.
        /// </summary>
        public static ForecastingPrimaryMetrics NormalizedRootMeanSquaredError { get; } = new ForecastingPrimaryMetrics("NormalizedRootMeanSquaredError");
        /// <summary>
        /// The R2 score is one of the performance evaluation measures for forecasting-based machine learning models.
        /// </summary>
        public static ForecastingPrimaryMetrics R2Score { get; } = new ForecastingPrimaryMetrics("R2Score");
        /// <summary>
        /// The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales.
        /// </summary>
        public static ForecastingPrimaryMetrics NormalizedMeanAbsoluteError { get; } = new ForecastingPrimaryMetrics("NormalizedMeanAbsoluteError");

        public static bool operator ==(ForecastingPrimaryMetrics left, ForecastingPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(ForecastingPrimaryMetrics left, ForecastingPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(ForecastingPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForecastingPrimaryMetrics other && Equals(other);
        public bool Equals(ForecastingPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Defines supported metric goals for hyperparameter tuning
    /// </summary>
    [EnumType]
    public readonly struct Goal : IEquatable<Goal>
    {
        private readonly string _value;

        private Goal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Goal Minimize { get; } = new Goal("Minimize");
        public static Goal Maximize { get; } = new Goal("Maximize");

        public static bool operator ==(Goal left, Goal right) => left.Equals(right);
        public static bool operator !=(Goal left, Goal right) => !left.Equals(right);

        public static explicit operator string(Goal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Goal other && Equals(other);
        public bool Equals(Goal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of identity framework.
    /// </summary>
    [EnumType]
    public readonly struct IdentityConfigurationType : IEquatable<IdentityConfigurationType>
    {
        private readonly string _value;

        private IdentityConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityConfigurationType Managed { get; } = new IdentityConfigurationType("Managed");
        public static IdentityConfigurationType AMLToken { get; } = new IdentityConfigurationType("AMLToken");
        public static IdentityConfigurationType UserIdentity { get; } = new IdentityConfigurationType("UserIdentity");

        public static bool operator ==(IdentityConfigurationType left, IdentityConfigurationType right) => left.Equals(right);
        public static bool operator !=(IdentityConfigurationType left, IdentityConfigurationType right) => !left.Equals(right);

        public static explicit operator string(IdentityConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityConfigurationType other && Equals(other);
        public bool Equals(IdentityConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the image. Possible values are: docker - For docker images. azureml - For AzureML Environment images (custom and curated)
    /// </summary>
    [EnumType]
    public readonly struct ImageType : IEquatable<ImageType>
    {
        private readonly string _value;

        private ImageType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageType Docker { get; } = new ImageType("docker");
        public static ImageType Azureml { get; } = new ImageType("azureml");

        public static bool operator ==(ImageType left, ImageType right) => left.Equals(right);
        public static bool operator !=(ImageType left, ImageType right) => !left.Equals(right);

        public static explicit operator string(ImageType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageType other && Equals(other);
        public bool Equals(ImageType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Input Asset Delivery Mode.
    /// </summary>
    [EnumType]
    public readonly struct InputDeliveryMode : IEquatable<InputDeliveryMode>
    {
        private readonly string _value;

        private InputDeliveryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InputDeliveryMode ReadOnlyMount { get; } = new InputDeliveryMode("ReadOnlyMount");
        public static InputDeliveryMode ReadWriteMount { get; } = new InputDeliveryMode("ReadWriteMount");
        public static InputDeliveryMode Download { get; } = new InputDeliveryMode("Download");
        public static InputDeliveryMode Direct { get; } = new InputDeliveryMode("Direct");
        public static InputDeliveryMode EvalMount { get; } = new InputDeliveryMode("EvalMount");
        public static InputDeliveryMode EvalDownload { get; } = new InputDeliveryMode("EvalDownload");

        public static bool operator ==(InputDeliveryMode left, InputDeliveryMode right) => left.Equals(right);
        public static bool operator !=(InputDeliveryMode left, InputDeliveryMode right) => !left.Equals(right);

        public static explicit operator string(InputDeliveryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InputDeliveryMode other && Equals(other);
        public bool Equals(InputDeliveryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric to optimize for this task.
    /// </summary>
    [EnumType]
    public readonly struct InstanceSegmentationPrimaryMetrics : IEquatable<InstanceSegmentationPrimaryMetrics>
    {
        private readonly string _value;

        private InstanceSegmentationPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mean Average Precision (MAP) is the average of AP (Average Precision).
        /// AP is calculated for each class and averaged to get the MAP.
        /// </summary>
        public static InstanceSegmentationPrimaryMetrics MeanAveragePrecision { get; } = new InstanceSegmentationPrimaryMetrics("MeanAveragePrecision");

        public static bool operator ==(InstanceSegmentationPrimaryMetrics left, InstanceSegmentationPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(InstanceSegmentationPrimaryMetrics left, InstanceSegmentationPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(InstanceSegmentationPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceSegmentationPrimaryMetrics other && Equals(other);
        public bool Equals(InstanceSegmentationPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Isolation mode for the managed network of a machine learning workspace.
    /// </summary>
    [EnumType]
    public readonly struct IsolationMode : IEquatable<IsolationMode>
    {
        private readonly string _value;

        private IsolationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IsolationMode Disabled { get; } = new IsolationMode("Disabled");
        public static IsolationMode AllowInternetOutbound { get; } = new IsolationMode("AllowInternetOutbound");
        public static IsolationMode AllowOnlyApprovedOutbound { get; } = new IsolationMode("AllowOnlyApprovedOutbound");

        public static bool operator ==(IsolationMode left, IsolationMode right) => left.Equals(right);
        public static bool operator !=(IsolationMode left, IsolationMode right) => !left.Equals(right);

        public static explicit operator string(IsolationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IsolationMode other && Equals(other);
        public bool Equals(IsolationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobInputType : IEquatable<JobInputType>
    {
        private readonly string _value;

        private JobInputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobInputType Literal { get; } = new JobInputType("literal");
        public static JobInputType Uri_file { get; } = new JobInputType("uri_file");
        public static JobInputType Uri_folder { get; } = new JobInputType("uri_folder");
        public static JobInputType Mltable { get; } = new JobInputType("mltable");
        public static JobInputType Custom_model { get; } = new JobInputType("custom_model");
        public static JobInputType Mlflow_model { get; } = new JobInputType("mlflow_model");
        public static JobInputType Triton_model { get; } = new JobInputType("triton_model");

        public static bool operator ==(JobInputType left, JobInputType right) => left.Equals(right);
        public static bool operator !=(JobInputType left, JobInputType right) => !left.Equals(right);

        public static explicit operator string(JobInputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobInputType other && Equals(other);
        public bool Equals(JobInputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] JobLimit type.
    /// </summary>
    [EnumType]
    public readonly struct JobLimitsType : IEquatable<JobLimitsType>
    {
        private readonly string _value;

        private JobLimitsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobLimitsType Command { get; } = new JobLimitsType("Command");
        public static JobLimitsType Sweep { get; } = new JobLimitsType("Sweep");

        public static bool operator ==(JobLimitsType left, JobLimitsType right) => left.Equals(right);
        public static bool operator !=(JobLimitsType left, JobLimitsType right) => !left.Equals(right);

        public static explicit operator string(JobLimitsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobLimitsType other && Equals(other);
        public bool Equals(JobLimitsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobOutputType : IEquatable<JobOutputType>
    {
        private readonly string _value;

        private JobOutputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobOutputType Uri_file { get; } = new JobOutputType("uri_file");
        public static JobOutputType Uri_folder { get; } = new JobOutputType("uri_folder");
        public static JobOutputType Mltable { get; } = new JobOutputType("mltable");
        public static JobOutputType Custom_model { get; } = new JobOutputType("custom_model");
        public static JobOutputType Mlflow_model { get; } = new JobOutputType("mlflow_model");
        public static JobOutputType Triton_model { get; } = new JobOutputType("triton_model");

        public static bool operator ==(JobOutputType left, JobOutputType right) => left.Equals(right);
        public static bool operator !=(JobOutputType left, JobOutputType right) => !left.Equals(right);

        public static explicit operator string(JobOutputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobOutputType other && Equals(other);
        public bool Equals(JobOutputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Controls the compute job tier
    /// </summary>
    [EnumType]
    public readonly struct JobTier : IEquatable<JobTier>
    {
        private readonly string _value;

        private JobTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobTier Null { get; } = new JobTier("Null");
        public static JobTier Spot { get; } = new JobTier("Spot");
        public static JobTier Basic { get; } = new JobTier("Basic");
        public static JobTier Standard { get; } = new JobTier("Standard");
        public static JobTier Premium { get; } = new JobTier("Premium");

        public static bool operator ==(JobTier left, JobTier right) => left.Equals(right);
        public static bool operator !=(JobTier left, JobTier right) => !left.Equals(right);

        public static explicit operator string(JobTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobTier other && Equals(other);
        public bool Equals(JobTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        private JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobType AutoML { get; } = new JobType("AutoML");
        public static JobType Command { get; } = new JobType("Command");
        public static JobType Sweep { get; } = new JobType("Sweep");
        public static JobType Pipeline { get; } = new JobType("Pipeline");
        public static JobType Spark { get; } = new JobType("Spark");
        public static JobType FineTuning { get; } = new JobType("FineTuning");

        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);

        public static explicit operator string(JobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobType other && Equals(other);
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
    /// </summary>
    [EnumType]
    public readonly struct LearningRateScheduler : IEquatable<LearningRateScheduler>
    {
        private readonly string _value;

        private LearningRateScheduler(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No learning rate scheduler selected.
        /// </summary>
        public static LearningRateScheduler None { get; } = new LearningRateScheduler("None");
        /// <summary>
        /// Cosine Annealing With Warmup.
        /// </summary>
        public static LearningRateScheduler WarmupCosine { get; } = new LearningRateScheduler("WarmupCosine");
        /// <summary>
        /// Step learning rate scheduler.
        /// </summary>
        public static LearningRateScheduler Step { get; } = new LearningRateScheduler("Step");

        public static bool operator ==(LearningRateScheduler left, LearningRateScheduler right) => left.Equals(right);
        public static bool operator !=(LearningRateScheduler left, LearningRateScheduler right) => !left.Equals(right);

        public static explicit operator string(LearningRateScheduler value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LearningRateScheduler other && Equals(other);
        public bool Equals(LearningRateScheduler other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Load Balancer Type
    /// </summary>
    [EnumType]
    public readonly struct LoadBalancerType : IEquatable<LoadBalancerType>
    {
        private readonly string _value;

        private LoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoadBalancerType PublicIp { get; } = new LoadBalancerType("PublicIp");
        public static LoadBalancerType InternalLoadBalancer { get; } = new LoadBalancerType("InternalLoadBalancer");

        public static bool operator ==(LoadBalancerType left, LoadBalancerType right) => left.Equals(right);
        public static bool operator !=(LoadBalancerType left, LoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(LoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoadBalancerType other && Equals(other);
        public bool Equals(LoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Log verbosity for the job.
    /// </summary>
    [EnumType]
    public readonly struct LogVerbosity : IEquatable<LogVerbosity>
    {
        private readonly string _value;

        private LogVerbosity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No logs emitted.
        /// </summary>
        public static LogVerbosity NotSet { get; } = new LogVerbosity("NotSet");
        /// <summary>
        /// Debug and above log statements logged.
        /// </summary>
        public static LogVerbosity Debug { get; } = new LogVerbosity("Debug");
        /// <summary>
        /// Info and above log statements logged.
        /// </summary>
        public static LogVerbosity Info { get; } = new LogVerbosity("Info");
        /// <summary>
        /// Warning and above log statements logged.
        /// </summary>
        public static LogVerbosity Warning { get; } = new LogVerbosity("Warning");
        /// <summary>
        /// Error and above log statements logged.
        /// </summary>
        public static LogVerbosity Error { get; } = new LogVerbosity("Error");
        /// <summary>
        /// Only critical statements logged.
        /// </summary>
        public static LogVerbosity Critical { get; } = new LogVerbosity("Critical");

        public static bool operator ==(LogVerbosity left, LogVerbosity right) => left.Equals(right);
        public static bool operator !=(LogVerbosity left, LogVerbosity right) => !left.Equals(right);

        public static explicit operator string(LogVerbosity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogVerbosity other && Equals(other);
        public bool Equals(LogVerbosity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Status for the managed network of a machine learning workspace.
    /// </summary>
    [EnumType]
    public readonly struct ManagedNetworkStatus : IEquatable<ManagedNetworkStatus>
    {
        private readonly string _value;

        private ManagedNetworkStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedNetworkStatus Inactive { get; } = new ManagedNetworkStatus("Inactive");
        public static ManagedNetworkStatus Active { get; } = new ManagedNetworkStatus("Active");

        public static bool operator ==(ManagedNetworkStatus left, ManagedNetworkStatus right) => left.Equals(right);
        public static bool operator !=(ManagedNetworkStatus left, ManagedNetworkStatus right) => !left.Equals(right);

        public static explicit operator string(ManagedNetworkStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedNetworkStatus other && Equals(other);
        public bool Equals(ManagedNetworkStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ManagedPERequirement : IEquatable<ManagedPERequirement>
    {
        private readonly string _value;

        private ManagedPERequirement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedPERequirement Required { get; } = new ManagedPERequirement("Required");
        public static ManagedPERequirement NotRequired { get; } = new ManagedPERequirement("NotRequired");
        public static ManagedPERequirement NotApplicable { get; } = new ManagedPERequirement("NotApplicable");

        public static bool operator ==(ManagedPERequirement left, ManagedPERequirement right) => left.Equals(right);
        public static bool operator !=(ManagedPERequirement left, ManagedPERequirement right) => !left.Equals(right);

        public static explicit operator string(ManagedPERequirement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedPERequirement other && Equals(other);
        public bool Equals(ManagedPERequirement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ManagedPEStatus : IEquatable<ManagedPEStatus>
    {
        private readonly string _value;

        private ManagedPEStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedPEStatus Inactive { get; } = new ManagedPEStatus("Inactive");
        public static ManagedPEStatus Active { get; } = new ManagedPEStatus("Active");
        public static ManagedPEStatus NotApplicable { get; } = new ManagedPEStatus("NotApplicable");

        public static bool operator ==(ManagedPEStatus left, ManagedPEStatus right) => left.Equals(right);
        public static bool operator !=(ManagedPEStatus left, ManagedPEStatus right) => !left.Equals(right);

        public static explicit operator string(ManagedPEStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedPEStatus other && Equals(other);
        public bool Equals(ManagedPEStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    /// </summary>
    [EnumType]
    public readonly struct ManagedServiceIdentityType : IEquatable<ManagedServiceIdentityType>
    {
        private readonly string _value;

        private ManagedServiceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ManagedServiceIdentityType None { get; } = new ManagedServiceIdentityType("None");
        public static ManagedServiceIdentityType SystemAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned");
        public static ManagedServiceIdentityType UserAssigned { get; } = new ManagedServiceIdentityType("UserAssigned");
        public static ManagedServiceIdentityType SystemAssigned_UserAssigned { get; } = new ManagedServiceIdentityType("SystemAssigned,UserAssigned");

        public static bool operator ==(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => left.Equals(right);
        public static bool operator !=(ManagedServiceIdentityType left, ManagedServiceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ManagedServiceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManagedServiceIdentityType other && Equals(other);
        public bool Equals(ManagedServiceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the stores to which materialization should happen
    /// </summary>
    [EnumType]
    public readonly struct MaterializationStoreType : IEquatable<MaterializationStoreType>
    {
        private readonly string _value;

        private MaterializationStoreType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MaterializationStoreType None { get; } = new MaterializationStoreType("None");
        public static MaterializationStoreType Online { get; } = new MaterializationStoreType("Online");
        public static MaterializationStoreType Offline { get; } = new MaterializationStoreType("Offline");
        public static MaterializationStoreType OnlineAndOffline { get; } = new MaterializationStoreType("OnlineAndOffline");

        public static bool operator ==(MaterializationStoreType left, MaterializationStoreType right) => left.Equals(right);
        public static bool operator !=(MaterializationStoreType left, MaterializationStoreType right) => !left.Equals(right);

        public static explicit operator string(MaterializationStoreType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaterializationStoreType other && Equals(other);
        public bool Equals(MaterializationStoreType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether mlflow autologger is enabled for notebooks.
    /// </summary>
    [EnumType]
    public readonly struct MlflowAutologger : IEquatable<MlflowAutologger>
    {
        private readonly string _value;

        private MlflowAutologger(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MlflowAutologger Enabled { get; } = new MlflowAutologger("Enabled");
        public static MlflowAutologger Disabled { get; } = new MlflowAutologger("Disabled");

        public static bool operator ==(MlflowAutologger left, MlflowAutologger right) => left.Equals(right);
        public static bool operator !=(MlflowAutologger left, MlflowAutologger right) => !left.Equals(right);

        public static explicit operator string(MlflowAutologger value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MlflowAutologger other && Equals(other);
        public bool Equals(MlflowAutologger other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Enum to determine the type of fine tuning.
    /// </summary>
    [EnumType]
    public readonly struct ModelProvider : IEquatable<ModelProvider>
    {
        private readonly string _value;

        private ModelProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Fine tuning using Azure Open AI model.
        /// </summary>
        public static ModelProvider AzureOpenAI { get; } = new ModelProvider("AzureOpenAI");
        /// <summary>
        /// Fine tuning using custom model.
        /// </summary>
        public static ModelProvider Custom { get; } = new ModelProvider("Custom");

        public static bool operator ==(ModelProvider left, ModelProvider right) => left.Equals(right);
        public static bool operator !=(ModelProvider left, ModelProvider right) => !left.Equals(right);

        public static explicit operator string(ModelProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModelProvider other && Equals(other);
        public bool Equals(ModelProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
    /// Note: training run may get into CUDA OOM if the model size is too big.
    /// Note: This settings is only supported for the 'yolov5' algorithm.
    /// </summary>
    [EnumType]
    public readonly struct ModelSize : IEquatable<ModelSize>
    {
        private readonly string _value;

        private ModelSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No value selected.
        /// </summary>
        public static ModelSize None { get; } = new ModelSize("None");
        /// <summary>
        /// Small size.
        /// </summary>
        public static ModelSize Small { get; } = new ModelSize("Small");
        /// <summary>
        /// Medium size.
        /// </summary>
        public static ModelSize Medium { get; } = new ModelSize("Medium");
        /// <summary>
        /// Large size.
        /// </summary>
        public static ModelSize Large { get; } = new ModelSize("Large");
        /// <summary>
        /// Extra large size.
        /// </summary>
        public static ModelSize ExtraLarge { get; } = new ModelSize("ExtraLarge");

        public static bool operator ==(ModelSize left, ModelSize right) => left.Equals(right);
        public static bool operator !=(ModelSize left, ModelSize right) => !left.Equals(right);

        public static explicit operator string(ModelSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModelSize other && Equals(other);
        public bool Equals(ModelSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The machine learning task type of the monitored model.
    /// </summary>
    [EnumType]
    public readonly struct ModelTaskType : IEquatable<ModelTaskType>
    {
        private readonly string _value;

        private ModelTaskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ModelTaskType Classification { get; } = new ModelTaskType("Classification");
        public static ModelTaskType Regression { get; } = new ModelTaskType("Regression");

        public static bool operator ==(ModelTaskType left, ModelTaskType right) => left.Equals(right);
        public static bool operator !=(ModelTaskType left, ModelTaskType right) => !left.Equals(right);

        public static explicit operator string(ModelTaskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModelTaskType other && Equals(other);
        public bool Equals(ModelTaskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of identity to use within the monitoring jobs.
    /// </summary>
    [EnumType]
    public readonly struct MonitorComputeIdentityType : IEquatable<MonitorComputeIdentityType>
    {
        private readonly string _value;

        private MonitorComputeIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Authenticates through user's AML token.
        /// </summary>
        public static MonitorComputeIdentityType AmlToken { get; } = new MonitorComputeIdentityType("AmlToken");
        /// <summary>
        /// Authenticates through a user-provided managed identity.
        /// </summary>
        public static MonitorComputeIdentityType ManagedIdentity { get; } = new MonitorComputeIdentityType("ManagedIdentity");

        public static bool operator ==(MonitorComputeIdentityType left, MonitorComputeIdentityType right) => left.Equals(right);
        public static bool operator !=(MonitorComputeIdentityType left, MonitorComputeIdentityType right) => !left.Equals(right);

        public static explicit operator string(MonitorComputeIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitorComputeIdentityType other && Equals(other);
        public bool Equals(MonitorComputeIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of signal to monitor.
    /// </summary>
    [EnumType]
    public readonly struct MonitorComputeType : IEquatable<MonitorComputeType>
    {
        private readonly string _value;

        private MonitorComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Serverless Spark compute.
        /// </summary>
        public static MonitorComputeType ServerlessSpark { get; } = new MonitorComputeType("ServerlessSpark");

        public static bool operator ==(MonitorComputeType left, MonitorComputeType right) => left.Equals(right);
        public static bool operator !=(MonitorComputeType left, MonitorComputeType right) => !left.Equals(right);

        public static explicit operator string(MonitorComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitorComputeType other && Equals(other);
        public bool Equals(MonitorComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the data type of the metric threshold.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringFeatureDataType : IEquatable<MonitoringFeatureDataType>
    {
        private readonly string _value;

        private MonitoringFeatureDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Used for features of numerical data type.
        /// </summary>
        public static MonitoringFeatureDataType Numerical { get; } = new MonitoringFeatureDataType("Numerical");
        /// <summary>
        /// Used for features of categorical data type.
        /// </summary>
        public static MonitoringFeatureDataType Categorical { get; } = new MonitoringFeatureDataType("Categorical");

        public static bool operator ==(MonitoringFeatureDataType left, MonitoringFeatureDataType right) => left.Equals(right);
        public static bool operator !=(MonitoringFeatureDataType left, MonitoringFeatureDataType right) => !left.Equals(right);

        public static explicit operator string(MonitoringFeatureDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringFeatureDataType other && Equals(other);
        public bool Equals(MonitoringFeatureDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the feature filter to leverage when selecting features to calculate metrics over.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringFeatureFilterType : IEquatable<MonitoringFeatureFilterType>
    {
        private readonly string _value;

        private MonitoringFeatureFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Includes all features.
        /// </summary>
        public static MonitoringFeatureFilterType AllFeatures { get; } = new MonitoringFeatureFilterType("AllFeatures");
        /// <summary>
        /// Only includes the top contributing features, measured by feature attribution.
        /// </summary>
        public static MonitoringFeatureFilterType TopNByAttribution { get; } = new MonitoringFeatureFilterType("TopNByAttribution");
        /// <summary>
        /// Includes a user-defined subset of features.
        /// </summary>
        public static MonitoringFeatureFilterType FeatureSubset { get; } = new MonitoringFeatureFilterType("FeatureSubset");

        public static bool operator ==(MonitoringFeatureFilterType left, MonitoringFeatureFilterType right) => left.Equals(right);
        public static bool operator !=(MonitoringFeatureFilterType left, MonitoringFeatureFilterType right) => !left.Equals(right);

        public static explicit operator string(MonitoringFeatureFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringFeatureFilterType other && Equals(other);
        public bool Equals(MonitoringFeatureFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of signal to monitor.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringInputDataType : IEquatable<MonitoringInputDataType>
    {
        private readonly string _value;

        private MonitoringInputDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An input data with a fixed window size.
        /// </summary>
        public static MonitoringInputDataType Static { get; } = new MonitoringInputDataType("Static");
        /// <summary>
        /// An input data which rolls relatively to the monitor's current run time.
        /// </summary>
        public static MonitoringInputDataType Rolling { get; } = new MonitoringInputDataType("Rolling");
        /// <summary>
        /// An input data with tabular format which doesn't require preprocessing.
        /// </summary>
        public static MonitoringInputDataType Fixed { get; } = new MonitoringInputDataType("Fixed");

        public static bool operator ==(MonitoringInputDataType left, MonitoringInputDataType right) => left.Equals(right);
        public static bool operator !=(MonitoringInputDataType left, MonitoringInputDataType right) => !left.Equals(right);

        public static explicit operator string(MonitoringInputDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringInputDataType other && Equals(other);
        public bool Equals(MonitoringInputDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MonitoringNotificationType : IEquatable<MonitoringNotificationType>
    {
        private readonly string _value;

        private MonitoringNotificationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Enables email notifications through AML notifications.
        /// </summary>
        public static MonitoringNotificationType AmlNotification { get; } = new MonitoringNotificationType("AmlNotification");

        public static bool operator ==(MonitoringNotificationType left, MonitoringNotificationType right) => left.Equals(right);
        public static bool operator !=(MonitoringNotificationType left, MonitoringNotificationType right) => !left.Equals(right);

        public static explicit operator string(MonitoringNotificationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringNotificationType other && Equals(other);
        public bool Equals(MonitoringNotificationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of signal to monitor.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringSignalType : IEquatable<MonitoringSignalType>
    {
        private readonly string _value;

        private MonitoringSignalType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Tracks model input data distribution change, comparing against training data or past production data.
        /// </summary>
        public static MonitoringSignalType DataDrift { get; } = new MonitoringSignalType("DataDrift");
        /// <summary>
        /// Tracks prediction result data distribution change, comparing against validation/test label data or past production data.
        /// </summary>
        public static MonitoringSignalType PredictionDrift { get; } = new MonitoringSignalType("PredictionDrift");
        /// <summary>
        /// Tracks model input data integrity.
        /// </summary>
        public static MonitoringSignalType DataQuality { get; } = new MonitoringSignalType("DataQuality");
        /// <summary>
        /// Tracks feature importance change in production, comparing against feature importance at training time.
        /// </summary>
        public static MonitoringSignalType FeatureAttributionDrift { get; } = new MonitoringSignalType("FeatureAttributionDrift");
        /// <summary>
        /// Tracks a custom signal provided by users.
        /// </summary>
        public static MonitoringSignalType Custom { get; } = new MonitoringSignalType("Custom");

        public static bool operator ==(MonitoringSignalType left, MonitoringSignalType right) => left.Equals(right);
        public static bool operator !=(MonitoringSignalType left, MonitoringSignalType right) => !left.Equals(right);

        public static explicit operator string(MonitoringSignalType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringSignalType other && Equals(other);
        public bool Equals(MonitoringSignalType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Mode for determining N-Cross validations.
    /// </summary>
    [EnumType]
    public readonly struct NCrossValidationsMode : IEquatable<NCrossValidationsMode>
    {
        private readonly string _value;

        private NCrossValidationsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Determine N-Cross validations value automatically. Supported only for 'Forecasting' AutoML task.
        /// </summary>
        public static NCrossValidationsMode Auto { get; } = new NCrossValidationsMode("Auto");
        /// <summary>
        /// Use custom N-Cross validations value.
        /// </summary>
        public static NCrossValidationsMode Custom { get; } = new NCrossValidationsMode("Custom");

        public static bool operator ==(NCrossValidationsMode left, NCrossValidationsMode right) => left.Equals(right);
        public static bool operator !=(NCrossValidationsMode left, NCrossValidationsMode right) => !left.Equals(right);

        public static explicit operator string(NCrossValidationsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NCrossValidationsMode other && Equals(other);
        public bool Equals(NCrossValidationsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of the Nodes value
    /// </summary>
    [EnumType]
    public readonly struct NodesValueType : IEquatable<NodesValueType>
    {
        private readonly string _value;

        private NodesValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodesValueType All { get; } = new NodesValueType("All");

        public static bool operator ==(NodesValueType left, NodesValueType right) => left.Equals(right);
        public static bool operator !=(NodesValueType left, NodesValueType right) => !left.Equals(right);

        public static explicit operator string(NodesValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodesValueType other && Equals(other);
        public bool Equals(NodesValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The numerical data drift metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct NumericalDataDriftMetric : IEquatable<NumericalDataDriftMetric>
    {
        private readonly string _value;

        private NumericalDataDriftMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Jensen Shannon Distance (JSD) metric.
        /// </summary>
        public static NumericalDataDriftMetric JensenShannonDistance { get; } = new NumericalDataDriftMetric("JensenShannonDistance");
        /// <summary>
        /// The Population Stability Index (PSI) metric.
        /// </summary>
        public static NumericalDataDriftMetric PopulationStabilityIndex { get; } = new NumericalDataDriftMetric("PopulationStabilityIndex");
        /// <summary>
        /// The Normalized Wasserstein Distance metric.
        /// </summary>
        public static NumericalDataDriftMetric NormalizedWassersteinDistance { get; } = new NumericalDataDriftMetric("NormalizedWassersteinDistance");
        /// <summary>
        /// The Two Sample Kolmogorov-Smirnov Test (two-sample Kâ€“S) metric.
        /// </summary>
        public static NumericalDataDriftMetric TwoSampleKolmogorovSmirnovTest { get; } = new NumericalDataDriftMetric("TwoSampleKolmogorovSmirnovTest");

        public static bool operator ==(NumericalDataDriftMetric left, NumericalDataDriftMetric right) => left.Equals(right);
        public static bool operator !=(NumericalDataDriftMetric left, NumericalDataDriftMetric right) => !left.Equals(right);

        public static explicit operator string(NumericalDataDriftMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NumericalDataDriftMetric other && Equals(other);
        public bool Equals(NumericalDataDriftMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The numerical data quality metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct NumericalDataQualityMetric : IEquatable<NumericalDataQualityMetric>
    {
        private readonly string _value;

        private NumericalDataQualityMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Calculates the rate of null values.
        /// </summary>
        public static NumericalDataQualityMetric NullValueRate { get; } = new NumericalDataQualityMetric("NullValueRate");
        /// <summary>
        /// Calculates the rate of data type errors.
        /// </summary>
        public static NumericalDataQualityMetric DataTypeErrorRate { get; } = new NumericalDataQualityMetric("DataTypeErrorRate");
        /// <summary>
        /// Calculates the rate values are out of bounds.
        /// </summary>
        public static NumericalDataQualityMetric OutOfBoundsRate { get; } = new NumericalDataQualityMetric("OutOfBoundsRate");

        public static bool operator ==(NumericalDataQualityMetric left, NumericalDataQualityMetric right) => left.Equals(right);
        public static bool operator !=(NumericalDataQualityMetric left, NumericalDataQualityMetric right) => !left.Equals(right);

        public static explicit operator string(NumericalDataQualityMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NumericalDataQualityMetric other && Equals(other);
        public bool Equals(NumericalDataQualityMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The numerical prediction drift metric to calculate.
    /// </summary>
    [EnumType]
    public readonly struct NumericalPredictionDriftMetric : IEquatable<NumericalPredictionDriftMetric>
    {
        private readonly string _value;

        private NumericalPredictionDriftMetric(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Jensen Shannon Distance (JSD) metric.
        /// </summary>
        public static NumericalPredictionDriftMetric JensenShannonDistance { get; } = new NumericalPredictionDriftMetric("JensenShannonDistance");
        /// <summary>
        /// The Population Stability Index (PSI) metric.
        /// </summary>
        public static NumericalPredictionDriftMetric PopulationStabilityIndex { get; } = new NumericalPredictionDriftMetric("PopulationStabilityIndex");
        /// <summary>
        /// The Normalized Wasserstein Distance metric.
        /// </summary>
        public static NumericalPredictionDriftMetric NormalizedWassersteinDistance { get; } = new NumericalPredictionDriftMetric("NormalizedWassersteinDistance");
        /// <summary>
        /// The Two Sample Kolmogorov-Smirnov Test (two-sample Kâ€“S) metric.
        /// </summary>
        public static NumericalPredictionDriftMetric TwoSampleKolmogorovSmirnovTest { get; } = new NumericalPredictionDriftMetric("TwoSampleKolmogorovSmirnovTest");

        public static bool operator ==(NumericalPredictionDriftMetric left, NumericalPredictionDriftMetric right) => left.Equals(right);
        public static bool operator !=(NumericalPredictionDriftMetric left, NumericalPredictionDriftMetric right) => !left.Equals(right);

        public static explicit operator string(NumericalPredictionDriftMetric value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NumericalPredictionDriftMetric other && Equals(other);
        public bool Equals(NumericalPredictionDriftMetric other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric to optimize for this task.
    /// </summary>
    [EnumType]
    public readonly struct ObjectDetectionPrimaryMetrics : IEquatable<ObjectDetectionPrimaryMetrics>
    {
        private readonly string _value;

        private ObjectDetectionPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mean Average Precision (MAP) is the average of AP (Average Precision).
        /// AP is calculated for each class and averaged to get the MAP.
        /// </summary>
        public static ObjectDetectionPrimaryMetrics MeanAveragePrecision { get; } = new ObjectDetectionPrimaryMetrics("MeanAveragePrecision");

        public static bool operator ==(ObjectDetectionPrimaryMetrics left, ObjectDetectionPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(ObjectDetectionPrimaryMetrics left, ObjectDetectionPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(ObjectDetectionPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ObjectDetectionPrimaryMetrics other && Equals(other);
        public bool Equals(ObjectDetectionPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] OneLake artifact type
    /// </summary>
    [EnumType]
    public readonly struct OneLakeArtifactType : IEquatable<OneLakeArtifactType>
    {
        private readonly string _value;

        private OneLakeArtifactType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OneLakeArtifactType LakeHouse { get; } = new OneLakeArtifactType("LakeHouse");

        public static bool operator ==(OneLakeArtifactType left, OneLakeArtifactType right) => left.Equals(right);
        public static bool operator !=(OneLakeArtifactType left, OneLakeArtifactType right) => !left.Equals(right);

        public static explicit operator string(OneLakeArtifactType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OneLakeArtifactType other && Equals(other);
        public bool Equals(OneLakeArtifactType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS type of the environment.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemType : IEquatable<OperatingSystemType>
    {
        private readonly string _value;

        private OperatingSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemType Linux { get; } = new OperatingSystemType("Linux");
        public static OperatingSystemType Windows { get; } = new OperatingSystemType("Windows");

        public static bool operator ==(OperatingSystemType left, OperatingSystemType right) => left.Equals(right);
        public static bool operator !=(OperatingSystemType left, OperatingSystemType right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemType other && Equals(other);
        public bool Equals(OperatingSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compute OS Type
    /// </summary>
    [EnumType]
    public readonly struct OsType : IEquatable<OsType>
    {
        private readonly string _value;

        private OsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsType Linux { get; } = new OsType("Linux");
        public static OsType Windows { get; } = new OsType("Windows");

        public static bool operator ==(OsType left, OsType right) => left.Equals(right);
        public static bool operator !=(OsType left, OsType right) => !left.Equals(right);

        public static explicit operator string(OsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsType other && Equals(other);
        public bool Equals(OsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output Asset Delivery Mode.
    /// </summary>
    [EnumType]
    public readonly struct OutputDeliveryMode : IEquatable<OutputDeliveryMode>
    {
        private readonly string _value;

        private OutputDeliveryMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OutputDeliveryMode ReadWriteMount { get; } = new OutputDeliveryMode("ReadWriteMount");
        public static OutputDeliveryMode Upload { get; } = new OutputDeliveryMode("Upload");
        public static OutputDeliveryMode Direct { get; } = new OutputDeliveryMode("Direct");

        public static bool operator ==(OutputDeliveryMode left, OutputDeliveryMode right) => left.Equals(right);
        public static bool operator !=(OutputDeliveryMode left, OutputDeliveryMode right) => !left.Equals(right);

        public static explicit operator string(OutputDeliveryMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OutputDeliveryMode other && Equals(other);
        public bool Equals(OutputDeliveryMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current provisioning state.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointConnectionProvisioningState : IEquatable<PrivateEndpointConnectionProvisioningState>
    {
        private readonly string _value;

        private PrivateEndpointConnectionProvisioningState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointConnectionProvisioningState Succeeded { get; } = new PrivateEndpointConnectionProvisioningState("Succeeded");
        public static PrivateEndpointConnectionProvisioningState Creating { get; } = new PrivateEndpointConnectionProvisioningState("Creating");
        public static PrivateEndpointConnectionProvisioningState Deleting { get; } = new PrivateEndpointConnectionProvisioningState("Deleting");
        public static PrivateEndpointConnectionProvisioningState Failed { get; } = new PrivateEndpointConnectionProvisioningState("Failed");

        public static bool operator ==(PrivateEndpointConnectionProvisioningState left, PrivateEndpointConnectionProvisioningState right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointConnectionProvisioningState left, PrivateEndpointConnectionProvisioningState right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointConnectionProvisioningState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointConnectionProvisioningState other && Equals(other);
        public bool Equals(PrivateEndpointConnectionProvisioningState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Protocol over which communication will happen over this endpoint
    /// </summary>
    [EnumType]
    public readonly struct Protocol : IEquatable<Protocol>
    {
        private readonly string _value;

        private Protocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Protocol Tcp { get; } = new Protocol("tcp");
        public static Protocol Udp { get; } = new Protocol("udp");
        public static Protocol Http { get; } = new Protocol("http");

        public static bool operator ==(Protocol left, Protocol right) => left.Equals(right);
        public static bool operator !=(Protocol left, Protocol right) => !left.Equals(right);

        public static explicit operator string(Protocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Protocol other && Equals(other);
        public bool Equals(Protocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether requests from Public Network are allowed.
    /// </summary>
    [EnumType]
    public readonly struct PublicNetworkAccessType : IEquatable<PublicNetworkAccessType>
    {
        private readonly string _value;

        private PublicNetworkAccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicNetworkAccessType Enabled { get; } = new PublicNetworkAccessType("Enabled");
        public static PublicNetworkAccessType Disabled { get; } = new PublicNetworkAccessType("Disabled");

        public static bool operator ==(PublicNetworkAccessType left, PublicNetworkAccessType right) => left.Equals(right);
        public static bool operator !=(PublicNetworkAccessType left, PublicNetworkAccessType right) => !left.Equals(right);

        public static explicit operator string(PublicNetworkAccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicNetworkAccessType other && Equals(other);
        public bool Equals(PublicNetworkAccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Content source to apply the Content Filters.
    /// </summary>
    [EnumType]
    public readonly struct RaiPolicyContentSource : IEquatable<RaiPolicyContentSource>
    {
        private readonly string _value;

        private RaiPolicyContentSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RaiPolicyContentSource Prompt { get; } = new RaiPolicyContentSource("Prompt");
        public static RaiPolicyContentSource Completion { get; } = new RaiPolicyContentSource("Completion");

        public static bool operator ==(RaiPolicyContentSource left, RaiPolicyContentSource right) => left.Equals(right);
        public static bool operator !=(RaiPolicyContentSource left, RaiPolicyContentSource right) => !left.Equals(right);

        public static explicit operator string(RaiPolicyContentSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RaiPolicyContentSource other && Equals(other);
        public bool Equals(RaiPolicyContentSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Content Filters mode.
    /// </summary>
    [EnumType]
    public readonly struct RaiPolicyMode : IEquatable<RaiPolicyMode>
    {
        private readonly string _value;

        private RaiPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RaiPolicyMode Default { get; } = new RaiPolicyMode("Default");
        public static RaiPolicyMode Deferred { get; } = new RaiPolicyMode("Deferred");
        public static RaiPolicyMode Blocking { get; } = new RaiPolicyMode("Blocking");

        public static bool operator ==(RaiPolicyMode left, RaiPolicyMode right) => left.Equals(right);
        public static bool operator !=(RaiPolicyMode left, RaiPolicyMode right) => !left.Equals(right);

        public static explicit operator string(RaiPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RaiPolicyMode other && Equals(other);
        public bool Equals(RaiPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Content Filters policy type.
    /// </summary>
    [EnumType]
    public readonly struct RaiPolicyType : IEquatable<RaiPolicyType>
    {
        private readonly string _value;

        private RaiPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RaiPolicyType UserManaged { get; } = new RaiPolicyType("UserManaged");
        public static RaiPolicyType SystemManaged { get; } = new RaiPolicyType("SystemManaged");

        public static bool operator ==(RaiPolicyType left, RaiPolicyType right) => left.Equals(right);
        public static bool operator !=(RaiPolicyType left, RaiPolicyType right) => !left.Equals(right);

        public static explicit operator string(RaiPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RaiPolicyType other && Equals(other);
        public bool Equals(RaiPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specific type of random algorithm
    /// </summary>
    [EnumType]
    public readonly struct RandomSamplingAlgorithmRule : IEquatable<RandomSamplingAlgorithmRule>
    {
        private readonly string _value;

        private RandomSamplingAlgorithmRule(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RandomSamplingAlgorithmRule Random { get; } = new RandomSamplingAlgorithmRule("Random");
        public static RandomSamplingAlgorithmRule Sobol { get; } = new RandomSamplingAlgorithmRule("Sobol");

        public static bool operator ==(RandomSamplingAlgorithmRule left, RandomSamplingAlgorithmRule right) => left.Equals(right);
        public static bool operator !=(RandomSamplingAlgorithmRule left, RandomSamplingAlgorithmRule right) => !left.Equals(right);

        public static explicit operator string(RandomSamplingAlgorithmRule value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RandomSamplingAlgorithmRule other && Equals(other);
        public bool Equals(RandomSamplingAlgorithmRule other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The frequency to trigger schedule.
    /// </summary>
    [EnumType]
    public readonly struct RecurrenceFrequency : IEquatable<RecurrenceFrequency>
    {
        private readonly string _value;

        private RecurrenceFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Minute frequency
        /// </summary>
        public static RecurrenceFrequency Minute { get; } = new RecurrenceFrequency("Minute");
        /// <summary>
        /// Hour frequency
        /// </summary>
        public static RecurrenceFrequency Hour { get; } = new RecurrenceFrequency("Hour");
        /// <summary>
        /// Day frequency
        /// </summary>
        public static RecurrenceFrequency Day { get; } = new RecurrenceFrequency("Day");
        /// <summary>
        /// Week frequency
        /// </summary>
        public static RecurrenceFrequency Week { get; } = new RecurrenceFrequency("Week");
        /// <summary>
        /// Month frequency
        /// </summary>
        public static RecurrenceFrequency Month { get; } = new RecurrenceFrequency("Month");

        public static bool operator ==(RecurrenceFrequency left, RecurrenceFrequency right) => left.Equals(right);
        public static bool operator !=(RecurrenceFrequency left, RecurrenceFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurrenceFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurrenceFrequency other && Equals(other);
        public bool Equals(RecurrenceFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of asset reference.
    /// </summary>
    [EnumType]
    public readonly struct ReferenceType : IEquatable<ReferenceType>
    {
        private readonly string _value;

        private ReferenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReferenceType Id { get; } = new ReferenceType("Id");
        public static ReferenceType DataPath { get; } = new ReferenceType("DataPath");
        public static ReferenceType OutputPath { get; } = new ReferenceType("OutputPath");

        public static bool operator ==(ReferenceType left, ReferenceType right) => left.Equals(right);
        public static bool operator !=(ReferenceType left, ReferenceType right) => !left.Equals(right);

        public static explicit operator string(ReferenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReferenceType other && Equals(other);
        public bool Equals(ReferenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum for all Regression models supported by AutoML.
    /// </summary>
    [EnumType]
    public readonly struct RegressionModels : IEquatable<RegressionModels>
    {
        private readonly string _value;

        private RegressionModels(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions.
        /// </summary>
        public static RegressionModels ElasticNet { get; } = new RegressionModels("ElasticNet");
        /// <summary>
        /// The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
        /// </summary>
        public static RegressionModels GradientBoosting { get; } = new RegressionModels("GradientBoosting");
        /// <summary>
        /// Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
        /// The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
        /// </summary>
        public static RegressionModels DecisionTree { get; } = new RegressionModels("DecisionTree");
        /// <summary>
        /// K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
        /// which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
        /// </summary>
        public static RegressionModels KNN { get; } = new RegressionModels("KNN");
        /// <summary>
        /// Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer.
        /// </summary>
        public static RegressionModels LassoLars { get; } = new RegressionModels("LassoLars");
        /// <summary>
        /// SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
        /// to find the model parameters that correspond to the best fit between predicted and actual outputs.
        /// It's an inexact but powerful technique.
        /// </summary>
        public static RegressionModels SGD { get; } = new RegressionModels("SGD");
        /// <summary>
        /// Random forest is a supervised learning algorithm.
        /// The "forest" it builds, is an ensemble of decision trees, usually trained with the "bagging" method.
        /// The general idea of the bagging method is that a combination of learning models increases the overall result.
        /// </summary>
        public static RegressionModels RandomForest { get; } = new RegressionModels("RandomForest");
        /// <summary>
        /// Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
        /// </summary>
        public static RegressionModels ExtremeRandomTrees { get; } = new RegressionModels("ExtremeRandomTrees");
        /// <summary>
        /// LightGBM is a gradient boosting framework that uses tree based learning algorithms.
        /// </summary>
        public static RegressionModels LightGBM { get; } = new RegressionModels("LightGBM");
        /// <summary>
        /// XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners.
        /// </summary>
        public static RegressionModels XGBoostRegressor { get; } = new RegressionModels("XGBoostRegressor");

        public static bool operator ==(RegressionModels left, RegressionModels right) => left.Equals(right);
        public static bool operator !=(RegressionModels left, RegressionModels right) => !left.Equals(right);

        public static explicit operator string(RegressionModels value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegressionModels other && Equals(other);
        public bool Equals(RegressionModels other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Primary metric for regression task.
    /// </summary>
    [EnumType]
    public readonly struct RegressionPrimaryMetrics : IEquatable<RegressionPrimaryMetrics>
    {
        private readonly string _value;

        private RegressionPrimaryMetrics(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The Spearman's rank coefficient of correlation is a nonparametric measure of rank correlation.
        /// </summary>
        public static RegressionPrimaryMetrics SpearmanCorrelation { get; } = new RegressionPrimaryMetrics("SpearmanCorrelation");
        /// <summary>
        /// The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales.
        /// </summary>
        public static RegressionPrimaryMetrics NormalizedRootMeanSquaredError { get; } = new RegressionPrimaryMetrics("NormalizedRootMeanSquaredError");
        /// <summary>
        /// The R2 score is one of the performance evaluation measures for forecasting-based machine learning models.
        /// </summary>
        public static RegressionPrimaryMetrics R2Score { get; } = new RegressionPrimaryMetrics("R2Score");
        /// <summary>
        /// The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales.
        /// </summary>
        public static RegressionPrimaryMetrics NormalizedMeanAbsoluteError { get; } = new RegressionPrimaryMetrics("NormalizedMeanAbsoluteError");

        public static bool operator ==(RegressionPrimaryMetrics left, RegressionPrimaryMetrics right) => left.Equals(right);
        public static bool operator !=(RegressionPrimaryMetrics left, RegressionPrimaryMetrics right) => !left.Equals(right);

        public static explicit operator string(RegressionPrimaryMetrics value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegressionPrimaryMetrics other && Equals(other);
        public bool Equals(RegressionPrimaryMetrics other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct RemoteLoginPortPublicAccess : IEquatable<RemoteLoginPortPublicAccess>
    {
        private readonly string _value;

        private RemoteLoginPortPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteLoginPortPublicAccess Enabled { get; } = new RemoteLoginPortPublicAccess("Enabled");
        public static RemoteLoginPortPublicAccess Disabled { get; } = new RemoteLoginPortPublicAccess("Disabled");
        public static RemoteLoginPortPublicAccess NotSpecified { get; } = new RemoteLoginPortPublicAccess("NotSpecified");

        public static bool operator ==(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => left.Equals(right);
        public static bool operator !=(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => !left.Equals(right);

        public static explicit operator string(RemoteLoginPortPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteLoginPortPublicAccess other && Equals(other);
        public bool Equals(RemoteLoginPortPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
    /// If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
    /// If it's day, all data will be collected in blob path /yyyy/MM/dd/.
    /// The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
    /// </summary>
    [EnumType]
    public readonly struct RollingRateType : IEquatable<RollingRateType>
    {
        private readonly string _value;

        private RollingRateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RollingRateType Year { get; } = new RollingRateType("Year");
        public static RollingRateType Month { get; } = new RollingRateType("Month");
        public static RollingRateType Day { get; } = new RollingRateType("Day");
        public static RollingRateType Hour { get; } = new RollingRateType("Hour");
        public static RollingRateType Minute { get; } = new RollingRateType("Minute");

        public static bool operator ==(RollingRateType left, RollingRateType right) => left.Equals(right);
        public static bool operator !=(RollingRateType left, RollingRateType right) => !left.Equals(right);

        public static explicit operator string(RollingRateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RollingRateType other && Equals(other);
        public bool Equals(RollingRateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action enum for networking rule.
    /// </summary>
    [EnumType]
    public readonly struct RuleAction : IEquatable<RuleAction>
    {
        private readonly string _value;

        private RuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleAction Allow { get; } = new RuleAction("Allow");
        public static RuleAction Deny { get; } = new RuleAction("Deny");

        public static bool operator ==(RuleAction left, RuleAction right) => left.Equals(right);
        public static bool operator !=(RuleAction left, RuleAction right) => !left.Equals(right);

        public static explicit operator string(RuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleAction other && Equals(other);
        public bool Equals(RuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Category of a managed network Outbound Rule of a machine learning workspace.
    /// </summary>
    [EnumType]
    public readonly struct RuleCategory : IEquatable<RuleCategory>
    {
        private readonly string _value;

        private RuleCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleCategory Required { get; } = new RuleCategory("Required");
        public static RuleCategory Recommended { get; } = new RuleCategory("Recommended");
        public static RuleCategory UserDefined { get; } = new RuleCategory("UserDefined");
        public static RuleCategory Dependency { get; } = new RuleCategory("Dependency");

        public static bool operator ==(RuleCategory left, RuleCategory right) => left.Equals(right);
        public static bool operator !=(RuleCategory left, RuleCategory right) => !left.Equals(right);

        public static explicit operator string(RuleCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleCategory other && Equals(other);
        public bool Equals(RuleCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of a managed network Outbound Rule of a machine learning workspace.
    /// </summary>
    [EnumType]
    public readonly struct RuleStatus : IEquatable<RuleStatus>
    {
        private readonly string _value;

        private RuleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleStatus Inactive { get; } = new RuleStatus("Inactive");
        public static RuleStatus Active { get; } = new RuleStatus("Active");

        public static bool operator ==(RuleStatus left, RuleStatus right) => left.Equals(right);
        public static bool operator !=(RuleStatus left, RuleStatus right) => !left.Equals(right);

        public static explicit operator string(RuleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleStatus other && Equals(other);
        public bool Equals(RuleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of a managed network Outbound Rule of a machine learning workspace.
    /// </summary>
    [EnumType]
    public readonly struct RuleType : IEquatable<RuleType>
    {
        private readonly string _value;

        private RuleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleType FQDN { get; } = new RuleType("FQDN");
        public static RuleType PrivateEndpoint { get; } = new RuleType("PrivateEndpoint");
        public static RuleType ServiceTag { get; } = new RuleType("ServiceTag");

        public static bool operator ==(RuleType left, RuleType right) => left.Equals(right);
        public static bool operator !=(RuleType left, RuleType right) => !left.Equals(right);

        public static explicit operator string(RuleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleType other && Equals(other);
        public bool Equals(RuleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The algorithm used for generating hyperparameter values, along with configuration properties
    /// </summary>
    [EnumType]
    public readonly struct SamplingAlgorithmType : IEquatable<SamplingAlgorithmType>
    {
        private readonly string _value;

        private SamplingAlgorithmType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SamplingAlgorithmType Grid { get; } = new SamplingAlgorithmType("Grid");
        public static SamplingAlgorithmType Random { get; } = new SamplingAlgorithmType("Random");
        public static SamplingAlgorithmType Bayesian { get; } = new SamplingAlgorithmType("Bayesian");

        public static bool operator ==(SamplingAlgorithmType left, SamplingAlgorithmType right) => left.Equals(right);
        public static bool operator !=(SamplingAlgorithmType left, SamplingAlgorithmType right) => !left.Equals(right);

        public static explicit operator string(SamplingAlgorithmType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SamplingAlgorithmType other && Equals(other);
        public bool Equals(SamplingAlgorithmType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of deployment scaling algorithm
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType Default { get; } = new ScaleType("Default");
        public static ScaleType TargetUtilization { get; } = new ScaleType("TargetUtilization");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the action type of the schedule
    /// </summary>
    [EnumType]
    public readonly struct ScheduleActionType : IEquatable<ScheduleActionType>
    {
        private readonly string _value;

        private ScheduleActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScheduleActionType CreateJob { get; } = new ScheduleActionType("CreateJob");
        public static ScheduleActionType InvokeBatchEndpoint { get; } = new ScheduleActionType("InvokeBatchEndpoint");
        public static ScheduleActionType CreateMonitor { get; } = new ScheduleActionType("CreateMonitor");

        public static bool operator ==(ScheduleActionType left, ScheduleActionType right) => left.Equals(right);
        public static bool operator !=(ScheduleActionType left, ScheduleActionType right) => !left.Equals(right);

        public static explicit operator string(ScheduleActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduleActionType other && Equals(other);
        public bool Equals(ScheduleActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current deployment state of schedule.
    /// </summary>
    [EnumType]
    public readonly struct ScheduleProvisioningState : IEquatable<ScheduleProvisioningState>
    {
        private readonly string _value;

        private ScheduleProvisioningState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScheduleProvisioningState Completed { get; } = new ScheduleProvisioningState("Completed");
        public static ScheduleProvisioningState Provisioning { get; } = new ScheduleProvisioningState("Provisioning");
        public static ScheduleProvisioningState Failed { get; } = new ScheduleProvisioningState("Failed");

        public static bool operator ==(ScheduleProvisioningState left, ScheduleProvisioningState right) => left.Equals(right);
        public static bool operator !=(ScheduleProvisioningState left, ScheduleProvisioningState right) => !left.Equals(right);

        public static explicit operator string(ScheduleProvisioningState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduleProvisioningState other && Equals(other);
        public bool Equals(ScheduleProvisioningState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Is the schedule enabled or disabled?
    /// </summary>
    [EnumType]
    public readonly struct ScheduleStatus : IEquatable<ScheduleStatus>
    {
        private readonly string _value;

        private ScheduleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScheduleStatus Enabled { get; } = new ScheduleStatus("Enabled");
        public static ScheduleStatus Disabled { get; } = new ScheduleStatus("Disabled");

        public static bool operator ==(ScheduleStatus left, ScheduleStatus right) => left.Equals(right);
        public static bool operator !=(ScheduleStatus left, ScheduleStatus right) => !left.Equals(right);

        public static explicit operator string(ScheduleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScheduleStatus other && Equals(other);
        public bool Equals(ScheduleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Seasonality mode.
    /// </summary>
    [EnumType]
    public readonly struct SeasonalityMode : IEquatable<SeasonalityMode>
    {
        private readonly string _value;

        private SeasonalityMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Seasonality to be determined automatically.
        /// </summary>
        public static SeasonalityMode Auto { get; } = new SeasonalityMode("Auto");
        /// <summary>
        /// Use the custom seasonality value.
        /// </summary>
        public static SeasonalityMode Custom { get; } = new SeasonalityMode("Custom");

        public static bool operator ==(SeasonalityMode left, SeasonalityMode right) => left.Equals(right);
        public static bool operator !=(SeasonalityMode left, SeasonalityMode right) => !left.Equals(right);

        public static explicit operator string(SeasonalityMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SeasonalityMode other && Equals(other);
        public bool Equals(SeasonalityMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Credential type used to authentication with storage.
    /// </summary>
    [EnumType]
    public readonly struct SecretsType : IEquatable<SecretsType>
    {
        private readonly string _value;

        private SecretsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecretsType AccountKey { get; } = new SecretsType("AccountKey");
        public static SecretsType Certificate { get; } = new SecretsType("Certificate");
        public static SecretsType Sas { get; } = new SecretsType("Sas");
        public static SecretsType ServicePrincipal { get; } = new SecretsType("ServicePrincipal");

        public static bool operator ==(SecretsType left, SecretsType right) => left.Equals(right);
        public static bool operator !=(SecretsType left, SecretsType right) => !left.Equals(right);

        public static explicit operator string(SecretsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecretsType other && Equals(other);
        public bool Equals(SecretsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the authentication mode for the Serverless endpoint.
    /// </summary>
    [EnumType]
    public readonly struct ServerlessInferenceEndpointAuthMode : IEquatable<ServerlessInferenceEndpointAuthMode>
    {
        private readonly string _value;

        private ServerlessInferenceEndpointAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerlessInferenceEndpointAuthMode Key { get; } = new ServerlessInferenceEndpointAuthMode("Key");

        public static bool operator ==(ServerlessInferenceEndpointAuthMode left, ServerlessInferenceEndpointAuthMode right) => left.Equals(right);
        public static bool operator !=(ServerlessInferenceEndpointAuthMode left, ServerlessInferenceEndpointAuthMode right) => !left.Equals(right);

        public static explicit operator string(ServerlessInferenceEndpointAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerlessInferenceEndpointAuthMode other && Equals(other);
        public bool Equals(ServerlessInferenceEndpointAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates which identity to use to authenticate service data access to customer's storage.
    /// </summary>
    [EnumType]
    public readonly struct ServiceDataAccessAuthIdentity : IEquatable<ServiceDataAccessAuthIdentity>
    {
        private readonly string _value;

        private ServiceDataAccessAuthIdentity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use any identity for service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity None { get; } = new ServiceDataAccessAuthIdentity("None");
        /// <summary>
        /// Use the system assigned managed identity of the Workspace to authenticate service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity WorkspaceSystemAssignedIdentity { get; } = new ServiceDataAccessAuthIdentity("WorkspaceSystemAssignedIdentity");
        /// <summary>
        /// Use the user assigned managed identity of the Workspace to authenticate service data access.
        /// </summary>
        public static ServiceDataAccessAuthIdentity WorkspaceUserAssignedIdentity { get; } = new ServiceDataAccessAuthIdentity("WorkspaceUserAssignedIdentity");

        public static bool operator ==(ServiceDataAccessAuthIdentity left, ServiceDataAccessAuthIdentity right) => left.Equals(right);
        public static bool operator !=(ServiceDataAccessAuthIdentity left, ServiceDataAccessAuthIdentity right) => !left.Equals(right);

        public static explicit operator string(ServiceDataAccessAuthIdentity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDataAccessAuthIdentity other && Equals(other);
        public bool Equals(ServiceDataAccessAuthIdentity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parameter defining how if AutoML should handle short time series.
    /// </summary>
    [EnumType]
    public readonly struct ShortSeriesHandlingConfiguration : IEquatable<ShortSeriesHandlingConfiguration>
    {
        private readonly string _value;

        private ShortSeriesHandlingConfiguration(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represents no/null value.
        /// </summary>
        public static ShortSeriesHandlingConfiguration None { get; } = new ShortSeriesHandlingConfiguration("None");
        /// <summary>
        /// Short series will be padded if there are no long series, otherwise short series will be dropped.
        /// </summary>
        public static ShortSeriesHandlingConfiguration Auto { get; } = new ShortSeriesHandlingConfiguration("Auto");
        /// <summary>
        /// All the short series will be padded.
        /// </summary>
        public static ShortSeriesHandlingConfiguration Pad { get; } = new ShortSeriesHandlingConfiguration("Pad");
        /// <summary>
        /// All the short series will be dropped.
        /// </summary>
        public static ShortSeriesHandlingConfiguration Drop { get; } = new ShortSeriesHandlingConfiguration("Drop");

        public static bool operator ==(ShortSeriesHandlingConfiguration left, ShortSeriesHandlingConfiguration right) => left.Equals(right);
        public static bool operator !=(ShortSeriesHandlingConfiguration left, ShortSeriesHandlingConfiguration right) => !left.Equals(right);

        public static explicit operator string(ShortSeriesHandlingConfiguration value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ShortSeriesHandlingConfiguration other && Equals(other);
        public bool Equals(ShortSeriesHandlingConfiguration other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
    /// </summary>
    [EnumType]
    public readonly struct SkuTier : IEquatable<SkuTier>
    {
        private readonly string _value;

        private SkuTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SkuTier Free { get; } = new SkuTier("Free");
        public static SkuTier Basic { get; } = new SkuTier("Basic");
        public static SkuTier Standard { get; } = new SkuTier("Standard");
        public static SkuTier Premium { get; } = new SkuTier("Premium");

        public static bool operator ==(SkuTier left, SkuTier right) => left.Equals(right);
        public static bool operator !=(SkuTier left, SkuTier right) => !left.Equals(right);

        public static explicit operator string(SkuTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SkuTier other && Equals(other);
        public bool Equals(SkuTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of the job's entry point.
    /// </summary>
    [EnumType]
    public readonly struct SparkJobEntryType : IEquatable<SparkJobEntryType>
    {
        private readonly string _value;

        private SparkJobEntryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SparkJobEntryType SparkJobPythonEntry { get; } = new SparkJobEntryType("SparkJobPythonEntry");
        public static SparkJobEntryType SparkJobScalaEntry { get; } = new SparkJobEntryType("SparkJobScalaEntry");

        public static bool operator ==(SparkJobEntryType left, SparkJobEntryType right) => left.Equals(right);
        public static bool operator !=(SparkJobEntryType left, SparkJobEntryType right) => !left.Equals(right);

        public static explicit operator string(SparkJobEntryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SparkJobEntryType other && Equals(other);
        public bool Equals(SparkJobEntryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
    /// </summary>
    [EnumType]
    public readonly struct SshPublicAccess : IEquatable<SshPublicAccess>
    {
        private readonly string _value;

        private SshPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SshPublicAccess Enabled { get; } = new SshPublicAccess("Enabled");
        public static SshPublicAccess Disabled { get; } = new SshPublicAccess("Disabled");

        public static bool operator ==(SshPublicAccess left, SshPublicAccess right) => left.Equals(right);
        public static bool operator !=(SshPublicAccess left, SshPublicAccess right) => !left.Equals(right);

        public static explicit operator string(SshPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SshPublicAccess other && Equals(other);
        public bool Equals(SshPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable or disable ssl for scoring
    /// </summary>
    [EnumType]
    public readonly struct SslConfigStatus : IEquatable<SslConfigStatus>
    {
        private readonly string _value;

        private SslConfigStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslConfigStatus Disabled { get; } = new SslConfigStatus("Disabled");
        public static SslConfigStatus Enabled { get; } = new SslConfigStatus("Enabled");
        public static SslConfigStatus Auto { get; } = new SslConfigStatus("Auto");

        public static bool operator ==(SslConfigStatus left, SslConfigStatus right) => left.Equals(right);
        public static bool operator !=(SslConfigStatus left, SslConfigStatus right) => !left.Equals(right);

        public static explicit operator string(SslConfigStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslConfigStatus other && Equals(other);
        public bool Equals(SslConfigStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The meta-learner is a model trained on the output of the individual heterogeneous models.
    /// </summary>
    [EnumType]
    public readonly struct StackMetaLearnerType : IEquatable<StackMetaLearnerType>
    {
        private readonly string _value;

        private StackMetaLearnerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackMetaLearnerType None { get; } = new StackMetaLearnerType("None");
        /// <summary>
        /// Default meta-learners are LogisticRegression for classification tasks.
        /// </summary>
        public static StackMetaLearnerType LogisticRegression { get; } = new StackMetaLearnerType("LogisticRegression");
        /// <summary>
        /// Default meta-learners are LogisticRegression for classification task when CV is on.
        /// </summary>
        public static StackMetaLearnerType LogisticRegressionCV { get; } = new StackMetaLearnerType("LogisticRegressionCV");
        public static StackMetaLearnerType LightGBMClassifier { get; } = new StackMetaLearnerType("LightGBMClassifier");
        /// <summary>
        /// Default meta-learners are LogisticRegression for regression task.
        /// </summary>
        public static StackMetaLearnerType ElasticNet { get; } = new StackMetaLearnerType("ElasticNet");
        /// <summary>
        /// Default meta-learners are LogisticRegression for regression task when CV is on.
        /// </summary>
        public static StackMetaLearnerType ElasticNetCV { get; } = new StackMetaLearnerType("ElasticNetCV");
        public static StackMetaLearnerType LightGBMRegressor { get; } = new StackMetaLearnerType("LightGBMRegressor");
        public static StackMetaLearnerType LinearRegression { get; } = new StackMetaLearnerType("LinearRegression");

        public static bool operator ==(StackMetaLearnerType left, StackMetaLearnerType right) => left.Equals(right);
        public static bool operator !=(StackMetaLearnerType left, StackMetaLearnerType right) => !left.Equals(right);

        public static explicit operator string(StackMetaLearnerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackMetaLearnerType other && Equals(other);
        public bool Equals(StackMetaLearnerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of optimizer.
    /// </summary>
    [EnumType]
    public readonly struct StochasticOptimizer : IEquatable<StochasticOptimizer>
    {
        private readonly string _value;

        private StochasticOptimizer(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No optimizer selected.
        /// </summary>
        public static StochasticOptimizer None { get; } = new StochasticOptimizer("None");
        /// <summary>
        /// Stochastic Gradient Descent optimizer.
        /// </summary>
        public static StochasticOptimizer Sgd { get; } = new StochasticOptimizer("Sgd");
        /// <summary>
        /// Adam is algorithm the optimizes stochastic objective functions based on adaptive estimates of moments
        /// </summary>
        public static StochasticOptimizer Adam { get; } = new StochasticOptimizer("Adam");
        /// <summary>
        /// AdamW is a variant of the optimizer Adam that has an improved implementation of weight decay.
        /// </summary>
        public static StochasticOptimizer Adamw { get; } = new StochasticOptimizer("Adamw");

        public static bool operator ==(StochasticOptimizer left, StochasticOptimizer right) => left.Equals(right);
        public static bool operator !=(StochasticOptimizer left, StochasticOptimizer right) => !left.Equals(right);

        public static explicit operator string(StochasticOptimizer value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StochasticOptimizer other && Equals(other);
        public bool Equals(StochasticOptimizer other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The auth mode used for accessing the system datastores of the workspace.
    /// </summary>
    [EnumType]
    public readonly struct SystemDatastoresAuthMode : IEquatable<SystemDatastoresAuthMode>
    {
        private readonly string _value;

        private SystemDatastoresAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SystemDatastoresAuthMode AccessKey { get; } = new SystemDatastoresAuthMode("AccessKey");
        public static SystemDatastoresAuthMode Identity { get; } = new SystemDatastoresAuthMode("Identity");
        public static SystemDatastoresAuthMode UserDelegationSAS { get; } = new SystemDatastoresAuthMode("UserDelegationSAS");

        public static bool operator ==(SystemDatastoresAuthMode left, SystemDatastoresAuthMode right) => left.Equals(right);
        public static bool operator !=(SystemDatastoresAuthMode left, SystemDatastoresAuthMode right) => !left.Equals(right);

        public static explicit operator string(SystemDatastoresAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SystemDatastoresAuthMode other && Equals(other);
        public bool Equals(SystemDatastoresAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The function to be used to aggregate the time series target column to conform to a user specified frequency.
    /// If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
    /// </summary>
    [EnumType]
    public readonly struct TargetAggregationFunction : IEquatable<TargetAggregationFunction>
    {
        private readonly string _value;

        private TargetAggregationFunction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Represent no value set.
        /// </summary>
        public static TargetAggregationFunction None { get; } = new TargetAggregationFunction("None");
        public static TargetAggregationFunction Sum { get; } = new TargetAggregationFunction("Sum");
        public static TargetAggregationFunction Max { get; } = new TargetAggregationFunction("Max");
        public static TargetAggregationFunction Min { get; } = new TargetAggregationFunction("Min");
        public static TargetAggregationFunction Mean { get; } = new TargetAggregationFunction("Mean");

        public static bool operator ==(TargetAggregationFunction left, TargetAggregationFunction right) => left.Equals(right);
        public static bool operator !=(TargetAggregationFunction left, TargetAggregationFunction right) => !left.Equals(right);

        public static explicit operator string(TargetAggregationFunction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetAggregationFunction other && Equals(other);
        public bool Equals(TargetAggregationFunction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Set target lags mode - Auto/Custom
    /// </summary>
    [EnumType]
    public readonly struct TargetLagsMode : IEquatable<TargetLagsMode>
    {
        private readonly string _value;

        private TargetLagsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Target lags to be determined automatically.
        /// </summary>
        public static TargetLagsMode Auto { get; } = new TargetLagsMode("Auto");
        /// <summary>
        /// Use the custom target lags.
        /// </summary>
        public static TargetLagsMode Custom { get; } = new TargetLagsMode("Custom");

        public static bool operator ==(TargetLagsMode left, TargetLagsMode right) => left.Equals(right);
        public static bool operator !=(TargetLagsMode left, TargetLagsMode right) => !left.Equals(right);

        public static explicit operator string(TargetLagsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetLagsMode other && Equals(other);
        public bool Equals(TargetLagsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] TargetRollingWindowSiz detection mode.
    /// </summary>
    [EnumType]
    public readonly struct TargetRollingWindowSizeMode : IEquatable<TargetRollingWindowSizeMode>
    {
        private readonly string _value;

        private TargetRollingWindowSizeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Determine rolling windows size automatically.
        /// </summary>
        public static TargetRollingWindowSizeMode Auto { get; } = new TargetRollingWindowSizeMode("Auto");
        /// <summary>
        /// Use the specified rolling window size.
        /// </summary>
        public static TargetRollingWindowSizeMode Custom { get; } = new TargetRollingWindowSizeMode("Custom");

        public static bool operator ==(TargetRollingWindowSizeMode left, TargetRollingWindowSizeMode right) => left.Equals(right);
        public static bool operator !=(TargetRollingWindowSizeMode left, TargetRollingWindowSizeMode right) => !left.Equals(right);

        public static explicit operator string(TargetRollingWindowSizeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetRollingWindowSizeMode other && Equals(other);
        public bool Equals(TargetRollingWindowSizeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Task type for AutoMLJob.
    /// </summary>
    [EnumType]
    public readonly struct TaskType : IEquatable<TaskType>
    {
        private readonly string _value;

        private TaskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Classification in machine learning and statistics is a supervised learning approach in which
        /// the computer program learns from the data given to it and make new observations or classifications.
        /// </summary>
        public static TaskType Classification { get; } = new TaskType("Classification");
        /// <summary>
        /// Regression means to predict the value using the input data. Regression models are used to predict a continuous value.
        /// </summary>
        public static TaskType Regression { get; } = new TaskType("Regression");
        /// <summary>
        /// Forecasting is a special kind of regression task that deals with time-series data and creates forecasting model
        /// that can be used to predict the near future values based on the inputs.
        /// </summary>
        public static TaskType Forecasting { get; } = new TaskType("Forecasting");
        /// <summary>
        /// Image Classification. Multi-class image classification is used when an image is classified with only a single label
        /// from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
        /// </summary>
        public static TaskType ImageClassification { get; } = new TaskType("ImageClassification");
        /// <summary>
        /// Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
        /// from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
        /// </summary>
        public static TaskType ImageClassificationMultilabel { get; } = new TaskType("ImageClassificationMultilabel");
        /// <summary>
        /// Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
        /// bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
        /// </summary>
        public static TaskType ImageObjectDetection { get; } = new TaskType("ImageObjectDetection");
        /// <summary>
        /// Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
        /// drawing a polygon around each object in the image.
        /// </summary>
        public static TaskType ImageInstanceSegmentation { get; } = new TaskType("ImageInstanceSegmentation");
        /// <summary>
        /// Text classification (also known as text tagging or text categorization) is the process of sorting texts into categories.
        /// Categories are mutually exclusive.
        /// </summary>
        public static TaskType TextClassification { get; } = new TaskType("TextClassification");
        /// <summary>
        /// Multilabel classification task assigns each sample to a group (zero or more) of target labels.
        /// </summary>
        public static TaskType TextClassificationMultilabel { get; } = new TaskType("TextClassificationMultilabel");
        /// <summary>
        /// Text Named Entity Recognition a.k.a. TextNER.
        /// Named Entity Recognition (NER) is the ability to take free-form text and identify the occurrences of entities such as people, locations, organizations, and more.
        /// </summary>
        public static TaskType TextNER { get; } = new TaskType("TextNER");

        public static bool operator ==(TaskType left, TaskType right) => left.Equals(right);
        public static bool operator !=(TaskType left, TaskType right) => !left.Equals(right);

        public static explicit operator string(TaskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskType other && Equals(other);
        public bool Equals(TaskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] 
    /// </summary>
    [EnumType]
    public readonly struct TriggerType : IEquatable<TriggerType>
    {
        private readonly string _value;

        private TriggerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TriggerType Recurrence { get; } = new TriggerType("Recurrence");
        public static TriggerType Cron { get; } = new TriggerType("Cron");

        public static bool operator ==(TriggerType left, TriggerType right) => left.Equals(right);
        public static bool operator !=(TriggerType left, TriggerType right) => !left.Equals(right);

        public static explicit operator string(TriggerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggerType other && Equals(other);
        public bool Equals(TriggerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configure STL Decomposition of the time-series target column.
    /// </summary>
    [EnumType]
    public readonly struct UseStl : IEquatable<UseStl>
    {
        private readonly string _value;

        private UseStl(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No stl decomposition.
        /// </summary>
        public static UseStl None { get; } = new UseStl("None");
        public static UseStl Season { get; } = new UseStl("Season");
        public static UseStl SeasonTrend { get; } = new UseStl("SeasonTrend");

        public static bool operator ==(UseStl left, UseStl right) => left.Equals(right);
        public static bool operator !=(UseStl left, UseStl right) => !left.Equals(right);

        public static explicit operator string(UseStl value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UseStl other && Equals(other);
        public bool Equals(UseStl other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Metric computation method to use for validation metrics.
    /// </summary>
    [EnumType]
    public readonly struct ValidationMetricType : IEquatable<ValidationMetricType>
    {
        private readonly string _value;

        private ValidationMetricType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No metric.
        /// </summary>
        public static ValidationMetricType None { get; } = new ValidationMetricType("None");
        /// <summary>
        /// Coco metric.
        /// </summary>
        public static ValidationMetricType Coco { get; } = new ValidationMetricType("Coco");
        /// <summary>
        /// Voc metric.
        /// </summary>
        public static ValidationMetricType Voc { get; } = new ValidationMetricType("Voc");
        /// <summary>
        /// CocoVoc metric.
        /// </summary>
        public static ValidationMetricType CocoVoc { get; } = new ValidationMetricType("CocoVoc");

        public static bool operator ==(ValidationMetricType left, ValidationMetricType right) => left.Equals(right);
        public static bool operator !=(ValidationMetricType left, ValidationMetricType right) => !left.Equals(right);

        public static explicit operator string(ValidationMetricType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValidationMetricType other && Equals(other);
        public bool Equals(ValidationMetricType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Virtual Machine priority
    /// </summary>
    [EnumType]
    public readonly struct VmPriority : IEquatable<VmPriority>
    {
        private readonly string _value;

        private VmPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VmPriority Dedicated { get; } = new VmPriority("Dedicated");
        public static VmPriority LowPriority { get; } = new VmPriority("LowPriority");

        public static bool operator ==(VmPriority left, VmPriority right) => left.Equals(right);
        public static bool operator !=(VmPriority left, VmPriority right) => !left.Equals(right);

        public static explicit operator string(VmPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmPriority other && Equals(other);
        public bool Equals(VmPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
    /// </summary>
    [EnumType]
    public readonly struct VolumeDefinitionType : IEquatable<VolumeDefinitionType>
    {
        private readonly string _value;

        private VolumeDefinitionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VolumeDefinitionType Bind { get; } = new VolumeDefinitionType("bind");
        public static VolumeDefinitionType Volume { get; } = new VolumeDefinitionType("volume");
        public static VolumeDefinitionType Tmpfs { get; } = new VolumeDefinitionType("tmpfs");
        public static VolumeDefinitionType Npipe { get; } = new VolumeDefinitionType("npipe");

        public static bool operator ==(VolumeDefinitionType left, VolumeDefinitionType right) => left.Equals(right);
        public static bool operator !=(VolumeDefinitionType left, VolumeDefinitionType right) => !left.Equals(right);

        public static explicit operator string(VolumeDefinitionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VolumeDefinitionType other && Equals(other);
        public bool Equals(VolumeDefinitionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of service to send a callback
    /// </summary>
    [EnumType]
    public readonly struct WebhookType : IEquatable<WebhookType>
    {
        private readonly string _value;

        private WebhookType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebhookType AzureDevOps { get; } = new WebhookType("AzureDevOps");

        public static bool operator ==(WebhookType left, WebhookType right) => left.Equals(right);
        public static bool operator !=(WebhookType left, WebhookType right) => !left.Equals(right);

        public static explicit operator string(WebhookType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebhookType other && Equals(other);
        public bool Equals(WebhookType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enum of weekday
    /// </summary>
    [EnumType]
    public readonly struct WeekDay : IEquatable<WeekDay>
    {
        private readonly string _value;

        private WeekDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Monday weekday
        /// </summary>
        public static WeekDay Monday { get; } = new WeekDay("Monday");
        /// <summary>
        /// Tuesday weekday
        /// </summary>
        public static WeekDay Tuesday { get; } = new WeekDay("Tuesday");
        /// <summary>
        /// Wednesday weekday
        /// </summary>
        public static WeekDay Wednesday { get; } = new WeekDay("Wednesday");
        /// <summary>
        /// Thursday weekday
        /// </summary>
        public static WeekDay Thursday { get; } = new WeekDay("Thursday");
        /// <summary>
        /// Friday weekday
        /// </summary>
        public static WeekDay Friday { get; } = new WeekDay("Friday");
        /// <summary>
        /// Saturday weekday
        /// </summary>
        public static WeekDay Saturday { get; } = new WeekDay("Saturday");
        /// <summary>
        /// Sunday weekday
        /// </summary>
        public static WeekDay Sunday { get; } = new WeekDay("Sunday");

        public static bool operator ==(WeekDay left, WeekDay right) => left.Equals(right);
        public static bool operator !=(WeekDay left, WeekDay right) => !left.Equals(right);

        public static explicit operator string(WeekDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeekDay other && Equals(other);
        public bool Equals(WeekDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
