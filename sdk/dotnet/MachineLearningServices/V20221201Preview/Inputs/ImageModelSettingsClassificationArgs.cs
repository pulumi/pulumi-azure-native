// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AzureNative.MachineLearningServices.V20221201Preview.Inputs
{

    /// <summary>
    /// Settings used for training the model.
    /// For more information on the available settings please visit the official documentation:
    /// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    /// </summary>
    public sealed class ImageModelSettingsClassificationArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Settings for advanced scenarios.
        /// </summary>
        [Input("advancedSettings")]
        public Input<string>? AdvancedSettings { get; set; }

        /// <summary>
        /// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        /// </summary>
        [Input("amsGradient")]
        public Input<bool>? AmsGradient { get; set; }

        /// <summary>
        /// Settings for using Augmentations.
        /// </summary>
        [Input("augmentations")]
        public Input<string>? Augmentations { get; set; }

        /// <summary>
        /// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        /// </summary>
        [Input("beta1")]
        public Input<double>? Beta1 { get; set; }

        /// <summary>
        /// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        /// </summary>
        [Input("beta2")]
        public Input<double>? Beta2 { get; set; }

        /// <summary>
        /// Frequency to store model checkpoints. Must be a positive integer.
        /// </summary>
        [Input("checkpointFrequency")]
        public Input<int>? CheckpointFrequency { get; set; }

        /// <summary>
        /// The pretrained checkpoint model for incremental training.
        /// </summary>
        [Input("checkpointModel")]
        public Input<Inputs.MLFlowModelJobInputArgs>? CheckpointModel { get; set; }

        /// <summary>
        /// The id of a previous run that has a pretrained checkpoint for incremental training.
        /// </summary>
        [Input("checkpointRunId")]
        public Input<string>? CheckpointRunId { get; set; }

        /// <summary>
        /// Whether to use distributed training.
        /// </summary>
        [Input("distributed")]
        public Input<bool>? Distributed { get; set; }

        /// <summary>
        /// Enable early stopping logic during training.
        /// </summary>
        [Input("earlyStopping")]
        public Input<bool>? EarlyStopping { get; set; }

        /// <summary>
        /// Minimum number of epochs or validation evaluations to wait before primary metric improvement
        /// is tracked for early stopping. Must be a positive integer.
        /// </summary>
        [Input("earlyStoppingDelay")]
        public Input<int>? EarlyStoppingDelay { get; set; }

        /// <summary>
        /// Minimum number of epochs or validation evaluations with no primary metric improvement before
        /// the run is stopped. Must be a positive integer.
        /// </summary>
        [Input("earlyStoppingPatience")]
        public Input<int>? EarlyStoppingPatience { get; set; }

        /// <summary>
        /// Enable normalization when exporting ONNX model.
        /// </summary>
        [Input("enableOnnxNormalization")]
        public Input<bool>? EnableOnnxNormalization { get; set; }

        /// <summary>
        /// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        /// </summary>
        [Input("evaluationFrequency")]
        public Input<int>? EvaluationFrequency { get; set; }

        /// <summary>
        /// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        /// updating the model weights while accumulating the gradients of those steps, and then using
        /// the accumulated gradients to compute the weight updates. Must be a positive integer.
        /// </summary>
        [Input("gradientAccumulationStep")]
        public Input<int>? GradientAccumulationStep { get; set; }

        /// <summary>
        /// Number of layers to freeze for the model. Must be a positive integer.
        /// For instance, passing 2 as value for 'seresnext' means
        /// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        /// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        /// </summary>
        [Input("layersToFreeze")]
        public Input<int>? LayersToFreeze { get; set; }

        /// <summary>
        /// Initial learning rate. Must be a float in the range [0, 1].
        /// </summary>
        [Input("learningRate")]
        public Input<double>? LearningRate { get; set; }

        /// <summary>
        /// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        /// </summary>
        [Input("learningRateScheduler")]
        public InputUnion<string, Pulumi.AzureNative.MachineLearningServices.V20221201Preview.LearningRateScheduler>? LearningRateScheduler { get; set; }

        /// <summary>
        /// Name of the model to use for training.
        /// For more information on the available models please visit the official documentation:
        /// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        /// </summary>
        [Input("modelName")]
        public Input<string>? ModelName { get; set; }

        /// <summary>
        /// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        /// </summary>
        [Input("momentum")]
        public Input<double>? Momentum { get; set; }

        /// <summary>
        /// Enable nesterov when optimizer is 'sgd'.
        /// </summary>
        [Input("nesterov")]
        public Input<bool>? Nesterov { get; set; }

        /// <summary>
        /// Number of training epochs. Must be a positive integer.
        /// </summary>
        [Input("numberOfEpochs")]
        public Input<int>? NumberOfEpochs { get; set; }

        /// <summary>
        /// Number of data loader workers. Must be a non-negative integer.
        /// </summary>
        [Input("numberOfWorkers")]
        public Input<int>? NumberOfWorkers { get; set; }

        /// <summary>
        /// Type of optimizer.
        /// </summary>
        [Input("optimizer")]
        public InputUnion<string, Pulumi.AzureNative.MachineLearningServices.V20221201Preview.StochasticOptimizer>? Optimizer { get; set; }

        /// <summary>
        /// Random seed to be used when using deterministic training.
        /// </summary>
        [Input("randomSeed")]
        public Input<int>? RandomSeed { get; set; }

        /// <summary>
        /// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        /// </summary>
        [Input("stepLRGamma")]
        public Input<double>? StepLRGamma { get; set; }

        /// <summary>
        /// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        /// </summary>
        [Input("stepLRStepSize")]
        public Input<int>? StepLRStepSize { get; set; }

        /// <summary>
        /// Training batch size. Must be a positive integer.
        /// </summary>
        [Input("trainingBatchSize")]
        public Input<int>? TrainingBatchSize { get; set; }

        /// <summary>
        /// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        /// </summary>
        [Input("trainingCropSize")]
        public Input<int>? TrainingCropSize { get; set; }

        /// <summary>
        /// Validation batch size. Must be a positive integer.
        /// </summary>
        [Input("validationBatchSize")]
        public Input<int>? ValidationBatchSize { get; set; }

        /// <summary>
        /// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        /// </summary>
        [Input("validationCropSize")]
        public Input<int>? ValidationCropSize { get; set; }

        /// <summary>
        /// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        /// </summary>
        [Input("validationResizeSize")]
        public Input<int>? ValidationResizeSize { get; set; }

        /// <summary>
        /// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        /// </summary>
        [Input("warmupCosineLRCycles")]
        public Input<double>? WarmupCosineLRCycles { get; set; }

        /// <summary>
        /// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        /// </summary>
        [Input("warmupCosineLRWarmupEpochs")]
        public Input<int>? WarmupCosineLRWarmupEpochs { get; set; }

        /// <summary>
        /// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        /// </summary>
        [Input("weightDecay")]
        public Input<double>? WeightDecay { get; set; }

        /// <summary>
        /// Weighted loss. The accepted values are 0 for no weighted loss.
        /// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        /// </summary>
        [Input("weightedLoss")]
        public Input<int>? WeightedLoss { get; set; }

        public ImageModelSettingsClassificationArgs()
        {
            LearningRateScheduler = "None";
            Optimizer = "None";
        }
        public static new ImageModelSettingsClassificationArgs Empty => new ImageModelSettingsClassificationArgs();
    }
}
