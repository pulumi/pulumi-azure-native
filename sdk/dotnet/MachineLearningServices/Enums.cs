// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AzureNative.MachineLearningServices
{
    /// <summary>
    /// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
    /// </summary>
    [EnumType]
    public readonly struct ApplicationSharingPolicy : IEquatable<ApplicationSharingPolicy>
    {
        private readonly string _value;

        private ApplicationSharingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ApplicationSharingPolicy Personal { get; } = new ApplicationSharingPolicy("Personal");
        public static ApplicationSharingPolicy Shared { get; } = new ApplicationSharingPolicy("Shared");

        public static bool operator ==(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => left.Equals(right);
        public static bool operator !=(ApplicationSharingPolicy left, ApplicationSharingPolicy right) => !left.Equals(right);

        public static explicit operator string(ApplicationSharingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApplicationSharingPolicy other && Equals(other);
        public bool Equals(ApplicationSharingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logging level for batch inference operation.
    /// </summary>
    [EnumType]
    public readonly struct BatchLoggingLevel : IEquatable<BatchLoggingLevel>
    {
        private readonly string _value;

        private BatchLoggingLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchLoggingLevel Info { get; } = new BatchLoggingLevel("Info");
        public static BatchLoggingLevel Warning { get; } = new BatchLoggingLevel("Warning");
        public static BatchLoggingLevel Debug { get; } = new BatchLoggingLevel("Debug");

        public static bool operator ==(BatchLoggingLevel left, BatchLoggingLevel right) => left.Equals(right);
        public static bool operator !=(BatchLoggingLevel left, BatchLoggingLevel right) => !left.Equals(right);

        public static explicit operator string(BatchLoggingLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchLoggingLevel other && Equals(other);
        public bool Equals(BatchLoggingLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how the output will be organized.
    /// </summary>
    [EnumType]
    public readonly struct BatchOutputAction : IEquatable<BatchOutputAction>
    {
        private readonly string _value;

        private BatchOutputAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BatchOutputAction SummaryOnly { get; } = new BatchOutputAction("SummaryOnly");
        public static BatchOutputAction AppendRow { get; } = new BatchOutputAction("AppendRow");

        public static bool operator ==(BatchOutputAction left, BatchOutputAction right) => left.Equals(right);
        public static bool operator !=(BatchOutputAction left, BatchOutputAction right) => !left.Equals(right);

        public static explicit operator string(BatchOutputAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BatchOutputAction other && Equals(other);
        public bool Equals(BatchOutputAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Intended usage of the cluster
    /// </summary>
    [EnumType]
    public readonly struct ClusterPurpose : IEquatable<ClusterPurpose>
    {
        private readonly string _value;

        private ClusterPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterPurpose FastProd { get; } = new ClusterPurpose("FastProd");
        public static ClusterPurpose DenseProd { get; } = new ClusterPurpose("DenseProd");
        public static ClusterPurpose DevTest { get; } = new ClusterPurpose("DevTest");

        public static bool operator ==(ClusterPurpose left, ClusterPurpose right) => left.Equals(right);
        public static bool operator !=(ClusterPurpose left, ClusterPurpose right) => !left.Equals(right);

        public static explicit operator string(ClusterPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterPurpose other && Equals(other);
        public bool Equals(ClusterPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The compute environment type for the service.
    /// </summary>
    [EnumType]
    public readonly struct ComputeEnvironmentType : IEquatable<ComputeEnvironmentType>
    {
        private readonly string _value;

        private ComputeEnvironmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeEnvironmentType ACI { get; } = new ComputeEnvironmentType("ACI");
        public static ComputeEnvironmentType AKS { get; } = new ComputeEnvironmentType("AKS");

        public static bool operator ==(ComputeEnvironmentType left, ComputeEnvironmentType right) => left.Equals(right);
        public static bool operator !=(ComputeEnvironmentType left, ComputeEnvironmentType right) => !left.Equals(right);

        public static explicit operator string(ComputeEnvironmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeEnvironmentType other && Equals(other);
        public bool Equals(ComputeEnvironmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Compute Instance Authorization type. Available values are personal (default).
    /// </summary>
    [EnumType]
    public readonly struct ComputeInstanceAuthorizationType : IEquatable<ComputeInstanceAuthorizationType>
    {
        private readonly string _value;

        private ComputeInstanceAuthorizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeInstanceAuthorizationType Personal { get; } = new ComputeInstanceAuthorizationType("personal");

        public static bool operator ==(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => left.Equals(right);
        public static bool operator !=(ComputeInstanceAuthorizationType left, ComputeInstanceAuthorizationType right) => !left.Equals(right);

        public static explicit operator string(ComputeInstanceAuthorizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeInstanceAuthorizationType other && Equals(other);
        public bool Equals(ComputeInstanceAuthorizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compute
    /// </summary>
    [EnumType]
    public readonly struct ComputeType : IEquatable<ComputeType>
    {
        private readonly string _value;

        private ComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeType AKS { get; } = new ComputeType("AKS");
        public static ComputeType AmlCompute { get; } = new ComputeType("AmlCompute");
        public static ComputeType ComputeInstance { get; } = new ComputeType("ComputeInstance");
        public static ComputeType DataFactory { get; } = new ComputeType("DataFactory");
        public static ComputeType VirtualMachine { get; } = new ComputeType("VirtualMachine");
        public static ComputeType HDInsight { get; } = new ComputeType("HDInsight");
        public static ComputeType Databricks { get; } = new ComputeType("Databricks");
        public static ComputeType DataLakeAnalytics { get; } = new ComputeType("DataLakeAnalytics");

        public static bool operator ==(ComputeType left, ComputeType right) => left.Equals(right);
        public static bool operator !=(ComputeType left, ComputeType right) => !left.Equals(right);

        public static explicit operator string(ComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeType other && Equals(other);
        public bool Equals(ComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of container to retrieve logs from.
    /// </summary>
    [EnumType]
    public readonly struct ContainerType : IEquatable<ContainerType>
    {
        private readonly string _value;

        private ContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerType StorageInitializer { get; } = new ContainerType("StorageInitializer");
        public static ContainerType InferenceServer { get; } = new ContainerType("InferenceServer");

        public static bool operator ==(ContainerType left, ContainerType right) => left.Equals(right);
        public static bool operator !=(ContainerType left, ContainerType right) => !left.Equals(right);

        public static explicit operator string(ContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerType other && Equals(other);
        public bool Equals(ContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mechanism for data movement to datastore.
    /// </summary>
    [EnumType]
    public readonly struct DataBindingMode : IEquatable<DataBindingMode>
    {
        private readonly string _value;

        private DataBindingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DataBindingMode Mount { get; } = new DataBindingMode("Mount");
        public static DataBindingMode Download { get; } = new DataBindingMode("Download");
        public static DataBindingMode Upload { get; } = new DataBindingMode("Upload");
        public static DataBindingMode ReadOnlyMount { get; } = new DataBindingMode("ReadOnlyMount");
        public static DataBindingMode ReadWriteMount { get; } = new DataBindingMode("ReadWriteMount");
        public static DataBindingMode Direct { get; } = new DataBindingMode("Direct");
        public static DataBindingMode EvalMount { get; } = new DataBindingMode("EvalMount");
        public static DataBindingMode EvalDownload { get; } = new DataBindingMode("EvalDownload");

        public static bool operator ==(DataBindingMode left, DataBindingMode right) => left.Equals(right);
        public static bool operator !=(DataBindingMode left, DataBindingMode right) => !left.Equals(right);

        public static explicit operator string(DataBindingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataBindingMode other && Equals(other);
        public bool Equals(DataBindingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies dataset type.
    /// </summary>
    [EnumType]
    public readonly struct DatasetType : IEquatable<DatasetType>
    {
        private readonly string _value;

        private DatasetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatasetType Tabular { get; } = new DatasetType("tabular");
        public static DatasetType File { get; } = new DatasetType("file");

        public static bool operator ==(DatasetType left, DatasetType right) => left.Equals(right);
        public static bool operator !=(DatasetType left, DatasetType right) => !left.Equals(right);

        public static explicit operator string(DatasetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetType other && Equals(other);
        public bool Equals(DatasetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies datastore type.
    /// </summary>
    [EnumType]
    public readonly struct DatastoreTypeArm : IEquatable<DatastoreTypeArm>
    {
        private readonly string _value;

        private DatastoreTypeArm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DatastoreTypeArm Blob { get; } = new DatastoreTypeArm("blob");
        public static DatastoreTypeArm Adls { get; } = new DatastoreTypeArm("adls");
        public static DatastoreTypeArm Adls_gen2 { get; } = new DatastoreTypeArm("adls-gen2");
        public static DatastoreTypeArm Dbfs { get; } = new DatastoreTypeArm("dbfs");
        public static DatastoreTypeArm File { get; } = new DatastoreTypeArm("file");
        public static DatastoreTypeArm Mysqldb { get; } = new DatastoreTypeArm("mysqldb");
        public static DatastoreTypeArm Sqldb { get; } = new DatastoreTypeArm("sqldb");
        public static DatastoreTypeArm Psqldb { get; } = new DatastoreTypeArm("psqldb");

        public static bool operator ==(DatastoreTypeArm left, DatastoreTypeArm right) => left.Equals(right);
        public static bool operator !=(DatastoreTypeArm left, DatastoreTypeArm right) => !left.Equals(right);

        public static explicit operator string(DatastoreTypeArm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatastoreTypeArm other && Equals(other);
        public bool Equals(DatastoreTypeArm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of distribution framework.
    /// </summary>
    [EnumType]
    public readonly struct DistributionType : IEquatable<DistributionType>
    {
        private readonly string _value;

        private DistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionType PyTorch { get; } = new DistributionType("PyTorch");
        public static DistributionType TensorFlow { get; } = new DistributionType("TensorFlow");
        public static DistributionType Mpi { get; } = new DistributionType("Mpi");

        public static bool operator ==(DistributionType left, DistributionType right) => left.Equals(right);
        public static bool operator !=(DistributionType left, DistributionType right) => !left.Equals(right);

        public static explicit operator string(DistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionType other && Equals(other);
        public bool Equals(DistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Docker specification must be either Build or Image
    /// </summary>
    [EnumType]
    public readonly struct DockerSpecificationType : IEquatable<DockerSpecificationType>
    {
        private readonly string _value;

        private DockerSpecificationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DockerSpecificationType Build { get; } = new DockerSpecificationType("Build");
        public static DockerSpecificationType Image { get; } = new DockerSpecificationType("Image");

        public static bool operator ==(DockerSpecificationType left, DockerSpecificationType right) => left.Equals(right);
        public static bool operator !=(DockerSpecificationType left, DockerSpecificationType right) => !left.Equals(right);

        public static explicit operator string(DockerSpecificationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DockerSpecificationType other && Equals(other);
        public bool Equals(DockerSpecificationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Name of policy configuration
    /// </summary>
    [EnumType]
    public readonly struct EarlyTerminationPolicyType : IEquatable<EarlyTerminationPolicyType>
    {
        private readonly string _value;

        private EarlyTerminationPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EarlyTerminationPolicyType Bandit { get; } = new EarlyTerminationPolicyType("Bandit");
        public static EarlyTerminationPolicyType MedianStopping { get; } = new EarlyTerminationPolicyType("MedianStopping");
        public static EarlyTerminationPolicyType TruncationSelection { get; } = new EarlyTerminationPolicyType("TruncationSelection");

        public static bool operator ==(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => left.Equals(right);
        public static bool operator !=(EarlyTerminationPolicyType left, EarlyTerminationPolicyType right) => !left.Equals(right);

        public static explicit operator string(EarlyTerminationPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EarlyTerminationPolicyType other && Equals(other);
        public bool Equals(EarlyTerminationPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not the encryption is enabled for the workspace.
    /// </summary>
    [EnumType]
    public readonly struct EncryptionStatus : IEquatable<EncryptionStatus>
    {
        private readonly string _value;

        private EncryptionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EncryptionStatus Enabled { get; } = new EncryptionStatus("Enabled");
        public static EncryptionStatus Disabled { get; } = new EncryptionStatus("Disabled");

        public static bool operator ==(EncryptionStatus left, EncryptionStatus right) => left.Equals(right);
        public static bool operator !=(EncryptionStatus left, EncryptionStatus right) => !left.Equals(right);

        public static explicit operator string(EncryptionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EncryptionStatus other && Equals(other);
        public bool Equals(EncryptionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Inference endpoint authentication mode type
    /// </summary>
    [EnumType]
    public readonly struct EndpointAuthMode : IEquatable<EndpointAuthMode>
    {
        private readonly string _value;

        private EndpointAuthMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointAuthMode AMLToken { get; } = new EndpointAuthMode("AMLToken");
        public static EndpointAuthMode Key { get; } = new EndpointAuthMode("Key");
        public static EndpointAuthMode AADToken { get; } = new EndpointAuthMode("AADToken");

        public static bool operator ==(EndpointAuthMode left, EndpointAuthMode right) => left.Equals(right);
        public static bool operator !=(EndpointAuthMode left, EndpointAuthMode right) => !left.Equals(right);

        public static explicit operator string(EndpointAuthMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointAuthMode other && Equals(other);
        public bool Equals(EndpointAuthMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] The compute type of the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct EndpointComputeType : IEquatable<EndpointComputeType>
    {
        private readonly string _value;

        private EndpointComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EndpointComputeType Managed { get; } = new EndpointComputeType("Managed");
        public static EndpointComputeType K8S { get; } = new EndpointComputeType("K8S");
        public static EndpointComputeType AzureMLCompute { get; } = new EndpointComputeType("AzureMLCompute");

        public static bool operator ==(EndpointComputeType left, EndpointComputeType right) => left.Equals(right);
        public static bool operator !=(EndpointComputeType left, EndpointComputeType right) => !left.Equals(right);

        public static explicit operator string(EndpointComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointComputeType other && Equals(other);
        public bool Equals(EndpointComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Defines supported metric goals for hyperparameter tuning
    /// </summary>
    [EnumType]
    public readonly struct Goal : IEquatable<Goal>
    {
        private readonly string _value;

        private Goal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Goal Minimize { get; } = new Goal("Minimize");
        public static Goal Maximize { get; } = new Goal("Maximize");

        public static bool operator ==(Goal left, Goal right) => left.Equals(right);
        public static bool operator !=(Goal left, Goal right) => !left.Equals(right);

        public static explicit operator string(Goal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Goal other && Equals(other);
        public bool Equals(Goal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Header type.
    /// </summary>
    [EnumType]
    public readonly struct Header : IEquatable<Header>
    {
        private readonly string _value;

        private Header(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Header All_files_have_same_headers { get; } = new Header("all_files_have_same_headers");
        public static Header Only_first_file_has_headers { get; } = new Header("only_first_file_has_headers");
        public static Header No_headers { get; } = new Header("no_headers");
        public static Header Combine_all_files_headers { get; } = new Header("combine_all_files_headers");

        public static bool operator ==(Header left, Header right) => left.Equals(right);
        public static bool operator !=(Header left, Header right) => !left.Equals(right);

        public static explicit operator string(Header value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Header other && Equals(other);
        public bool Equals(Header other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of identity framework.
    /// </summary>
    [EnumType]
    public readonly struct IdentityConfigurationType : IEquatable<IdentityConfigurationType>
    {
        private readonly string _value;

        private IdentityConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityConfigurationType Managed { get; } = new IdentityConfigurationType("Managed");
        public static IdentityConfigurationType AMLToken { get; } = new IdentityConfigurationType("AMLToken");

        public static bool operator ==(IdentityConfigurationType left, IdentityConfigurationType right) => left.Equals(right);
        public static bool operator !=(IdentityConfigurationType left, IdentityConfigurationType right) => !left.Equals(right);

        public static explicit operator string(IdentityConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityConfigurationType other && Equals(other);
        public bool Equals(IdentityConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Annotation type of image labeling tasks.
    /// </summary>
    [EnumType]
    public readonly struct ImageAnnotationType : IEquatable<ImageAnnotationType>
    {
        private readonly string _value;

        private ImageAnnotationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageAnnotationType Classification { get; } = new ImageAnnotationType("Classification");
        public static ImageAnnotationType BoundingBox { get; } = new ImageAnnotationType("BoundingBox");
        public static ImageAnnotationType InstanceSegmentation { get; } = new ImageAnnotationType("InstanceSegmentation");

        public static bool operator ==(ImageAnnotationType left, ImageAnnotationType right) => left.Equals(right);
        public static bool operator !=(ImageAnnotationType left, ImageAnnotationType right) => !left.Equals(right);

        public static explicit operator string(ImageAnnotationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageAnnotationType other && Equals(other);
        public bool Equals(ImageAnnotationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of job.
    /// </summary>
    [EnumType]
    public readonly struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        private JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static JobType Command { get; } = new JobType("Command");
        public static JobType Sweep { get; } = new JobType("Sweep");
        public static JobType Labeling { get; } = new JobType("Labeling");

        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);

        public static explicit operator string(JobType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobType other && Equals(other);
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the link target.
    /// </summary>
    [EnumType]
    public readonly struct LinkedServiceLinkType : IEquatable<LinkedServiceLinkType>
    {
        private readonly string _value;

        private LinkedServiceLinkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LinkedServiceLinkType Synapse { get; } = new LinkedServiceLinkType("Synapse");

        public static bool operator ==(LinkedServiceLinkType left, LinkedServiceLinkType right) => left.Equals(right);
        public static bool operator !=(LinkedServiceLinkType left, LinkedServiceLinkType right) => !left.Equals(right);

        public static explicit operator string(LinkedServiceLinkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinkedServiceLinkType other && Equals(other);
        public bool Equals(LinkedServiceLinkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Media type of data asset.
    /// </summary>
    [EnumType]
    public readonly struct MediaType : IEquatable<MediaType>
    {
        private readonly string _value;

        private MediaType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MediaType Image { get; } = new MediaType("Image");
        public static MediaType Text { get; } = new MediaType("Text");

        public static bool operator ==(MediaType left, MediaType right) => left.Equals(right);
        public static bool operator !=(MediaType left, MediaType right) => !left.Equals(right);

        public static explicit operator string(MediaType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MediaType other && Equals(other);
        public bool Equals(MediaType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The OS type the Environment.
    /// </summary>
    [EnumType]
    public readonly struct OperatingSystemType : IEquatable<OperatingSystemType>
    {
        private readonly string _value;

        private OperatingSystemType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OperatingSystemType Linux { get; } = new OperatingSystemType("Linux");
        public static OperatingSystemType Windows { get; } = new OperatingSystemType("Windows");

        public static bool operator ==(OperatingSystemType left, OperatingSystemType right) => left.Equals(right);
        public static bool operator !=(OperatingSystemType left, OperatingSystemType right) => !left.Equals(right);

        public static explicit operator string(OperatingSystemType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OperatingSystemType other && Equals(other);
        public bool Equals(OperatingSystemType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compute OS Type
    /// </summary>
    [EnumType]
    public readonly struct OsType : IEquatable<OsType>
    {
        private readonly string _value;

        private OsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OsType Linux { get; } = new OsType("Linux");
        public static OsType Windows { get; } = new OsType("Windows");

        public static bool operator ==(OsType left, OsType right) => left.Equals(right);
        public static bool operator !=(OsType left, OsType right) => !left.Equals(right);

        public static explicit operator string(OsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OsType other && Equals(other);
        public bool Equals(OsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
    /// </summary>
    [EnumType]
    public readonly struct PrivateEndpointServiceConnectionStatus : IEquatable<PrivateEndpointServiceConnectionStatus>
    {
        private readonly string _value;

        private PrivateEndpointServiceConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrivateEndpointServiceConnectionStatus Pending { get; } = new PrivateEndpointServiceConnectionStatus("Pending");
        public static PrivateEndpointServiceConnectionStatus Approved { get; } = new PrivateEndpointServiceConnectionStatus("Approved");
        public static PrivateEndpointServiceConnectionStatus Rejected { get; } = new PrivateEndpointServiceConnectionStatus("Rejected");
        public static PrivateEndpointServiceConnectionStatus Disconnected { get; } = new PrivateEndpointServiceConnectionStatus("Disconnected");
        public static PrivateEndpointServiceConnectionStatus Timeout { get; } = new PrivateEndpointServiceConnectionStatus("Timeout");

        public static bool operator ==(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => left.Equals(right);
        public static bool operator !=(PrivateEndpointServiceConnectionStatus left, PrivateEndpointServiceConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(PrivateEndpointServiceConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateEndpointServiceConnectionStatus other && Equals(other);
        public bool Equals(PrivateEndpointServiceConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Specifies the type of asset reference.
    /// </summary>
    [EnumType]
    public readonly struct ReferenceType : IEquatable<ReferenceType>
    {
        private readonly string _value;

        private ReferenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReferenceType Id { get; } = new ReferenceType("Id");
        public static ReferenceType DataPath { get; } = new ReferenceType("DataPath");
        public static ReferenceType OutputPath { get; } = new ReferenceType("OutputPath");

        public static bool operator ==(ReferenceType left, ReferenceType right) => left.Equals(right);
        public static bool operator !=(ReferenceType left, ReferenceType right) => !left.Equals(right);

        public static explicit operator string(ReferenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReferenceType other && Equals(other);
        public bool Equals(ReferenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct RemoteLoginPortPublicAccess : IEquatable<RemoteLoginPortPublicAccess>
    {
        private readonly string _value;

        private RemoteLoginPortPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RemoteLoginPortPublicAccess Enabled { get; } = new RemoteLoginPortPublicAccess("Enabled");
        public static RemoteLoginPortPublicAccess Disabled { get; } = new RemoteLoginPortPublicAccess("Disabled");
        public static RemoteLoginPortPublicAccess NotSpecified { get; } = new RemoteLoginPortPublicAccess("NotSpecified");

        public static bool operator ==(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => left.Equals(right);
        public static bool operator !=(RemoteLoginPortPublicAccess left, RemoteLoginPortPublicAccess right) => !left.Equals(right);

        public static explicit operator string(RemoteLoginPortPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemoteLoginPortPublicAccess other && Equals(other);
        public bool Equals(RemoteLoginPortPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines values for a ResourceIdentity's type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityAssignment : IEquatable<ResourceIdentityAssignment>
    {
        private readonly string _value;

        private ResourceIdentityAssignment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityAssignment SystemAssigned { get; } = new ResourceIdentityAssignment("SystemAssigned");
        public static ResourceIdentityAssignment UserAssigned { get; } = new ResourceIdentityAssignment("UserAssigned");
        public static ResourceIdentityAssignment SystemAssigned_UserAssigned { get; } = new ResourceIdentityAssignment("SystemAssigned,UserAssigned");
        public static ResourceIdentityAssignment None { get; } = new ResourceIdentityAssignment("None");

        public static bool operator ==(ResourceIdentityAssignment left, ResourceIdentityAssignment right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityAssignment left, ResourceIdentityAssignment right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityAssignment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityAssignment other && Equals(other);
        public bool Equals(ResourceIdentityAssignment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The identity type.
    /// </summary>
    [EnumType]
    public readonly struct ResourceIdentityType : IEquatable<ResourceIdentityType>
    {
        private readonly string _value;

        private ResourceIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceIdentityType SystemAssigned { get; } = new ResourceIdentityType("SystemAssigned");
        public static ResourceIdentityType SystemAssigned_UserAssigned { get; } = new ResourceIdentityType("SystemAssigned,UserAssigned");
        public static ResourceIdentityType UserAssigned { get; } = new ResourceIdentityType("UserAssigned");
        public static ResourceIdentityType None { get; } = new ResourceIdentityType("None");

        public static bool operator ==(ResourceIdentityType left, ResourceIdentityType right) => left.Equals(right);
        public static bool operator !=(ResourceIdentityType left, ResourceIdentityType right) => !left.Equals(right);

        public static explicit operator string(ResourceIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceIdentityType other && Equals(other);
        public bool Equals(ResourceIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of the hyperparameter sampling algorithms
    /// </summary>
    [EnumType]
    public readonly struct SamplingAlgorithm : IEquatable<SamplingAlgorithm>
    {
        private readonly string _value;

        private SamplingAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SamplingAlgorithm Grid { get; } = new SamplingAlgorithm("Grid");
        public static SamplingAlgorithm Random { get; } = new SamplingAlgorithm("Random");
        public static SamplingAlgorithm Bayesian { get; } = new SamplingAlgorithm("Bayesian");

        public static bool operator ==(SamplingAlgorithm left, SamplingAlgorithm right) => left.Equals(right);
        public static bool operator !=(SamplingAlgorithm left, SamplingAlgorithm right) => !left.Equals(right);

        public static explicit operator string(SamplingAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SamplingAlgorithm other && Equals(other);
        public bool Equals(SamplingAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Required] Type of deployment scaling algorithm
    /// </summary>
    [EnumType]
    public readonly struct ScaleType : IEquatable<ScaleType>
    {
        private readonly string _value;

        private ScaleType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ScaleType Auto { get; } = new ScaleType("Auto");
        public static ScaleType Manual { get; } = new ScaleType("Manual");

        public static bool operator ==(ScaleType left, ScaleType right) => left.Equals(right);
        public static bool operator !=(ScaleType left, ScaleType right) => !left.Equals(right);

        public static explicit operator string(ScaleType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScaleType other && Equals(other);
        public bool Equals(ScaleType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data source type.
    /// </summary>
    [EnumType]
    public readonly struct SourceType : IEquatable<SourceType>
    {
        private readonly string _value;

        private SourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SourceType Delimited_files { get; } = new SourceType("delimited_files");
        public static SourceType Json_lines_files { get; } = new SourceType("json_lines_files");
        public static SourceType Parquet_files { get; } = new SourceType("parquet_files");

        public static bool operator ==(SourceType left, SourceType right) => left.Equals(right);
        public static bool operator !=(SourceType left, SourceType right) => !left.Equals(right);

        public static explicit operator string(SourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceType other && Equals(other);
        public bool Equals(SourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
    /// </summary>
    [EnumType]
    public readonly struct SshPublicAccess : IEquatable<SshPublicAccess>
    {
        private readonly string _value;

        private SshPublicAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SshPublicAccess Enabled { get; } = new SshPublicAccess("Enabled");
        public static SshPublicAccess Disabled { get; } = new SshPublicAccess("Disabled");

        public static bool operator ==(SshPublicAccess left, SshPublicAccess right) => left.Equals(right);
        public static bool operator !=(SshPublicAccess left, SshPublicAccess right) => !left.Equals(right);

        public static explicit operator string(SshPublicAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SshPublicAccess other && Equals(other);
        public bool Equals(SshPublicAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// format for the workspace connection value
    /// </summary>
    [EnumType]
    public readonly struct ValueFormat : IEquatable<ValueFormat>
    {
        private readonly string _value;

        private ValueFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ValueFormat JSON { get; } = new ValueFormat("JSON");

        public static bool operator ==(ValueFormat left, ValueFormat right) => left.Equals(right);
        public static bool operator !=(ValueFormat left, ValueFormat right) => !left.Equals(right);

        public static explicit operator string(ValueFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ValueFormat other && Equals(other);
        public bool Equals(ValueFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the variant.
    /// </summary>
    [EnumType]
    public readonly struct VariantType : IEquatable<VariantType>
    {
        private readonly string _value;

        private VariantType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VariantType Control { get; } = new VariantType("Control");
        public static VariantType Treatment { get; } = new VariantType("Treatment");

        public static bool operator ==(VariantType left, VariantType right) => left.Equals(right);
        public static bool operator !=(VariantType left, VariantType right) => !left.Equals(right);

        public static explicit operator string(VariantType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VariantType other && Equals(other);
        public bool Equals(VariantType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Virtual Machine priority
    /// </summary>
    [EnumType]
    public readonly struct VmPriority : IEquatable<VmPriority>
    {
        private readonly string _value;

        private VmPriority(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VmPriority Dedicated { get; } = new VmPriority("Dedicated");
        public static VmPriority LowPriority { get; } = new VmPriority("LowPriority");

        public static bool operator ==(VmPriority left, VmPriority right) => left.Equals(right);
        public static bool operator !=(VmPriority left, VmPriority right) => !left.Equals(right);

        public static explicit operator string(VmPriority value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmPriority other && Equals(other);
        public bool Equals(VmPriority other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
