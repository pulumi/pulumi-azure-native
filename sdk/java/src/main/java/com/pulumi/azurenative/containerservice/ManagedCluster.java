// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.containerservice;

import com.pulumi.azurenative.Utilities;
import com.pulumi.azurenative.containerservice.ManagedClusterArgs;
import com.pulumi.azurenative.containerservice.outputs.ContainerServiceLinuxProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ContainerServiceNetworkProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ExtendedLocationResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterAADProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterAPIServerAccessProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterAddonProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterAgentPoolProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterAutoUpgradeProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterHTTPProxyConfigResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterIdentityResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterPodIdentityProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterPropertiesResponseAutoScalerProfile;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterPropertiesResponseIdentityProfile;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterSKUResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterServicePrincipalProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.ManagedClusterWindowsProfileResponse;
import com.pulumi.azurenative.containerservice.outputs.PowerStateResponse;
import com.pulumi.azurenative.containerservice.outputs.PrivateLinkResourceResponse;
import com.pulumi.core.Alias;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Managed cluster.
 * API Version: 2021-03-01.
 * 
 * ## Example Usage
 * ### Create Managed Cluster with Azure KeyVault Secrets Provider Addon
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles(Map.of(&#34;azureKeyvaultSecretsProvider&#34;, Map.ofEntries(
 *                 Map.entry(&#34;config&#34;, Map.of(&#34;enableSecretRotation&#34;, &#34;true&#34;)),
 *                 Map.entry(&#34;enabled&#34;, true)
 *             )))
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with EncryptionAtHost enabled
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableEncryptionAtHost&#34;, true),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with FIPS enabled OS
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableFIPS&#34;, true),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(false)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with GPUMIG
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;gpuInstanceProfile&#34;, &#34;MIG3g&#34;),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_ND96asr_v4&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .httpProxyConfig(Map.ofEntries(
 *                 Map.entry(&#34;httpProxy&#34;, &#34;http://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;httpsProxy&#34;, &#34;https://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;noProxy&#34;,                 
 *                     &#34;localhost&#34;,
 *                     &#34;127.0.0.1&#34;),
 *                 Map.entry(&#34;trustedCa&#34;, &#34;Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U=&#34;)
 *             ))
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with HTTP proxy configured
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .httpProxyConfig(Map.ofEntries(
 *                 Map.entry(&#34;httpProxy&#34;, &#34;http://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;httpsProxy&#34;, &#34;https://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;noProxy&#34;,                 
 *                     &#34;localhost&#34;,
 *                     &#34;127.0.0.1&#34;),
 *                 Map.entry(&#34;trustedCa&#34;, &#34;Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U=&#34;)
 *             ))
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with Node Public IP Prefix
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;nodePublicIPPrefixID&#34;, &#34;/subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.Network/publicIPPrefixes/public-ip-prefix&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with OSSKU
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osSKU&#34;, &#34;CBLMariner&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .httpProxyConfig(Map.ofEntries(
 *                 Map.entry(&#34;httpProxy&#34;, &#34;http://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;httpsProxy&#34;, &#34;https://myproxy.server.com:8080&#34;),
 *                 Map.entry(&#34;noProxy&#34;,                 
 *                     &#34;localhost&#34;,
 *                     &#34;127.0.0.1&#34;),
 *                 Map.entry(&#34;trustedCa&#34;, &#34;Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U=&#34;)
 *             ))
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with PPG
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;proximityPlacementGroupID&#34;, &#34;/subscriptions/subid1/resourcegroups/rg1/providers//Microsoft.Compute/proximityPlacementGroups/ppg1&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Cluster with PodIdentity enabled
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .podIdentityProfile(Map.ofEntries(
 *                 Map.entry(&#34;allowNetworkPluginKubenet&#34;, true),
 *                 Map.entry(&#34;enabled&#34;, true)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create Managed Private Cluster with fqdn subdomain specified
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableEncryptionAtHost&#34;, true),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS2_v2&#34;)
 *             ))
 *             .apiServerAccessProfile(Map.ofEntries(
 *                 Map.entry(&#34;enablePrivateCluster&#34;, true),
 *                 Map.entry(&#34;privateDNSZone&#34;, &#34;/subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.Network/privateDnsZones/privatelink.location1.azmk8s.io&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .fqdnSubdomain(&#34;domain1&#34;)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create/Update AAD Managed Cluster with EnableAzureRBAC
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .aadProfile(Map.ofEntries(
 *                 Map.entry(&#34;enableAzureRBAC&#34;, true),
 *                 Map.entry(&#34;managed&#34;, true)
 *             ))
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;availabilityZones&#34;,                 
 *                     &#34;1&#34;,
 *                     &#34;2&#34;,
 *                     &#34;3&#34;),
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS1_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create/Update Managed Cluster
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;availabilityZones&#34;,                 
 *                     &#34;1&#34;,
 *                     &#34;2&#34;,
 *                     &#34;3&#34;),
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS1_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;balanceSimilarNodeGroups&#34;, &#34;true&#34;),
 *                 Map.entry(&#34;expander&#34;, &#34;priority&#34;),
 *                 Map.entry(&#34;maxNodeProvisionTime&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;newPodScaleUpDelay&#34;, &#34;1m&#34;),
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;),
 *                 Map.entry(&#34;skipNodesWithSystemPods&#34;, &#34;false&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .identity(Map.ofEntries(
 *                 Map.entry(&#34;type&#34;, &#34;UserAssigned&#34;),
 *                 Map.entry(&#34;userAssignedIdentities&#34;, Map.of(&#34;/subscriptions/subid1/resourceGroups/rgName1/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity1&#34;, ))
 *             ))
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Create/Update Managed Cluster with EnableAHUB
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var managedCluster = new ManagedCluster(&#34;managedCluster&#34;, ManagedClusterArgs.builder()        
 *             .addonProfiles()
 *             .agentPoolProfiles(Map.ofEntries(
 *                 Map.entry(&#34;availabilityZones&#34;,                 
 *                     &#34;1&#34;,
 *                     &#34;2&#34;,
 *                     &#34;3&#34;),
 *                 Map.entry(&#34;count&#34;, 3),
 *                 Map.entry(&#34;enableNodePublicIP&#34;, true),
 *                 Map.entry(&#34;mode&#34;, &#34;System&#34;),
 *                 Map.entry(&#34;name&#34;, &#34;nodepool1&#34;),
 *                 Map.entry(&#34;osType&#34;, &#34;Linux&#34;),
 *                 Map.entry(&#34;type&#34;, &#34;VirtualMachineScaleSets&#34;),
 *                 Map.entry(&#34;vmSize&#34;, &#34;Standard_DS1_v2&#34;)
 *             ))
 *             .autoScalerProfile(Map.ofEntries(
 *                 Map.entry(&#34;scaleDownDelayAfterAdd&#34;, &#34;15m&#34;),
 *                 Map.entry(&#34;scanInterval&#34;, &#34;20s&#34;)
 *             ))
 *             .diskEncryptionSetID(&#34;/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des&#34;)
 *             .dnsPrefix(&#34;dnsprefix1&#34;)
 *             .enablePodSecurityPolicy(true)
 *             .enableRBAC(true)
 *             .identity(Map.ofEntries(
 *                 Map.entry(&#34;type&#34;, &#34;UserAssigned&#34;),
 *                 Map.entry(&#34;userAssignedIdentities&#34;, Map.of(&#34;/subscriptions/subid1/resourceGroups/rgName1/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity1&#34;, ))
 *             ))
 *             .kubernetesVersion(&#34;&#34;)
 *             .linuxProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;ssh&#34;, Map.of(&#34;publicKeys&#34;, Map.of(&#34;keyData&#34;, &#34;keydata&#34;)))
 *             ))
 *             .location(&#34;location1&#34;)
 *             .networkProfile(Map.ofEntries(
 *                 Map.entry(&#34;loadBalancerProfile&#34;, Map.of(&#34;managedOutboundIPs&#34;, Map.of(&#34;count&#34;, 2))),
 *                 Map.entry(&#34;loadBalancerSku&#34;, &#34;standard&#34;),
 *                 Map.entry(&#34;outboundType&#34;, &#34;loadBalancer&#34;)
 *             ))
 *             .resourceGroupName(&#34;rg1&#34;)
 *             .resourceName(&#34;clustername1&#34;)
 *             .servicePrincipalProfile(Map.ofEntries(
 *                 Map.entry(&#34;clientId&#34;, &#34;clientid&#34;),
 *                 Map.entry(&#34;secret&#34;, &#34;secret&#34;)
 *             ))
 *             .sku(Map.ofEntries(
 *                 Map.entry(&#34;name&#34;, &#34;Basic&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;Free&#34;)
 *             ))
 *             .tags(Map.ofEntries(
 *                 Map.entry(&#34;archv2&#34;, &#34;&#34;),
 *                 Map.entry(&#34;tier&#34;, &#34;production&#34;)
 *             ))
 *             .windowsProfile(Map.ofEntries(
 *                 Map.entry(&#34;adminPassword&#34;, &#34;replacePassword1234$&#34;),
 *                 Map.entry(&#34;adminUsername&#34;, &#34;azureuser&#34;),
 *                 Map.entry(&#34;licenseType&#34;, &#34;Windows_Server&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * 
 * ## Import
 * 
 * An existing resource can be imported using its type token, name, and identifier, e.g.
 * 
 * ```sh
 * $ pulumi import azure-native:containerservice:ManagedCluster clustername1 /subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.ContainerService/managedClusters/clustername1 
 * ```
 * 
 */
@ResourceType(type="azure-native:containerservice:ManagedCluster")
public class ManagedCluster extends com.pulumi.resources.CustomResource {
    /**
     * Profile of Azure Active Directory configuration.
     * 
     */
    @Export(name="aadProfile", type=ManagedClusterAADProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterAADProfileResponse> aadProfile;

    /**
     * @return Profile of Azure Active Directory configuration.
     * 
     */
    public Output<Optional<ManagedClusterAADProfileResponse>> aadProfile() {
        return Codegen.optional(this.aadProfile);
    }
    /**
     * Profile of managed cluster add-on.
     * 
     */
    @Export(name="addonProfiles", type=Map.class, parameters={String.class, ManagedClusterAddonProfileResponse.class})
    private Output</* @Nullable */ Map<String,ManagedClusterAddonProfileResponse>> addonProfiles;

    /**
     * @return Profile of managed cluster add-on.
     * 
     */
    public Output<Optional<Map<String,ManagedClusterAddonProfileResponse>>> addonProfiles() {
        return Codegen.optional(this.addonProfiles);
    }
    /**
     * Properties of the agent pool.
     * 
     */
    @Export(name="agentPoolProfiles", type=List.class, parameters={ManagedClusterAgentPoolProfileResponse.class})
    private Output</* @Nullable */ List<ManagedClusterAgentPoolProfileResponse>> agentPoolProfiles;

    /**
     * @return Properties of the agent pool.
     * 
     */
    public Output<Optional<List<ManagedClusterAgentPoolProfileResponse>>> agentPoolProfiles() {
        return Codegen.optional(this.agentPoolProfiles);
    }
    /**
     * Access profile for managed cluster API server.
     * 
     */
    @Export(name="apiServerAccessProfile", type=ManagedClusterAPIServerAccessProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterAPIServerAccessProfileResponse> apiServerAccessProfile;

    /**
     * @return Access profile for managed cluster API server.
     * 
     */
    public Output<Optional<ManagedClusterAPIServerAccessProfileResponse>> apiServerAccessProfile() {
        return Codegen.optional(this.apiServerAccessProfile);
    }
    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     * 
     */
    @Export(name="autoScalerProfile", type=ManagedClusterPropertiesResponseAutoScalerProfile.class, parameters={})
    private Output</* @Nullable */ ManagedClusterPropertiesResponseAutoScalerProfile> autoScalerProfile;

    /**
     * @return Parameters to be applied to the cluster-autoscaler when enabled
     * 
     */
    public Output<Optional<ManagedClusterPropertiesResponseAutoScalerProfile>> autoScalerProfile() {
        return Codegen.optional(this.autoScalerProfile);
    }
    /**
     * Profile of auto upgrade configuration.
     * 
     */
    @Export(name="autoUpgradeProfile", type=ManagedClusterAutoUpgradeProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterAutoUpgradeProfileResponse> autoUpgradeProfile;

    /**
     * @return Profile of auto upgrade configuration.
     * 
     */
    public Output<Optional<ManagedClusterAutoUpgradeProfileResponse>> autoUpgradeProfile() {
        return Codegen.optional(this.autoUpgradeProfile);
    }
    /**
     * FQDN for the master pool which used by proxy config.
     * 
     */
    @Export(name="azurePortalFQDN", type=String.class, parameters={})
    private Output<String> azurePortalFQDN;

    /**
     * @return FQDN for the master pool which used by proxy config.
     * 
     */
    public Output<String> azurePortalFQDN() {
        return this.azurePortalFQDN;
    }
    /**
     * If set to true, getting static credential will be disabled for this cluster. Expected to only be used for AAD clusters.
     * 
     */
    @Export(name="disableLocalAccounts", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> disableLocalAccounts;

    /**
     * @return If set to true, getting static credential will be disabled for this cluster. Expected to only be used for AAD clusters.
     * 
     */
    public Output<Optional<Boolean>> disableLocalAccounts() {
        return Codegen.optional(this.disableLocalAccounts);
    }
    /**
     * ResourceId of the disk encryption set to use for enabling encryption at rest.
     * 
     */
    @Export(name="diskEncryptionSetID", type=String.class, parameters={})
    private Output</* @Nullable */ String> diskEncryptionSetID;

    /**
     * @return ResourceId of the disk encryption set to use for enabling encryption at rest.
     * 
     */
    public Output<Optional<String>> diskEncryptionSetID() {
        return Codegen.optional(this.diskEncryptionSetID);
    }
    /**
     * DNS prefix specified when creating the managed cluster.
     * 
     */
    @Export(name="dnsPrefix", type=String.class, parameters={})
    private Output</* @Nullable */ String> dnsPrefix;

    /**
     * @return DNS prefix specified when creating the managed cluster.
     * 
     */
    public Output<Optional<String>> dnsPrefix() {
        return Codegen.optional(this.dnsPrefix);
    }
    /**
     * (DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy.
     * 
     */
    @Export(name="enablePodSecurityPolicy", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enablePodSecurityPolicy;

    /**
     * @return (DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy.
     * 
     */
    public Output<Optional<Boolean>> enablePodSecurityPolicy() {
        return Codegen.optional(this.enablePodSecurityPolicy);
    }
    /**
     * Whether to enable Kubernetes Role-Based Access Control.
     * 
     */
    @Export(name="enableRBAC", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enableRBAC;

    /**
     * @return Whether to enable Kubernetes Role-Based Access Control.
     * 
     */
    public Output<Optional<Boolean>> enableRBAC() {
        return Codegen.optional(this.enableRBAC);
    }
    /**
     * The extended location of the Virtual Machine.
     * 
     */
    @Export(name="extendedLocation", type=ExtendedLocationResponse.class, parameters={})
    private Output</* @Nullable */ ExtendedLocationResponse> extendedLocation;

    /**
     * @return The extended location of the Virtual Machine.
     * 
     */
    public Output<Optional<ExtendedLocationResponse>> extendedLocation() {
        return Codegen.optional(this.extendedLocation);
    }
    /**
     * FQDN for the master pool.
     * 
     */
    @Export(name="fqdn", type=String.class, parameters={})
    private Output<String> fqdn;

    /**
     * @return FQDN for the master pool.
     * 
     */
    public Output<String> fqdn() {
        return this.fqdn;
    }
    /**
     * FQDN subdomain specified when creating private cluster with custom private dns zone.
     * 
     */
    @Export(name="fqdnSubdomain", type=String.class, parameters={})
    private Output</* @Nullable */ String> fqdnSubdomain;

    /**
     * @return FQDN subdomain specified when creating private cluster with custom private dns zone.
     * 
     */
    public Output<Optional<String>> fqdnSubdomain() {
        return Codegen.optional(this.fqdnSubdomain);
    }
    /**
     * Configurations for provisioning the cluster with HTTP proxy servers.
     * 
     */
    @Export(name="httpProxyConfig", type=ManagedClusterHTTPProxyConfigResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterHTTPProxyConfigResponse> httpProxyConfig;

    /**
     * @return Configurations for provisioning the cluster with HTTP proxy servers.
     * 
     */
    public Output<Optional<ManagedClusterHTTPProxyConfigResponse>> httpProxyConfig() {
        return Codegen.optional(this.httpProxyConfig);
    }
    /**
     * The identity of the managed cluster, if configured.
     * 
     */
    @Export(name="identity", type=ManagedClusterIdentityResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterIdentityResponse> identity;

    /**
     * @return The identity of the managed cluster, if configured.
     * 
     */
    public Output<Optional<ManagedClusterIdentityResponse>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * Identities associated with the cluster.
     * 
     */
    @Export(name="identityProfile", type=Map.class, parameters={String.class, ManagedClusterPropertiesResponseIdentityProfile.class})
    private Output</* @Nullable */ Map<String,ManagedClusterPropertiesResponseIdentityProfile>> identityProfile;

    /**
     * @return Identities associated with the cluster.
     * 
     */
    public Output<Optional<Map<String,ManagedClusterPropertiesResponseIdentityProfile>>> identityProfile() {
        return Codegen.optional(this.identityProfile);
    }
    /**
     * Version of Kubernetes specified when creating the managed cluster.
     * 
     */
    @Export(name="kubernetesVersion", type=String.class, parameters={})
    private Output</* @Nullable */ String> kubernetesVersion;

    /**
     * @return Version of Kubernetes specified when creating the managed cluster.
     * 
     */
    public Output<Optional<String>> kubernetesVersion() {
        return Codegen.optional(this.kubernetesVersion);
    }
    /**
     * Profile for Linux VMs in the container service cluster.
     * 
     */
    @Export(name="linuxProfile", type=ContainerServiceLinuxProfileResponse.class, parameters={})
    private Output</* @Nullable */ ContainerServiceLinuxProfileResponse> linuxProfile;

    /**
     * @return Profile for Linux VMs in the container service cluster.
     * 
     */
    public Output<Optional<ContainerServiceLinuxProfileResponse>> linuxProfile() {
        return Codegen.optional(this.linuxProfile);
    }
    /**
     * Resource location
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output<String> location;

    /**
     * @return Resource location
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * The max number of agent pools for the managed cluster.
     * 
     */
    @Export(name="maxAgentPools", type=Integer.class, parameters={})
    private Output<Integer> maxAgentPools;

    /**
     * @return The max number of agent pools for the managed cluster.
     * 
     */
    public Output<Integer> maxAgentPools() {
        return this.maxAgentPools;
    }
    /**
     * Resource name
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Resource name
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Profile of network configuration.
     * 
     */
    @Export(name="networkProfile", type=ContainerServiceNetworkProfileResponse.class, parameters={})
    private Output</* @Nullable */ ContainerServiceNetworkProfileResponse> networkProfile;

    /**
     * @return Profile of network configuration.
     * 
     */
    public Output<Optional<ContainerServiceNetworkProfileResponse>> networkProfile() {
        return Codegen.optional(this.networkProfile);
    }
    /**
     * Name of the resource group containing agent pool nodes.
     * 
     */
    @Export(name="nodeResourceGroup", type=String.class, parameters={})
    private Output</* @Nullable */ String> nodeResourceGroup;

    /**
     * @return Name of the resource group containing agent pool nodes.
     * 
     */
    public Output<Optional<String>> nodeResourceGroup() {
        return Codegen.optional(this.nodeResourceGroup);
    }
    /**
     * Profile of managed cluster pod identity.
     * 
     */
    @Export(name="podIdentityProfile", type=ManagedClusterPodIdentityProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterPodIdentityProfileResponse> podIdentityProfile;

    /**
     * @return Profile of managed cluster pod identity.
     * 
     */
    public Output<Optional<ManagedClusterPodIdentityProfileResponse>> podIdentityProfile() {
        return Codegen.optional(this.podIdentityProfile);
    }
    /**
     * Represents the Power State of the cluster
     * 
     */
    @Export(name="powerState", type=PowerStateResponse.class, parameters={})
    private Output<PowerStateResponse> powerState;

    /**
     * @return Represents the Power State of the cluster
     * 
     */
    public Output<PowerStateResponse> powerState() {
        return this.powerState;
    }
    /**
     * FQDN of private cluster.
     * 
     */
    @Export(name="privateFQDN", type=String.class, parameters={})
    private Output<String> privateFQDN;

    /**
     * @return FQDN of private cluster.
     * 
     */
    public Output<String> privateFQDN() {
        return this.privateFQDN;
    }
    /**
     * Private link resources associated with the cluster.
     * 
     */
    @Export(name="privateLinkResources", type=List.class, parameters={PrivateLinkResourceResponse.class})
    private Output</* @Nullable */ List<PrivateLinkResourceResponse>> privateLinkResources;

    /**
     * @return Private link resources associated with the cluster.
     * 
     */
    public Output<Optional<List<PrivateLinkResourceResponse>>> privateLinkResources() {
        return Codegen.optional(this.privateLinkResources);
    }
    /**
     * The current deployment or provisioning state, which only appears in the response.
     * 
     */
    @Export(name="provisioningState", type=String.class, parameters={})
    private Output<String> provisioningState;

    /**
     * @return The current deployment or provisioning state, which only appears in the response.
     * 
     */
    public Output<String> provisioningState() {
        return this.provisioningState;
    }
    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     * 
     */
    @Export(name="servicePrincipalProfile", type=ManagedClusterServicePrincipalProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterServicePrincipalProfileResponse> servicePrincipalProfile;

    /**
     * @return Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     * 
     */
    public Output<Optional<ManagedClusterServicePrincipalProfileResponse>> servicePrincipalProfile() {
        return Codegen.optional(this.servicePrincipalProfile);
    }
    /**
     * The managed cluster SKU.
     * 
     */
    @Export(name="sku", type=ManagedClusterSKUResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterSKUResponse> sku;

    /**
     * @return The managed cluster SKU.
     * 
     */
    public Output<Optional<ManagedClusterSKUResponse>> sku() {
        return Codegen.optional(this.sku);
    }
    /**
     * Resource tags
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return Resource tags
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Resource type
     * 
     */
    @Export(name="type", type=String.class, parameters={})
    private Output<String> type;

    /**
     * @return Resource type
     * 
     */
    public Output<String> type() {
        return this.type;
    }
    /**
     * Profile for Windows VMs in the container service cluster.
     * 
     */
    @Export(name="windowsProfile", type=ManagedClusterWindowsProfileResponse.class, parameters={})
    private Output</* @Nullable */ ManagedClusterWindowsProfileResponse> windowsProfile;

    /**
     * @return Profile for Windows VMs in the container service cluster.
     * 
     */
    public Output<Optional<ManagedClusterWindowsProfileResponse>> windowsProfile() {
        return Codegen.optional(this.windowsProfile);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ManagedCluster(String name) {
        this(name, ManagedClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ManagedCluster(String name, ManagedClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ManagedCluster(String name, ManagedClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure-native:containerservice:ManagedCluster", name, args == null ? ManagedClusterArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private ManagedCluster(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure-native:containerservice:ManagedCluster", name, null, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .aliases(List.of(
                Output.of(Alias.builder().type("azure-native:containerservice/v20170831:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20180331:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20180801preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20190201:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20190401:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20190601:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20190801:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20191001:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20191101:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200101:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200201:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200301:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200401:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200601:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200701:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20200901:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20201101:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20201201:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210201:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210301:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210501:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210701:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210801:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20210901:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20211001:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20211101preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220101:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220102preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220201:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220202preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220301:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220302preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220401:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220402preview:ManagedCluster").build()),
                Output.of(Alias.builder().type("azure-native:containerservice/v20220502preview:ManagedCluster").build())
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ManagedCluster get(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ManagedCluster(name, id, options);
    }
}
