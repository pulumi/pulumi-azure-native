// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.servicefabric;

import com.pulumi.azurenative.Utilities;
import com.pulumi.azurenative.servicefabric.ApplicationArgs;
import com.pulumi.azurenative.servicefabric.outputs.ApplicationMetricDescriptionResponse;
import com.pulumi.azurenative.servicefabric.outputs.ApplicationUpgradePolicyResponse;
import com.pulumi.azurenative.servicefabric.outputs.ApplicationUserAssignedIdentityResponse;
import com.pulumi.azurenative.servicefabric.outputs.ManagedIdentityResponse;
import com.pulumi.core.Alias;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * The application resource.
 * API Version: 2020-03-01.
 * 
 * ## Example Usage
 * ### Put an application with maximum parameters
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var application = new Application(&#34;application&#34;, ApplicationArgs.builder()        
 *             .applicationName(&#34;myApp&#34;)
 *             .clusterName(&#34;myCluster&#34;)
 *             .maximumNodes(3)
 *             .metrics(Map.ofEntries(
 *                 Map.entry(&#34;maximumCapacity&#34;, 3),
 *                 Map.entry(&#34;name&#34;, &#34;metric1&#34;),
 *                 Map.entry(&#34;reservationCapacity&#34;, 1),
 *                 Map.entry(&#34;totalApplicationCapacity&#34;, 5)
 *             ))
 *             .minimumNodes(1)
 *             .parameters(Map.of(&#34;param1&#34;, &#34;value1&#34;))
 *             .removeApplicationCapacity(false)
 *             .resourceGroupName(&#34;resRg&#34;)
 *             .typeName(&#34;myAppType&#34;)
 *             .typeVersion(&#34;1.0&#34;)
 *             .upgradePolicy(Map.ofEntries(
 *                 Map.entry(&#34;applicationHealthPolicy&#34;, Map.ofEntries(
 *                     Map.entry(&#34;considerWarningAsError&#34;, true),
 *                     Map.entry(&#34;defaultServiceTypeHealthPolicy&#34;, Map.ofEntries(
 *                         Map.entry(&#34;maxPercentUnhealthyPartitionsPerService&#34;, 0),
 *                         Map.entry(&#34;maxPercentUnhealthyReplicasPerPartition&#34;, 0),
 *                         Map.entry(&#34;maxPercentUnhealthyServices&#34;, 0)
 *                     )),
 *                     Map.entry(&#34;maxPercentUnhealthyDeployedApplications&#34;, 0)
 *                 )),
 *                 Map.entry(&#34;forceRestart&#34;, false),
 *                 Map.entry(&#34;rollingUpgradeMonitoringPolicy&#34;, Map.ofEntries(
 *                     Map.entry(&#34;failureAction&#34;, &#34;Rollback&#34;),
 *                     Map.entry(&#34;healthCheckRetryTimeout&#34;, &#34;00:10:00&#34;),
 *                     Map.entry(&#34;healthCheckStableDuration&#34;, &#34;00:05:00&#34;),
 *                     Map.entry(&#34;healthCheckWaitDuration&#34;, &#34;00:02:00&#34;),
 *                     Map.entry(&#34;upgradeDomainTimeout&#34;, &#34;1.06:00:00&#34;),
 *                     Map.entry(&#34;upgradeTimeout&#34;, &#34;01:00:00&#34;)
 *                 )),
 *                 Map.entry(&#34;upgradeMode&#34;, &#34;Monitored&#34;),
 *                 Map.entry(&#34;upgradeReplicaSetCheckTimeout&#34;, &#34;01:00:00&#34;)
 *             ))
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * ### Put an application with minimum parameters
 * 
 * ```java
 * package generated_program;
 * 
 * import java.util.*;
 * import java.io.*;
 * import java.nio.*;
 * import com.pulumi.*;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var application = new Application(&#34;application&#34;, ApplicationArgs.builder()        
 *             .applicationName(&#34;myApp&#34;)
 *             .clusterName(&#34;myCluster&#34;)
 *             .removeApplicationCapacity(false)
 *             .resourceGroupName(&#34;resRg&#34;)
 *             .typeName(&#34;myAppType&#34;)
 *             .typeVersion(&#34;1.0&#34;)
 *             .build());
 * 
 *     }
 * }
 * 
 * ```
 * 
 * ## Import
 * 
 * An existing resource can be imported using its type token, name, and identifier, e.g.
 * 
 * ```sh
 * $ pulumi import azure-native:servicefabric:Application myCluster /subscriptions/00000000-0000-0000-0000-000000000000/resourcegroups/resRg/providers/Microsoft.ServiceFabric/clusters/myCluster/applications/myApp 
 * ```
 * 
 */
@ResourceType(type="azure-native:servicefabric:Application")
public class Application extends com.pulumi.resources.CustomResource {
    /**
     * Azure resource etag.
     * 
     */
    @Export(name="etag", type=String.class, parameters={})
    private Output<String> etag;

    /**
     * @return Azure resource etag.
     * 
     */
    public Output<String> etag() {
        return this.etag;
    }
    /**
     * Describes the managed identities for an Azure resource.
     * 
     */
    @Export(name="identity", type=ManagedIdentityResponse.class, parameters={})
    private Output</* @Nullable */ ManagedIdentityResponse> identity;

    /**
     * @return Describes the managed identities for an Azure resource.
     * 
     */
    public Output<Optional<ManagedIdentityResponse>> identity() {
        return Codegen.optional(this.identity);
    }
    /**
     * It will be deprecated in New API, resource location depends on the parent resource.
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output</* @Nullable */ String> location;

    /**
     * @return It will be deprecated in New API, resource location depends on the parent resource.
     * 
     */
    public Output<Optional<String>> location() {
        return Codegen.optional(this.location);
    }
    /**
     * List of user assigned identities for the application, each mapped to a friendly name.
     * 
     */
    @Export(name="managedIdentities", type=List.class, parameters={ApplicationUserAssignedIdentityResponse.class})
    private Output</* @Nullable */ List<ApplicationUserAssignedIdentityResponse>> managedIdentities;

    /**
     * @return List of user assigned identities for the application, each mapped to a friendly name.
     * 
     */
    public Output<Optional<List<ApplicationUserAssignedIdentityResponse>>> managedIdentities() {
        return Codegen.optional(this.managedIdentities);
    }
    /**
     * The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. By default, the value of this property is zero and it means that the services can be placed on any node.
     * 
     */
    @Export(name="maximumNodes", type=Double.class, parameters={})
    private Output</* @Nullable */ Double> maximumNodes;

    /**
     * @return The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. By default, the value of this property is zero and it means that the services can be placed on any node.
     * 
     */
    public Output<Optional<Double>> maximumNodes() {
        return Codegen.optional(this.maximumNodes);
    }
    /**
     * List of application capacity metric description.
     * 
     */
    @Export(name="metrics", type=List.class, parameters={ApplicationMetricDescriptionResponse.class})
    private Output</* @Nullable */ List<ApplicationMetricDescriptionResponse>> metrics;

    /**
     * @return List of application capacity metric description.
     * 
     */
    public Output<Optional<List<ApplicationMetricDescriptionResponse>>> metrics() {
        return Codegen.optional(this.metrics);
    }
    /**
     * The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. If this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.
     * 
     */
    @Export(name="minimumNodes", type=Double.class, parameters={})
    private Output</* @Nullable */ Double> minimumNodes;

    /**
     * @return The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. If this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.
     * 
     */
    public Output<Optional<Double>> minimumNodes() {
        return Codegen.optional(this.minimumNodes);
    }
    /**
     * Azure resource name.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Azure resource name.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * List of application parameters with overridden values from their default values specified in the application manifest.
     * 
     */
    @Export(name="parameters", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> parameters;

    /**
     * @return List of application parameters with overridden values from their default values specified in the application manifest.
     * 
     */
    public Output<Optional<Map<String,String>>> parameters() {
        return Codegen.optional(this.parameters);
    }
    /**
     * The current deployment or provisioning state, which only appears in the response
     * 
     */
    @Export(name="provisioningState", type=String.class, parameters={})
    private Output<String> provisioningState;

    /**
     * @return The current deployment or provisioning state, which only appears in the response
     * 
     */
    public Output<String> provisioningState() {
        return this.provisioningState;
    }
    /**
     * Remove the current application capacity settings.
     * 
     */
    @Export(name="removeApplicationCapacity", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> removeApplicationCapacity;

    /**
     * @return Remove the current application capacity settings.
     * 
     */
    public Output<Optional<Boolean>> removeApplicationCapacity() {
        return Codegen.optional(this.removeApplicationCapacity);
    }
    /**
     * Azure resource tags.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return Azure resource tags.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Azure resource type.
     * 
     */
    @Export(name="type", type=String.class, parameters={})
    private Output<String> type;

    /**
     * @return Azure resource type.
     * 
     */
    public Output<String> type() {
        return this.type;
    }
    /**
     * The application type name as defined in the application manifest.
     * 
     */
    @Export(name="typeName", type=String.class, parameters={})
    private Output</* @Nullable */ String> typeName;

    /**
     * @return The application type name as defined in the application manifest.
     * 
     */
    public Output<Optional<String>> typeName() {
        return Codegen.optional(this.typeName);
    }
    /**
     * The version of the application type as defined in the application manifest.
     * 
     */
    @Export(name="typeVersion", type=String.class, parameters={})
    private Output</* @Nullable */ String> typeVersion;

    /**
     * @return The version of the application type as defined in the application manifest.
     * 
     */
    public Output<Optional<String>> typeVersion() {
        return Codegen.optional(this.typeVersion);
    }
    /**
     * Describes the policy for a monitored application upgrade.
     * 
     */
    @Export(name="upgradePolicy", type=ApplicationUpgradePolicyResponse.class, parameters={})
    private Output</* @Nullable */ ApplicationUpgradePolicyResponse> upgradePolicy;

    /**
     * @return Describes the policy for a monitored application upgrade.
     * 
     */
    public Output<Optional<ApplicationUpgradePolicyResponse>> upgradePolicy() {
        return Codegen.optional(this.upgradePolicy);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Application(String name) {
        this(name, ApplicationArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Application(String name, ApplicationArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Application(String name, ApplicationArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure-native:servicefabric:Application", name, args == null ? ApplicationArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Application(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("azure-native:servicefabric:Application", name, null, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .aliases(List.of(
                Output.of(Alias.builder().type("azure-native:servicefabric/v20170701preview:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20190301:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20190301preview:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20190601preview:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20191101preview:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20200301:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20201201preview:Application").build()),
                Output.of(Alias.builder().type("azure-native:servicefabric/v20210601:Application").build())
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Application get(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Application(name, id, options);
    }
}
