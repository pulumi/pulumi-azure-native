// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20220201preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Machine Learning compute based on AKS.
type AKS struct {
	// The type of compute
	// Expected value is 'AKS'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// AKS properties
	Properties *AKSSchemaProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AKS
func (val *AKS) Defaults() *AKS {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// A Machine Learning compute based on AKS.
type AKSResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AKS'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// AKS properties
	Properties *AKSSchemaResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AKSResponse
func (val *AKSResponse) Defaults() *AKSResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// AKS properties
type AKSSchemaProperties struct {
	// Number of agents
	AgentCount *int `pulumi:"agentCount"`
	// Agent virtual machine size
	AgentVmSize *string `pulumi:"agentVmSize"`
	// AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `pulumi:"aksNetworkingConfiguration"`
	// Cluster full qualified domain name
	ClusterFqdn *string `pulumi:"clusterFqdn"`
	// Intended usage of the cluster
	ClusterPurpose *string `pulumi:"clusterPurpose"`
	// Load Balancer Subnet
	LoadBalancerSubnet *string `pulumi:"loadBalancerSubnet"`
	// Load Balancer Type
	LoadBalancerType *string `pulumi:"loadBalancerType"`
	// SSL configuration
	SslConfiguration *SslConfiguration `pulumi:"sslConfiguration"`
}

// Defaults sets the appropriate defaults for AKSSchemaProperties
func (val *AKSSchemaProperties) Defaults() *AKSSchemaProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ClusterPurpose) {
		clusterPurpose_ := "FastProd"
		tmp.ClusterPurpose = &clusterPurpose_
	}
	if isZero(tmp.LoadBalancerType) {
		loadBalancerType_ := "PublicIp"
		tmp.LoadBalancerType = &loadBalancerType_
	}
	return &tmp
}

// AKS properties
type AKSSchemaResponseProperties struct {
	// Number of agents
	AgentCount *int `pulumi:"agentCount"`
	// Agent virtual machine size
	AgentVmSize *string `pulumi:"agentVmSize"`
	// AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfigurationResponse `pulumi:"aksNetworkingConfiguration"`
	// Cluster full qualified domain name
	ClusterFqdn *string `pulumi:"clusterFqdn"`
	// Intended usage of the cluster
	ClusterPurpose *string `pulumi:"clusterPurpose"`
	// Load Balancer Subnet
	LoadBalancerSubnet *string `pulumi:"loadBalancerSubnet"`
	// Load Balancer Type
	LoadBalancerType *string `pulumi:"loadBalancerType"`
	// SSL configuration
	SslConfiguration *SslConfigurationResponse `pulumi:"sslConfiguration"`
	// System services
	SystemServices []SystemServiceResponse `pulumi:"systemServices"`
}

// Defaults sets the appropriate defaults for AKSSchemaResponseProperties
func (val *AKSSchemaResponseProperties) Defaults() *AKSSchemaResponseProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ClusterPurpose) {
		clusterPurpose_ := "FastProd"
		tmp.ClusterPurpose = &clusterPurpose_
	}
	if isZero(tmp.LoadBalancerType) {
		loadBalancerType_ := "PublicIp"
		tmp.LoadBalancerType = &loadBalancerType_
	}
	return &tmp
}

// Account key datastore credentials configuration.
type AccountKeyDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'AccountKey'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] Storage account secrets.
	Secrets AccountKeyDatastoreSecrets `pulumi:"secrets"`
}

// Account key datastore credentials configuration.
type AccountKeyDatastoreCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'AccountKey'.
	CredentialsType string `pulumi:"credentialsType"`
}

// Datastore account key secrets.
type AccountKeyDatastoreSecrets struct {
	// Storage account key.
	Key *string `pulumi:"key"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'AccountKey'.
	SecretsType string `pulumi:"secretsType"`
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `pulumi:"dnsServiceIP"`
	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `pulumi:"dockerBridgeCidr"`
	// A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `pulumi:"serviceCidr"`
	// Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `pulumi:"subnetId"`
}

// Advance configuration for AKS networking
type AksNetworkingConfigurationResponse struct {
	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `pulumi:"dnsServiceIP"`
	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `pulumi:"dockerBridgeCidr"`
	// A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `pulumi:"serviceCidr"`
	// Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `pulumi:"subnetId"`
}

// An Azure Machine Learning compute.
type AmlCompute struct {
	// The type of compute
	// Expected value is 'AmlCompute'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of AmlCompute
	Properties *AmlComputeProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AmlCompute
func (val *AmlCompute) Defaults() *AmlCompute {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Compute node information related to a AmlCompute.
type AmlComputeNodeInformationResponse struct {
	// ID of the compute node.
	NodeId string `pulumi:"nodeId"`
	// State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
	NodeState string `pulumi:"nodeState"`
	// SSH port number of the node.
	Port float64 `pulumi:"port"`
	// Private IP address of the compute node.
	PrivateIpAddress string `pulumi:"privateIpAddress"`
	// Public IP address of the compute node.
	PublicIpAddress string `pulumi:"publicIpAddress"`
	// ID of the Experiment running on the node, if any else null.
	RunId string `pulumi:"runId"`
}

// Compute node information related to a AmlCompute.
type AmlComputeNodeInformationResponseOutput struct{ *pulumi.OutputState }

func (AmlComputeNodeInformationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AmlComputeNodeInformationResponse)(nil)).Elem()
}

func (o AmlComputeNodeInformationResponseOutput) ToAmlComputeNodeInformationResponseOutput() AmlComputeNodeInformationResponseOutput {
	return o
}

func (o AmlComputeNodeInformationResponseOutput) ToAmlComputeNodeInformationResponseOutputWithContext(ctx context.Context) AmlComputeNodeInformationResponseOutput {
	return o
}

// ID of the compute node.
func (o AmlComputeNodeInformationResponseOutput) NodeId() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.NodeId }).(pulumi.StringOutput)
}

// State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
func (o AmlComputeNodeInformationResponseOutput) NodeState() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.NodeState }).(pulumi.StringOutput)
}

// SSH port number of the node.
func (o AmlComputeNodeInformationResponseOutput) Port() pulumi.Float64Output {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) float64 { return v.Port }).(pulumi.Float64Output)
}

// Private IP address of the compute node.
func (o AmlComputeNodeInformationResponseOutput) PrivateIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.PrivateIpAddress }).(pulumi.StringOutput)
}

// Public IP address of the compute node.
func (o AmlComputeNodeInformationResponseOutput) PublicIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.PublicIpAddress }).(pulumi.StringOutput)
}

// ID of the Experiment running on the node, if any else null.
func (o AmlComputeNodeInformationResponseOutput) RunId() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.RunId }).(pulumi.StringOutput)
}

type AmlComputeNodeInformationResponseArrayOutput struct{ *pulumi.OutputState }

func (AmlComputeNodeInformationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AmlComputeNodeInformationResponse)(nil)).Elem()
}

func (o AmlComputeNodeInformationResponseArrayOutput) ToAmlComputeNodeInformationResponseArrayOutput() AmlComputeNodeInformationResponseArrayOutput {
	return o
}

func (o AmlComputeNodeInformationResponseArrayOutput) ToAmlComputeNodeInformationResponseArrayOutputWithContext(ctx context.Context) AmlComputeNodeInformationResponseArrayOutput {
	return o
}

func (o AmlComputeNodeInformationResponseArrayOutput) Index(i pulumi.IntInput) AmlComputeNodeInformationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AmlComputeNodeInformationResponse {
		return vs[0].([]AmlComputeNodeInformationResponse)[vs[1].(int)]
	}).(AmlComputeNodeInformationResponseOutput)
}

// AML Compute properties
type AmlComputeProperties struct {
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Network is isolated or not
	IsolatedNetwork *bool `pulumi:"isolatedNetwork"`
	// Compute OS Type
	OsType *string `pulumi:"osType"`
	// A property bag containing additional properties.
	PropertyBag interface{} `pulumi:"propertyBag"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
	RemoteLoginPortPublicAccess *string `pulumi:"remoteLoginPortPublicAccess"`
	// Scale settings for AML Compute
	ScaleSettings *ScaleSettings `pulumi:"scaleSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `pulumi:"subnet"`
	// Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `pulumi:"userAccountCredentials"`
	// Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `pulumi:"virtualMachineImage"`
	// Virtual Machine priority
	VmPriority *string `pulumi:"vmPriority"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for AmlComputeProperties
func (val *AmlComputeProperties) Defaults() *AmlComputeProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableNodePublicIp) {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	if isZero(tmp.OsType) {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	if isZero(tmp.RemoteLoginPortPublicAccess) {
		remoteLoginPortPublicAccess_ := "NotSpecified"
		tmp.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess_
	}
	tmp.ScaleSettings = tmp.ScaleSettings.Defaults()

	return &tmp
}

// AML Compute properties
type AmlComputePropertiesResponse struct {
	// Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
	AllocationState string `pulumi:"allocationState"`
	// The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime string `pulumi:"allocationStateTransitionTime"`
	// The number of compute nodes currently assigned to the compute.
	CurrentNodeCount int `pulumi:"currentNodeCount"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Collection of errors encountered by various compute nodes during node setup.
	Errors []ErrorResponseResponse `pulumi:"errors"`
	// Network is isolated or not
	IsolatedNetwork *bool `pulumi:"isolatedNetwork"`
	// Counts of various node states on the compute.
	NodeStateCounts NodeStateCountsResponse `pulumi:"nodeStateCounts"`
	// Compute OS Type
	OsType *string `pulumi:"osType"`
	// A property bag containing additional properties.
	PropertyBag interface{} `pulumi:"propertyBag"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
	RemoteLoginPortPublicAccess *string `pulumi:"remoteLoginPortPublicAccess"`
	// Scale settings for AML Compute
	ScaleSettings *ScaleSettingsResponse `pulumi:"scaleSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceIdResponse `pulumi:"subnet"`
	// The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
	TargetNodeCount int `pulumi:"targetNodeCount"`
	// Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentialsResponse `pulumi:"userAccountCredentials"`
	// Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImageResponse `pulumi:"virtualMachineImage"`
	// Virtual Machine priority
	VmPriority *string `pulumi:"vmPriority"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for AmlComputePropertiesResponse
func (val *AmlComputePropertiesResponse) Defaults() *AmlComputePropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableNodePublicIp) {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	if isZero(tmp.OsType) {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	if isZero(tmp.RemoteLoginPortPublicAccess) {
		remoteLoginPortPublicAccess_ := "NotSpecified"
		tmp.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess_
	}
	tmp.ScaleSettings = tmp.ScaleSettings.Defaults()

	return &tmp
}

// An Azure Machine Learning compute.
type AmlComputeResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AmlCompute'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of AmlCompute
	Properties *AmlComputePropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AmlComputeResponse
func (val *AmlComputeResponse) Defaults() *AmlComputeResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// AML Token identity configuration.
type AmlToken struct {
	// Enum to determine identity framework.
	// Expected value is 'AMLToken'.
	IdentityType string `pulumi:"identityType"`
}

// AML Token identity configuration.
type AmlTokenResponse struct {
	// Enum to determine identity framework.
	// Expected value is 'AMLToken'.
	IdentityType string `pulumi:"identityType"`
}

// A user that can be assigned to a compute instance.
type AssignedUser struct {
	// User’s AAD Object Id.
	ObjectId string `pulumi:"objectId"`
	// User’s AAD Tenant Id.
	TenantId string `pulumi:"tenantId"`
}

// A user that can be assigned to a compute instance.
type AssignedUserResponse struct {
	// User’s AAD Object Id.
	ObjectId string `pulumi:"objectId"`
	// User’s AAD Tenant Id.
	TenantId string `pulumi:"tenantId"`
}

// Forecast horizon determined automatically by system.
type AutoForecastHorizon struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Forecast horizon determined automatically by system.
type AutoForecastHorizonResponse struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// AutoMLJob class.
// Use this class for executing AutoML tasks like Classification/Regression etc.
// See TaskType enum for all the tasks supported.
type AutoMLJob struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The ARM resource ID of the Environment specification for the job.
	// This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'AutoML'.
	JobType string `pulumi:"jobType"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfiguration `pulumi:"resources"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] This represents scenario which can be one of Tables/NLP/Image
	TaskDetails interface{} `pulumi:"taskDetails"`
}

// Defaults sets the appropriate defaults for AutoMLJob
func (val *AutoMLJob) Defaults() *AutoMLJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// AutoMLJob class.
// Use this class for executing AutoML tasks like Classification/Regression etc.
// See TaskType enum for all the tasks supported.
type AutoMLJobResponse struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The ARM resource ID of the Environment specification for the job.
	// This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'AutoML'.
	JobType string `pulumi:"jobType"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfigurationResponse `pulumi:"resources"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] This represents scenario which can be one of Tables/NLP/Image
	TaskDetails interface{} `pulumi:"taskDetails"`
}

// Defaults sets the appropriate defaults for AutoMLJobResponse
func (val *AutoMLJobResponse) Defaults() *AutoMLJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// N-Cross validations determined automatically.
type AutoNCrossValidations struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// N-Cross validations determined automatically.
type AutoNCrossValidationsResponse struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int  `pulumi:"delayInMinutes"`
	Enabled        *bool `pulumi:"enabled"`
}

// Auto pause properties
type AutoPausePropertiesResponse struct {
	DelayInMinutes *int  `pulumi:"delayInMinutes"`
	Enabled        *bool `pulumi:"enabled"`
}

// Auto scale properties
type AutoScaleProperties struct {
	Enabled      *bool `pulumi:"enabled"`
	MaxNodeCount *int  `pulumi:"maxNodeCount"`
	MinNodeCount *int  `pulumi:"minNodeCount"`
}

// Auto scale properties
type AutoScalePropertiesResponse struct {
	Enabled      *bool `pulumi:"enabled"`
	MaxNodeCount *int  `pulumi:"maxNodeCount"`
	MinNodeCount *int  `pulumi:"minNodeCount"`
}

type AutoSeasonality struct {
	// Forecasting seasonality mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoSeasonalityResponse struct {
	// Forecasting seasonality mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoTargetLags struct {
	// Target lags selection modes.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoTargetLagsResponse struct {
	// Target lags selection modes.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Target lags rolling window determined automatically.
type AutoTargetRollingWindowSize struct {
	// Target rolling windows size mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Target lags rolling window determined automatically.
type AutoTargetRollingWindowSizeResponse struct {
	// Target rolling windows size mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Azure Blob datastore configuration.
type AzureBlobDatastore struct {
	// Storage account name.
	AccountName *string `pulumi:"accountName"`
	// Storage account container name.
	ContainerName *string `pulumi:"containerName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureBlob'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureBlobDatastore
func (val *AzureBlobDatastore) Defaults() *AzureBlobDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Blob datastore configuration.
type AzureBlobDatastoreResponse struct {
	// Storage account name.
	AccountName *string `pulumi:"accountName"`
	// Storage account container name.
	ContainerName *string `pulumi:"containerName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureBlob'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureBlobDatastoreResponse
func (val *AzureBlobDatastoreResponse) Defaults() *AzureBlobDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen1 datastore configuration.
type AzureDataLakeGen1Datastore struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen1'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// [Required] Azure Data Lake store name.
	StoreName string `pulumi:"storeName"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen1Datastore
func (val *AzureDataLakeGen1Datastore) Defaults() *AzureDataLakeGen1Datastore {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen1 datastore configuration.
type AzureDataLakeGen1DatastoreResponse struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen1'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// [Required] Azure Data Lake store name.
	StoreName string `pulumi:"storeName"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen1DatastoreResponse
func (val *AzureDataLakeGen1DatastoreResponse) Defaults() *AzureDataLakeGen1DatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen2 datastore configuration.
type AzureDataLakeGen2Datastore struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen2'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Data Lake Gen2 filesystem.
	Filesystem string `pulumi:"filesystem"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen2Datastore
func (val *AzureDataLakeGen2Datastore) Defaults() *AzureDataLakeGen2Datastore {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen2 datastore configuration.
type AzureDataLakeGen2DatastoreResponse struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen2'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Data Lake Gen2 filesystem.
	Filesystem string `pulumi:"filesystem"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen2DatastoreResponse
func (val *AzureDataLakeGen2DatastoreResponse) Defaults() *AzureDataLakeGen2DatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure File datastore configuration.
type AzureFileDatastore struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureFile'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Azure file share that the datastore points to.
	FileShareName string `pulumi:"fileShareName"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureFileDatastore
func (val *AzureFileDatastore) Defaults() *AzureFileDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure File datastore configuration.
type AzureFileDatastoreResponse struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureFile'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Azure file share that the datastore points to.
	FileShareName string `pulumi:"fileShareName"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureFileDatastoreResponse
func (val *AzureFileDatastoreResponse) Defaults() *AzureFileDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ServiceDataAccessAuthIdentity) {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
type BanditPolicy struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'Bandit'.
	PolicyType string `pulumi:"policyType"`
	// Absolute distance allowed from the best performing run.
	SlackAmount *float64 `pulumi:"slackAmount"`
	// Ratio of the allowed distance from the best performing run.
	SlackFactor *float64 `pulumi:"slackFactor"`
}

// Defaults sets the appropriate defaults for BanditPolicy
func (val *BanditPolicy) Defaults() *BanditPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if isZero(tmp.SlackAmount) {
		slackAmount_ := 0.0
		tmp.SlackAmount = &slackAmount_
	}
	if isZero(tmp.SlackFactor) {
		slackFactor_ := 0.0
		tmp.SlackFactor = &slackFactor_
	}
	return &tmp
}

// Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
type BanditPolicyResponse struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'Bandit'.
	PolicyType string `pulumi:"policyType"`
	// Absolute distance allowed from the best performing run.
	SlackAmount *float64 `pulumi:"slackAmount"`
	// Ratio of the allowed distance from the best performing run.
	SlackFactor *float64 `pulumi:"slackFactor"`
}

// Defaults sets the appropriate defaults for BanditPolicyResponse
func (val *BanditPolicyResponse) Defaults() *BanditPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if isZero(tmp.SlackAmount) {
		slackAmount_ := 0.0
		tmp.SlackAmount = &slackAmount_
	}
	if isZero(tmp.SlackFactor) {
		slackFactor_ := 0.0
		tmp.SlackFactor = &slackFactor_
	}
	return &tmp
}

// Batch inference settings per deployment.
type BatchDeploymentType struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute *string `pulumi:"compute"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold *int `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel *string `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance *int `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize *float64 `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model interface{} `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction *string `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName *string `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources *ResourceConfiguration `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings *BatchRetrySettings `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentType
func (val *BatchDeploymentType) Defaults() *BatchDeploymentType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ErrorThreshold) {
		errorThreshold_ := -1
		tmp.ErrorThreshold = &errorThreshold_
	}
	if isZero(tmp.LoggingLevel) {
		loggingLevel_ := "Info"
		tmp.LoggingLevel = &loggingLevel_
	}
	if isZero(tmp.MaxConcurrencyPerInstance) {
		maxConcurrencyPerInstance_ := 1
		tmp.MaxConcurrencyPerInstance = &maxConcurrencyPerInstance_
	}
	if isZero(tmp.MiniBatchSize) {
		miniBatchSize_ := 10.0
		tmp.MiniBatchSize = &miniBatchSize_
	}
	if isZero(tmp.OutputAction) {
		outputAction_ := "AppendRow"
		tmp.OutputAction = &outputAction_
	}
	if isZero(tmp.OutputFileName) {
		outputFileName_ := "predictions.csv"
		tmp.OutputFileName = &outputFileName_
	}
	tmp.Resources = tmp.Resources.Defaults()

	tmp.RetrySettings = tmp.RetrySettings.Defaults()

	return &tmp
}

// BatchDeploymentTypeInput is an input type that accepts BatchDeploymentTypeArgs and BatchDeploymentTypeOutput values.
// You can construct a concrete instance of `BatchDeploymentTypeInput` via:
//
//	BatchDeploymentTypeArgs{...}
type BatchDeploymentTypeInput interface {
	pulumi.Input

	ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput
	ToBatchDeploymentTypeOutputWithContext(context.Context) BatchDeploymentTypeOutput
}

// Batch inference settings per deployment.
type BatchDeploymentTypeArgs struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration CodeConfigurationPtrInput `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute pulumi.StringPtrInput `pulumi:"compute"`
	// Description of the endpoint deployment.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId pulumi.StringPtrInput `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables pulumi.StringMapInput `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold pulumi.IntPtrInput `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel pulumi.StringPtrInput `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance pulumi.IntPtrInput `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize pulumi.Float64PtrInput `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model pulumi.Input `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction pulumi.StringPtrInput `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName pulumi.StringPtrInput `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources ResourceConfigurationPtrInput `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings BatchRetrySettingsPtrInput `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentTypeArgs
func (val *BatchDeploymentTypeArgs) Defaults() *BatchDeploymentTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ErrorThreshold) {
		tmp.ErrorThreshold = pulumi.IntPtr(-1)
	}
	if isZero(tmp.LoggingLevel) {
		tmp.LoggingLevel = pulumi.StringPtr("Info")
	}
	if isZero(tmp.MaxConcurrencyPerInstance) {
		tmp.MaxConcurrencyPerInstance = pulumi.IntPtr(1)
	}
	if isZero(tmp.MiniBatchSize) {
		tmp.MiniBatchSize = pulumi.Float64Ptr(10.0)
	}
	if isZero(tmp.OutputAction) {
		tmp.OutputAction = pulumi.StringPtr("AppendRow")
	}
	if isZero(tmp.OutputFileName) {
		tmp.OutputFileName = pulumi.StringPtr("predictions.csv")
	}

	return &tmp
}
func (BatchDeploymentTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentType)(nil)).Elem()
}

func (i BatchDeploymentTypeArgs) ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput {
	return i.ToBatchDeploymentTypeOutputWithContext(context.Background())
}

func (i BatchDeploymentTypeArgs) ToBatchDeploymentTypeOutputWithContext(ctx context.Context) BatchDeploymentTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchDeploymentTypeOutput)
}

// Batch inference settings per deployment.
type BatchDeploymentTypeOutput struct{ *pulumi.OutputState }

func (BatchDeploymentTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentType)(nil)).Elem()
}

func (o BatchDeploymentTypeOutput) ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput {
	return o
}

func (o BatchDeploymentTypeOutput) ToBatchDeploymentTypeOutputWithContext(ctx context.Context) BatchDeploymentTypeOutput {
	return o
}

// Code configuration for the endpoint deployment.
func (o BatchDeploymentTypeOutput) CodeConfiguration() CodeConfigurationPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *CodeConfiguration { return v.CodeConfiguration }).(CodeConfigurationPtrOutput)
}

// Compute target for batch inference operation.
func (o BatchDeploymentTypeOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the endpoint deployment.
func (o BatchDeploymentTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the environment specification for the endpoint deployment.
func (o BatchDeploymentTypeOutput) EnvironmentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.EnvironmentId }).(pulumi.StringPtrOutput)
}

// Environment variables configuration for the deployment.
func (o BatchDeploymentTypeOutput) EnvironmentVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentType) map[string]string { return v.EnvironmentVariables }).(pulumi.StringMapOutput)
}

// Error threshold, if the error count for the entire input goes above this value,
// the batch inference will be aborted. Range is [-1, int.MaxValue].
// For FileDataset, this value is the count of file failures.
// For TabularDataset, this value is the count of record failures.
// If set to -1 (the lower bound), all failures during batch inference will be ignored.
func (o BatchDeploymentTypeOutput) ErrorThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *int { return v.ErrorThreshold }).(pulumi.IntPtrOutput)
}

// Logging level for batch inference operation.
func (o BatchDeploymentTypeOutput) LoggingLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.LoggingLevel }).(pulumi.StringPtrOutput)
}

// Indicates maximum number of parallelism per instance.
func (o BatchDeploymentTypeOutput) MaxConcurrencyPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *int { return v.MaxConcurrencyPerInstance }).(pulumi.IntPtrOutput)
}

// Size of the mini-batch passed to each batch invocation.
// For FileDataset, this is the number of files per mini-batch.
// For TabularDataset, this is the size of the records in bytes, per mini-batch.
func (o BatchDeploymentTypeOutput) MiniBatchSize() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *float64 { return v.MiniBatchSize }).(pulumi.Float64PtrOutput)
}

// Reference to the model asset for the endpoint deployment.
func (o BatchDeploymentTypeOutput) Model() pulumi.AnyOutput {
	return o.ApplyT(func(v BatchDeploymentType) interface{} { return v.Model }).(pulumi.AnyOutput)
}

// Indicates how the output will be organized.
func (o BatchDeploymentTypeOutput) OutputAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.OutputAction }).(pulumi.StringPtrOutput)
}

// Customized output file name for append_row output action.
func (o BatchDeploymentTypeOutput) OutputFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.OutputFileName }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchDeploymentTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Indicates compute configuration for the job.
// If not provided, will default to the defaults defined in ResourceConfiguration.
func (o BatchDeploymentTypeOutput) Resources() ResourceConfigurationPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *ResourceConfiguration { return v.Resources }).(ResourceConfigurationPtrOutput)
}

// Retry Settings for the batch inference operation.
// If not provided, will default to the defaults defined in BatchRetrySettings.
func (o BatchDeploymentTypeOutput) RetrySettings() BatchRetrySettingsPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *BatchRetrySettings { return v.RetrySettings }).(BatchRetrySettingsPtrOutput)
}

// Batch inference settings per deployment.
type BatchDeploymentResponse struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute *string `pulumi:"compute"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold *int `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel *string `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance *int `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize *float64 `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model interface{} `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction *string `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName *string `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources *ResourceConfigurationResponse `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings *BatchRetrySettingsResponse `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentResponse
func (val *BatchDeploymentResponse) Defaults() *BatchDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ErrorThreshold) {
		errorThreshold_ := -1
		tmp.ErrorThreshold = &errorThreshold_
	}
	if isZero(tmp.LoggingLevel) {
		loggingLevel_ := "Info"
		tmp.LoggingLevel = &loggingLevel_
	}
	if isZero(tmp.MaxConcurrencyPerInstance) {
		maxConcurrencyPerInstance_ := 1
		tmp.MaxConcurrencyPerInstance = &maxConcurrencyPerInstance_
	}
	if isZero(tmp.MiniBatchSize) {
		miniBatchSize_ := 10.0
		tmp.MiniBatchSize = &miniBatchSize_
	}
	if isZero(tmp.OutputAction) {
		outputAction_ := "AppendRow"
		tmp.OutputAction = &outputAction_
	}
	if isZero(tmp.OutputFileName) {
		outputFileName_ := "predictions.csv"
		tmp.OutputFileName = &outputFileName_
	}
	tmp.Resources = tmp.Resources.Defaults()

	tmp.RetrySettings = tmp.RetrySettings.Defaults()

	return &tmp
}

// Batch inference settings per deployment.
type BatchDeploymentResponseOutput struct{ *pulumi.OutputState }

func (BatchDeploymentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentResponse)(nil)).Elem()
}

func (o BatchDeploymentResponseOutput) ToBatchDeploymentResponseOutput() BatchDeploymentResponseOutput {
	return o
}

func (o BatchDeploymentResponseOutput) ToBatchDeploymentResponseOutputWithContext(ctx context.Context) BatchDeploymentResponseOutput {
	return o
}

// Code configuration for the endpoint deployment.
func (o BatchDeploymentResponseOutput) CodeConfiguration() CodeConfigurationResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *CodeConfigurationResponse { return v.CodeConfiguration }).(CodeConfigurationResponsePtrOutput)
}

// Compute target for batch inference operation.
func (o BatchDeploymentResponseOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the endpoint deployment.
func (o BatchDeploymentResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the environment specification for the endpoint deployment.
func (o BatchDeploymentResponseOutput) EnvironmentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.EnvironmentId }).(pulumi.StringPtrOutput)
}

// Environment variables configuration for the deployment.
func (o BatchDeploymentResponseOutput) EnvironmentVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) map[string]string { return v.EnvironmentVariables }).(pulumi.StringMapOutput)
}

// Error threshold, if the error count for the entire input goes above this value,
// the batch inference will be aborted. Range is [-1, int.MaxValue].
// For FileDataset, this value is the count of file failures.
// For TabularDataset, this value is the count of record failures.
// If set to -1 (the lower bound), all failures during batch inference will be ignored.
func (o BatchDeploymentResponseOutput) ErrorThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *int { return v.ErrorThreshold }).(pulumi.IntPtrOutput)
}

// Logging level for batch inference operation.
func (o BatchDeploymentResponseOutput) LoggingLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.LoggingLevel }).(pulumi.StringPtrOutput)
}

// Indicates maximum number of parallelism per instance.
func (o BatchDeploymentResponseOutput) MaxConcurrencyPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *int { return v.MaxConcurrencyPerInstance }).(pulumi.IntPtrOutput)
}

// Size of the mini-batch passed to each batch invocation.
// For FileDataset, this is the number of files per mini-batch.
// For TabularDataset, this is the size of the records in bytes, per mini-batch.
func (o BatchDeploymentResponseOutput) MiniBatchSize() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *float64 { return v.MiniBatchSize }).(pulumi.Float64PtrOutput)
}

// Reference to the model asset for the endpoint deployment.
func (o BatchDeploymentResponseOutput) Model() pulumi.AnyOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) interface{} { return v.Model }).(pulumi.AnyOutput)
}

// Indicates how the output will be organized.
func (o BatchDeploymentResponseOutput) OutputAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.OutputAction }).(pulumi.StringPtrOutput)
}

// Customized output file name for append_row output action.
func (o BatchDeploymentResponseOutput) OutputFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.OutputFileName }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchDeploymentResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint deployment.
func (o BatchDeploymentResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Indicates compute configuration for the job.
// If not provided, will default to the defaults defined in ResourceConfiguration.
func (o BatchDeploymentResponseOutput) Resources() ResourceConfigurationResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *ResourceConfigurationResponse { return v.Resources }).(ResourceConfigurationResponsePtrOutput)
}

// Retry Settings for the batch inference operation.
// If not provided, will default to the defaults defined in BatchRetrySettings.
func (o BatchDeploymentResponseOutput) RetrySettings() BatchRetrySettingsResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *BatchRetrySettingsResponse { return v.RetrySettings }).(BatchRetrySettingsResponsePtrOutput)
}

// Batch endpoint configuration.
type BatchEndpointType struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// Default values for Batch Endpoint
	Defaults *BatchEndpointDefaults `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `pulumi:"keys"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
}

// BatchEndpointTypeInput is an input type that accepts BatchEndpointTypeArgs and BatchEndpointTypeOutput values.
// You can construct a concrete instance of `BatchEndpointTypeInput` via:
//
//	BatchEndpointTypeArgs{...}
type BatchEndpointTypeInput interface {
	pulumi.Input

	ToBatchEndpointTypeOutput() BatchEndpointTypeOutput
	ToBatchEndpointTypeOutputWithContext(context.Context) BatchEndpointTypeOutput
}

// Batch endpoint configuration.
type BatchEndpointTypeArgs struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode pulumi.StringInput `pulumi:"authMode"`
	// Default values for Batch Endpoint
	Defaults BatchEndpointDefaultsPtrInput `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys EndpointAuthKeysPtrInput `pulumi:"keys"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
}

func (BatchEndpointTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointType)(nil)).Elem()
}

func (i BatchEndpointTypeArgs) ToBatchEndpointTypeOutput() BatchEndpointTypeOutput {
	return i.ToBatchEndpointTypeOutputWithContext(context.Background())
}

func (i BatchEndpointTypeArgs) ToBatchEndpointTypeOutputWithContext(ctx context.Context) BatchEndpointTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointTypeOutput)
}

// Batch endpoint configuration.
type BatchEndpointTypeOutput struct{ *pulumi.OutputState }

func (BatchEndpointTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointType)(nil)).Elem()
}

func (o BatchEndpointTypeOutput) ToBatchEndpointTypeOutput() BatchEndpointTypeOutput {
	return o
}

func (o BatchEndpointTypeOutput) ToBatchEndpointTypeOutputWithContext(ctx context.Context) BatchEndpointTypeOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o BatchEndpointTypeOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointType) string { return v.AuthMode }).(pulumi.StringOutput)
}

// Default values for Batch Endpoint
func (o BatchEndpointTypeOutput) Defaults() BatchEndpointDefaultsPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *BatchEndpointDefaults { return v.Defaults }).(BatchEndpointDefaultsPtrOutput)
}

// Description of the inference endpoint.
func (o BatchEndpointTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// EndpointAuthKeys to set initially on an Endpoint.
// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
func (o BatchEndpointTypeOutput) Keys() EndpointAuthKeysPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *EndpointAuthKeys { return v.Keys }).(EndpointAuthKeysPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchEndpointTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchEndpointType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Batch endpoint default values
type BatchEndpointDefaults struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName *string `pulumi:"deploymentName"`
}

// BatchEndpointDefaultsInput is an input type that accepts BatchEndpointDefaultsArgs and BatchEndpointDefaultsOutput values.
// You can construct a concrete instance of `BatchEndpointDefaultsInput` via:
//
//	BatchEndpointDefaultsArgs{...}
type BatchEndpointDefaultsInput interface {
	pulumi.Input

	ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput
	ToBatchEndpointDefaultsOutputWithContext(context.Context) BatchEndpointDefaultsOutput
}

// Batch endpoint default values
type BatchEndpointDefaultsArgs struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName pulumi.StringPtrInput `pulumi:"deploymentName"`
}

func (BatchEndpointDefaultsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaults)(nil)).Elem()
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput {
	return i.ToBatchEndpointDefaultsOutputWithContext(context.Background())
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsOutputWithContext(ctx context.Context) BatchEndpointDefaultsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsOutput)
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return i.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsOutput).ToBatchEndpointDefaultsPtrOutputWithContext(ctx)
}

// BatchEndpointDefaultsPtrInput is an input type that accepts BatchEndpointDefaultsArgs, BatchEndpointDefaultsPtr and BatchEndpointDefaultsPtrOutput values.
// You can construct a concrete instance of `BatchEndpointDefaultsPtrInput` via:
//
//	        BatchEndpointDefaultsArgs{...}
//
//	or:
//
//	        nil
type BatchEndpointDefaultsPtrInput interface {
	pulumi.Input

	ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput
	ToBatchEndpointDefaultsPtrOutputWithContext(context.Context) BatchEndpointDefaultsPtrOutput
}

type batchEndpointDefaultsPtrType BatchEndpointDefaultsArgs

func BatchEndpointDefaultsPtr(v *BatchEndpointDefaultsArgs) BatchEndpointDefaultsPtrInput {
	return (*batchEndpointDefaultsPtrType)(v)
}

func (*batchEndpointDefaultsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaults)(nil)).Elem()
}

func (i *batchEndpointDefaultsPtrType) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return i.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (i *batchEndpointDefaultsPtrType) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsPtrOutput)
}

// Batch endpoint default values
type BatchEndpointDefaultsOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaults)(nil)).Elem()
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput {
	return o
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsOutputWithContext(ctx context.Context) BatchEndpointDefaultsOutput {
	return o
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return o.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BatchEndpointDefaults) *BatchEndpointDefaults {
		return &v
	}).(BatchEndpointDefaultsPtrOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointDefaults) *string { return v.DeploymentName }).(pulumi.StringPtrOutput)
}

type BatchEndpointDefaultsPtrOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaults)(nil)).Elem()
}

func (o BatchEndpointDefaultsPtrOutput) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return o
}

func (o BatchEndpointDefaultsPtrOutput) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return o
}

func (o BatchEndpointDefaultsPtrOutput) Elem() BatchEndpointDefaultsOutput {
	return o.ApplyT(func(v *BatchEndpointDefaults) BatchEndpointDefaults {
		if v != nil {
			return *v
		}
		var ret BatchEndpointDefaults
		return ret
	}).(BatchEndpointDefaultsOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsPtrOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchEndpointDefaults) *string {
		if v == nil {
			return nil
		}
		return v.DeploymentName
	}).(pulumi.StringPtrOutput)
}

// Batch endpoint default values
type BatchEndpointDefaultsResponse struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName *string `pulumi:"deploymentName"`
}

// Batch endpoint default values
type BatchEndpointDefaultsResponseOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaultsResponse)(nil)).Elem()
}

func (o BatchEndpointDefaultsResponseOutput) ToBatchEndpointDefaultsResponseOutput() BatchEndpointDefaultsResponseOutput {
	return o
}

func (o BatchEndpointDefaultsResponseOutput) ToBatchEndpointDefaultsResponseOutputWithContext(ctx context.Context) BatchEndpointDefaultsResponseOutput {
	return o
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsResponseOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointDefaultsResponse) *string { return v.DeploymentName }).(pulumi.StringPtrOutput)
}

type BatchEndpointDefaultsResponsePtrOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaultsResponse)(nil)).Elem()
}

func (o BatchEndpointDefaultsResponsePtrOutput) ToBatchEndpointDefaultsResponsePtrOutput() BatchEndpointDefaultsResponsePtrOutput {
	return o
}

func (o BatchEndpointDefaultsResponsePtrOutput) ToBatchEndpointDefaultsResponsePtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsResponsePtrOutput {
	return o
}

func (o BatchEndpointDefaultsResponsePtrOutput) Elem() BatchEndpointDefaultsResponseOutput {
	return o.ApplyT(func(v *BatchEndpointDefaultsResponse) BatchEndpointDefaultsResponse {
		if v != nil {
			return *v
		}
		var ret BatchEndpointDefaultsResponse
		return ret
	}).(BatchEndpointDefaultsResponseOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsResponsePtrOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchEndpointDefaultsResponse) *string {
		if v == nil {
			return nil
		}
		return v.DeploymentName
	}).(pulumi.StringPtrOutput)
}

// Batch endpoint configuration.
type BatchEndpointResponse struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// Default values for Batch Endpoint
	Defaults *BatchEndpointDefaultsResponse `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint.
	ProvisioningState string `pulumi:"provisioningState"`
	// Endpoint URI.
	ScoringUri string `pulumi:"scoringUri"`
	// Endpoint Swagger URI.
	SwaggerUri string `pulumi:"swaggerUri"`
}

// Batch endpoint configuration.
type BatchEndpointResponseOutput struct{ *pulumi.OutputState }

func (BatchEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointResponse)(nil)).Elem()
}

func (o BatchEndpointResponseOutput) ToBatchEndpointResponseOutput() BatchEndpointResponseOutput {
	return o
}

func (o BatchEndpointResponseOutput) ToBatchEndpointResponseOutputWithContext(ctx context.Context) BatchEndpointResponseOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o BatchEndpointResponseOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.AuthMode }).(pulumi.StringOutput)
}

// Default values for Batch Endpoint
func (o BatchEndpointResponseOutput) Defaults() BatchEndpointDefaultsResponsePtrOutput {
	return o.ApplyT(func(v BatchEndpointResponse) *BatchEndpointDefaultsResponse { return v.Defaults }).(BatchEndpointDefaultsResponsePtrOutput)
}

// Description of the inference endpoint.
func (o BatchEndpointResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchEndpointResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchEndpointResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint.
func (o BatchEndpointResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Endpoint URI.
func (o BatchEndpointResponseOutput) ScoringUri() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.ScoringUri }).(pulumi.StringOutput)
}

// Endpoint Swagger URI.
func (o BatchEndpointResponseOutput) SwaggerUri() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.SwaggerUri }).(pulumi.StringOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettings struct {
	// Maximum retry count for a mini-batch
	MaxRetries *int `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettings
func (val *BatchRetrySettings) Defaults() *BatchRetrySettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxRetries) {
		maxRetries_ := 3
		tmp.MaxRetries = &maxRetries_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT30S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// BatchRetrySettingsInput is an input type that accepts BatchRetrySettingsArgs and BatchRetrySettingsOutput values.
// You can construct a concrete instance of `BatchRetrySettingsInput` via:
//
//	BatchRetrySettingsArgs{...}
type BatchRetrySettingsInput interface {
	pulumi.Input

	ToBatchRetrySettingsOutput() BatchRetrySettingsOutput
	ToBatchRetrySettingsOutputWithContext(context.Context) BatchRetrySettingsOutput
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsArgs struct {
	// Maximum retry count for a mini-batch
	MaxRetries pulumi.IntPtrInput `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout pulumi.StringPtrInput `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettingsArgs
func (val *BatchRetrySettingsArgs) Defaults() *BatchRetrySettingsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxRetries) {
		tmp.MaxRetries = pulumi.IntPtr(3)
	}
	if isZero(tmp.Timeout) {
		tmp.Timeout = pulumi.StringPtr("PT30S")
	}
	return &tmp
}
func (BatchRetrySettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettings)(nil)).Elem()
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsOutput() BatchRetrySettingsOutput {
	return i.ToBatchRetrySettingsOutputWithContext(context.Background())
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsOutputWithContext(ctx context.Context) BatchRetrySettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsOutput)
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return i.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsOutput).ToBatchRetrySettingsPtrOutputWithContext(ctx)
}

// BatchRetrySettingsPtrInput is an input type that accepts BatchRetrySettingsArgs, BatchRetrySettingsPtr and BatchRetrySettingsPtrOutput values.
// You can construct a concrete instance of `BatchRetrySettingsPtrInput` via:
//
//	        BatchRetrySettingsArgs{...}
//
//	or:
//
//	        nil
type BatchRetrySettingsPtrInput interface {
	pulumi.Input

	ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput
	ToBatchRetrySettingsPtrOutputWithContext(context.Context) BatchRetrySettingsPtrOutput
}

type batchRetrySettingsPtrType BatchRetrySettingsArgs

func BatchRetrySettingsPtr(v *BatchRetrySettingsArgs) BatchRetrySettingsPtrInput {
	return (*batchRetrySettingsPtrType)(v)
}

func (*batchRetrySettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettings)(nil)).Elem()
}

func (i *batchRetrySettingsPtrType) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return i.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (i *batchRetrySettingsPtrType) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsPtrOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettings)(nil)).Elem()
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsOutput() BatchRetrySettingsOutput {
	return o
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsOutputWithContext(ctx context.Context) BatchRetrySettingsOutput {
	return o
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return o.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BatchRetrySettings) *BatchRetrySettings {
		return &v
	}).(BatchRetrySettingsPtrOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchRetrySettings) *int { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchRetrySettings) *string { return v.Timeout }).(pulumi.StringPtrOutput)
}

type BatchRetrySettingsPtrOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettings)(nil)).Elem()
}

func (o BatchRetrySettingsPtrOutput) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return o
}

func (o BatchRetrySettingsPtrOutput) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return o
}

func (o BatchRetrySettingsPtrOutput) Elem() BatchRetrySettingsOutput {
	return o.ApplyT(func(v *BatchRetrySettings) BatchRetrySettings {
		if v != nil {
			return *v
		}
		var ret BatchRetrySettings
		return ret
	}).(BatchRetrySettingsOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsPtrOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettings) *int {
		if v == nil {
			return nil
		}
		return v.MaxRetries
	}).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsPtrOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettings) *string {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.StringPtrOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsResponse struct {
	// Maximum retry count for a mini-batch
	MaxRetries *int `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettingsResponse
func (val *BatchRetrySettingsResponse) Defaults() *BatchRetrySettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxRetries) {
		maxRetries_ := 3
		tmp.MaxRetries = &maxRetries_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT30S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsResponseOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettingsResponse)(nil)).Elem()
}

func (o BatchRetrySettingsResponseOutput) ToBatchRetrySettingsResponseOutput() BatchRetrySettingsResponseOutput {
	return o
}

func (o BatchRetrySettingsResponseOutput) ToBatchRetrySettingsResponseOutputWithContext(ctx context.Context) BatchRetrySettingsResponseOutput {
	return o
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsResponseOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchRetrySettingsResponse) *int { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsResponseOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchRetrySettingsResponse) *string { return v.Timeout }).(pulumi.StringPtrOutput)
}

type BatchRetrySettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettingsResponse)(nil)).Elem()
}

func (o BatchRetrySettingsResponsePtrOutput) ToBatchRetrySettingsResponsePtrOutput() BatchRetrySettingsResponsePtrOutput {
	return o
}

func (o BatchRetrySettingsResponsePtrOutput) ToBatchRetrySettingsResponsePtrOutputWithContext(ctx context.Context) BatchRetrySettingsResponsePtrOutput {
	return o
}

func (o BatchRetrySettingsResponsePtrOutput) Elem() BatchRetrySettingsResponseOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) BatchRetrySettingsResponse {
		if v != nil {
			return *v
		}
		var ret BatchRetrySettingsResponse
		return ret
	}).(BatchRetrySettingsResponseOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsResponsePtrOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxRetries
	}).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsResponsePtrOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.StringPtrOutput)
}

// Defines a Sampling Algorithm that generates values based on previous values
type BayesianSamplingAlgorithm struct {
	// Expected value is 'Bayesian'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// Defines a Sampling Algorithm that generates values based on previous values
type BayesianSamplingAlgorithmResponse struct {
	// Expected value is 'Bayesian'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// Configuration settings for Docker build context
type BuildContext struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri string `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath *string `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContext
func (val *BuildContext) Defaults() *BuildContext {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DockerfilePath) {
		dockerfilePath_ := "Dockerfile"
		tmp.DockerfilePath = &dockerfilePath_
	}
	return &tmp
}

// BuildContextInput is an input type that accepts BuildContextArgs and BuildContextOutput values.
// You can construct a concrete instance of `BuildContextInput` via:
//
//	BuildContextArgs{...}
type BuildContextInput interface {
	pulumi.Input

	ToBuildContextOutput() BuildContextOutput
	ToBuildContextOutputWithContext(context.Context) BuildContextOutput
}

// Configuration settings for Docker build context
type BuildContextArgs struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri pulumi.StringInput `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath pulumi.StringPtrInput `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContextArgs
func (val *BuildContextArgs) Defaults() *BuildContextArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DockerfilePath) {
		tmp.DockerfilePath = pulumi.StringPtr("Dockerfile")
	}
	return &tmp
}
func (BuildContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (i BuildContextArgs) ToBuildContextOutput() BuildContextOutput {
	return i.ToBuildContextOutputWithContext(context.Background())
}

func (i BuildContextArgs) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextOutput)
}

func (i BuildContextArgs) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return i.ToBuildContextPtrOutputWithContext(context.Background())
}

func (i BuildContextArgs) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextOutput).ToBuildContextPtrOutputWithContext(ctx)
}

// BuildContextPtrInput is an input type that accepts BuildContextArgs, BuildContextPtr and BuildContextPtrOutput values.
// You can construct a concrete instance of `BuildContextPtrInput` via:
//
//	        BuildContextArgs{...}
//
//	or:
//
//	        nil
type BuildContextPtrInput interface {
	pulumi.Input

	ToBuildContextPtrOutput() BuildContextPtrOutput
	ToBuildContextPtrOutputWithContext(context.Context) BuildContextPtrOutput
}

type buildContextPtrType BuildContextArgs

func BuildContextPtr(v *BuildContextArgs) BuildContextPtrInput {
	return (*buildContextPtrType)(v)
}

func (*buildContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContext)(nil)).Elem()
}

func (i *buildContextPtrType) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return i.ToBuildContextPtrOutputWithContext(context.Background())
}

func (i *buildContextPtrType) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextPtrOutput)
}

// Configuration settings for Docker build context
type BuildContextOutput struct{ *pulumi.OutputState }

func (BuildContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (o BuildContextOutput) ToBuildContextOutput() BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return o.ToBuildContextPtrOutputWithContext(context.Background())
}

func (o BuildContextOutput) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuildContext) *BuildContext {
		return &v
	}).(BuildContextPtrOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextOutput) ContextUri() pulumi.StringOutput {
	return o.ApplyT(func(v BuildContext) string { return v.ContextUri }).(pulumi.StringOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildContext) *string { return v.DockerfilePath }).(pulumi.StringPtrOutput)
}

type BuildContextPtrOutput struct{ *pulumi.OutputState }

func (BuildContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContext)(nil)).Elem()
}

func (o BuildContextPtrOutput) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return o
}

func (o BuildContextPtrOutput) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return o
}

func (o BuildContextPtrOutput) Elem() BuildContextOutput {
	return o.ApplyT(func(v *BuildContext) BuildContext {
		if v != nil {
			return *v
		}
		var ret BuildContext
		return ret
	}).(BuildContextOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextPtrOutput) ContextUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContext) *string {
		if v == nil {
			return nil
		}
		return &v.ContextUri
	}).(pulumi.StringPtrOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextPtrOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContext) *string {
		if v == nil {
			return nil
		}
		return v.DockerfilePath
	}).(pulumi.StringPtrOutput)
}

// Configuration settings for Docker build context
type BuildContextResponse struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri string `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath *string `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContextResponse
func (val *BuildContextResponse) Defaults() *BuildContextResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DockerfilePath) {
		dockerfilePath_ := "Dockerfile"
		tmp.DockerfilePath = &dockerfilePath_
	}
	return &tmp
}

// Configuration settings for Docker build context
type BuildContextResponseOutput struct{ *pulumi.OutputState }

func (BuildContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContextResponse)(nil)).Elem()
}

func (o BuildContextResponseOutput) ToBuildContextResponseOutput() BuildContextResponseOutput {
	return o
}

func (o BuildContextResponseOutput) ToBuildContextResponseOutputWithContext(ctx context.Context) BuildContextResponseOutput {
	return o
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextResponseOutput) ContextUri() pulumi.StringOutput {
	return o.ApplyT(func(v BuildContextResponse) string { return v.ContextUri }).(pulumi.StringOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextResponseOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildContextResponse) *string { return v.DockerfilePath }).(pulumi.StringPtrOutput)
}

type BuildContextResponsePtrOutput struct{ *pulumi.OutputState }

func (BuildContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContextResponse)(nil)).Elem()
}

func (o BuildContextResponsePtrOutput) ToBuildContextResponsePtrOutput() BuildContextResponsePtrOutput {
	return o
}

func (o BuildContextResponsePtrOutput) ToBuildContextResponsePtrOutputWithContext(ctx context.Context) BuildContextResponsePtrOutput {
	return o
}

func (o BuildContextResponsePtrOutput) Elem() BuildContextResponseOutput {
	return o.ApplyT(func(v *BuildContextResponse) BuildContextResponse {
		if v != nil {
			return *v
		}
		var ret BuildContextResponse
		return ret
	}).(BuildContextResponseOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextResponsePtrOutput) ContextUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContextUri
	}).(pulumi.StringPtrOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextResponsePtrOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContextResponse) *string {
		if v == nil {
			return nil
		}
		return v.DockerfilePath
	}).(pulumi.StringPtrOutput)
}

// Certificate datastore credentials configuration.
type CertificateDatastoreCredentials struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'Certificate'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] Service principal secrets.
	Secrets CertificateDatastoreSecrets `pulumi:"secrets"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
	// [Required] Thumbprint of the certificate used for authentication.
	Thumbprint string `pulumi:"thumbprint"`
}

// Certificate datastore credentials configuration.
type CertificateDatastoreCredentialsResponse struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'Certificate'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
	// [Required] Thumbprint of the certificate used for authentication.
	Thumbprint string `pulumi:"thumbprint"`
}

// Datastore certificate secrets.
type CertificateDatastoreSecrets struct {
	// Service principal certificate.
	Certificate *string `pulumi:"certificate"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'Certificate'.
	SecretsType string `pulumi:"secretsType"`
}

// Classification task in AutoML Table vertical.
type Classification struct {
	// Allowed models for classification task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for classification task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for the task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Classification'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettings `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for Classification
func (val *Classification) Defaults() *Classification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "AUCWeighted"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

// Classification task in AutoML Table vertical.
type ClassificationResponse struct {
	// Allowed models for classification task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for classification task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for the task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Classification'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettingsResponse `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for ClassificationResponse
func (val *ClassificationResponse) Defaults() *ClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "AUCWeighted"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

// Configuration for a scoring code asset.
type CodeConfiguration struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript string `pulumi:"scoringScript"`
}

// CodeConfigurationInput is an input type that accepts CodeConfigurationArgs and CodeConfigurationOutput values.
// You can construct a concrete instance of `CodeConfigurationInput` via:
//
//	CodeConfigurationArgs{...}
type CodeConfigurationInput interface {
	pulumi.Input

	ToCodeConfigurationOutput() CodeConfigurationOutput
	ToCodeConfigurationOutputWithContext(context.Context) CodeConfigurationOutput
}

// Configuration for a scoring code asset.
type CodeConfigurationArgs struct {
	// ARM resource ID of the code asset.
	CodeId pulumi.StringPtrInput `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript pulumi.StringInput `pulumi:"scoringScript"`
}

func (CodeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfiguration)(nil)).Elem()
}

func (i CodeConfigurationArgs) ToCodeConfigurationOutput() CodeConfigurationOutput {
	return i.ToCodeConfigurationOutputWithContext(context.Background())
}

func (i CodeConfigurationArgs) ToCodeConfigurationOutputWithContext(ctx context.Context) CodeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationOutput)
}

func (i CodeConfigurationArgs) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return i.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (i CodeConfigurationArgs) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationOutput).ToCodeConfigurationPtrOutputWithContext(ctx)
}

// CodeConfigurationPtrInput is an input type that accepts CodeConfigurationArgs, CodeConfigurationPtr and CodeConfigurationPtrOutput values.
// You can construct a concrete instance of `CodeConfigurationPtrInput` via:
//
//	        CodeConfigurationArgs{...}
//
//	or:
//
//	        nil
type CodeConfigurationPtrInput interface {
	pulumi.Input

	ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput
	ToCodeConfigurationPtrOutputWithContext(context.Context) CodeConfigurationPtrOutput
}

type codeConfigurationPtrType CodeConfigurationArgs

func CodeConfigurationPtr(v *CodeConfigurationArgs) CodeConfigurationPtrInput {
	return (*codeConfigurationPtrType)(v)
}

func (*codeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfiguration)(nil)).Elem()
}

func (i *codeConfigurationPtrType) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return i.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (i *codeConfigurationPtrType) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationPtrOutput)
}

// Configuration for a scoring code asset.
type CodeConfigurationOutput struct{ *pulumi.OutputState }

func (CodeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfiguration)(nil)).Elem()
}

func (o CodeConfigurationOutput) ToCodeConfigurationOutput() CodeConfigurationOutput {
	return o
}

func (o CodeConfigurationOutput) ToCodeConfigurationOutputWithContext(ctx context.Context) CodeConfigurationOutput {
	return o
}

func (o CodeConfigurationOutput) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return o.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (o CodeConfigurationOutput) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CodeConfiguration) *CodeConfiguration {
		return &v
	}).(CodeConfigurationPtrOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeConfiguration) *string { return v.CodeId }).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationOutput) ScoringScript() pulumi.StringOutput {
	return o.ApplyT(func(v CodeConfiguration) string { return v.ScoringScript }).(pulumi.StringOutput)
}

type CodeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CodeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfiguration)(nil)).Elem()
}

func (o CodeConfigurationPtrOutput) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return o
}

func (o CodeConfigurationPtrOutput) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return o
}

func (o CodeConfigurationPtrOutput) Elem() CodeConfigurationOutput {
	return o.ApplyT(func(v *CodeConfiguration) CodeConfiguration {
		if v != nil {
			return *v
		}
		var ret CodeConfiguration
		return ret
	}).(CodeConfigurationOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationPtrOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CodeId
	}).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationPtrOutput) ScoringScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.ScoringScript
	}).(pulumi.StringPtrOutput)
}

// Configuration for a scoring code asset.
type CodeConfigurationResponse struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript string `pulumi:"scoringScript"`
}

// Configuration for a scoring code asset.
type CodeConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CodeConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfigurationResponse)(nil)).Elem()
}

func (o CodeConfigurationResponseOutput) ToCodeConfigurationResponseOutput() CodeConfigurationResponseOutput {
	return o
}

func (o CodeConfigurationResponseOutput) ToCodeConfigurationResponseOutputWithContext(ctx context.Context) CodeConfigurationResponseOutput {
	return o
}

// ARM resource ID of the code asset.
func (o CodeConfigurationResponseOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeConfigurationResponse) *string { return v.CodeId }).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationResponseOutput) ScoringScript() pulumi.StringOutput {
	return o.ApplyT(func(v CodeConfigurationResponse) string { return v.ScoringScript }).(pulumi.StringOutput)
}

type CodeConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CodeConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfigurationResponse)(nil)).Elem()
}

func (o CodeConfigurationResponsePtrOutput) ToCodeConfigurationResponsePtrOutput() CodeConfigurationResponsePtrOutput {
	return o
}

func (o CodeConfigurationResponsePtrOutput) ToCodeConfigurationResponsePtrOutputWithContext(ctx context.Context) CodeConfigurationResponsePtrOutput {
	return o
}

func (o CodeConfigurationResponsePtrOutput) Elem() CodeConfigurationResponseOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) CodeConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CodeConfigurationResponse
		return ret
	}).(CodeConfigurationResponseOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationResponsePtrOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CodeId
	}).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationResponsePtrOutput) ScoringScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ScoringScript
	}).(pulumi.StringPtrOutput)
}

// Container for code asset versions.
type CodeContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerType
func (val *CodeContainerType) Defaults() *CodeContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// CodeContainerTypeInput is an input type that accepts CodeContainerTypeArgs and CodeContainerTypeOutput values.
// You can construct a concrete instance of `CodeContainerTypeInput` via:
//
//	CodeContainerTypeArgs{...}
type CodeContainerTypeInput interface {
	pulumi.Input

	ToCodeContainerTypeOutput() CodeContainerTypeOutput
	ToCodeContainerTypeOutputWithContext(context.Context) CodeContainerTypeOutput
}

// Container for code asset versions.
type CodeContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerTypeArgs
func (val *CodeContainerTypeArgs) Defaults() *CodeContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (CodeContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerType)(nil)).Elem()
}

func (i CodeContainerTypeArgs) ToCodeContainerTypeOutput() CodeContainerTypeOutput {
	return i.ToCodeContainerTypeOutputWithContext(context.Background())
}

func (i CodeContainerTypeArgs) ToCodeContainerTypeOutputWithContext(ctx context.Context) CodeContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeContainerTypeOutput)
}

// Container for code asset versions.
type CodeContainerTypeOutput struct{ *pulumi.OutputState }

func (CodeContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerType)(nil)).Elem()
}

func (o CodeContainerTypeOutput) ToCodeContainerTypeOutput() CodeContainerTypeOutput {
	return o
}

func (o CodeContainerTypeOutput) ToCodeContainerTypeOutputWithContext(ctx context.Context) CodeContainerTypeOutput {
	return o
}

// The asset description text.
func (o CodeContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o CodeContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for code asset versions.
type CodeContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerResponse
func (val *CodeContainerResponse) Defaults() *CodeContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for code asset versions.
type CodeContainerResponseOutput struct{ *pulumi.OutputState }

func (CodeContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerResponse)(nil)).Elem()
}

func (o CodeContainerResponseOutput) ToCodeContainerResponseOutput() CodeContainerResponseOutput {
	return o
}

func (o CodeContainerResponseOutput) ToCodeContainerResponseOutputWithContext(ctx context.Context) CodeContainerResponseOutput {
	return o
}

// The asset description text.
func (o CodeContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o CodeContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o CodeContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v CodeContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o CodeContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v CodeContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o CodeContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Code asset version details.
type CodeVersionType struct {
	// Uri where code is located
	CodeUri *string `pulumi:"codeUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionType
func (val *CodeVersionType) Defaults() *CodeVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// CodeVersionTypeInput is an input type that accepts CodeVersionTypeArgs and CodeVersionTypeOutput values.
// You can construct a concrete instance of `CodeVersionTypeInput` via:
//
//	CodeVersionTypeArgs{...}
type CodeVersionTypeInput interface {
	pulumi.Input

	ToCodeVersionTypeOutput() CodeVersionTypeOutput
	ToCodeVersionTypeOutputWithContext(context.Context) CodeVersionTypeOutput
}

// Code asset version details.
type CodeVersionTypeArgs struct {
	// Uri where code is located
	CodeUri pulumi.StringPtrInput `pulumi:"codeUri"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionTypeArgs
func (val *CodeVersionTypeArgs) Defaults() *CodeVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (CodeVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionType)(nil)).Elem()
}

func (i CodeVersionTypeArgs) ToCodeVersionTypeOutput() CodeVersionTypeOutput {
	return i.ToCodeVersionTypeOutputWithContext(context.Background())
}

func (i CodeVersionTypeArgs) ToCodeVersionTypeOutputWithContext(ctx context.Context) CodeVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeVersionTypeOutput)
}

// Code asset version details.
type CodeVersionTypeOutput struct{ *pulumi.OutputState }

func (CodeVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionType)(nil)).Elem()
}

func (o CodeVersionTypeOutput) ToCodeVersionTypeOutput() CodeVersionTypeOutput {
	return o
}

func (o CodeVersionTypeOutput) ToCodeVersionTypeOutputWithContext(ctx context.Context) CodeVersionTypeOutput {
	return o
}

// Uri where code is located
func (o CodeVersionTypeOutput) CodeUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *string { return v.CodeUri }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o CodeVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o CodeVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o CodeVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Code asset version details.
type CodeVersionResponse struct {
	// Uri where code is located
	CodeUri *string `pulumi:"codeUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionResponse
func (val *CodeVersionResponse) Defaults() *CodeVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Code asset version details.
type CodeVersionResponseOutput struct{ *pulumi.OutputState }

func (CodeVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionResponse)(nil)).Elem()
}

func (o CodeVersionResponseOutput) ToCodeVersionResponseOutput() CodeVersionResponseOutput {
	return o
}

func (o CodeVersionResponseOutput) ToCodeVersionResponseOutputWithContext(ctx context.Context) CodeVersionResponseOutput {
	return o
}

// Uri where code is located
func (o CodeVersionResponseOutput) CodeUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *string { return v.CodeUri }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o CodeVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o CodeVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o CodeVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Column transformer parameters.
type ColumnTransformer struct {
	// Fields to apply transformer logic on.
	Fields []string `pulumi:"fields"`
	// Different properties to be passed to transformer.
	// Input expected is dictionary of key,value pairs in JSON format.
	Parameters interface{} `pulumi:"parameters"`
}

// Column transformer parameters.
type ColumnTransformerResponse struct {
	// Fields to apply transformer logic on.
	Fields []string `pulumi:"fields"`
	// Different properties to be passed to transformer.
	// Input expected is dictionary of key,value pairs in JSON format.
	Parameters interface{} `pulumi:"parameters"`
}

// Command job definition.
type CommandJob struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Command'.
	JobType string `pulumi:"jobType"`
	// Command Job limit.
	Limits *CommandJobLimits `pulumi:"limits"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfiguration `pulumi:"resources"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CommandJob
func (val *CommandJob) Defaults() *CommandJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// Command Job limit class.
type CommandJobLimits struct {
	// Expected value is 'Command'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
}

// Command Job limit class.
type CommandJobLimitsResponse struct {
	// Expected value is 'Command'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
}

// Command job definition.
type CommandJobResponse struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Command'.
	JobType string `pulumi:"jobType"`
	// Command Job limit.
	Limits *CommandJobLimitsResponse `pulumi:"limits"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// Input parameters.
	Parameters interface{} `pulumi:"parameters"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfigurationResponse `pulumi:"resources"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CommandJobResponse
func (val *CommandJobResponse) Defaults() *CommandJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerType
func (val *ComponentContainerType) Defaults() *ComponentContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ComponentContainerTypeInput is an input type that accepts ComponentContainerTypeArgs and ComponentContainerTypeOutput values.
// You can construct a concrete instance of `ComponentContainerTypeInput` via:
//
//	ComponentContainerTypeArgs{...}
type ComponentContainerTypeInput interface {
	pulumi.Input

	ToComponentContainerTypeOutput() ComponentContainerTypeOutput
	ToComponentContainerTypeOutputWithContext(context.Context) ComponentContainerTypeOutput
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerTypeArgs
func (val *ComponentContainerTypeArgs) Defaults() *ComponentContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ComponentContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerType)(nil)).Elem()
}

func (i ComponentContainerTypeArgs) ToComponentContainerTypeOutput() ComponentContainerTypeOutput {
	return i.ToComponentContainerTypeOutputWithContext(context.Background())
}

func (i ComponentContainerTypeArgs) ToComponentContainerTypeOutputWithContext(ctx context.Context) ComponentContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComponentContainerTypeOutput)
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerTypeOutput struct{ *pulumi.OutputState }

func (ComponentContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerType)(nil)).Elem()
}

func (o ComponentContainerTypeOutput) ToComponentContainerTypeOutput() ComponentContainerTypeOutput {
	return o
}

func (o ComponentContainerTypeOutput) ToComponentContainerTypeOutputWithContext(ctx context.Context) ComponentContainerTypeOutput {
	return o
}

// The asset description text.
func (o ComponentContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ComponentContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerResponse
func (val *ComponentContainerResponse) Defaults() *ComponentContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerResponseOutput struct{ *pulumi.OutputState }

func (ComponentContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerResponse)(nil)).Elem()
}

func (o ComponentContainerResponseOutput) ToComponentContainerResponseOutput() ComponentContainerResponseOutput {
	return o
}

func (o ComponentContainerResponseOutput) ToComponentContainerResponseOutputWithContext(ctx context.Context) ComponentContainerResponseOutput {
	return o
}

// The asset description text.
func (o ComponentContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ComponentContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o ComponentContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o ComponentContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o ComponentContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionType struct {
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec interface{} `pulumi:"componentSpec"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionType
func (val *ComponentVersionType) Defaults() *ComponentVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ComponentVersionTypeInput is an input type that accepts ComponentVersionTypeArgs and ComponentVersionTypeOutput values.
// You can construct a concrete instance of `ComponentVersionTypeInput` via:
//
//	ComponentVersionTypeArgs{...}
type ComponentVersionTypeInput interface {
	pulumi.Input

	ToComponentVersionTypeOutput() ComponentVersionTypeOutput
	ToComponentVersionTypeOutputWithContext(context.Context) ComponentVersionTypeOutput
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionTypeArgs struct {
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec pulumi.Input `pulumi:"componentSpec"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionTypeArgs
func (val *ComponentVersionTypeArgs) Defaults() *ComponentVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ComponentVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionType)(nil)).Elem()
}

func (i ComponentVersionTypeArgs) ToComponentVersionTypeOutput() ComponentVersionTypeOutput {
	return i.ToComponentVersionTypeOutputWithContext(context.Background())
}

func (i ComponentVersionTypeArgs) ToComponentVersionTypeOutputWithContext(ctx context.Context) ComponentVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComponentVersionTypeOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionTypeOutput struct{ *pulumi.OutputState }

func (ComponentVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionType)(nil)).Elem()
}

func (o ComponentVersionTypeOutput) ToComponentVersionTypeOutput() ComponentVersionTypeOutput {
	return o
}

func (o ComponentVersionTypeOutput) ToComponentVersionTypeOutputWithContext(ctx context.Context) ComponentVersionTypeOutput {
	return o
}

// Defines Component definition details.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
func (o ComponentVersionTypeOutput) ComponentSpec() pulumi.AnyOutput {
	return o.ApplyT(func(v ComponentVersionType) interface{} { return v.ComponentSpec }).(pulumi.AnyOutput)
}

// The asset description text.
func (o ComponentVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o ComponentVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o ComponentVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionResponse struct {
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec interface{} `pulumi:"componentSpec"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionResponse
func (val *ComponentVersionResponse) Defaults() *ComponentVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionResponseOutput struct{ *pulumi.OutputState }

func (ComponentVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionResponse)(nil)).Elem()
}

func (o ComponentVersionResponseOutput) ToComponentVersionResponseOutput() ComponentVersionResponseOutput {
	return o
}

func (o ComponentVersionResponseOutput) ToComponentVersionResponseOutputWithContext(ctx context.Context) ComponentVersionResponseOutput {
	return o
}

// Defines Component definition details.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
func (o ComponentVersionResponseOutput) ComponentSpec() pulumi.AnyOutput {
	return o.ApplyT(func(v ComponentVersionResponse) interface{} { return v.ComponentSpec }).(pulumi.AnyOutput)
}

// The asset description text.
func (o ComponentVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o ComponentVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o ComponentVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// An Azure Machine Learning compute instance.
type ComputeInstance struct {
	// The type of compute
	// Expected value is 'ComputeInstance'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of ComputeInstance
	Properties *ComputeInstanceProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for ComputeInstance
func (val *ComputeInstance) Defaults() *ComputeInstance {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplicationResponse struct {
	// Name of the ComputeInstance application.
	DisplayName *string `pulumi:"displayName"`
	// Application' endpoint URI.
	EndpointUri *string `pulumi:"endpointUri"`
}

// Defines all connectivity endpoints and properties for an ComputeInstance.
type ComputeInstanceConnectivityEndpointsResponse struct {
	// Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
	PrivateIpAddress string `pulumi:"privateIpAddress"`
	// Public IP Address of this ComputeInstance.
	PublicIpAddress string `pulumi:"publicIpAddress"`
}

// Defines an Aml Instance container.
type ComputeInstanceContainerResponse struct {
	// Auto save settings.
	Autosave *string `pulumi:"autosave"`
	// Environment information of this container.
	Environment *ComputeInstanceEnvironmentInfoResponse `pulumi:"environment"`
	// Information of GPU.
	Gpu *string `pulumi:"gpu"`
	// Name of the ComputeInstance container.
	Name *string `pulumi:"name"`
	// network of this container.
	Network *string `pulumi:"network"`
	// services of this containers.
	Services []interface{} `pulumi:"services"`
}

// Describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedByResponse struct {
	// Uniquely identifies the user within his/her organization.
	UserId string `pulumi:"userId"`
	// Name of the user.
	UserName string `pulumi:"userName"`
	// Uniquely identifies user' Azure Active Directory organization.
	UserOrgId string `pulumi:"userOrgId"`
}

// Defines an Aml Instance DataDisk.
type ComputeInstanceDataDiskResponse struct {
	// Caching type of Data Disk.
	Caching *string `pulumi:"caching"`
	// The initial disk size in gigabytes.
	DiskSizeGB *int `pulumi:"diskSizeGB"`
	// The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
	Lun *int `pulumi:"lun"`
	// type of this storage account.
	StorageAccountType *string `pulumi:"storageAccountType"`
}

// Defaults sets the appropriate defaults for ComputeInstanceDataDiskResponse
func (val *ComputeInstanceDataDiskResponse) Defaults() *ComputeInstanceDataDiskResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.StorageAccountType) {
		storageAccountType_ := "Standard_LRS"
		tmp.StorageAccountType = &storageAccountType_
	}
	return &tmp
}

// Defines an Aml Instance DataMount.
type ComputeInstanceDataMountResponse struct {
	// who this data mount created by.
	CreatedBy *string `pulumi:"createdBy"`
	// Error of this data mount.
	Error *string `pulumi:"error"`
	// Mount Action.
	MountAction *string `pulumi:"mountAction"`
	// name of the ComputeInstance data mount.
	MountName *string `pulumi:"mountName"`
	// Path of this data mount.
	MountPath *string `pulumi:"mountPath"`
	// Mount state.
	MountState *string `pulumi:"mountState"`
	// The time when the disk mounted.
	MountedOn *string `pulumi:"mountedOn"`
	// Source of the ComputeInstance data mount.
	Source *string `pulumi:"source"`
	// Data source type.
	SourceType *string `pulumi:"sourceType"`
}

// Environment information
type ComputeInstanceEnvironmentInfoResponse struct {
	// name of environment.
	Name *string `pulumi:"name"`
	// version of environment.
	Version *string `pulumi:"version"`
}

// The last operation on ComputeInstance.
type ComputeInstanceLastOperationResponse struct {
	// Name of the last operation.
	OperationName *string `pulumi:"operationName"`
	// Operation status.
	OperationStatus *string `pulumi:"operationStatus"`
	// Time of the last operation.
	OperationTime *string `pulumi:"operationTime"`
	// Trigger of operation.
	OperationTrigger *string `pulumi:"operationTrigger"`
}

// Compute Instance properties
type ComputeInstanceProperties struct {
	// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *string `pulumi:"applicationSharingPolicy"`
	// The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *string `pulumi:"computeInstanceAuthorizationType"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `pulumi:"personalComputeInstanceSettings"`
	// Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `pulumi:"setupScripts"`
	// Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings `pulumi:"sshSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `pulumi:"subnet"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for ComputeInstanceProperties
func (val *ComputeInstanceProperties) Defaults() *ComputeInstanceProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ApplicationSharingPolicy) {
		applicationSharingPolicy_ := "Shared"
		tmp.ApplicationSharingPolicy = &applicationSharingPolicy_
	}
	if isZero(tmp.ComputeInstanceAuthorizationType) {
		computeInstanceAuthorizationType_ := "personal"
		tmp.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType_
	}
	tmp.SshSettings = tmp.SshSettings.Defaults()

	return &tmp
}

// Compute Instance properties
type ComputeInstancePropertiesResponse struct {
	// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *string `pulumi:"applicationSharingPolicy"`
	// Describes available applications and their endpoints on this ComputeInstance.
	Applications []ComputeInstanceApplicationResponse `pulumi:"applications"`
	// The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *string `pulumi:"computeInstanceAuthorizationType"`
	// Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints ComputeInstanceConnectivityEndpointsResponse `pulumi:"connectivityEndpoints"`
	// Describes informations of containers on this ComputeInstance.
	Containers []ComputeInstanceContainerResponse `pulumi:"containers"`
	// Describes information on user who created this ComputeInstance.
	CreatedBy ComputeInstanceCreatedByResponse `pulumi:"createdBy"`
	// Describes informations of dataDisks on this ComputeInstance.
	DataDisks []ComputeInstanceDataDiskResponse `pulumi:"dataDisks"`
	// Describes informations of dataMounts on this ComputeInstance.
	DataMounts []ComputeInstanceDataMountResponse `pulumi:"dataMounts"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Collection of errors encountered on this ComputeInstance.
	Errors []ErrorResponseResponse `pulumi:"errors"`
	// The last operation on ComputeInstance.
	LastOperation ComputeInstanceLastOperationResponse `pulumi:"lastOperation"`
	// Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettingsResponse `pulumi:"personalComputeInstanceSettings"`
	// The list of schedules to be applied on the computes.
	Schedules ComputeSchedulesResponse `pulumi:"schedules"`
	// Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScriptsResponse `pulumi:"setupScripts"`
	// Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettingsResponse `pulumi:"sshSettings"`
	// The current state of this ComputeInstance.
	State string `pulumi:"state"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceIdResponse `pulumi:"subnet"`
	// ComputeInstance version.
	Versions ComputeInstanceVersionResponse `pulumi:"versions"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for ComputeInstancePropertiesResponse
func (val *ComputeInstancePropertiesResponse) Defaults() *ComputeInstancePropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ApplicationSharingPolicy) {
		applicationSharingPolicy_ := "Shared"
		tmp.ApplicationSharingPolicy = &applicationSharingPolicy_
	}
	if isZero(tmp.ComputeInstanceAuthorizationType) {
		computeInstanceAuthorizationType_ := "personal"
		tmp.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType_
	}
	tmp.SshSettings = tmp.SshSettings.Defaults()

	return &tmp
}

// An Azure Machine Learning compute instance.
type ComputeInstanceResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'ComputeInstance'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of ComputeInstance
	Properties *ComputeInstancePropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for ComputeInstanceResponse
func (val *ComputeInstanceResponse) Defaults() *ComputeInstanceResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings struct {
	// Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `pulumi:"adminPublicKey"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
	SshPublicAccess *string `pulumi:"sshPublicAccess"`
}

// Defaults sets the appropriate defaults for ComputeInstanceSshSettings
func (val *ComputeInstanceSshSettings) Defaults() *ComputeInstanceSshSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.SshPublicAccess) {
		sshPublicAccess_ := "Disabled"
		tmp.SshPublicAccess = &sshPublicAccess_
	}
	return &tmp
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettingsResponse struct {
	// Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `pulumi:"adminPublicKey"`
	// Describes the admin user name.
	AdminUserName string `pulumi:"adminUserName"`
	// Describes the port for connecting through SSH.
	SshPort int `pulumi:"sshPort"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
	SshPublicAccess *string `pulumi:"sshPublicAccess"`
}

// Defaults sets the appropriate defaults for ComputeInstanceSshSettingsResponse
func (val *ComputeInstanceSshSettingsResponse) Defaults() *ComputeInstanceSshSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.SshPublicAccess) {
		sshPublicAccess_ := "Disabled"
		tmp.SshPublicAccess = &sshPublicAccess_
	}
	return &tmp
}

// Version of computeInstance.
type ComputeInstanceVersionResponse struct {
	// Runtime of compute instance.
	Runtime *string `pulumi:"runtime"`
}

// The list of schedules to be applied on the computes
type ComputeSchedulesResponse struct {
	// The list of compute start stop schedules to be applied.
	ComputeStartStop []ComputeStartStopScheduleResponse `pulumi:"computeStartStop"`
}

// Compute start stop schedule properties
type ComputeStartStopScheduleResponse struct {
	// The compute power action.
	Action *string `pulumi:"action"`
	// Schedule id.
	Id string `pulumi:"id"`
	// The current deployment state of schedule.
	ProvisioningStatus string `pulumi:"provisioningStatus"`
	// Base definition of a schedule
	Schedule interface{} `pulumi:"schedule"`
}

// Resource requirements for each container instance within an online deployment.
type ContainerResourceRequirements struct {
	// Container resource limit info:
	ContainerResourceLimits *ContainerResourceSettings `pulumi:"containerResourceLimits"`
	// Container resource request info:
	ContainerResourceRequests *ContainerResourceSettings `pulumi:"containerResourceRequests"`
}

// Resource requirements for each container instance within an online deployment.
type ContainerResourceRequirementsResponse struct {
	// Container resource limit info:
	ContainerResourceLimits *ContainerResourceSettingsResponse `pulumi:"containerResourceLimits"`
	// Container resource request info:
	ContainerResourceRequests *ContainerResourceSettingsResponse `pulumi:"containerResourceRequests"`
}

type ContainerResourceSettings struct {
	// Number of vCPUs request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Cpu *string `pulumi:"cpu"`
	// Number of Nvidia GPU cards request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Gpu *string `pulumi:"gpu"`
	// Memory size request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Memory *string `pulumi:"memory"`
}

type ContainerResourceSettingsResponse struct {
	// Number of vCPUs request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Cpu *string `pulumi:"cpu"`
	// Number of Nvidia GPU cards request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Gpu *string `pulumi:"gpu"`
	// Memory size request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Memory *string `pulumi:"memory"`
}

type CosmosDbSettings struct {
	// The throughput of the collections in cosmosdb database
	CollectionsThroughput *int `pulumi:"collectionsThroughput"`
}

// CosmosDbSettingsInput is an input type that accepts CosmosDbSettingsArgs and CosmosDbSettingsOutput values.
// You can construct a concrete instance of `CosmosDbSettingsInput` via:
//
//	CosmosDbSettingsArgs{...}
type CosmosDbSettingsInput interface {
	pulumi.Input

	ToCosmosDbSettingsOutput() CosmosDbSettingsOutput
	ToCosmosDbSettingsOutputWithContext(context.Context) CosmosDbSettingsOutput
}

type CosmosDbSettingsArgs struct {
	// The throughput of the collections in cosmosdb database
	CollectionsThroughput pulumi.IntPtrInput `pulumi:"collectionsThroughput"`
}

func (CosmosDbSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettings)(nil)).Elem()
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsOutput() CosmosDbSettingsOutput {
	return i.ToCosmosDbSettingsOutputWithContext(context.Background())
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsOutputWithContext(ctx context.Context) CosmosDbSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsOutput)
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return i.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsOutput).ToCosmosDbSettingsPtrOutputWithContext(ctx)
}

// CosmosDbSettingsPtrInput is an input type that accepts CosmosDbSettingsArgs, CosmosDbSettingsPtr and CosmosDbSettingsPtrOutput values.
// You can construct a concrete instance of `CosmosDbSettingsPtrInput` via:
//
//	        CosmosDbSettingsArgs{...}
//
//	or:
//
//	        nil
type CosmosDbSettingsPtrInput interface {
	pulumi.Input

	ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput
	ToCosmosDbSettingsPtrOutputWithContext(context.Context) CosmosDbSettingsPtrOutput
}

type cosmosDbSettingsPtrType CosmosDbSettingsArgs

func CosmosDbSettingsPtr(v *CosmosDbSettingsArgs) CosmosDbSettingsPtrInput {
	return (*cosmosDbSettingsPtrType)(v)
}

func (*cosmosDbSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettings)(nil)).Elem()
}

func (i *cosmosDbSettingsPtrType) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return i.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (i *cosmosDbSettingsPtrType) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsPtrOutput)
}

type CosmosDbSettingsOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettings)(nil)).Elem()
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsOutput() CosmosDbSettingsOutput {
	return o
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsOutputWithContext(ctx context.Context) CosmosDbSettingsOutput {
	return o
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return o.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CosmosDbSettings) *CosmosDbSettings {
		return &v
	}).(CosmosDbSettingsPtrOutput)
}

// The throughput of the collections in cosmosdb database
func (o CosmosDbSettingsOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CosmosDbSettings) *int { return v.CollectionsThroughput }).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsPtrOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettings)(nil)).Elem()
}

func (o CosmosDbSettingsPtrOutput) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return o
}

func (o CosmosDbSettingsPtrOutput) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return o
}

func (o CosmosDbSettingsPtrOutput) Elem() CosmosDbSettingsOutput {
	return o.ApplyT(func(v *CosmosDbSettings) CosmosDbSettings {
		if v != nil {
			return *v
		}
		var ret CosmosDbSettings
		return ret
	}).(CosmosDbSettingsOutput)
}

// The throughput of the collections in cosmosdb database
func (o CosmosDbSettingsPtrOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CosmosDbSettings) *int {
		if v == nil {
			return nil
		}
		return v.CollectionsThroughput
	}).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsResponse struct {
	// The throughput of the collections in cosmosdb database
	CollectionsThroughput *int `pulumi:"collectionsThroughput"`
}

type CosmosDbSettingsResponseOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettingsResponse)(nil)).Elem()
}

func (o CosmosDbSettingsResponseOutput) ToCosmosDbSettingsResponseOutput() CosmosDbSettingsResponseOutput {
	return o
}

func (o CosmosDbSettingsResponseOutput) ToCosmosDbSettingsResponseOutputWithContext(ctx context.Context) CosmosDbSettingsResponseOutput {
	return o
}

// The throughput of the collections in cosmosdb database
func (o CosmosDbSettingsResponseOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CosmosDbSettingsResponse) *int { return v.CollectionsThroughput }).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettingsResponse)(nil)).Elem()
}

func (o CosmosDbSettingsResponsePtrOutput) ToCosmosDbSettingsResponsePtrOutput() CosmosDbSettingsResponsePtrOutput {
	return o
}

func (o CosmosDbSettingsResponsePtrOutput) ToCosmosDbSettingsResponsePtrOutputWithContext(ctx context.Context) CosmosDbSettingsResponsePtrOutput {
	return o
}

func (o CosmosDbSettingsResponsePtrOutput) Elem() CosmosDbSettingsResponseOutput {
	return o.ApplyT(func(v *CosmosDbSettingsResponse) CosmosDbSettingsResponse {
		if v != nil {
			return *v
		}
		var ret CosmosDbSettingsResponse
		return ret
	}).(CosmosDbSettingsResponseOutput)
}

// The throughput of the collections in cosmosdb database
func (o CosmosDbSettingsResponsePtrOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CosmosDbSettingsResponse) *int {
		if v == nil {
			return nil
		}
		return v.CollectionsThroughput
	}).(pulumi.IntPtrOutput)
}

// Cron schedule definition
type CronSchedule struct {
	// Specifies end time of schedule in ISO 8601 format.
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression string `pulumi:"expression"`
	// Specifies the schedule's status
	ScheduleStatus *string `pulumi:"scheduleStatus"`
	// Enum to describe type of schedule
	// Expected value is 'Cron'.
	ScheduleType string `pulumi:"scheduleType"`
	// Specifies start time of schedule in ISO 8601 format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format.
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for CronSchedule
func (val *CronSchedule) Defaults() *CronSchedule {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ScheduleStatus) {
		scheduleStatus_ := "Enabled"
		tmp.ScheduleStatus = &scheduleStatus_
	}
	if isZero(tmp.TimeZone) {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// Cron schedule definition
type CronScheduleResponse struct {
	// Specifies end time of schedule in ISO 8601 format.
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression string `pulumi:"expression"`
	// Specifies the schedule's status
	ScheduleStatus *string `pulumi:"scheduleStatus"`
	// Enum to describe type of schedule
	// Expected value is 'Cron'.
	ScheduleType string `pulumi:"scheduleType"`
	// Specifies start time of schedule in ISO 8601 format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format.
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for CronScheduleResponse
func (val *CronScheduleResponse) Defaults() *CronScheduleResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ScheduleStatus) {
		scheduleStatus_ := "Enabled"
		tmp.ScheduleStatus = &scheduleStatus_
	}
	if isZero(tmp.TimeZone) {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// The desired maximum forecast horizon in units of time-series frequency.
type CustomForecastHorizon struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Forecast horizon value.
	Value int `pulumi:"value"`
}

// The desired maximum forecast horizon in units of time-series frequency.
type CustomForecastHorizonResponse struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Forecast horizon value.
	Value int `pulumi:"value"`
}

type CustomModelJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'CustomModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobInput
func (val *CustomModelJobInput) Defaults() *CustomModelJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'CustomModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobInputResponse
func (val *CustomModelJobInputResponse) Defaults() *CustomModelJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'CustomModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobOutput
func (val *CustomModelJobOutput) Defaults() *CustomModelJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'CustomModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobOutputResponse
func (val *CustomModelJobOutputResponse) Defaults() *CustomModelJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// N-Cross validations are specified by user.
type CustomNCrossValidations struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] N-Cross validations value.
	Value int `pulumi:"value"`
}

// N-Cross validations are specified by user.
type CustomNCrossValidationsResponse struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] N-Cross validations value.
	Value int `pulumi:"value"`
}

type CustomSeasonality struct {
	// Forecasting seasonality mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Seasonality value.
	Value int `pulumi:"value"`
}

type CustomSeasonalityResponse struct {
	// Forecasting seasonality mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Seasonality value.
	Value int `pulumi:"value"`
}

type CustomTargetLags struct {
	// Target lags selection modes.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Set target lags values.
	Values []int `pulumi:"values"`
}

type CustomTargetLagsResponse struct {
	// Target lags selection modes.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Set target lags values.
	Values []int `pulumi:"values"`
}

type CustomTargetRollingWindowSize struct {
	// Target rolling windows size mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] TargetRollingWindowSize value.
	Value int `pulumi:"value"`
}

type CustomTargetRollingWindowSizeResponse struct {
	// Target rolling windows size mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] TargetRollingWindowSize value.
	Value int `pulumi:"value"`
}

// Container for data asset versions.
type DataContainerType struct {
	// [Required] Specifies the type of data.
	DataType string `pulumi:"dataType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerType
func (val *DataContainerType) Defaults() *DataContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// DataContainerTypeInput is an input type that accepts DataContainerTypeArgs and DataContainerTypeOutput values.
// You can construct a concrete instance of `DataContainerTypeInput` via:
//
//	DataContainerTypeArgs{...}
type DataContainerTypeInput interface {
	pulumi.Input

	ToDataContainerTypeOutput() DataContainerTypeOutput
	ToDataContainerTypeOutputWithContext(context.Context) DataContainerTypeOutput
}

// Container for data asset versions.
type DataContainerTypeArgs struct {
	// [Required] Specifies the type of data.
	DataType pulumi.StringInput `pulumi:"dataType"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerTypeArgs
func (val *DataContainerTypeArgs) Defaults() *DataContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (DataContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerType)(nil)).Elem()
}

func (i DataContainerTypeArgs) ToDataContainerTypeOutput() DataContainerTypeOutput {
	return i.ToDataContainerTypeOutputWithContext(context.Background())
}

func (i DataContainerTypeArgs) ToDataContainerTypeOutputWithContext(ctx context.Context) DataContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataContainerTypeOutput)
}

// Container for data asset versions.
type DataContainerTypeOutput struct{ *pulumi.OutputState }

func (DataContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerType)(nil)).Elem()
}

func (o DataContainerTypeOutput) ToDataContainerTypeOutput() DataContainerTypeOutput {
	return o
}

func (o DataContainerTypeOutput) ToDataContainerTypeOutputWithContext(ctx context.Context) DataContainerTypeOutput {
	return o
}

// [Required] Specifies the type of data.
func (o DataContainerTypeOutput) DataType() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerType) string { return v.DataType }).(pulumi.StringOutput)
}

// The asset description text.
func (o DataContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o DataContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DataContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o DataContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o DataContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for data asset versions.
type DataContainerResponse struct {
	// [Required] Specifies the type of data.
	DataType string `pulumi:"dataType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerResponse
func (val *DataContainerResponse) Defaults() *DataContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for data asset versions.
type DataContainerResponseOutput struct{ *pulumi.OutputState }

func (DataContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerResponse)(nil)).Elem()
}

func (o DataContainerResponseOutput) ToDataContainerResponseOutput() DataContainerResponseOutput {
	return o
}

func (o DataContainerResponseOutput) ToDataContainerResponseOutputWithContext(ctx context.Context) DataContainerResponseOutput {
	return o
}

// [Required] Specifies the type of data.
func (o DataContainerResponseOutput) DataType() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.DataType }).(pulumi.StringOutput)
}

// The asset description text.
func (o DataContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o DataContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DataContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o DataContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o DataContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o DataContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o DataContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// A DataFactory compute.
type DataFactory struct {
	// The type of compute
	// Expected value is 'DataFactory'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// A DataFactory compute.
type DataFactoryResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataFactory'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// A DataLakeAnalytics compute.
type DataLakeAnalytics struct {
	// The type of compute
	// Expected value is 'DataLakeAnalytics'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                              `pulumi:"disableLocalAuth"`
	Properties       *DataLakeAnalyticsSchemaProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// A DataLakeAnalytics compute.
type DataLakeAnalyticsResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataLakeAnalytics'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string                                     `pulumi:"modifiedOn"`
	Properties *DataLakeAnalyticsSchemaResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type DataLakeAnalyticsSchemaProperties struct {
	// DataLake Store Account Name
	DataLakeStoreAccountName *string `pulumi:"dataLakeStoreAccountName"`
}

type DataLakeAnalyticsSchemaResponseProperties struct {
	// DataLake Store Account Name
	DataLakeStoreAccountName *string `pulumi:"dataLakeStoreAccountName"`
}

// Reference to an asset via its path in a datastore.
type DataPathAssetReference struct {
	// ARM resource ID of the datastore where the asset is located.
	DatastoreId *string `pulumi:"datastoreId"`
	// The path of the file/directory in the datastore.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'DataPath'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its path in a datastore.
type DataPathAssetReferenceResponse struct {
	// ARM resource ID of the datastore where the asset is located.
	DatastoreId *string `pulumi:"datastoreId"`
	// The path of the file/directory in the datastore.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'DataPath'.
	ReferenceType string `pulumi:"referenceType"`
}

// A DataFactory compute.
type Databricks struct {
	// The type of compute
	// Expected value is 'Databricks'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of Databricks
	Properties *DatabricksProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Properties of Databricks
type DatabricksProperties struct {
	// Databricks access token
	DatabricksAccessToken *string `pulumi:"databricksAccessToken"`
	// Workspace Url
	WorkspaceUrl *string `pulumi:"workspaceUrl"`
}

// Properties of Databricks
type DatabricksPropertiesResponse struct {
	// Databricks access token
	DatabricksAccessToken *string `pulumi:"databricksAccessToken"`
	// Workspace Url
	WorkspaceUrl *string `pulumi:"workspaceUrl"`
}

// A DataFactory compute.
type DatabricksResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Databricks'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of Databricks
	Properties *DatabricksPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type DefaultScaleSettings struct {
	// Expected value is 'Default'.
	ScaleType string `pulumi:"scaleType"`
}

type DefaultScaleSettingsResponse struct {
	// Expected value is 'Default'.
	ScaleType string `pulumi:"scaleType"`
}

type EncryptionKeyVaultProperties struct {
	// For future use - The client id of the identity which will be used to access key vault.
	IdentityClientId *string `pulumi:"identityClientId"`
	// Key vault uri to access the encryption key.
	KeyIdentifier string `pulumi:"keyIdentifier"`
	// The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmId string `pulumi:"keyVaultArmId"`
}

// EncryptionKeyVaultPropertiesInput is an input type that accepts EncryptionKeyVaultPropertiesArgs and EncryptionKeyVaultPropertiesOutput values.
// You can construct a concrete instance of `EncryptionKeyVaultPropertiesInput` via:
//
//	EncryptionKeyVaultPropertiesArgs{...}
type EncryptionKeyVaultPropertiesInput interface {
	pulumi.Input

	ToEncryptionKeyVaultPropertiesOutput() EncryptionKeyVaultPropertiesOutput
	ToEncryptionKeyVaultPropertiesOutputWithContext(context.Context) EncryptionKeyVaultPropertiesOutput
}

type EncryptionKeyVaultPropertiesArgs struct {
	// For future use - The client id of the identity which will be used to access key vault.
	IdentityClientId pulumi.StringPtrInput `pulumi:"identityClientId"`
	// Key vault uri to access the encryption key.
	KeyIdentifier pulumi.StringInput `pulumi:"keyIdentifier"`
	// The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmId pulumi.StringInput `pulumi:"keyVaultArmId"`
}

func (EncryptionKeyVaultPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionKeyVaultProperties)(nil)).Elem()
}

func (i EncryptionKeyVaultPropertiesArgs) ToEncryptionKeyVaultPropertiesOutput() EncryptionKeyVaultPropertiesOutput {
	return i.ToEncryptionKeyVaultPropertiesOutputWithContext(context.Background())
}

func (i EncryptionKeyVaultPropertiesArgs) ToEncryptionKeyVaultPropertiesOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyVaultPropertiesOutput)
}

func (i EncryptionKeyVaultPropertiesArgs) ToEncryptionKeyVaultPropertiesPtrOutput() EncryptionKeyVaultPropertiesPtrOutput {
	return i.ToEncryptionKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i EncryptionKeyVaultPropertiesArgs) ToEncryptionKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyVaultPropertiesOutput).ToEncryptionKeyVaultPropertiesPtrOutputWithContext(ctx)
}

// EncryptionKeyVaultPropertiesPtrInput is an input type that accepts EncryptionKeyVaultPropertiesArgs, EncryptionKeyVaultPropertiesPtr and EncryptionKeyVaultPropertiesPtrOutput values.
// You can construct a concrete instance of `EncryptionKeyVaultPropertiesPtrInput` via:
//
//	        EncryptionKeyVaultPropertiesArgs{...}
//
//	or:
//
//	        nil
type EncryptionKeyVaultPropertiesPtrInput interface {
	pulumi.Input

	ToEncryptionKeyVaultPropertiesPtrOutput() EncryptionKeyVaultPropertiesPtrOutput
	ToEncryptionKeyVaultPropertiesPtrOutputWithContext(context.Context) EncryptionKeyVaultPropertiesPtrOutput
}

type encryptionKeyVaultPropertiesPtrType EncryptionKeyVaultPropertiesArgs

func EncryptionKeyVaultPropertiesPtr(v *EncryptionKeyVaultPropertiesArgs) EncryptionKeyVaultPropertiesPtrInput {
	return (*encryptionKeyVaultPropertiesPtrType)(v)
}

func (*encryptionKeyVaultPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKeyVaultProperties)(nil)).Elem()
}

func (i *encryptionKeyVaultPropertiesPtrType) ToEncryptionKeyVaultPropertiesPtrOutput() EncryptionKeyVaultPropertiesPtrOutput {
	return i.ToEncryptionKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i *encryptionKeyVaultPropertiesPtrType) ToEncryptionKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyVaultPropertiesPtrOutput)
}

type EncryptionKeyVaultPropertiesOutput struct{ *pulumi.OutputState }

func (EncryptionKeyVaultPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionKeyVaultProperties)(nil)).Elem()
}

func (o EncryptionKeyVaultPropertiesOutput) ToEncryptionKeyVaultPropertiesOutput() EncryptionKeyVaultPropertiesOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesOutput) ToEncryptionKeyVaultPropertiesOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesOutput) ToEncryptionKeyVaultPropertiesPtrOutput() EncryptionKeyVaultPropertiesPtrOutput {
	return o.ToEncryptionKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (o EncryptionKeyVaultPropertiesOutput) ToEncryptionKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EncryptionKeyVaultProperties) *EncryptionKeyVaultProperties {
		return &v
	}).(EncryptionKeyVaultPropertiesPtrOutput)
}

// For future use - The client id of the identity which will be used to access key vault.
func (o EncryptionKeyVaultPropertiesOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionKeyVaultProperties) *string { return v.IdentityClientId }).(pulumi.StringPtrOutput)
}

// Key vault uri to access the encryption key.
func (o EncryptionKeyVaultPropertiesOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionKeyVaultProperties) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

// The ArmId of the keyVault where the customer owned encryption key is present.
func (o EncryptionKeyVaultPropertiesOutput) KeyVaultArmId() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionKeyVaultProperties) string { return v.KeyVaultArmId }).(pulumi.StringOutput)
}

type EncryptionKeyVaultPropertiesPtrOutput struct{ *pulumi.OutputState }

func (EncryptionKeyVaultPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKeyVaultProperties)(nil)).Elem()
}

func (o EncryptionKeyVaultPropertiesPtrOutput) ToEncryptionKeyVaultPropertiesPtrOutput() EncryptionKeyVaultPropertiesPtrOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesPtrOutput) ToEncryptionKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesPtrOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesPtrOutput) Elem() EncryptionKeyVaultPropertiesOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultProperties) EncryptionKeyVaultProperties {
		if v != nil {
			return *v
		}
		var ret EncryptionKeyVaultProperties
		return ret
	}).(EncryptionKeyVaultPropertiesOutput)
}

// For future use - The client id of the identity which will be used to access key vault.
func (o EncryptionKeyVaultPropertiesPtrOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return v.IdentityClientId
	}).(pulumi.StringPtrOutput)
}

// Key vault uri to access the encryption key.
func (o EncryptionKeyVaultPropertiesPtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The ArmId of the keyVault where the customer owned encryption key is present.
func (o EncryptionKeyVaultPropertiesPtrOutput) KeyVaultArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultArmId
	}).(pulumi.StringPtrOutput)
}

type EncryptionKeyVaultPropertiesResponse struct {
	// For future use - The client id of the identity which will be used to access key vault.
	IdentityClientId *string `pulumi:"identityClientId"`
	// Key vault uri to access the encryption key.
	KeyIdentifier string `pulumi:"keyIdentifier"`
	// The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmId string `pulumi:"keyVaultArmId"`
}

type EncryptionKeyVaultPropertiesResponseOutput struct{ *pulumi.OutputState }

func (EncryptionKeyVaultPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionKeyVaultPropertiesResponse)(nil)).Elem()
}

func (o EncryptionKeyVaultPropertiesResponseOutput) ToEncryptionKeyVaultPropertiesResponseOutput() EncryptionKeyVaultPropertiesResponseOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesResponseOutput) ToEncryptionKeyVaultPropertiesResponseOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesResponseOutput {
	return o
}

// For future use - The client id of the identity which will be used to access key vault.
func (o EncryptionKeyVaultPropertiesResponseOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionKeyVaultPropertiesResponse) *string { return v.IdentityClientId }).(pulumi.StringPtrOutput)
}

// Key vault uri to access the encryption key.
func (o EncryptionKeyVaultPropertiesResponseOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionKeyVaultPropertiesResponse) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

// The ArmId of the keyVault where the customer owned encryption key is present.
func (o EncryptionKeyVaultPropertiesResponseOutput) KeyVaultArmId() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionKeyVaultPropertiesResponse) string { return v.KeyVaultArmId }).(pulumi.StringOutput)
}

type EncryptionKeyVaultPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (EncryptionKeyVaultPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKeyVaultPropertiesResponse)(nil)).Elem()
}

func (o EncryptionKeyVaultPropertiesResponsePtrOutput) ToEncryptionKeyVaultPropertiesResponsePtrOutput() EncryptionKeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesResponsePtrOutput) ToEncryptionKeyVaultPropertiesResponsePtrOutputWithContext(ctx context.Context) EncryptionKeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o EncryptionKeyVaultPropertiesResponsePtrOutput) Elem() EncryptionKeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultPropertiesResponse) EncryptionKeyVaultPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret EncryptionKeyVaultPropertiesResponse
		return ret
	}).(EncryptionKeyVaultPropertiesResponseOutput)
}

// For future use - The client id of the identity which will be used to access key vault.
func (o EncryptionKeyVaultPropertiesResponsePtrOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.IdentityClientId
	}).(pulumi.StringPtrOutput)
}

// Key vault uri to access the encryption key.
func (o EncryptionKeyVaultPropertiesResponsePtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The ArmId of the keyVault where the customer owned encryption key is present.
func (o EncryptionKeyVaultPropertiesResponsePtrOutput) KeyVaultArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionKeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultArmId
	}).(pulumi.StringPtrOutput)
}

type EncryptionProperty struct {
	// The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmk `pulumi:"identity"`
	// Customer Key vault properties.
	KeyVaultProperties EncryptionKeyVaultProperties `pulumi:"keyVaultProperties"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status string `pulumi:"status"`
}

// EncryptionPropertyInput is an input type that accepts EncryptionPropertyArgs and EncryptionPropertyOutput values.
// You can construct a concrete instance of `EncryptionPropertyInput` via:
//
//	EncryptionPropertyArgs{...}
type EncryptionPropertyInput interface {
	pulumi.Input

	ToEncryptionPropertyOutput() EncryptionPropertyOutput
	ToEncryptionPropertyOutputWithContext(context.Context) EncryptionPropertyOutput
}

type EncryptionPropertyArgs struct {
	// The identity that will be used to access the key vault for encryption at rest.
	Identity IdentityForCmkPtrInput `pulumi:"identity"`
	// Customer Key vault properties.
	KeyVaultProperties EncryptionKeyVaultPropertiesInput `pulumi:"keyVaultProperties"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status pulumi.StringInput `pulumi:"status"`
}

func (EncryptionPropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionProperty)(nil)).Elem()
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyOutput() EncryptionPropertyOutput {
	return i.ToEncryptionPropertyOutputWithContext(context.Background())
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyOutputWithContext(ctx context.Context) EncryptionPropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyOutput)
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return i.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyOutput).ToEncryptionPropertyPtrOutputWithContext(ctx)
}

// EncryptionPropertyPtrInput is an input type that accepts EncryptionPropertyArgs, EncryptionPropertyPtr and EncryptionPropertyPtrOutput values.
// You can construct a concrete instance of `EncryptionPropertyPtrInput` via:
//
//	        EncryptionPropertyArgs{...}
//
//	or:
//
//	        nil
type EncryptionPropertyPtrInput interface {
	pulumi.Input

	ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput
	ToEncryptionPropertyPtrOutputWithContext(context.Context) EncryptionPropertyPtrOutput
}

type encryptionPropertyPtrType EncryptionPropertyArgs

func EncryptionPropertyPtr(v *EncryptionPropertyArgs) EncryptionPropertyPtrInput {
	return (*encryptionPropertyPtrType)(v)
}

func (*encryptionPropertyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionProperty)(nil)).Elem()
}

func (i *encryptionPropertyPtrType) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return i.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (i *encryptionPropertyPtrType) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyPtrOutput)
}

type EncryptionPropertyOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionProperty)(nil)).Elem()
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyOutput() EncryptionPropertyOutput {
	return o
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyOutputWithContext(ctx context.Context) EncryptionPropertyOutput {
	return o
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return o.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EncryptionProperty) *EncryptionProperty {
		return &v
	}).(EncryptionPropertyPtrOutput)
}

// The identity that will be used to access the key vault for encryption at rest.
func (o EncryptionPropertyOutput) Identity() IdentityForCmkPtrOutput {
	return o.ApplyT(func(v EncryptionProperty) *IdentityForCmk { return v.Identity }).(IdentityForCmkPtrOutput)
}

// Customer Key vault properties.
func (o EncryptionPropertyOutput) KeyVaultProperties() EncryptionKeyVaultPropertiesOutput {
	return o.ApplyT(func(v EncryptionProperty) EncryptionKeyVaultProperties { return v.KeyVaultProperties }).(EncryptionKeyVaultPropertiesOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionProperty) string { return v.Status }).(pulumi.StringOutput)
}

type EncryptionPropertyPtrOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionProperty)(nil)).Elem()
}

func (o EncryptionPropertyPtrOutput) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return o
}

func (o EncryptionPropertyPtrOutput) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return o
}

func (o EncryptionPropertyPtrOutput) Elem() EncryptionPropertyOutput {
	return o.ApplyT(func(v *EncryptionProperty) EncryptionProperty {
		if v != nil {
			return *v
		}
		var ret EncryptionProperty
		return ret
	}).(EncryptionPropertyOutput)
}

// The identity that will be used to access the key vault for encryption at rest.
func (o EncryptionPropertyPtrOutput) Identity() IdentityForCmkPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *IdentityForCmk {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(IdentityForCmkPtrOutput)
}

// Customer Key vault properties.
func (o EncryptionPropertyPtrOutput) KeyVaultProperties() EncryptionKeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *EncryptionKeyVaultProperties {
		if v == nil {
			return nil
		}
		return &v.KeyVaultProperties
	}).(EncryptionKeyVaultPropertiesPtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

type EncryptionPropertyResponse struct {
	// The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmkResponse `pulumi:"identity"`
	// Customer Key vault properties.
	KeyVaultProperties EncryptionKeyVaultPropertiesResponse `pulumi:"keyVaultProperties"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status string `pulumi:"status"`
}

type EncryptionPropertyResponseOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionPropertyResponse)(nil)).Elem()
}

func (o EncryptionPropertyResponseOutput) ToEncryptionPropertyResponseOutput() EncryptionPropertyResponseOutput {
	return o
}

func (o EncryptionPropertyResponseOutput) ToEncryptionPropertyResponseOutputWithContext(ctx context.Context) EncryptionPropertyResponseOutput {
	return o
}

// The identity that will be used to access the key vault for encryption at rest.
func (o EncryptionPropertyResponseOutput) Identity() IdentityForCmkResponsePtrOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) *IdentityForCmkResponse { return v.Identity }).(IdentityForCmkResponsePtrOutput)
}

// Customer Key vault properties.
func (o EncryptionPropertyResponseOutput) KeyVaultProperties() EncryptionKeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) EncryptionKeyVaultPropertiesResponse { return v.KeyVaultProperties }).(EncryptionKeyVaultPropertiesResponseOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) string { return v.Status }).(pulumi.StringOutput)
}

type EncryptionPropertyResponsePtrOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionPropertyResponse)(nil)).Elem()
}

func (o EncryptionPropertyResponsePtrOutput) ToEncryptionPropertyResponsePtrOutput() EncryptionPropertyResponsePtrOutput {
	return o
}

func (o EncryptionPropertyResponsePtrOutput) ToEncryptionPropertyResponsePtrOutputWithContext(ctx context.Context) EncryptionPropertyResponsePtrOutput {
	return o
}

func (o EncryptionPropertyResponsePtrOutput) Elem() EncryptionPropertyResponseOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) EncryptionPropertyResponse {
		if v != nil {
			return *v
		}
		var ret EncryptionPropertyResponse
		return ret
	}).(EncryptionPropertyResponseOutput)
}

// The identity that will be used to access the key vault for encryption at rest.
func (o EncryptionPropertyResponsePtrOutput) Identity() IdentityForCmkResponsePtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *IdentityForCmkResponse {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(IdentityForCmkResponsePtrOutput)
}

// Customer Key vault properties.
func (o EncryptionPropertyResponsePtrOutput) KeyVaultProperties() EncryptionKeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *EncryptionKeyVaultPropertiesResponse {
		if v == nil {
			return nil
		}
		return &v.KeyVaultProperties
	}).(EncryptionKeyVaultPropertiesResponsePtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// Keys for endpoint authentication.
type EndpointAuthKeys struct {
	// The primary key.
	PrimaryKey *string `pulumi:"primaryKey"`
	// The secondary key.
	SecondaryKey *string `pulumi:"secondaryKey"`
}

// EndpointAuthKeysInput is an input type that accepts EndpointAuthKeysArgs and EndpointAuthKeysOutput values.
// You can construct a concrete instance of `EndpointAuthKeysInput` via:
//
//	EndpointAuthKeysArgs{...}
type EndpointAuthKeysInput interface {
	pulumi.Input

	ToEndpointAuthKeysOutput() EndpointAuthKeysOutput
	ToEndpointAuthKeysOutputWithContext(context.Context) EndpointAuthKeysOutput
}

// Keys for endpoint authentication.
type EndpointAuthKeysArgs struct {
	// The primary key.
	PrimaryKey pulumi.StringPtrInput `pulumi:"primaryKey"`
	// The secondary key.
	SecondaryKey pulumi.StringPtrInput `pulumi:"secondaryKey"`
}

func (EndpointAuthKeysArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointAuthKeys)(nil)).Elem()
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysOutput() EndpointAuthKeysOutput {
	return i.ToEndpointAuthKeysOutputWithContext(context.Background())
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysOutputWithContext(ctx context.Context) EndpointAuthKeysOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysOutput)
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return i.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysOutput).ToEndpointAuthKeysPtrOutputWithContext(ctx)
}

// EndpointAuthKeysPtrInput is an input type that accepts EndpointAuthKeysArgs, EndpointAuthKeysPtr and EndpointAuthKeysPtrOutput values.
// You can construct a concrete instance of `EndpointAuthKeysPtrInput` via:
//
//	        EndpointAuthKeysArgs{...}
//
//	or:
//
//	        nil
type EndpointAuthKeysPtrInput interface {
	pulumi.Input

	ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput
	ToEndpointAuthKeysPtrOutputWithContext(context.Context) EndpointAuthKeysPtrOutput
}

type endpointAuthKeysPtrType EndpointAuthKeysArgs

func EndpointAuthKeysPtr(v *EndpointAuthKeysArgs) EndpointAuthKeysPtrInput {
	return (*endpointAuthKeysPtrType)(v)
}

func (*endpointAuthKeysPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAuthKeys)(nil)).Elem()
}

func (i *endpointAuthKeysPtrType) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return i.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (i *endpointAuthKeysPtrType) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysPtrOutput)
}

// Keys for endpoint authentication.
type EndpointAuthKeysOutput struct{ *pulumi.OutputState }

func (EndpointAuthKeysOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointAuthKeys)(nil)).Elem()
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysOutput() EndpointAuthKeysOutput {
	return o
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysOutputWithContext(ctx context.Context) EndpointAuthKeysOutput {
	return o
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return o.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EndpointAuthKeys) *EndpointAuthKeys {
		return &v
	}).(EndpointAuthKeysPtrOutput)
}

// The primary key.
func (o EndpointAuthKeysOutput) PrimaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EndpointAuthKeys) *string { return v.PrimaryKey }).(pulumi.StringPtrOutput)
}

// The secondary key.
func (o EndpointAuthKeysOutput) SecondaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EndpointAuthKeys) *string { return v.SecondaryKey }).(pulumi.StringPtrOutput)
}

type EndpointAuthKeysPtrOutput struct{ *pulumi.OutputState }

func (EndpointAuthKeysPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAuthKeys)(nil)).Elem()
}

func (o EndpointAuthKeysPtrOutput) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return o
}

func (o EndpointAuthKeysPtrOutput) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return o
}

func (o EndpointAuthKeysPtrOutput) Elem() EndpointAuthKeysOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) EndpointAuthKeys {
		if v != nil {
			return *v
		}
		var ret EndpointAuthKeys
		return ret
	}).(EndpointAuthKeysOutput)
}

// The primary key.
func (o EndpointAuthKeysPtrOutput) PrimaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) *string {
		if v == nil {
			return nil
		}
		return v.PrimaryKey
	}).(pulumi.StringPtrOutput)
}

// The secondary key.
func (o EndpointAuthKeysPtrOutput) SecondaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) *string {
		if v == nil {
			return nil
		}
		return v.SecondaryKey
	}).(pulumi.StringPtrOutput)
}

// Container for environment specification versions.
type EnvironmentContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerType
func (val *EnvironmentContainerType) Defaults() *EnvironmentContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// EnvironmentContainerTypeInput is an input type that accepts EnvironmentContainerTypeArgs and EnvironmentContainerTypeOutput values.
// You can construct a concrete instance of `EnvironmentContainerTypeInput` via:
//
//	EnvironmentContainerTypeArgs{...}
type EnvironmentContainerTypeInput interface {
	pulumi.Input

	ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput
	ToEnvironmentContainerTypeOutputWithContext(context.Context) EnvironmentContainerTypeOutput
}

// Container for environment specification versions.
type EnvironmentContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerTypeArgs
func (val *EnvironmentContainerTypeArgs) Defaults() *EnvironmentContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (EnvironmentContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerType)(nil)).Elem()
}

func (i EnvironmentContainerTypeArgs) ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput {
	return i.ToEnvironmentContainerTypeOutputWithContext(context.Background())
}

func (i EnvironmentContainerTypeArgs) ToEnvironmentContainerTypeOutputWithContext(ctx context.Context) EnvironmentContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentContainerTypeOutput)
}

// Container for environment specification versions.
type EnvironmentContainerTypeOutput struct{ *pulumi.OutputState }

func (EnvironmentContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerType)(nil)).Elem()
}

func (o EnvironmentContainerTypeOutput) ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput {
	return o
}

func (o EnvironmentContainerTypeOutput) ToEnvironmentContainerTypeOutputWithContext(ctx context.Context) EnvironmentContainerTypeOutput {
	return o
}

// The asset description text.
func (o EnvironmentContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o EnvironmentContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for environment specification versions.
type EnvironmentContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerResponse
func (val *EnvironmentContainerResponse) Defaults() *EnvironmentContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for environment specification versions.
type EnvironmentContainerResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerResponse)(nil)).Elem()
}

func (o EnvironmentContainerResponseOutput) ToEnvironmentContainerResponseOutput() EnvironmentContainerResponseOutput {
	return o
}

func (o EnvironmentContainerResponseOutput) ToEnvironmentContainerResponseOutputWithContext(ctx context.Context) EnvironmentContainerResponseOutput {
	return o
}

// The asset description text.
func (o EnvironmentContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o EnvironmentContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o EnvironmentContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o EnvironmentContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o EnvironmentContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Environment version details.
type EnvironmentVersionType struct {
	// Configuration settings for Docker build context.
	Build *BuildContext `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile *string `pulumi:"condaFile"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image *string `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig *InferenceContainerProperties `pulumi:"inferenceConfig"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType *string `pulumi:"osType"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionType
func (val *EnvironmentVersionType) Defaults() *EnvironmentVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Build = tmp.Build.Defaults()

	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if isZero(tmp.OsType) {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	return &tmp
}

// EnvironmentVersionTypeInput is an input type that accepts EnvironmentVersionTypeArgs and EnvironmentVersionTypeOutput values.
// You can construct a concrete instance of `EnvironmentVersionTypeInput` via:
//
//	EnvironmentVersionTypeArgs{...}
type EnvironmentVersionTypeInput interface {
	pulumi.Input

	ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput
	ToEnvironmentVersionTypeOutputWithContext(context.Context) EnvironmentVersionTypeOutput
}

// Environment version details.
type EnvironmentVersionTypeArgs struct {
	// Configuration settings for Docker build context.
	Build BuildContextPtrInput `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile pulumi.StringPtrInput `pulumi:"condaFile"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig InferenceContainerPropertiesPtrInput `pulumi:"inferenceConfig"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType pulumi.StringPtrInput `pulumi:"osType"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionTypeArgs
func (val *EnvironmentVersionTypeArgs) Defaults() *EnvironmentVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if isZero(tmp.IsAnonymous) {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	if isZero(tmp.OsType) {
		tmp.OsType = pulumi.StringPtr("Linux")
	}
	return &tmp
}
func (EnvironmentVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionType)(nil)).Elem()
}

func (i EnvironmentVersionTypeArgs) ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput {
	return i.ToEnvironmentVersionTypeOutputWithContext(context.Background())
}

func (i EnvironmentVersionTypeArgs) ToEnvironmentVersionTypeOutputWithContext(ctx context.Context) EnvironmentVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentVersionTypeOutput)
}

// Environment version details.
type EnvironmentVersionTypeOutput struct{ *pulumi.OutputState }

func (EnvironmentVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionType)(nil)).Elem()
}

func (o EnvironmentVersionTypeOutput) ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput {
	return o
}

func (o EnvironmentVersionTypeOutput) ToEnvironmentVersionTypeOutputWithContext(ctx context.Context) EnvironmentVersionTypeOutput {
	return o
}

// Configuration settings for Docker build context.
func (o EnvironmentVersionTypeOutput) Build() BuildContextPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *BuildContext { return v.Build }).(BuildContextPtrOutput)
}

// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
func (o EnvironmentVersionTypeOutput) CondaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.CondaFile }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o EnvironmentVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the image that will be used for the environment.
// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
func (o EnvironmentVersionTypeOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Defines configuration specific to inference.
func (o EnvironmentVersionTypeOutput) InferenceConfig() InferenceContainerPropertiesPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *InferenceContainerProperties { return v.InferenceConfig }).(InferenceContainerPropertiesPtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o EnvironmentVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o EnvironmentVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The OS type of the environment.
func (o EnvironmentVersionTypeOutput) OsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.OsType }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Environment version details.
type EnvironmentVersionResponse struct {
	// Configuration settings for Docker build context.
	Build *BuildContextResponse `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile *string `pulumi:"condaFile"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Environment type is either user managed or curated by the Azure ML service
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
	EnvironmentType string `pulumi:"environmentType"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image *string `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig *InferenceContainerPropertiesResponse `pulumi:"inferenceConfig"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType *string `pulumi:"osType"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionResponse
func (val *EnvironmentVersionResponse) Defaults() *EnvironmentVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Build = tmp.Build.Defaults()

	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if isZero(tmp.OsType) {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	return &tmp
}

// Environment version details.
type EnvironmentVersionResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionResponse)(nil)).Elem()
}

func (o EnvironmentVersionResponseOutput) ToEnvironmentVersionResponseOutput() EnvironmentVersionResponseOutput {
	return o
}

func (o EnvironmentVersionResponseOutput) ToEnvironmentVersionResponseOutputWithContext(ctx context.Context) EnvironmentVersionResponseOutput {
	return o
}

// Configuration settings for Docker build context.
func (o EnvironmentVersionResponseOutput) Build() BuildContextResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *BuildContextResponse { return v.Build }).(BuildContextResponsePtrOutput)
}

// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
func (o EnvironmentVersionResponseOutput) CondaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.CondaFile }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o EnvironmentVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Environment type is either user managed or curated by the Azure ML service
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
func (o EnvironmentVersionResponseOutput) EnvironmentType() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) string { return v.EnvironmentType }).(pulumi.StringOutput)
}

// Name of the image that will be used for the environment.
// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
func (o EnvironmentVersionResponseOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Defines configuration specific to inference.
func (o EnvironmentVersionResponseOutput) InferenceConfig() InferenceContainerPropertiesResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *InferenceContainerPropertiesResponse { return v.InferenceConfig }).(InferenceContainerPropertiesResponsePtrOutput)
}

// If the name version are system generated (anonymous registration).
func (o EnvironmentVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o EnvironmentVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The OS type of the environment.
func (o EnvironmentVersionResponseOutput) OsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.OsType }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The resource management error additional info.
type ErrorAdditionalInfoResponse struct {
	// The additional info.
	Info interface{} `pulumi:"info"`
	// The additional info type.
	Type string `pulumi:"type"`
}

// The error detail.
type ErrorDetailResponse struct {
	// The error additional info.
	AdditionalInfo []ErrorAdditionalInfoResponse `pulumi:"additionalInfo"`
	// The error code.
	Code string `pulumi:"code"`
	// The error details.
	Details []ErrorDetailResponse `pulumi:"details"`
	// The error message.
	Message string `pulumi:"message"`
	// The error target.
	Target string `pulumi:"target"`
}

// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
type ErrorResponseResponse struct {
	// The error object.
	Error *ErrorDetailResponse `pulumi:"error"`
}

type FlavorData struct {
	// Model flavor-specific data.
	Data map[string]string `pulumi:"data"`
}

// FlavorDataInput is an input type that accepts FlavorDataArgs and FlavorDataOutput values.
// You can construct a concrete instance of `FlavorDataInput` via:
//
//	FlavorDataArgs{...}
type FlavorDataInput interface {
	pulumi.Input

	ToFlavorDataOutput() FlavorDataOutput
	ToFlavorDataOutputWithContext(context.Context) FlavorDataOutput
}

type FlavorDataArgs struct {
	// Model flavor-specific data.
	Data pulumi.StringMapInput `pulumi:"data"`
}

func (FlavorDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorData)(nil)).Elem()
}

func (i FlavorDataArgs) ToFlavorDataOutput() FlavorDataOutput {
	return i.ToFlavorDataOutputWithContext(context.Background())
}

func (i FlavorDataArgs) ToFlavorDataOutputWithContext(ctx context.Context) FlavorDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlavorDataOutput)
}

// FlavorDataMapInput is an input type that accepts FlavorDataMap and FlavorDataMapOutput values.
// You can construct a concrete instance of `FlavorDataMapInput` via:
//
//	FlavorDataMap{ "key": FlavorDataArgs{...} }
type FlavorDataMapInput interface {
	pulumi.Input

	ToFlavorDataMapOutput() FlavorDataMapOutput
	ToFlavorDataMapOutputWithContext(context.Context) FlavorDataMapOutput
}

type FlavorDataMap map[string]FlavorDataInput

func (FlavorDataMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorData)(nil)).Elem()
}

func (i FlavorDataMap) ToFlavorDataMapOutput() FlavorDataMapOutput {
	return i.ToFlavorDataMapOutputWithContext(context.Background())
}

func (i FlavorDataMap) ToFlavorDataMapOutputWithContext(ctx context.Context) FlavorDataMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlavorDataMapOutput)
}

type FlavorDataOutput struct{ *pulumi.OutputState }

func (FlavorDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorData)(nil)).Elem()
}

func (o FlavorDataOutput) ToFlavorDataOutput() FlavorDataOutput {
	return o
}

func (o FlavorDataOutput) ToFlavorDataOutputWithContext(ctx context.Context) FlavorDataOutput {
	return o
}

// Model flavor-specific data.
func (o FlavorDataOutput) Data() pulumi.StringMapOutput {
	return o.ApplyT(func(v FlavorData) map[string]string { return v.Data }).(pulumi.StringMapOutput)
}

type FlavorDataMapOutput struct{ *pulumi.OutputState }

func (FlavorDataMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorData)(nil)).Elem()
}

func (o FlavorDataMapOutput) ToFlavorDataMapOutput() FlavorDataMapOutput {
	return o
}

func (o FlavorDataMapOutput) ToFlavorDataMapOutputWithContext(ctx context.Context) FlavorDataMapOutput {
	return o
}

func (o FlavorDataMapOutput) MapIndex(k pulumi.StringInput) FlavorDataOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) FlavorData {
		return vs[0].(map[string]FlavorData)[vs[1].(string)]
	}).(FlavorDataOutput)
}

type FlavorDataResponse struct {
	// Model flavor-specific data.
	Data map[string]string `pulumi:"data"`
}

type FlavorDataResponseOutput struct{ *pulumi.OutputState }

func (FlavorDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorDataResponse)(nil)).Elem()
}

func (o FlavorDataResponseOutput) ToFlavorDataResponseOutput() FlavorDataResponseOutput {
	return o
}

func (o FlavorDataResponseOutput) ToFlavorDataResponseOutputWithContext(ctx context.Context) FlavorDataResponseOutput {
	return o
}

// Model flavor-specific data.
func (o FlavorDataResponseOutput) Data() pulumi.StringMapOutput {
	return o.ApplyT(func(v FlavorDataResponse) map[string]string { return v.Data }).(pulumi.StringMapOutput)
}

type FlavorDataResponseMapOutput struct{ *pulumi.OutputState }

func (FlavorDataResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorDataResponse)(nil)).Elem()
}

func (o FlavorDataResponseMapOutput) ToFlavorDataResponseMapOutput() FlavorDataResponseMapOutput {
	return o
}

func (o FlavorDataResponseMapOutput) ToFlavorDataResponseMapOutputWithContext(ctx context.Context) FlavorDataResponseMapOutput {
	return o
}

func (o FlavorDataResponseMapOutput) MapIndex(k pulumi.StringInput) FlavorDataResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) FlavorDataResponse {
		return vs[0].(map[string]FlavorDataResponse)[vs[1].(string)]
	}).(FlavorDataResponseOutput)
}

// Forecasting task in AutoML Table vertical.
type Forecasting struct {
	// Allowed models for forecasting task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for forecasting task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Forecasting task specific inputs.
	ForecastingSettings *ForecastingSettings `pulumi:"forecastingSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for forecasting task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Forecasting'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettings `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for Forecasting
func (val *Forecasting) Defaults() *Forecasting {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.ForecastingSettings = tmp.ForecastingSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

// Forecasting task in AutoML Table vertical.
type ForecastingResponse struct {
	// Allowed models for forecasting task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for forecasting task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Forecasting task specific inputs.
	ForecastingSettings *ForecastingSettingsResponse `pulumi:"forecastingSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for forecasting task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Forecasting'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettingsResponse `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for ForecastingResponse
func (val *ForecastingResponse) Defaults() *ForecastingResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.ForecastingSettings = tmp.ForecastingSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

// Forecasting specific parameters.
type ForecastingSettings struct {
	// Country or region for holidays for forecasting tasks.
	// These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
	CountryOrRegionForHolidays *string `pulumi:"countryOrRegionForHolidays"`
	// Number of periods between the origin time of one CV fold and the next fold. For
	// example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
	// three days apart.
	CvStepSize *int `pulumi:"cvStepSize"`
	// Flag for generating lags for the numeric features with 'auto' or null.
	FeatureLags *string `pulumi:"featureLags"`
	// The desired maximum forecast horizon in units of time-series frequency.
	ForecastHorizon interface{} `pulumi:"forecastHorizon"`
	// When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
	Frequency *string `pulumi:"frequency"`
	// Set time series seasonality as an integer multiple of the series frequency.
	// If seasonality is set to 'auto', it will be inferred.
	Seasonality interface{} `pulumi:"seasonality"`
	// The parameter defining how if AutoML should handle short time series.
	ShortSeriesHandlingConfig *string `pulumi:"shortSeriesHandlingConfig"`
	// The function to be used to aggregate the time series target column to conform to a user specified frequency.
	// If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
	TargetAggregateFunction *string `pulumi:"targetAggregateFunction"`
	// The number of past periods to lag from the target column.
	TargetLags interface{} `pulumi:"targetLags"`
	// The number of past periods used to create a rolling window average of the target column.
	TargetRollingWindowSize interface{} `pulumi:"targetRollingWindowSize"`
	// The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
	TimeColumnName *string `pulumi:"timeColumnName"`
	// The names of columns used to group a timeseries. It can be used to create multiple series.
	// If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
	TimeSeriesIdColumnNames []string `pulumi:"timeSeriesIdColumnNames"`
	// Configure STL Decomposition of the time-series target column.
	UseStl *string `pulumi:"useStl"`
}

// Defaults sets the appropriate defaults for ForecastingSettings
func (val *ForecastingSettings) Defaults() *ForecastingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.FeatureLags) {
		featureLags_ := "None"
		tmp.FeatureLags = &featureLags_
	}
	if isZero(tmp.ShortSeriesHandlingConfig) {
		shortSeriesHandlingConfig_ := "Auto"
		tmp.ShortSeriesHandlingConfig = &shortSeriesHandlingConfig_
	}
	if isZero(tmp.TargetAggregateFunction) {
		targetAggregateFunction_ := "None"
		tmp.TargetAggregateFunction = &targetAggregateFunction_
	}
	if isZero(tmp.UseStl) {
		useStl_ := "None"
		tmp.UseStl = &useStl_
	}
	return &tmp
}

// Forecasting specific parameters.
type ForecastingSettingsResponse struct {
	// Country or region for holidays for forecasting tasks.
	// These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
	CountryOrRegionForHolidays *string `pulumi:"countryOrRegionForHolidays"`
	// Number of periods between the origin time of one CV fold and the next fold. For
	// example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
	// three days apart.
	CvStepSize *int `pulumi:"cvStepSize"`
	// Flag for generating lags for the numeric features with 'auto' or null.
	FeatureLags *string `pulumi:"featureLags"`
	// The desired maximum forecast horizon in units of time-series frequency.
	ForecastHorizon interface{} `pulumi:"forecastHorizon"`
	// When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
	Frequency *string `pulumi:"frequency"`
	// Set time series seasonality as an integer multiple of the series frequency.
	// If seasonality is set to 'auto', it will be inferred.
	Seasonality interface{} `pulumi:"seasonality"`
	// The parameter defining how if AutoML should handle short time series.
	ShortSeriesHandlingConfig *string `pulumi:"shortSeriesHandlingConfig"`
	// The function to be used to aggregate the time series target column to conform to a user specified frequency.
	// If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
	TargetAggregateFunction *string `pulumi:"targetAggregateFunction"`
	// The number of past periods to lag from the target column.
	TargetLags interface{} `pulumi:"targetLags"`
	// The number of past periods used to create a rolling window average of the target column.
	TargetRollingWindowSize interface{} `pulumi:"targetRollingWindowSize"`
	// The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
	TimeColumnName *string `pulumi:"timeColumnName"`
	// The names of columns used to group a timeseries. It can be used to create multiple series.
	// If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
	TimeSeriesIdColumnNames []string `pulumi:"timeSeriesIdColumnNames"`
	// Configure STL Decomposition of the time-series target column.
	UseStl *string `pulumi:"useStl"`
}

// Defaults sets the appropriate defaults for ForecastingSettingsResponse
func (val *ForecastingSettingsResponse) Defaults() *ForecastingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.FeatureLags) {
		featureLags_ := "None"
		tmp.FeatureLags = &featureLags_
	}
	if isZero(tmp.ShortSeriesHandlingConfig) {
		shortSeriesHandlingConfig_ := "Auto"
		tmp.ShortSeriesHandlingConfig = &shortSeriesHandlingConfig_
	}
	if isZero(tmp.TargetAggregateFunction) {
		targetAggregateFunction_ := "None"
		tmp.TargetAggregateFunction = &targetAggregateFunction_
	}
	if isZero(tmp.UseStl) {
		useStl_ := "None"
		tmp.UseStl = &useStl_
	}
	return &tmp
}

// Defines a Sampling Algorithm that exhaustively generates every value combination in the space
type GridSamplingAlgorithm struct {
	// Expected value is 'Grid'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// Defines a Sampling Algorithm that exhaustively generates every value combination in the space
type GridSamplingAlgorithmResponse struct {
	// Expected value is 'Grid'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// A HDInsight compute.
type HDInsight struct {
	// The type of compute
	// Expected value is 'HDInsight'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// HDInsight compute properties
	Properties *HDInsightProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// HDInsight compute properties
type HDInsightProperties struct {
	// Public IP address of the master node of the cluster.
	Address *string `pulumi:"address"`
	// Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials `pulumi:"administratorAccount"`
	// Port open for ssh connections on the master node of the cluster.
	SshPort *int `pulumi:"sshPort"`
}

// HDInsight compute properties
type HDInsightPropertiesResponse struct {
	// Public IP address of the master node of the cluster.
	Address *string `pulumi:"address"`
	// Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentialsResponse `pulumi:"administratorAccount"`
	// Port open for ssh connections on the master node of the cluster.
	SshPort *int `pulumi:"sshPort"`
}

// A HDInsight compute.
type HDInsightResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'HDInsight'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// HDInsight compute properties
	Properties *HDInsightPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type HdfsDatastore struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'Hdfs'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
	HdfsServerCertificate *string `pulumi:"hdfsServerCertificate"`
	// [Required] IP Address or DNS HostName.
	NameNodeAddress string `pulumi:"nameNodeAddress"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account (Https/Http).
	Protocol *string `pulumi:"protocol"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for HdfsDatastore
func (val *HdfsDatastore) Defaults() *HdfsDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Protocol) {
		protocol_ := "http"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

type HdfsDatastoreResponse struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'Hdfs'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
	HdfsServerCertificate *string `pulumi:"hdfsServerCertificate"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// [Required] IP Address or DNS HostName.
	NameNodeAddress string `pulumi:"nameNodeAddress"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account (Https/Http).
	Protocol *string `pulumi:"protocol"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for HdfsDatastoreResponse
func (val *HdfsDatastoreResponse) Defaults() *HdfsDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Protocol) {
		protocol_ := "http"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

// Reference to an asset via its ARM resource ID.
type IdAssetReference struct {
	// [Required] ARM resource ID of the asset.
	AssetId string `pulumi:"assetId"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'Id'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its ARM resource ID.
type IdAssetReferenceResponse struct {
	// [Required] ARM resource ID of the asset.
	AssetId string `pulumi:"assetId"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'Id'.
	ReferenceType string `pulumi:"referenceType"`
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmk struct {
	// The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

// IdentityForCmkInput is an input type that accepts IdentityForCmkArgs and IdentityForCmkOutput values.
// You can construct a concrete instance of `IdentityForCmkInput` via:
//
//	IdentityForCmkArgs{...}
type IdentityForCmkInput interface {
	pulumi.Input

	ToIdentityForCmkOutput() IdentityForCmkOutput
	ToIdentityForCmkOutputWithContext(context.Context) IdentityForCmkOutput
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmkArgs struct {
	// The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity pulumi.StringPtrInput `pulumi:"userAssignedIdentity"`
}

func (IdentityForCmkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmk)(nil)).Elem()
}

func (i IdentityForCmkArgs) ToIdentityForCmkOutput() IdentityForCmkOutput {
	return i.ToIdentityForCmkOutputWithContext(context.Background())
}

func (i IdentityForCmkArgs) ToIdentityForCmkOutputWithContext(ctx context.Context) IdentityForCmkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkOutput)
}

func (i IdentityForCmkArgs) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return i.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (i IdentityForCmkArgs) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkOutput).ToIdentityForCmkPtrOutputWithContext(ctx)
}

// IdentityForCmkPtrInput is an input type that accepts IdentityForCmkArgs, IdentityForCmkPtr and IdentityForCmkPtrOutput values.
// You can construct a concrete instance of `IdentityForCmkPtrInput` via:
//
//	        IdentityForCmkArgs{...}
//
//	or:
//
//	        nil
type IdentityForCmkPtrInput interface {
	pulumi.Input

	ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput
	ToIdentityForCmkPtrOutputWithContext(context.Context) IdentityForCmkPtrOutput
}

type identityForCmkPtrType IdentityForCmkArgs

func IdentityForCmkPtr(v *IdentityForCmkArgs) IdentityForCmkPtrInput {
	return (*identityForCmkPtrType)(v)
}

func (*identityForCmkPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmk)(nil)).Elem()
}

func (i *identityForCmkPtrType) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return i.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (i *identityForCmkPtrType) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkPtrOutput)
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmkOutput struct{ *pulumi.OutputState }

func (IdentityForCmkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmk)(nil)).Elem()
}

func (o IdentityForCmkOutput) ToIdentityForCmkOutput() IdentityForCmkOutput {
	return o
}

func (o IdentityForCmkOutput) ToIdentityForCmkOutputWithContext(ctx context.Context) IdentityForCmkOutput {
	return o
}

func (o IdentityForCmkOutput) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return o.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (o IdentityForCmkOutput) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IdentityForCmk) *IdentityForCmk {
		return &v
	}).(IdentityForCmkPtrOutput)
}

// The ArmId of the user assigned identity that will be used to access the customer managed key vault
func (o IdentityForCmkOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IdentityForCmk) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type IdentityForCmkPtrOutput struct{ *pulumi.OutputState }

func (IdentityForCmkPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmk)(nil)).Elem()
}

func (o IdentityForCmkPtrOutput) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return o
}

func (o IdentityForCmkPtrOutput) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return o
}

func (o IdentityForCmkPtrOutput) Elem() IdentityForCmkOutput {
	return o.ApplyT(func(v *IdentityForCmk) IdentityForCmk {
		if v != nil {
			return *v
		}
		var ret IdentityForCmk
		return ret
	}).(IdentityForCmkOutput)
}

// The ArmId of the user assigned identity that will be used to access the customer managed key vault
func (o IdentityForCmkPtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdentityForCmk) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmkResponse struct {
	// The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmkResponseOutput struct{ *pulumi.OutputState }

func (IdentityForCmkResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmkResponse)(nil)).Elem()
}

func (o IdentityForCmkResponseOutput) ToIdentityForCmkResponseOutput() IdentityForCmkResponseOutput {
	return o
}

func (o IdentityForCmkResponseOutput) ToIdentityForCmkResponseOutputWithContext(ctx context.Context) IdentityForCmkResponseOutput {
	return o
}

// The ArmId of the user assigned identity that will be used to access the customer managed key vault
func (o IdentityForCmkResponseOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IdentityForCmkResponse) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type IdentityForCmkResponsePtrOutput struct{ *pulumi.OutputState }

func (IdentityForCmkResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmkResponse)(nil)).Elem()
}

func (o IdentityForCmkResponsePtrOutput) ToIdentityForCmkResponsePtrOutput() IdentityForCmkResponsePtrOutput {
	return o
}

func (o IdentityForCmkResponsePtrOutput) ToIdentityForCmkResponsePtrOutputWithContext(ctx context.Context) IdentityForCmkResponsePtrOutput {
	return o
}

func (o IdentityForCmkResponsePtrOutput) Elem() IdentityForCmkResponseOutput {
	return o.ApplyT(func(v *IdentityForCmkResponse) IdentityForCmkResponse {
		if v != nil {
			return *v
		}
		var ret IdentityForCmkResponse
		return ret
	}).(IdentityForCmkResponseOutput)
}

// The ArmId of the user assigned identity that will be used to access the customer managed key vault
func (o IdentityForCmkResponsePtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdentityForCmkResponse) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// Image Classification. Multi-class image classification is used when an image is classified with only a single label
// from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
type ImageClassification struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettings `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassification `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassification `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassification'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageClassification
func (val *ImageClassification) Defaults() *ImageClassification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
// from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
type ImageClassificationMultilabel struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettings `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassification `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassification `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageClassificationMultilabel
func (val *ImageClassificationMultilabel) Defaults() *ImageClassificationMultilabel {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "IOU"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
// from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
type ImageClassificationMultilabelResponse struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassificationResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassificationResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageClassificationMultilabelResponse
func (val *ImageClassificationMultilabelResponse) Defaults() *ImageClassificationMultilabelResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "IOU"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Classification. Multi-class image classification is used when an image is classified with only a single label
// from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
type ImageClassificationResponse struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassificationResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassificationResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassification'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageClassificationResponse
func (val *ImageClassificationResponse) Defaults() *ImageClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
// drawing a polygon around each object in the image.
type ImageInstanceSegmentation struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettings `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetection `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetection `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageInstanceSegmentation'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageInstanceSegmentation
func (val *ImageInstanceSegmentation) Defaults() *ImageInstanceSegmentation {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
// drawing a polygon around each object in the image.
type ImageInstanceSegmentationResponse struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetectionResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetectionResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageInstanceSegmentation'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageInstanceSegmentationResponse
func (val *ImageInstanceSegmentationResponse) Defaults() *ImageInstanceSegmentationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Limit settings for the AutoML job.
type ImageLimitSettings struct {
	// Maximum number of concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ImageLimitSettings
func (val *ImageLimitSettings) Defaults() *ImageLimitSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	return &tmp
}

// Limit settings for the AutoML job.
type ImageLimitSettingsResponse struct {
	// Maximum number of concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ImageLimitSettingsResponse
func (val *ImageLimitSettingsResponse) Defaults() *ImageLimitSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	return &tmp
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
// <code>
// ModelName = "choice('seresnext', 'resnest50')";
// LearningRate = "uniform(0.001, 0.01)";
// LayersToFreeze = "choice(0, 2)";
// </code></example>
// For more details on how to compose distribution expressions please check the documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelDistributionSettingsClassification struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *string `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *string `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *string `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *string `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *string `pulumi:"weightedLoss"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
// <code>
// ModelName = "choice('seresnext', 'resnest50')";
// LearningRate = "uniform(0.001, 0.01)";
// LayersToFreeze = "choice(0, 2)";
// </code></example>
// For more details on how to compose distribution expressions please check the documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelDistributionSettingsClassificationResponse struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *string `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *string `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *string `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *string `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *string `pulumi:"weightedLoss"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
// <code>
// ModelName = "choice('seresnext', 'resnest50')";
// LearningRate = "uniform(0.001, 0.01)";
// LayersToFreeze = "choice(0, 2)";
// </code></example>
// For more details on how to compose distribution expressions please check the documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelDistributionSettingsObjectDetection struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *string `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *string `pulumi:"boxScoreThreshold"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *string `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *string `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *string `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *string `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
	NmsIouThreshold *string `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *string `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *string `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	// NMS: Non-maximum suppression
	TilePredictionsNmsThreshold *string `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *string `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
// <code>
// ModelName = "choice('seresnext', 'resnest50')";
// LearningRate = "uniform(0.001, 0.01)";
// LayersToFreeze = "choice(0, 2)";
// </code></example>
// For more details on how to compose distribution expressions please check the documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelDistributionSettingsObjectDetectionResponse struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *string `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *string `pulumi:"boxScoreThreshold"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *string `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *string `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *string `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *string `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
	NmsIouThreshold *string `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *string `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *string `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	// NMS: Non-maximum suppression
	TilePredictionsNmsThreshold *string `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *string `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsClassification struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// FileDataset id for pretrained checkpoint(s) for incremental training.
	// Make sure to pass CheckpointFilename along with CheckpointDatasetId.
	CheckpointDatasetId *string `pulumi:"checkpointDatasetId"`
	// The pretrained checkpoint filename in FileDataset for incremental training.
	// Make sure to pass CheckpointDatasetId along with CheckpointFilename.
	CheckpointFilename *string `pulumi:"checkpointFilename"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *float64 `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *int `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *int `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *int `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *int `pulumi:"weightedLoss"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsClassification
func (val *ImageModelSettingsClassification) Defaults() *ImageModelSettingsClassification {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.LearningRateScheduler) {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if isZero(tmp.Optimizer) {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsClassificationResponse struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// FileDataset id for pretrained checkpoint(s) for incremental training.
	// Make sure to pass CheckpointFilename along with CheckpointDatasetId.
	CheckpointDatasetId *string `pulumi:"checkpointDatasetId"`
	// The pretrained checkpoint filename in FileDataset for incremental training.
	// Make sure to pass CheckpointDatasetId along with CheckpointFilename.
	CheckpointFilename *string `pulumi:"checkpointFilename"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *float64 `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *int `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *int `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *int `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *int `pulumi:"weightedLoss"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsClassificationResponse
func (val *ImageModelSettingsClassificationResponse) Defaults() *ImageModelSettingsClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.LearningRateScheduler) {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if isZero(tmp.Optimizer) {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsObjectDetection struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *int `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *float64 `pulumi:"boxScoreThreshold"`
	// FileDataset id for pretrained checkpoint(s) for incremental training.
	// Make sure to pass CheckpointFilename along with CheckpointDatasetId.
	CheckpointDatasetId *string `pulumi:"checkpointDatasetId"`
	// The pretrained checkpoint filename in FileDataset for incremental training.
	// Make sure to pass CheckpointDatasetId along with CheckpointFilename.
	CheckpointFilename *string `pulumi:"checkpointFilename"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *int `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *int `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *int `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *bool `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
	NmsIouThreshold *float64 `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *float64 `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *float64 `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TilePredictionsNmsThreshold *float64 `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *float64 `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsObjectDetection
func (val *ImageModelSettingsObjectDetection) Defaults() *ImageModelSettingsObjectDetection {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.LearningRateScheduler) {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if isZero(tmp.ModelSize) {
		modelSize_ := "None"
		tmp.ModelSize = &modelSize_
	}
	if isZero(tmp.Optimizer) {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	if isZero(tmp.ValidationMetricType) {
		validationMetricType_ := "None"
		tmp.ValidationMetricType = &validationMetricType_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsObjectDetectionResponse struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *int `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *float64 `pulumi:"boxScoreThreshold"`
	// FileDataset id for pretrained checkpoint(s) for incremental training.
	// Make sure to pass CheckpointFilename along with CheckpointDatasetId.
	CheckpointDatasetId *string `pulumi:"checkpointDatasetId"`
	// The pretrained checkpoint filename in FileDataset for incremental training.
	// Make sure to pass CheckpointDatasetId along with CheckpointFilename.
	CheckpointFilename *string `pulumi:"checkpointFilename"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *int `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *int `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *int `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *bool `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
	NmsIouThreshold *float64 `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// If validation data is not defined, this specifies the split ratio for splitting
	// train data into random train and validation subsets. Must be a float in the range [0, 1].
	SplitRatio *float64 `pulumi:"splitRatio"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *float64 `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TilePredictionsNmsThreshold *float64 `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *float64 `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsObjectDetectionResponse
func (val *ImageModelSettingsObjectDetectionResponse) Defaults() *ImageModelSettingsObjectDetectionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.LearningRateScheduler) {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if isZero(tmp.ModelSize) {
		modelSize_ := "None"
		tmp.ModelSize = &modelSize_
	}
	if isZero(tmp.Optimizer) {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	if isZero(tmp.ValidationMetricType) {
		validationMetricType_ := "None"
		tmp.ValidationMetricType = &validationMetricType_
	}
	return &tmp
}

// Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
// bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
type ImageObjectDetection struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettings `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetection `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetection `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageObjectDetection'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageObjectDetection
func (val *ImageObjectDetection) Defaults() *ImageObjectDetection {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
// bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
type ImageObjectDetectionResponse struct {
	// [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
	DataSettings ImageVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetectionResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetectionResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// AutoMLJob Task type.
	// Expected value is 'ImageObjectDetection'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for ImageObjectDetectionResponse
func (val *ImageObjectDetectionResponse) Defaults() *ImageObjectDetectionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = *tmp.DataSettings.Defaults()

	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Limit settings for model sweeping and hyperparameter sweeping.
type ImageSweepLimitSettings struct {
	// Maximum number of concurrent iterations for the underlying Sweep job.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of iterations for the underlying Sweep job.
	MaxTrials *int `pulumi:"maxTrials"`
}

// Limit settings for model sweeping and hyperparameter sweeping.
type ImageSweepLimitSettingsResponse struct {
	// Maximum number of concurrent iterations for the underlying Sweep job.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of iterations for the underlying Sweep job.
	MaxTrials *int `pulumi:"maxTrials"`
}

// Model sweeping and hyperparameter sweeping related settings.
type ImageSweepSettings struct {
	// Type of early termination policy.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Limit settings for model sweeping and hyperparameter sweeping.
	Limits ImageSweepLimitSettings `pulumi:"limits"`
	// [Required] Type of the hyperparameter sampling algorithms.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

// Model sweeping and hyperparameter sweeping related settings.
type ImageSweepSettingsResponse struct {
	// Type of early termination policy.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Limit settings for model sweeping and hyperparameter sweeping.
	Limits ImageSweepLimitSettingsResponse `pulumi:"limits"`
	// [Required] Type of the hyperparameter sampling algorithms.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

// Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
type ImageVerticalDataSettings struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettings `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettings `pulumi:"trainingData"`
	// Settings for the validation dataset.
	ValidationData *ImageVerticalValidationDataSettings `pulumi:"validationData"`
}

// Defaults sets the appropriate defaults for ImageVerticalDataSettings
func (val *ImageVerticalDataSettings) Defaults() *ImageVerticalDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
type ImageVerticalDataSettingsResponse struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettingsResponse `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettingsResponse `pulumi:"trainingData"`
	// Settings for the validation dataset.
	ValidationData *ImageVerticalValidationDataSettingsResponse `pulumi:"validationData"`
}

// Defaults sets the appropriate defaults for ImageVerticalDataSettingsResponse
func (val *ImageVerticalDataSettingsResponse) Defaults() *ImageVerticalDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

type ImageVerticalValidationDataSettings struct {
	// Validation data MLTable.
	Data *MLTableJobInput `pulumi:"data"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageVerticalValidationDataSettings
func (val *ImageVerticalValidationDataSettings) Defaults() *ImageVerticalValidationDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

type ImageVerticalValidationDataSettingsResponse struct {
	// Validation data MLTable.
	Data *MLTableJobInputResponse `pulumi:"data"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageVerticalValidationDataSettingsResponse
func (val *ImageVerticalValidationDataSettingsResponse) Defaults() *ImageVerticalValidationDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

type InferenceContainerProperties struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute *Route `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute *Route `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute *Route `pulumi:"scoringRoute"`
}

// InferenceContainerPropertiesInput is an input type that accepts InferenceContainerPropertiesArgs and InferenceContainerPropertiesOutput values.
// You can construct a concrete instance of `InferenceContainerPropertiesInput` via:
//
//	InferenceContainerPropertiesArgs{...}
type InferenceContainerPropertiesInput interface {
	pulumi.Input

	ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput
	ToInferenceContainerPropertiesOutputWithContext(context.Context) InferenceContainerPropertiesOutput
}

type InferenceContainerPropertiesArgs struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute RoutePtrInput `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute RoutePtrInput `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute RoutePtrInput `pulumi:"scoringRoute"`
}

func (InferenceContainerPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerProperties)(nil)).Elem()
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput {
	return i.ToInferenceContainerPropertiesOutputWithContext(context.Background())
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesOutputWithContext(ctx context.Context) InferenceContainerPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesOutput)
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return i.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesOutput).ToInferenceContainerPropertiesPtrOutputWithContext(ctx)
}

// InferenceContainerPropertiesPtrInput is an input type that accepts InferenceContainerPropertiesArgs, InferenceContainerPropertiesPtr and InferenceContainerPropertiesPtrOutput values.
// You can construct a concrete instance of `InferenceContainerPropertiesPtrInput` via:
//
//	        InferenceContainerPropertiesArgs{...}
//
//	or:
//
//	        nil
type InferenceContainerPropertiesPtrInput interface {
	pulumi.Input

	ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput
	ToInferenceContainerPropertiesPtrOutputWithContext(context.Context) InferenceContainerPropertiesPtrOutput
}

type inferenceContainerPropertiesPtrType InferenceContainerPropertiesArgs

func InferenceContainerPropertiesPtr(v *InferenceContainerPropertiesArgs) InferenceContainerPropertiesPtrInput {
	return (*inferenceContainerPropertiesPtrType)(v)
}

func (*inferenceContainerPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerProperties)(nil)).Elem()
}

func (i *inferenceContainerPropertiesPtrType) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return i.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (i *inferenceContainerPropertiesPtrType) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesPtrOutput)
}

type InferenceContainerPropertiesOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerProperties)(nil)).Elem()
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput {
	return o
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesOutputWithContext(ctx context.Context) InferenceContainerPropertiesOutput {
	return o
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return o.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InferenceContainerProperties) *InferenceContainerProperties {
		return &v
	}).(InferenceContainerPropertiesPtrOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesOutput) LivenessRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.LivenessRoute }).(RoutePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesOutput) ReadinessRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.ReadinessRoute }).(RoutePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesOutput) ScoringRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.ScoringRoute }).(RoutePtrOutput)
}

type InferenceContainerPropertiesPtrOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerProperties)(nil)).Elem()
}

func (o InferenceContainerPropertiesPtrOutput) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return o
}

func (o InferenceContainerPropertiesPtrOutput) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return o
}

func (o InferenceContainerPropertiesPtrOutput) Elem() InferenceContainerPropertiesOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) InferenceContainerProperties {
		if v != nil {
			return *v
		}
		var ret InferenceContainerProperties
		return ret
	}).(InferenceContainerPropertiesOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesPtrOutput) LivenessRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.LivenessRoute
	}).(RoutePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesPtrOutput) ReadinessRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.ReadinessRoute
	}).(RoutePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesPtrOutput) ScoringRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.ScoringRoute
	}).(RoutePtrOutput)
}

type InferenceContainerPropertiesResponse struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute *RouteResponse `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute *RouteResponse `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute *RouteResponse `pulumi:"scoringRoute"`
}

type InferenceContainerPropertiesResponseOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerPropertiesResponse)(nil)).Elem()
}

func (o InferenceContainerPropertiesResponseOutput) ToInferenceContainerPropertiesResponseOutput() InferenceContainerPropertiesResponseOutput {
	return o
}

func (o InferenceContainerPropertiesResponseOutput) ToInferenceContainerPropertiesResponseOutputWithContext(ctx context.Context) InferenceContainerPropertiesResponseOutput {
	return o
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesResponseOutput) LivenessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.LivenessRoute }).(RouteResponsePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesResponseOutput) ReadinessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.ReadinessRoute }).(RouteResponsePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesResponseOutput) ScoringRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.ScoringRoute }).(RouteResponsePtrOutput)
}

type InferenceContainerPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerPropertiesResponse)(nil)).Elem()
}

func (o InferenceContainerPropertiesResponsePtrOutput) ToInferenceContainerPropertiesResponsePtrOutput() InferenceContainerPropertiesResponsePtrOutput {
	return o
}

func (o InferenceContainerPropertiesResponsePtrOutput) ToInferenceContainerPropertiesResponsePtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesResponsePtrOutput {
	return o
}

func (o InferenceContainerPropertiesResponsePtrOutput) Elem() InferenceContainerPropertiesResponseOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) InferenceContainerPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret InferenceContainerPropertiesResponse
		return ret
	}).(InferenceContainerPropertiesResponseOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) LivenessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.LivenessRoute
	}).(RouteResponsePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) ReadinessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.ReadinessRoute
	}).(RouteResponsePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) ScoringRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.ScoringRoute
	}).(RouteResponsePtrOutput)
}

// Instance type schema.
type InstanceTypeSchema struct {
	// Node Selector
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResources `pulumi:"resources"`
}

// Resource requests/limits for this instance type
type InstanceTypeSchemaResources struct {
	// Resource limits for this instance type
	Limits map[string]string `pulumi:"limits"`
	// Resource requests for this instance type
	Requests map[string]string `pulumi:"requests"`
}

// Instance type schema.
type InstanceTypeSchemaResponse struct {
	// Node Selector
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResponseResources `pulumi:"resources"`
}

// Resource requests/limits for this instance type
type InstanceTypeSchemaResponseResources struct {
	// Resource limits for this instance type
	Limits map[string]string `pulumi:"limits"`
	// Resource requests for this instance type
	Requests map[string]string `pulumi:"requests"`
}

// Job endpoint definition
type JobService struct {
	// Url for endpoint.
	Endpoint *string `pulumi:"endpoint"`
	// Endpoint type.
	JobServiceType *string `pulumi:"jobServiceType"`
	// Port for endpoint.
	Port *int `pulumi:"port"`
	// Additional properties to set on the endpoint.
	Properties map[string]string `pulumi:"properties"`
}

// Job endpoint definition
type JobServiceResponse struct {
	// Url for endpoint.
	Endpoint *string `pulumi:"endpoint"`
	// Any error in the service.
	ErrorMessage string `pulumi:"errorMessage"`
	// Endpoint type.
	JobServiceType *string `pulumi:"jobServiceType"`
	// Port for endpoint.
	Port *int `pulumi:"port"`
	// Additional properties to set on the endpoint.
	Properties map[string]string `pulumi:"properties"`
	// Status of endpoint.
	Status string `pulumi:"status"`
}

type KerberosKeytabCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosKeytab'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
	// [Required] Keytab secrets.
	Secrets KerberosKeytabSecrets `pulumi:"secrets"`
}

type KerberosKeytabCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosKeytab'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
}

type KerberosKeytabSecrets struct {
	// Kerberos keytab secret.
	KerberosKeytab *string `pulumi:"kerberosKeytab"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'KerberosKeytab'.
	SecretsType string `pulumi:"secretsType"`
}

type KerberosPasswordCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosPassword'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
	// [Required] Kerberos password secrets.
	Secrets KerberosPasswordSecrets `pulumi:"secrets"`
}

type KerberosPasswordCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosPassword'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
}

type KerberosPasswordSecrets struct {
	// Kerberos password secret.
	KerberosPassword *string `pulumi:"kerberosPassword"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'KerberosPassword'.
	SecretsType string `pulumi:"secretsType"`
}

// A Machine Learning compute based on Kubernetes Compute.
type Kubernetes struct {
	// The type of compute
	// Expected value is 'Kubernetes'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of Kubernetes
	Properties *KubernetesProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for Kubernetes
func (val *Kubernetes) Defaults() *Kubernetes {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Properties specific to a KubernetesOnlineDeployment.
type KubernetesOnlineDeployment struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// The resource requirements for the container (cpu and memory).
	ContainerResourceRequirements *ContainerResourceRequirements `pulumi:"containerResourceRequirements"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Kubernetes'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// If true, enable private network connection.
	// DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
	PrivateNetworkConnection *bool `pulumi:"privateNetworkConnection"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for KubernetesOnlineDeployment
func (val *KubernetesOnlineDeployment) Defaults() *KubernetesOnlineDeployment {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.AppInsightsEnabled) {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	if isZero(tmp.EgressPublicNetworkAccess) {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	if isZero(tmp.PrivateNetworkConnection) {
		privateNetworkConnection_ := false
		tmp.PrivateNetworkConnection = &privateNetworkConnection_
	}
	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Properties specific to a KubernetesOnlineDeployment.
type KubernetesOnlineDeploymentResponse struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// The resource requirements for the container (cpu and memory).
	ContainerResourceRequirements *ContainerResourceRequirementsResponse `pulumi:"containerResourceRequirements"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Kubernetes'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettingsResponse `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// If true, enable private network connection.
	// DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
	PrivateNetworkConnection *bool `pulumi:"privateNetworkConnection"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettingsResponse `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettingsResponse `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for KubernetesOnlineDeploymentResponse
func (val *KubernetesOnlineDeploymentResponse) Defaults() *KubernetesOnlineDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.AppInsightsEnabled) {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	if isZero(tmp.EgressPublicNetworkAccess) {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	if isZero(tmp.PrivateNetworkConnection) {
		privateNetworkConnection_ := false
		tmp.PrivateNetworkConnection = &privateNetworkConnection_
	}
	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Kubernetes properties
type KubernetesProperties struct {
	// Default instance type
	DefaultInstanceType *string `pulumi:"defaultInstanceType"`
	// Extension instance release train.
	ExtensionInstanceReleaseTrain *string `pulumi:"extensionInstanceReleaseTrain"`
	// Extension principal-id.
	ExtensionPrincipalId *string `pulumi:"extensionPrincipalId"`
	// Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema `pulumi:"instanceTypes"`
	// Compute namespace
	Namespace *string `pulumi:"namespace"`
	// Relay connection string.
	RelayConnectionString *string `pulumi:"relayConnectionString"`
	// ServiceBus connection string.
	ServiceBusConnectionString *string `pulumi:"serviceBusConnectionString"`
	// VC name.
	VcName *string `pulumi:"vcName"`
}

// Defaults sets the appropriate defaults for KubernetesProperties
func (val *KubernetesProperties) Defaults() *KubernetesProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Namespace) {
		namespace_ := "default"
		tmp.Namespace = &namespace_
	}
	return &tmp
}

// Kubernetes properties
type KubernetesPropertiesResponse struct {
	// Default instance type
	DefaultInstanceType *string `pulumi:"defaultInstanceType"`
	// Extension instance release train.
	ExtensionInstanceReleaseTrain *string `pulumi:"extensionInstanceReleaseTrain"`
	// Extension principal-id.
	ExtensionPrincipalId *string `pulumi:"extensionPrincipalId"`
	// Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchemaResponse `pulumi:"instanceTypes"`
	// Compute namespace
	Namespace *string `pulumi:"namespace"`
	// Relay connection string.
	RelayConnectionString *string `pulumi:"relayConnectionString"`
	// ServiceBus connection string.
	ServiceBusConnectionString *string `pulumi:"serviceBusConnectionString"`
	// VC name.
	VcName *string `pulumi:"vcName"`
}

// Defaults sets the appropriate defaults for KubernetesPropertiesResponse
func (val *KubernetesPropertiesResponse) Defaults() *KubernetesPropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Namespace) {
		namespace_ := "default"
		tmp.Namespace = &namespace_
	}
	return &tmp
}

// A Machine Learning compute based on Kubernetes Compute.
type KubernetesResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Kubernetes'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of Kubernetes
	Properties *KubernetesPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for KubernetesResponse
func (val *KubernetesResponse) Defaults() *KubernetesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

type ListNotebookKeysResultResponse struct {
	PrimaryAccessKey   string `pulumi:"primaryAccessKey"`
	SecondaryAccessKey string `pulumi:"secondaryAccessKey"`
}

type ListNotebookKeysResultResponseOutput struct{ *pulumi.OutputState }

func (ListNotebookKeysResultResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ListNotebookKeysResultResponse)(nil)).Elem()
}

func (o ListNotebookKeysResultResponseOutput) ToListNotebookKeysResultResponseOutput() ListNotebookKeysResultResponseOutput {
	return o
}

func (o ListNotebookKeysResultResponseOutput) ToListNotebookKeysResultResponseOutputWithContext(ctx context.Context) ListNotebookKeysResultResponseOutput {
	return o
}

func (o ListNotebookKeysResultResponseOutput) PrimaryAccessKey() pulumi.StringOutput {
	return o.ApplyT(func(v ListNotebookKeysResultResponse) string { return v.PrimaryAccessKey }).(pulumi.StringOutput)
}

func (o ListNotebookKeysResultResponseOutput) SecondaryAccessKey() pulumi.StringOutput {
	return o.ApplyT(func(v ListNotebookKeysResultResponse) string { return v.SecondaryAccessKey }).(pulumi.StringOutput)
}

// Literal input type.
type LiteralJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'Literal'.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Literal value for the input.
	Value string `pulumi:"value"`
}

// Literal input type.
type LiteralJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'Literal'.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Literal value for the input.
	Value string `pulumi:"value"`
}

type MLFlowModelJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'MLFlowModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobInput
func (val *MLFlowModelJobInput) Defaults() *MLFlowModelJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'MLFlowModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobInputResponse
func (val *MLFlowModelJobInputResponse) Defaults() *MLFlowModelJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'MLFlowModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobOutput
func (val *MLFlowModelJobOutput) Defaults() *MLFlowModelJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'MLFlowModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobOutputResponse
func (val *MLFlowModelJobOutputResponse) Defaults() *MLFlowModelJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// MLTable data definition
type MLTableData struct {
	// Enum to determine the type of data.
	// Expected value is 'MLTable'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Uris referenced in the MLTable definition (required for lineage)
	ReferencedUris []string `pulumi:"referencedUris"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for MLTableData
func (val *MLTableData) Defaults() *MLTableData {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// MLTable data definition
type MLTableDataResponse struct {
	// Enum to determine the type of data.
	// Expected value is 'MLTable'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Uris referenced in the MLTable definition (required for lineage)
	ReferencedUris []string `pulumi:"referencedUris"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for MLTableDataResponse
func (val *MLTableDataResponse) Defaults() *MLTableDataResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type MLTableJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'MLTable'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobInput
func (val *MLTableJobInput) Defaults() *MLTableJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'MLTable'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobInputResponse
func (val *MLTableJobInputResponse) Defaults() *MLTableJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'MLTable'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobOutput
func (val *MLTableJobOutput) Defaults() *MLTableJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'MLTable'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobOutputResponse
func (val *MLTableJobOutputResponse) Defaults() *MLTableJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Managed identity configuration.
type ManagedIdentity struct {
	// Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
	ClientId *string `pulumi:"clientId"`
	// Enum to determine identity framework.
	// Expected value is 'Managed'.
	IdentityType string `pulumi:"identityType"`
	// Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
	ObjectId *string `pulumi:"objectId"`
	// Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
	ResourceId *string `pulumi:"resourceId"`
}

// Managed identity configuration.
type ManagedIdentityResponse struct {
	// Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
	ClientId *string `pulumi:"clientId"`
	// Enum to determine identity framework.
	// Expected value is 'Managed'.
	IdentityType string `pulumi:"identityType"`
	// Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
	ObjectId *string `pulumi:"objectId"`
	// Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
	ResourceId *string `pulumi:"resourceId"`
}

// Properties specific to a ManagedOnlineDeployment.
type ManagedOnlineDeployment struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Managed'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// If true, enable private network connection.
	// DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
	PrivateNetworkConnection *bool `pulumi:"privateNetworkConnection"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for ManagedOnlineDeployment
func (val *ManagedOnlineDeployment) Defaults() *ManagedOnlineDeployment {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.AppInsightsEnabled) {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	if isZero(tmp.EgressPublicNetworkAccess) {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	if isZero(tmp.PrivateNetworkConnection) {
		privateNetworkConnection_ := false
		tmp.PrivateNetworkConnection = &privateNetworkConnection_
	}
	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Properties specific to a ManagedOnlineDeployment.
type ManagedOnlineDeploymentResponse struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Managed'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettingsResponse `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// If true, enable private network connection.
	// DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
	PrivateNetworkConnection *bool `pulumi:"privateNetworkConnection"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettingsResponse `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettingsResponse `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for ManagedOnlineDeploymentResponse
func (val *ManagedOnlineDeploymentResponse) Defaults() *ManagedOnlineDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.AppInsightsEnabled) {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	if isZero(tmp.EgressPublicNetworkAccess) {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	if isZero(tmp.PrivateNetworkConnection) {
		privateNetworkConnection_ := false
		tmp.PrivateNetworkConnection = &privateNetworkConnection_
	}
	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type string `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities map[string]interface{} `pulumi:"userAssignedIdentities"`
}

// ManagedServiceIdentityInput is an input type that accepts ManagedServiceIdentityArgs and ManagedServiceIdentityOutput values.
// You can construct a concrete instance of `ManagedServiceIdentityInput` via:
//
//	ManagedServiceIdentityArgs{...}
type ManagedServiceIdentityInput interface {
	pulumi.Input

	ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput
	ToManagedServiceIdentityOutputWithContext(context.Context) ManagedServiceIdentityOutput
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityArgs struct {
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type pulumi.StringInput `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities pulumi.MapInput `pulumi:"userAssignedIdentities"`
}

func (ManagedServiceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentity)(nil)).Elem()
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput {
	return i.ToManagedServiceIdentityOutputWithContext(context.Background())
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityOutputWithContext(ctx context.Context) ManagedServiceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityOutput)
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return i.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityOutput).ToManagedServiceIdentityPtrOutputWithContext(ctx)
}

// ManagedServiceIdentityPtrInput is an input type that accepts ManagedServiceIdentityArgs, ManagedServiceIdentityPtr and ManagedServiceIdentityPtrOutput values.
// You can construct a concrete instance of `ManagedServiceIdentityPtrInput` via:
//
//	        ManagedServiceIdentityArgs{...}
//
//	or:
//
//	        nil
type ManagedServiceIdentityPtrInput interface {
	pulumi.Input

	ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput
	ToManagedServiceIdentityPtrOutputWithContext(context.Context) ManagedServiceIdentityPtrOutput
}

type managedServiceIdentityPtrType ManagedServiceIdentityArgs

func ManagedServiceIdentityPtr(v *ManagedServiceIdentityArgs) ManagedServiceIdentityPtrInput {
	return (*managedServiceIdentityPtrType)(v)
}

func (*managedServiceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentity)(nil)).Elem()
}

func (i *managedServiceIdentityPtrType) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return i.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (i *managedServiceIdentityPtrType) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityPtrOutput)
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentity)(nil)).Elem()
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput {
	return o
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityOutputWithContext(ctx context.Context) ManagedServiceIdentityOutput {
	return o
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return o.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedServiceIdentity) *ManagedServiceIdentity {
		return &v
	}).(ManagedServiceIdentityPtrOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v ManagedServiceIdentity) map[string]interface{} { return v.UserAssignedIdentities }).(pulumi.MapOutput)
}

type ManagedServiceIdentityPtrOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentity)(nil)).Elem()
}

func (o ManagedServiceIdentityPtrOutput) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return o
}

func (o ManagedServiceIdentityPtrOutput) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return o
}

func (o ManagedServiceIdentityPtrOutput) Elem() ManagedServiceIdentityOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) ManagedServiceIdentity {
		if v != nil {
			return *v
		}
		var ret ManagedServiceIdentity
		return ret
	}).(ManagedServiceIdentityOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityPtrOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.MapOutput)
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityResponse struct {
	// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
	PrincipalId string `pulumi:"principalId"`
	// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
	TenantId string `pulumi:"tenantId"`
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type string `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities map[string]UserAssignedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityResponseOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentityResponse)(nil)).Elem()
}

func (o ManagedServiceIdentityResponseOutput) ToManagedServiceIdentityResponseOutput() ManagedServiceIdentityResponseOutput {
	return o
}

func (o ManagedServiceIdentityResponseOutput) ToManagedServiceIdentityResponseOutputWithContext(ctx context.Context) ManagedServiceIdentityResponseOutput {
	return o
}

// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityResponseOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) map[string]UserAssignedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

type ManagedServiceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentityResponse)(nil)).Elem()
}

func (o ManagedServiceIdentityResponsePtrOutput) ToManagedServiceIdentityResponsePtrOutput() ManagedServiceIdentityResponsePtrOutput {
	return o
}

func (o ManagedServiceIdentityResponsePtrOutput) ToManagedServiceIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedServiceIdentityResponsePtrOutput {
	return o
}

func (o ManagedServiceIdentityResponsePtrOutput) Elem() ManagedServiceIdentityResponseOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) ManagedServiceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ManagedServiceIdentityResponse
		return ret
	}).(ManagedServiceIdentityResponseOutput)
}

// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) map[string]UserAssignedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

// Defines an early termination policy based on running averages of the primary metric of all runs
type MedianStoppingPolicy struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'MedianStopping'.
	PolicyType string `pulumi:"policyType"`
}

// Defaults sets the appropriate defaults for MedianStoppingPolicy
func (val *MedianStoppingPolicy) Defaults() *MedianStoppingPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	return &tmp
}

// Defines an early termination policy based on running averages of the primary metric of all runs
type MedianStoppingPolicyResponse struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'MedianStopping'.
	PolicyType string `pulumi:"policyType"`
}

// Defaults sets the appropriate defaults for MedianStoppingPolicyResponse
func (val *MedianStoppingPolicyResponse) Defaults() *MedianStoppingPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	return &tmp
}

type ModelContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerType
func (val *ModelContainerType) Defaults() *ModelContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ModelContainerTypeInput is an input type that accepts ModelContainerTypeArgs and ModelContainerTypeOutput values.
// You can construct a concrete instance of `ModelContainerTypeInput` via:
//
//	ModelContainerTypeArgs{...}
type ModelContainerTypeInput interface {
	pulumi.Input

	ToModelContainerTypeOutput() ModelContainerTypeOutput
	ToModelContainerTypeOutputWithContext(context.Context) ModelContainerTypeOutput
}

type ModelContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerTypeArgs
func (val *ModelContainerTypeArgs) Defaults() *ModelContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ModelContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerType)(nil)).Elem()
}

func (i ModelContainerTypeArgs) ToModelContainerTypeOutput() ModelContainerTypeOutput {
	return i.ToModelContainerTypeOutputWithContext(context.Background())
}

func (i ModelContainerTypeArgs) ToModelContainerTypeOutputWithContext(ctx context.Context) ModelContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ModelContainerTypeOutput)
}

type ModelContainerTypeOutput struct{ *pulumi.OutputState }

func (ModelContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerType)(nil)).Elem()
}

func (o ModelContainerTypeOutput) ToModelContainerTypeOutput() ModelContainerTypeOutput {
	return o
}

func (o ModelContainerTypeOutput) ToModelContainerTypeOutputWithContext(ctx context.Context) ModelContainerTypeOutput {
	return o
}

// The asset description text.
func (o ModelContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ModelContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ModelContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type ModelContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerResponse
func (val *ModelContainerResponse) Defaults() *ModelContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type ModelContainerResponseOutput struct{ *pulumi.OutputState }

func (ModelContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerResponse)(nil)).Elem()
}

func (o ModelContainerResponseOutput) ToModelContainerResponseOutput() ModelContainerResponseOutput {
	return o
}

func (o ModelContainerResponseOutput) ToModelContainerResponseOutputWithContext(ctx context.Context) ModelContainerResponseOutput {
	return o
}

// The asset description text.
func (o ModelContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ModelContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o ModelContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ModelContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o ModelContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ModelContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o ModelContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Model asset version details.
type ModelVersionType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors map[string]FlavorData `pulumi:"flavors"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName *string `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType *string `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri *string `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionType
func (val *ModelVersionType) Defaults() *ModelVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if isZero(tmp.ModelType) {
		modelType_ := "CustomModel"
		tmp.ModelType = &modelType_
	}
	return &tmp
}

// ModelVersionTypeInput is an input type that accepts ModelVersionTypeArgs and ModelVersionTypeOutput values.
// You can construct a concrete instance of `ModelVersionTypeInput` via:
//
//	ModelVersionTypeArgs{...}
type ModelVersionTypeInput interface {
	pulumi.Input

	ToModelVersionTypeOutput() ModelVersionTypeOutput
	ToModelVersionTypeOutputWithContext(context.Context) ModelVersionTypeOutput
}

// Model asset version details.
type ModelVersionTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors FlavorDataMapInput `pulumi:"flavors"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName pulumi.StringPtrInput `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType pulumi.StringPtrInput `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri pulumi.StringPtrInput `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionTypeArgs
func (val *ModelVersionTypeArgs) Defaults() *ModelVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if isZero(tmp.IsArchived) {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	if isZero(tmp.ModelType) {
		tmp.ModelType = pulumi.StringPtr("CustomModel")
	}
	return &tmp
}
func (ModelVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionType)(nil)).Elem()
}

func (i ModelVersionTypeArgs) ToModelVersionTypeOutput() ModelVersionTypeOutput {
	return i.ToModelVersionTypeOutputWithContext(context.Background())
}

func (i ModelVersionTypeArgs) ToModelVersionTypeOutputWithContext(ctx context.Context) ModelVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ModelVersionTypeOutput)
}

// Model asset version details.
type ModelVersionTypeOutput struct{ *pulumi.OutputState }

func (ModelVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionType)(nil)).Elem()
}

func (o ModelVersionTypeOutput) ToModelVersionTypeOutput() ModelVersionTypeOutput {
	return o
}

func (o ModelVersionTypeOutput) ToModelVersionTypeOutputWithContext(ctx context.Context) ModelVersionTypeOutput {
	return o
}

// The asset description text.
func (o ModelVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Mapping of model flavors to their properties.
func (o ModelVersionTypeOutput) Flavors() FlavorDataMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]FlavorData { return v.Flavors }).(FlavorDataMapOutput)
}

// If the name version are system generated (anonymous registration).
func (o ModelVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o ModelVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Name of the training job which produced this model
func (o ModelVersionTypeOutput) JobName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.JobName }).(pulumi.StringPtrOutput)
}

// The storage format for this entity. Used for NCD.
func (o ModelVersionTypeOutput) ModelType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.ModelType }).(pulumi.StringPtrOutput)
}

// The URI path to the model contents.
func (o ModelVersionTypeOutput) ModelUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.ModelUri }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o ModelVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Model asset version details.
type ModelVersionResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors map[string]FlavorDataResponse `pulumi:"flavors"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName *string `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType *string `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri *string `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionResponse
func (val *ModelVersionResponse) Defaults() *ModelVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if isZero(tmp.ModelType) {
		modelType_ := "CustomModel"
		tmp.ModelType = &modelType_
	}
	return &tmp
}

// Model asset version details.
type ModelVersionResponseOutput struct{ *pulumi.OutputState }

func (ModelVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionResponse)(nil)).Elem()
}

func (o ModelVersionResponseOutput) ToModelVersionResponseOutput() ModelVersionResponseOutput {
	return o
}

func (o ModelVersionResponseOutput) ToModelVersionResponseOutputWithContext(ctx context.Context) ModelVersionResponseOutput {
	return o
}

// The asset description text.
func (o ModelVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Mapping of model flavors to their properties.
func (o ModelVersionResponseOutput) Flavors() FlavorDataResponseMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]FlavorDataResponse { return v.Flavors }).(FlavorDataResponseMapOutput)
}

// If the name version are system generated (anonymous registration).
func (o ModelVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived?
func (o ModelVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Name of the training job which produced this model
func (o ModelVersionResponseOutput) JobName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.JobName }).(pulumi.StringPtrOutput)
}

// The storage format for this entity. Used for NCD.
func (o ModelVersionResponseOutput) ModelType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.ModelType }).(pulumi.StringPtrOutput)
}

// The URI path to the model contents.
func (o ModelVersionResponseOutput) ModelUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.ModelUri }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o ModelVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// MPI distribution configuration.
type Mpi struct {
	// Enum to determine the job distribution type.
	// Expected value is 'Mpi'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per MPI node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// MPI distribution configuration.
type MpiResponse struct {
	// Enum to determine the job distribution type.
	// Expected value is 'Mpi'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per MPI node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// Class for data inputs.
// NLP - Natural Language Processing.
type NlpVerticalDataSettings struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettings `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettings `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *NlpVerticalValidationDataSettings `pulumi:"validationData"`
}

// Defaults sets the appropriate defaults for NlpVerticalDataSettings
func (val *NlpVerticalDataSettings) Defaults() *NlpVerticalDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Class for data inputs.
// NLP - Natural Language Processing.
type NlpVerticalDataSettingsResponse struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettingsResponse `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettingsResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *NlpVerticalValidationDataSettingsResponse `pulumi:"validationData"`
}

// Defaults sets the appropriate defaults for NlpVerticalDataSettingsResponse
func (val *NlpVerticalDataSettingsResponse) Defaults() *NlpVerticalDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

type NlpVerticalFeaturizationSettings struct {
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
}

type NlpVerticalFeaturizationSettingsResponse struct {
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
}

// Job execution constraints.
type NlpVerticalLimitSettings struct {
	// Maximum Concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for NlpVerticalLimitSettings
func (val *NlpVerticalLimitSettings) Defaults() *NlpVerticalLimitSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	return &tmp
}

// Job execution constraints.
type NlpVerticalLimitSettingsResponse struct {
	// Maximum Concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for NlpVerticalLimitSettingsResponse
func (val *NlpVerticalLimitSettingsResponse) Defaults() *NlpVerticalLimitSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	return &tmp
}

type NlpVerticalValidationDataSettings struct {
	// Validation data MLTable.
	Data *MLTableJobInput `pulumi:"data"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for NlpVerticalValidationDataSettings
func (val *NlpVerticalValidationDataSettings) Defaults() *NlpVerticalValidationDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

type NlpVerticalValidationDataSettingsResponse struct {
	// Validation data MLTable.
	Data *MLTableJobInputResponse `pulumi:"data"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for NlpVerticalValidationDataSettingsResponse
func (val *NlpVerticalValidationDataSettingsResponse) Defaults() *NlpVerticalValidationDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

// Counts of various compute node states on the amlCompute.
type NodeStateCountsResponse struct {
	// Number of compute nodes in idle state.
	IdleNodeCount int `pulumi:"idleNodeCount"`
	// Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount int `pulumi:"leavingNodeCount"`
	// Number of compute nodes which are in preempted state.
	PreemptedNodeCount int `pulumi:"preemptedNodeCount"`
	// Number of compute nodes which are being prepared.
	PreparingNodeCount int `pulumi:"preparingNodeCount"`
	// Number of compute nodes which are running jobs.
	RunningNodeCount int `pulumi:"runningNodeCount"`
	// Number of compute nodes which are in unusable state.
	UnusableNodeCount int `pulumi:"unusableNodeCount"`
}

// Empty/none datastore credentials.
type NoneDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'None'.
	CredentialsType string `pulumi:"credentialsType"`
}

// Empty/none datastore credentials.
type NoneDatastoreCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'None'.
	CredentialsType string `pulumi:"credentialsType"`
}

type NotebookPreparationErrorResponse struct {
	ErrorMessage *string `pulumi:"errorMessage"`
	StatusCode   *int    `pulumi:"statusCode"`
}

type NotebookPreparationErrorResponseOutput struct{ *pulumi.OutputState }

func (NotebookPreparationErrorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotebookPreparationErrorResponse)(nil)).Elem()
}

func (o NotebookPreparationErrorResponseOutput) ToNotebookPreparationErrorResponseOutput() NotebookPreparationErrorResponseOutput {
	return o
}

func (o NotebookPreparationErrorResponseOutput) ToNotebookPreparationErrorResponseOutputWithContext(ctx context.Context) NotebookPreparationErrorResponseOutput {
	return o
}

func (o NotebookPreparationErrorResponseOutput) ErrorMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookPreparationErrorResponse) *string { return v.ErrorMessage }).(pulumi.StringPtrOutput)
}

func (o NotebookPreparationErrorResponseOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NotebookPreparationErrorResponse) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type NotebookPreparationErrorResponsePtrOutput struct{ *pulumi.OutputState }

func (NotebookPreparationErrorResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotebookPreparationErrorResponse)(nil)).Elem()
}

func (o NotebookPreparationErrorResponsePtrOutput) ToNotebookPreparationErrorResponsePtrOutput() NotebookPreparationErrorResponsePtrOutput {
	return o
}

func (o NotebookPreparationErrorResponsePtrOutput) ToNotebookPreparationErrorResponsePtrOutputWithContext(ctx context.Context) NotebookPreparationErrorResponsePtrOutput {
	return o
}

func (o NotebookPreparationErrorResponsePtrOutput) Elem() NotebookPreparationErrorResponseOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) NotebookPreparationErrorResponse {
		if v != nil {
			return *v
		}
		var ret NotebookPreparationErrorResponse
		return ret
	}).(NotebookPreparationErrorResponseOutput)
}

func (o NotebookPreparationErrorResponsePtrOutput) ErrorMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) *string {
		if v == nil {
			return nil
		}
		return v.ErrorMessage
	}).(pulumi.StringPtrOutput)
}

func (o NotebookPreparationErrorResponsePtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

type NotebookResourceInfoResponse struct {
	Fqdn *string `pulumi:"fqdn"`
	// The error that occurs when preparing notebook.
	NotebookPreparationError *NotebookPreparationErrorResponse `pulumi:"notebookPreparationError"`
	// the data plane resourceId that used to initialize notebook component
	ResourceId *string `pulumi:"resourceId"`
}

type NotebookResourceInfoResponseOutput struct{ *pulumi.OutputState }

func (NotebookResourceInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotebookResourceInfoResponse)(nil)).Elem()
}

func (o NotebookResourceInfoResponseOutput) ToNotebookResourceInfoResponseOutput() NotebookResourceInfoResponseOutput {
	return o
}

func (o NotebookResourceInfoResponseOutput) ToNotebookResourceInfoResponseOutputWithContext(ctx context.Context) NotebookResourceInfoResponseOutput {
	return o
}

func (o NotebookResourceInfoResponseOutput) Fqdn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *string { return v.Fqdn }).(pulumi.StringPtrOutput)
}

// The error that occurs when preparing notebook.
func (o NotebookResourceInfoResponseOutput) NotebookPreparationError() NotebookPreparationErrorResponsePtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *NotebookPreparationErrorResponse {
		return v.NotebookPreparationError
	}).(NotebookPreparationErrorResponsePtrOutput)
}

// the data plane resourceId that used to initialize notebook component
func (o NotebookResourceInfoResponseOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *string { return v.ResourceId }).(pulumi.StringPtrOutput)
}

// Optimization objective.
type Objective struct {
	// [Required] Defines supported metric goals for hyperparameter tuning
	Goal string `pulumi:"goal"`
	// [Required] Name of the metric to optimize.
	PrimaryMetric string `pulumi:"primaryMetric"`
}

// Optimization objective.
type ObjectiveResponse struct {
	// [Required] Defines supported metric goals for hyperparameter tuning
	Goal string `pulumi:"goal"`
	// [Required] Name of the metric to optimize.
	PrimaryMetric string `pulumi:"primaryMetric"`
}

// Online endpoint configuration
type OnlineEndpointType struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute *string `pulumi:"compute"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `pulumi:"keys"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic map[string]int `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic map[string]int `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointType
func (val *OnlineEndpointType) Defaults() *OnlineEndpointType {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.PublicNetworkAccess) {
		publicNetworkAccess_ := "Enabled"
		tmp.PublicNetworkAccess = &publicNetworkAccess_
	}
	return &tmp
}

// OnlineEndpointTypeInput is an input type that accepts OnlineEndpointTypeArgs and OnlineEndpointTypeOutput values.
// You can construct a concrete instance of `OnlineEndpointTypeInput` via:
//
//	OnlineEndpointTypeArgs{...}
type OnlineEndpointTypeInput interface {
	pulumi.Input

	ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput
	ToOnlineEndpointTypeOutputWithContext(context.Context) OnlineEndpointTypeOutput
}

// Online endpoint configuration
type OnlineEndpointTypeArgs struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode pulumi.StringInput `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute pulumi.StringPtrInput `pulumi:"compute"`
	// Description of the inference endpoint.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys EndpointAuthKeysPtrInput `pulumi:"keys"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic pulumi.IntMapInput `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess pulumi.StringPtrInput `pulumi:"publicNetworkAccess"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic pulumi.IntMapInput `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointTypeArgs
func (val *OnlineEndpointTypeArgs) Defaults() *OnlineEndpointTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.PublicNetworkAccess) {
		tmp.PublicNetworkAccess = pulumi.StringPtr("Enabled")
	}
	return &tmp
}
func (OnlineEndpointTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointType)(nil)).Elem()
}

func (i OnlineEndpointTypeArgs) ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput {
	return i.ToOnlineEndpointTypeOutputWithContext(context.Background())
}

func (i OnlineEndpointTypeArgs) ToOnlineEndpointTypeOutputWithContext(ctx context.Context) OnlineEndpointTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OnlineEndpointTypeOutput)
}

// Online endpoint configuration
type OnlineEndpointTypeOutput struct{ *pulumi.OutputState }

func (OnlineEndpointTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointType)(nil)).Elem()
}

func (o OnlineEndpointTypeOutput) ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput {
	return o
}

func (o OnlineEndpointTypeOutput) ToOnlineEndpointTypeOutputWithContext(ctx context.Context) OnlineEndpointTypeOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o OnlineEndpointTypeOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointType) string { return v.AuthMode }).(pulumi.StringOutput)
}

// ARM resource ID of the compute if it exists.
// optional
func (o OnlineEndpointTypeOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the inference endpoint.
func (o OnlineEndpointTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// EndpointAuthKeys to set initially on an Endpoint.
// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
func (o OnlineEndpointTypeOutput) Keys() EndpointAuthKeysPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *EndpointAuthKeys { return v.Keys }).(EndpointAuthKeysPtrOutput)
}

// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
func (o OnlineEndpointTypeOutput) MirrorTraffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]int { return v.MirrorTraffic }).(pulumi.IntMapOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o OnlineEndpointTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
func (o OnlineEndpointTypeOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
func (o OnlineEndpointTypeOutput) Traffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]int { return v.Traffic }).(pulumi.IntMapOutput)
}

// Online endpoint configuration
type OnlineEndpointResponse struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute *string `pulumi:"compute"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic map[string]int `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint.
	ProvisioningState string `pulumi:"provisioningState"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Endpoint URI.
	ScoringUri string `pulumi:"scoringUri"`
	// Endpoint Swagger URI.
	SwaggerUri string `pulumi:"swaggerUri"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic map[string]int `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointResponse
func (val *OnlineEndpointResponse) Defaults() *OnlineEndpointResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.PublicNetworkAccess) {
		publicNetworkAccess_ := "Enabled"
		tmp.PublicNetworkAccess = &publicNetworkAccess_
	}
	return &tmp
}

// Online endpoint configuration
type OnlineEndpointResponseOutput struct{ *pulumi.OutputState }

func (OnlineEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointResponse)(nil)).Elem()
}

func (o OnlineEndpointResponseOutput) ToOnlineEndpointResponseOutput() OnlineEndpointResponseOutput {
	return o
}

func (o OnlineEndpointResponseOutput) ToOnlineEndpointResponseOutputWithContext(ctx context.Context) OnlineEndpointResponseOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o OnlineEndpointResponseOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.AuthMode }).(pulumi.StringOutput)
}

// ARM resource ID of the compute if it exists.
// optional
func (o OnlineEndpointResponseOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the inference endpoint.
func (o OnlineEndpointResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
func (o OnlineEndpointResponseOutput) MirrorTraffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]int { return v.MirrorTraffic }).(pulumi.IntMapOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o OnlineEndpointResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint.
func (o OnlineEndpointResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
func (o OnlineEndpointResponseOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Endpoint URI.
func (o OnlineEndpointResponseOutput) ScoringUri() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.ScoringUri }).(pulumi.StringOutput)
}

// Endpoint Swagger URI.
func (o OnlineEndpointResponseOutput) SwaggerUri() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.SwaggerUri }).(pulumi.StringOutput)
}

// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
func (o OnlineEndpointResponseOutput) Traffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]int { return v.Traffic }).(pulumi.IntMapOutput)
}

// Online deployment scoring requests configuration.
type OnlineRequestSettings struct {
	// The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
	MaxConcurrentRequestsPerInstance *int `pulumi:"maxConcurrentRequestsPerInstance"`
	// The maximum amount of time a request will stay in the queue in ISO 8601 format.
	// Defaults to 500ms.
	MaxQueueWait *string `pulumi:"maxQueueWait"`
	// The scoring timeout in ISO 8601 format.
	// Defaults to 5000ms.
	RequestTimeout *string `pulumi:"requestTimeout"`
}

// Defaults sets the appropriate defaults for OnlineRequestSettings
func (val *OnlineRequestSettings) Defaults() *OnlineRequestSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentRequestsPerInstance) {
		maxConcurrentRequestsPerInstance_ := 1
		tmp.MaxConcurrentRequestsPerInstance = &maxConcurrentRequestsPerInstance_
	}
	if isZero(tmp.MaxQueueWait) {
		maxQueueWait_ := "PT0.5S"
		tmp.MaxQueueWait = &maxQueueWait_
	}
	if isZero(tmp.RequestTimeout) {
		requestTimeout_ := "PT5S"
		tmp.RequestTimeout = &requestTimeout_
	}
	return &tmp
}

// Online deployment scoring requests configuration.
type OnlineRequestSettingsResponse struct {
	// The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
	MaxConcurrentRequestsPerInstance *int `pulumi:"maxConcurrentRequestsPerInstance"`
	// The maximum amount of time a request will stay in the queue in ISO 8601 format.
	// Defaults to 500ms.
	MaxQueueWait *string `pulumi:"maxQueueWait"`
	// The scoring timeout in ISO 8601 format.
	// Defaults to 5000ms.
	RequestTimeout *string `pulumi:"requestTimeout"`
}

// Defaults sets the appropriate defaults for OnlineRequestSettingsResponse
func (val *OnlineRequestSettingsResponse) Defaults() *OnlineRequestSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxConcurrentRequestsPerInstance) {
		maxConcurrentRequestsPerInstance_ := 1
		tmp.MaxConcurrentRequestsPerInstance = &maxConcurrentRequestsPerInstance_
	}
	if isZero(tmp.MaxQueueWait) {
		maxQueueWait_ := "PT0.5S"
		tmp.MaxQueueWait = &maxQueueWait_
	}
	if isZero(tmp.RequestTimeout) {
		requestTimeout_ := "PT5S"
		tmp.RequestTimeout = &requestTimeout_
	}
	return &tmp
}

// Reference to an asset via its path in a job output.
type OutputPathAssetReference struct {
	// ARM resource ID of the job.
	JobId *string `pulumi:"jobId"`
	// The path of the file/directory in the job output.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'OutputPath'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its path in a job output.
type OutputPathAssetReferenceResponse struct {
	// ARM resource ID of the job.
	JobId *string `pulumi:"jobId"`
	// The path of the file/directory in the job output.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'OutputPath'.
	ReferenceType string `pulumi:"referenceType"`
}

type PasswordResponse struct {
	Name  string `pulumi:"name"`
	Value string `pulumi:"value"`
}

type PasswordResponseOutput struct{ *pulumi.OutputState }

func (PasswordResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PasswordResponse)(nil)).Elem()
}

func (o PasswordResponseOutput) ToPasswordResponseOutput() PasswordResponseOutput {
	return o
}

func (o PasswordResponseOutput) ToPasswordResponseOutputWithContext(ctx context.Context) PasswordResponseOutput {
	return o
}

func (o PasswordResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PasswordResponse) string { return v.Name }).(pulumi.StringOutput)
}

func (o PasswordResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v PasswordResponse) string { return v.Value }).(pulumi.StringOutput)
}

type PasswordResponseArrayOutput struct{ *pulumi.OutputState }

func (PasswordResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PasswordResponse)(nil)).Elem()
}

func (o PasswordResponseArrayOutput) ToPasswordResponseArrayOutput() PasswordResponseArrayOutput {
	return o
}

func (o PasswordResponseArrayOutput) ToPasswordResponseArrayOutputWithContext(ctx context.Context) PasswordResponseArrayOutput {
	return o
}

func (o PasswordResponseArrayOutput) Index(i pulumi.IntInput) PasswordResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PasswordResponse {
		return vs[0].([]PasswordResponse)[vs[1].(int)]
	}).(PasswordResponseOutput)
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `pulumi:"assignedUser"`
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettingsResponse struct {
	// A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUserResponse `pulumi:"assignedUser"`
}

// Pipeline Job definition: defines generic to MFE attributes.
type PipelineJob struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Inputs for the pipeline job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Pipeline'.
	JobType string `pulumi:"jobType"`
	// Jobs construct the Pipeline Job.
	Jobs map[string]interface{} `pulumi:"jobs"`
	// Outputs for the pipeline job
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Pipeline settings, for things like ContinueRunOnStepFailure etc.
	Settings interface{} `pulumi:"settings"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for PipelineJob
func (val *PipelineJob) Defaults() *PipelineJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Pipeline Job definition: defines generic to MFE attributes.
type PipelineJobResponse struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Inputs for the pipeline job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Pipeline'.
	JobType string `pulumi:"jobType"`
	// Jobs construct the Pipeline Job.
	Jobs map[string]interface{} `pulumi:"jobs"`
	// Outputs for the pipeline job
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Pipeline settings, for things like ContinueRunOnStepFailure etc.
	Settings interface{} `pulumi:"settings"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for PipelineJobResponse
func (val *PipelineJobResponse) Defaults() *PipelineJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponse struct {
	// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id string `pulumi:"id"`
	// The identity of the resource.
	Identity *ManagedServiceIdentityResponse `pulumi:"identity"`
	// Specifies the location of the resource.
	Location *string `pulumi:"location"`
	// The name of the resource
	Name string `pulumi:"name"`
	// The resource of private end point.
	PrivateEndpoint *PrivateEndpointResponse `pulumi:"privateEndpoint"`
	// A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState PrivateLinkServiceConnectionStateResponse `pulumi:"privateLinkServiceConnectionState"`
	// The provisioning state of the private endpoint connection resource.
	ProvisioningState string `pulumi:"provisioningState"`
	// The sku of the workspace.
	Sku *SkuResponse `pulumi:"sku"`
	// Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData SystemDataResponse `pulumi:"systemData"`
	// Contains resource tags defined as key/value pairs.
	Tags map[string]string `pulumi:"tags"`
	// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type string `pulumi:"type"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutput() PrivateEndpointConnectionResponseOutput {
	return o
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseOutput {
	return o
}

// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
func (o PrivateEndpointConnectionResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The identity of the resource.
func (o PrivateEndpointConnectionResponseOutput) Identity() ManagedServiceIdentityResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *ManagedServiceIdentityResponse { return v.Identity }).(ManagedServiceIdentityResponsePtrOutput)
}

// Specifies the location of the resource.
func (o PrivateEndpointConnectionResponseOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the resource
func (o PrivateEndpointConnectionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The resource of private end point.
func (o PrivateEndpointConnectionResponseOutput) PrivateEndpoint() PrivateEndpointResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *PrivateEndpointResponse { return v.PrivateEndpoint }).(PrivateEndpointResponsePtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
func (o PrivateEndpointConnectionResponseOutput) PrivateLinkServiceConnectionState() PrivateLinkServiceConnectionStateResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) PrivateLinkServiceConnectionStateResponse {
		return v.PrivateLinkServiceConnectionState
	}).(PrivateLinkServiceConnectionStateResponseOutput)
}

// The provisioning state of the private endpoint connection resource.
func (o PrivateEndpointConnectionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The sku of the workspace.
func (o PrivateEndpointConnectionResponseOutput) Sku() SkuResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *SkuResponse { return v.Sku }).(SkuResponsePtrOutput)
}

// Azure Resource Manager metadata containing createdBy and modifiedBy information.
func (o PrivateEndpointConnectionResponseOutput) SystemData() SystemDataResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) SystemDataResponse { return v.SystemData }).(SystemDataResponseOutput)
}

// Contains resource tags defined as key/value pairs.
func (o PrivateEndpointConnectionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
func (o PrivateEndpointConnectionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type PrivateEndpointConnectionResponseArrayOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutput() PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) Index(i pulumi.IntInput) PrivateEndpointConnectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PrivateEndpointConnectionResponse {
		return vs[0].([]PrivateEndpointConnectionResponse)[vs[1].(int)]
	}).(PrivateEndpointConnectionResponseOutput)
}

// The Private Endpoint resource.
type PrivateEndpointResponse struct {
	// The ARM identifier for Private Endpoint
	Id string `pulumi:"id"`
	// The ARM identifier for Subnet resource that private endpoint links to
	SubnetArmId string `pulumi:"subnetArmId"`
}

// The Private Endpoint resource.
type PrivateEndpointResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutput() PrivateEndpointResponseOutput {
	return o
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutputWithContext(ctx context.Context) PrivateEndpointResponseOutput {
	return o
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The ARM identifier for Subnet resource that private endpoint links to
func (o PrivateEndpointResponseOutput) SubnetArmId() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResponse) string { return v.SubnetArmId }).(pulumi.StringOutput)
}

type PrivateEndpointResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutput() PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutputWithContext(ctx context.Context) PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) Elem() PrivateEndpointResponseOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) PrivateEndpointResponse {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResponse
		return ret
	}).(PrivateEndpointResponseOutput)
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// The ARM identifier for Subnet resource that private endpoint links to
func (o PrivateEndpointResponsePtrOutput) SubnetArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SubnetArmId
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// PrivateLinkServiceConnectionStateInput is an input type that accepts PrivateLinkServiceConnectionStateArgs and PrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStateInput` via:
//
//	PrivateLinkServiceConnectionStateArgs{...}
type PrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput
	ToPrivateLinkServiceConnectionStateOutputWithContext(context.Context) PrivateLinkServiceConnectionStateOutput
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateArgs struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (PrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return i.ToPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponse struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutput() PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Deployment container liveness/readiness probe configuration.
type ProbeSettings struct {
	// The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int `pulumi:"failureThreshold"`
	// The delay before the first probe in ISO 8601 format.
	InitialDelay *string `pulumi:"initialDelay"`
	// The length of time between probes in ISO 8601 format.
	Period *string `pulumi:"period"`
	// The number of successful probes before returning a healthy status.
	SuccessThreshold *int `pulumi:"successThreshold"`
	// The probe timeout in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ProbeSettings
func (val *ProbeSettings) Defaults() *ProbeSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.FailureThreshold) {
		failureThreshold_ := 30
		tmp.FailureThreshold = &failureThreshold_
	}
	if isZero(tmp.Period) {
		period_ := "PT10S"
		tmp.Period = &period_
	}
	if isZero(tmp.SuccessThreshold) {
		successThreshold_ := 1
		tmp.SuccessThreshold = &successThreshold_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT2S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Deployment container liveness/readiness probe configuration.
type ProbeSettingsResponse struct {
	// The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int `pulumi:"failureThreshold"`
	// The delay before the first probe in ISO 8601 format.
	InitialDelay *string `pulumi:"initialDelay"`
	// The length of time between probes in ISO 8601 format.
	Period *string `pulumi:"period"`
	// The number of successful probes before returning a healthy status.
	SuccessThreshold *int `pulumi:"successThreshold"`
	// The probe timeout in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ProbeSettingsResponse
func (val *ProbeSettingsResponse) Defaults() *ProbeSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.FailureThreshold) {
		failureThreshold_ := 30
		tmp.FailureThreshold = &failureThreshold_
	}
	if isZero(tmp.Period) {
		period_ := "PT10S"
		tmp.Period = &period_
	}
	if isZero(tmp.SuccessThreshold) {
		successThreshold_ := 1
		tmp.SuccessThreshold = &successThreshold_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT2S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// PyTorch distribution configuration.
type PyTorch struct {
	// Enum to determine the job distribution type.
	// Expected value is 'PyTorch'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// PyTorch distribution configuration.
type PyTorchResponse struct {
	// Enum to determine the job distribution type.
	// Expected value is 'PyTorch'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// Defines a Sampling Algorithm that generates values randomly
type RandomSamplingAlgorithm struct {
	// The specific type of random algorithm
	Rule *string `pulumi:"rule"`
	// Expected value is 'Random'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
	// An optional integer to use as the seed for random number generation
	Seed *int `pulumi:"seed"`
}

// Defaults sets the appropriate defaults for RandomSamplingAlgorithm
func (val *RandomSamplingAlgorithm) Defaults() *RandomSamplingAlgorithm {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Rule) {
		rule_ := "Random"
		tmp.Rule = &rule_
	}
	return &tmp
}

// Defines a Sampling Algorithm that generates values randomly
type RandomSamplingAlgorithmResponse struct {
	// The specific type of random algorithm
	Rule *string `pulumi:"rule"`
	// Expected value is 'Random'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
	// An optional integer to use as the seed for random number generation
	Seed *int `pulumi:"seed"`
}

// Defaults sets the appropriate defaults for RandomSamplingAlgorithmResponse
func (val *RandomSamplingAlgorithmResponse) Defaults() *RandomSamplingAlgorithmResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Rule) {
		rule_ := "Random"
		tmp.Rule = &rule_
	}
	return &tmp
}

// Recurrence schedule pattern definition
type RecurrencePattern struct {
	// [Required] List of hours for recurrence schedule pattern
	Hours []int `pulumi:"hours"`
	// [Required] List of minutes for recurrence schedule pattern
	Minutes []int `pulumi:"minutes"`
	// List of weekdays for recurrence schedule pattern
	Weekdays []string `pulumi:"weekdays"`
}

// Recurrence schedule pattern definition
type RecurrencePatternResponse struct {
	// [Required] List of hours for recurrence schedule pattern
	Hours []int `pulumi:"hours"`
	// [Required] List of minutes for recurrence schedule pattern
	Minutes []int `pulumi:"minutes"`
	// List of weekdays for recurrence schedule pattern
	Weekdays []string `pulumi:"weekdays"`
}

// Recurrence schedule definition
type RecurrenceSchedule struct {
	// Specifies end time of schedule in ISO 8601 format.
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies frequency with with which to trigger schedule
	Frequency string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval int `pulumi:"interval"`
	// Specifies the recurrence schedule pattern
	Pattern *RecurrencePattern `pulumi:"pattern"`
	// Specifies the schedule's status
	ScheduleStatus *string `pulumi:"scheduleStatus"`
	// Enum to describe type of schedule
	// Expected value is 'Recurrence'.
	ScheduleType string `pulumi:"scheduleType"`
	// Specifies start time of schedule in ISO 8601 format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format.
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for RecurrenceSchedule
func (val *RecurrenceSchedule) Defaults() *RecurrenceSchedule {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ScheduleStatus) {
		scheduleStatus_ := "Enabled"
		tmp.ScheduleStatus = &scheduleStatus_
	}
	if isZero(tmp.TimeZone) {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// Recurrence schedule definition
type RecurrenceScheduleResponse struct {
	// Specifies end time of schedule in ISO 8601 format.
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies frequency with with which to trigger schedule
	Frequency string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval int `pulumi:"interval"`
	// Specifies the recurrence schedule pattern
	Pattern *RecurrencePatternResponse `pulumi:"pattern"`
	// Specifies the schedule's status
	ScheduleStatus *string `pulumi:"scheduleStatus"`
	// Enum to describe type of schedule
	// Expected value is 'Recurrence'.
	ScheduleType string `pulumi:"scheduleType"`
	// Specifies start time of schedule in ISO 8601 format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format.
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for RecurrenceScheduleResponse
func (val *RecurrenceScheduleResponse) Defaults() *RecurrenceScheduleResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ScheduleStatus) {
		scheduleStatus_ := "Enabled"
		tmp.ScheduleStatus = &scheduleStatus_
	}
	if isZero(tmp.TimeZone) {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

type RegistryListCredentialsResultResponse struct {
	Location  string             `pulumi:"location"`
	Passwords []PasswordResponse `pulumi:"passwords"`
	Username  string             `pulumi:"username"`
}

type RegistryListCredentialsResultResponseOutput struct{ *pulumi.OutputState }

func (RegistryListCredentialsResultResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryListCredentialsResultResponse)(nil)).Elem()
}

func (o RegistryListCredentialsResultResponseOutput) ToRegistryListCredentialsResultResponseOutput() RegistryListCredentialsResultResponseOutput {
	return o
}

func (o RegistryListCredentialsResultResponseOutput) ToRegistryListCredentialsResultResponseOutputWithContext(ctx context.Context) RegistryListCredentialsResultResponseOutput {
	return o
}

func (o RegistryListCredentialsResultResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) string { return v.Location }).(pulumi.StringOutput)
}

func (o RegistryListCredentialsResultResponseOutput) Passwords() PasswordResponseArrayOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) []PasswordResponse { return v.Passwords }).(PasswordResponseArrayOutput)
}

func (o RegistryListCredentialsResultResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) string { return v.Username }).(pulumi.StringOutput)
}

// Regression task in AutoML Table vertical.
type Regression struct {
	// Allowed models for regression task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for regression task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for regression task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Regression'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettings `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for Regression
func (val *Regression) Defaults() *Regression {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

// Regression task in AutoML Table vertical.
type RegressionResponse struct {
	// Allowed models for regression task.
	AllowedModels []string `pulumi:"allowedModels"`
	// Blocked models for regression task.
	BlockedModels []string `pulumi:"blockedModels"`
	// Data inputs for AutoMLJob.
	DataSettings *TableVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for regression task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'Regression'.
	TaskType string `pulumi:"taskType"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *TrainingSettingsResponse `pulumi:"trainingSettings"`
}

// Defaults sets the appropriate defaults for RegressionResponse
func (val *RegressionResponse) Defaults() *RegressionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	return &tmp
}

type ResourceConfiguration struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for ResourceConfiguration
func (val *ResourceConfiguration) Defaults() *ResourceConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.InstanceCount) {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	return &tmp
}

// ResourceConfigurationInput is an input type that accepts ResourceConfigurationArgs and ResourceConfigurationOutput values.
// You can construct a concrete instance of `ResourceConfigurationInput` via:
//
//	ResourceConfigurationArgs{...}
type ResourceConfigurationInput interface {
	pulumi.Input

	ToResourceConfigurationOutput() ResourceConfigurationOutput
	ToResourceConfigurationOutputWithContext(context.Context) ResourceConfigurationOutput
}

type ResourceConfigurationArgs struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
	// Additional properties bag.
	Properties pulumi.MapInput `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for ResourceConfigurationArgs
func (val *ResourceConfigurationArgs) Defaults() *ResourceConfigurationArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.InstanceCount) {
		tmp.InstanceCount = pulumi.IntPtr(1)
	}
	return &tmp
}
func (ResourceConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceConfiguration)(nil)).Elem()
}

func (i ResourceConfigurationArgs) ToResourceConfigurationOutput() ResourceConfigurationOutput {
	return i.ToResourceConfigurationOutputWithContext(context.Background())
}

func (i ResourceConfigurationArgs) ToResourceConfigurationOutputWithContext(ctx context.Context) ResourceConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceConfigurationOutput)
}

func (i ResourceConfigurationArgs) ToResourceConfigurationPtrOutput() ResourceConfigurationPtrOutput {
	return i.ToResourceConfigurationPtrOutputWithContext(context.Background())
}

func (i ResourceConfigurationArgs) ToResourceConfigurationPtrOutputWithContext(ctx context.Context) ResourceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceConfigurationOutput).ToResourceConfigurationPtrOutputWithContext(ctx)
}

// ResourceConfigurationPtrInput is an input type that accepts ResourceConfigurationArgs, ResourceConfigurationPtr and ResourceConfigurationPtrOutput values.
// You can construct a concrete instance of `ResourceConfigurationPtrInput` via:
//
//	        ResourceConfigurationArgs{...}
//
//	or:
//
//	        nil
type ResourceConfigurationPtrInput interface {
	pulumi.Input

	ToResourceConfigurationPtrOutput() ResourceConfigurationPtrOutput
	ToResourceConfigurationPtrOutputWithContext(context.Context) ResourceConfigurationPtrOutput
}

type resourceConfigurationPtrType ResourceConfigurationArgs

func ResourceConfigurationPtr(v *ResourceConfigurationArgs) ResourceConfigurationPtrInput {
	return (*resourceConfigurationPtrType)(v)
}

func (*resourceConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceConfiguration)(nil)).Elem()
}

func (i *resourceConfigurationPtrType) ToResourceConfigurationPtrOutput() ResourceConfigurationPtrOutput {
	return i.ToResourceConfigurationPtrOutputWithContext(context.Background())
}

func (i *resourceConfigurationPtrType) ToResourceConfigurationPtrOutputWithContext(ctx context.Context) ResourceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceConfigurationPtrOutput)
}

type ResourceConfigurationOutput struct{ *pulumi.OutputState }

func (ResourceConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceConfiguration)(nil)).Elem()
}

func (o ResourceConfigurationOutput) ToResourceConfigurationOutput() ResourceConfigurationOutput {
	return o
}

func (o ResourceConfigurationOutput) ToResourceConfigurationOutputWithContext(ctx context.Context) ResourceConfigurationOutput {
	return o
}

func (o ResourceConfigurationOutput) ToResourceConfigurationPtrOutput() ResourceConfigurationPtrOutput {
	return o.ToResourceConfigurationPtrOutputWithContext(context.Background())
}

func (o ResourceConfigurationOutput) ToResourceConfigurationPtrOutputWithContext(ctx context.Context) ResourceConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceConfiguration) *ResourceConfiguration {
		return &v
	}).(ResourceConfigurationPtrOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o ResourceConfigurationOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourceConfiguration) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o ResourceConfigurationOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceConfiguration) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Additional properties bag.
func (o ResourceConfigurationOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v ResourceConfiguration) map[string]interface{} { return v.Properties }).(pulumi.MapOutput)
}

type ResourceConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ResourceConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceConfiguration)(nil)).Elem()
}

func (o ResourceConfigurationPtrOutput) ToResourceConfigurationPtrOutput() ResourceConfigurationPtrOutput {
	return o
}

func (o ResourceConfigurationPtrOutput) ToResourceConfigurationPtrOutputWithContext(ctx context.Context) ResourceConfigurationPtrOutput {
	return o
}

func (o ResourceConfigurationPtrOutput) Elem() ResourceConfigurationOutput {
	return o.ApplyT(func(v *ResourceConfiguration) ResourceConfiguration {
		if v != nil {
			return *v
		}
		var ret ResourceConfiguration
		return ret
	}).(ResourceConfigurationOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o ResourceConfigurationPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourceConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o ResourceConfigurationPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Additional properties bag.
func (o ResourceConfigurationPtrOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v *ResourceConfiguration) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.MapOutput)
}

type ResourceConfigurationResponse struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for ResourceConfigurationResponse
func (val *ResourceConfigurationResponse) Defaults() *ResourceConfigurationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.InstanceCount) {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	return &tmp
}

type ResourceConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ResourceConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceConfigurationResponse)(nil)).Elem()
}

func (o ResourceConfigurationResponseOutput) ToResourceConfigurationResponseOutput() ResourceConfigurationResponseOutput {
	return o
}

func (o ResourceConfigurationResponseOutput) ToResourceConfigurationResponseOutputWithContext(ctx context.Context) ResourceConfigurationResponseOutput {
	return o
}

// Optional number of instances or nodes used by the compute target.
func (o ResourceConfigurationResponseOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourceConfigurationResponse) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o ResourceConfigurationResponseOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceConfigurationResponse) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Additional properties bag.
func (o ResourceConfigurationResponseOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v ResourceConfigurationResponse) map[string]interface{} { return v.Properties }).(pulumi.MapOutput)
}

type ResourceConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceConfigurationResponse)(nil)).Elem()
}

func (o ResourceConfigurationResponsePtrOutput) ToResourceConfigurationResponsePtrOutput() ResourceConfigurationResponsePtrOutput {
	return o
}

func (o ResourceConfigurationResponsePtrOutput) ToResourceConfigurationResponsePtrOutputWithContext(ctx context.Context) ResourceConfigurationResponsePtrOutput {
	return o
}

func (o ResourceConfigurationResponsePtrOutput) Elem() ResourceConfigurationResponseOutput {
	return o.ApplyT(func(v *ResourceConfigurationResponse) ResourceConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret ResourceConfigurationResponse
		return ret
	}).(ResourceConfigurationResponseOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o ResourceConfigurationResponsePtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourceConfigurationResponse) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o ResourceConfigurationResponsePtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Additional properties bag.
func (o ResourceConfigurationResponsePtrOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v *ResourceConfigurationResponse) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.MapOutput)
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId struct {
	// The ID of the resource
	Id string `pulumi:"id"`
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceIdResponse struct {
	// The ID of the resource
	Id string `pulumi:"id"`
}

type Route struct {
	// [Required] The path for the route.
	Path string `pulumi:"path"`
	// [Required] The port for the route.
	Port int `pulumi:"port"`
}

// RouteInput is an input type that accepts RouteArgs and RouteOutput values.
// You can construct a concrete instance of `RouteInput` via:
//
//	RouteArgs{...}
type RouteInput interface {
	pulumi.Input

	ToRouteOutput() RouteOutput
	ToRouteOutputWithContext(context.Context) RouteOutput
}

type RouteArgs struct {
	// [Required] The path for the route.
	Path pulumi.StringInput `pulumi:"path"`
	// [Required] The port for the route.
	Port pulumi.IntInput `pulumi:"port"`
}

func (RouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (i RouteArgs) ToRouteOutput() RouteOutput {
	return i.ToRouteOutputWithContext(context.Background())
}

func (i RouteArgs) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput)
}

func (i RouteArgs) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i RouteArgs) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput).ToRoutePtrOutputWithContext(ctx)
}

// RoutePtrInput is an input type that accepts RouteArgs, RoutePtr and RoutePtrOutput values.
// You can construct a concrete instance of `RoutePtrInput` via:
//
//	        RouteArgs{...}
//
//	or:
//
//	        nil
type RoutePtrInput interface {
	pulumi.Input

	ToRoutePtrOutput() RoutePtrOutput
	ToRoutePtrOutputWithContext(context.Context) RoutePtrOutput
}

type routePtrType RouteArgs

func RoutePtr(v *RouteArgs) RoutePtrInput {
	return (*routePtrType)(v)
}

func (*routePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil)).Elem()
}

func (i *routePtrType) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i *routePtrType) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoutePtrOutput)
}

type RouteOutput struct{ *pulumi.OutputState }

func (RouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (o RouteOutput) ToRouteOutput() RouteOutput {
	return o
}

func (o RouteOutput) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return o
}

func (o RouteOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o.ToRoutePtrOutputWithContext(context.Background())
}

func (o RouteOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Route) *Route {
		return &v
	}).(RoutePtrOutput)
}

// [Required] The path for the route.
func (o RouteOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v Route) string { return v.Path }).(pulumi.StringOutput)
}

// [Required] The port for the route.
func (o RouteOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v Route) int { return v.Port }).(pulumi.IntOutput)
}

type RoutePtrOutput struct{ *pulumi.OutputState }

func (RoutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil)).Elem()
}

func (o RoutePtrOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o
}

func (o RoutePtrOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o
}

func (o RoutePtrOutput) Elem() RouteOutput {
	return o.ApplyT(func(v *Route) Route {
		if v != nil {
			return *v
		}
		var ret Route
		return ret
	}).(RouteOutput)
}

// [Required] The path for the route.
func (o RoutePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Route) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// [Required] The port for the route.
func (o RoutePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Route) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

type RouteResponse struct {
	// [Required] The path for the route.
	Path string `pulumi:"path"`
	// [Required] The port for the route.
	Port int `pulumi:"port"`
}

type RouteResponseOutput struct{ *pulumi.OutputState }

func (RouteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RouteResponse)(nil)).Elem()
}

func (o RouteResponseOutput) ToRouteResponseOutput() RouteResponseOutput {
	return o
}

func (o RouteResponseOutput) ToRouteResponseOutputWithContext(ctx context.Context) RouteResponseOutput {
	return o
}

// [Required] The path for the route.
func (o RouteResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v RouteResponse) string { return v.Path }).(pulumi.StringOutput)
}

// [Required] The port for the route.
func (o RouteResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v RouteResponse) int { return v.Port }).(pulumi.IntOutput)
}

type RouteResponsePtrOutput struct{ *pulumi.OutputState }

func (RouteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RouteResponse)(nil)).Elem()
}

func (o RouteResponsePtrOutput) ToRouteResponsePtrOutput() RouteResponsePtrOutput {
	return o
}

func (o RouteResponsePtrOutput) ToRouteResponsePtrOutputWithContext(ctx context.Context) RouteResponsePtrOutput {
	return o
}

func (o RouteResponsePtrOutput) Elem() RouteResponseOutput {
	return o.ApplyT(func(v *RouteResponse) RouteResponse {
		if v != nil {
			return *v
		}
		var ret RouteResponse
		return ret
	}).(RouteResponseOutput)
}

// [Required] The path for the route.
func (o RouteResponsePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RouteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// [Required] The port for the route.
func (o RouteResponsePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RouteResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

// SAS datastore credentials configuration.
type SasDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'Sas'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] Storage container secrets.
	Secrets SasDatastoreSecrets `pulumi:"secrets"`
}

// SAS datastore credentials configuration.
type SasDatastoreCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'Sas'.
	CredentialsType string `pulumi:"credentialsType"`
}

// Datastore SAS secrets.
type SasDatastoreSecrets struct {
	// Storage container SAS token.
	SasToken *string `pulumi:"sasToken"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'Sas'.
	SecretsType string `pulumi:"secretsType"`
}

// scale settings for AML Compute
type ScaleSettings struct {
	// Max number of nodes to use
	MaxNodeCount int `pulumi:"maxNodeCount"`
	// Min number of nodes to use
	MinNodeCount *int `pulumi:"minNodeCount"`
	// Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `pulumi:"nodeIdleTimeBeforeScaleDown"`
}

// Defaults sets the appropriate defaults for ScaleSettings
func (val *ScaleSettings) Defaults() *ScaleSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MinNodeCount) {
		minNodeCount_ := 0
		tmp.MinNodeCount = &minNodeCount_
	}
	return &tmp
}

// scale settings for AML Compute
type ScaleSettingsResponse struct {
	// Max number of nodes to use
	MaxNodeCount int `pulumi:"maxNodeCount"`
	// Min number of nodes to use
	MinNodeCount *int `pulumi:"minNodeCount"`
	// Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `pulumi:"nodeIdleTimeBeforeScaleDown"`
}

// Defaults sets the appropriate defaults for ScaleSettingsResponse
func (val *ScaleSettingsResponse) Defaults() *ScaleSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MinNodeCount) {
		minNodeCount_ := 0
		tmp.MinNodeCount = &minNodeCount_
	}
	return &tmp
}

// Script reference
type ScriptReference struct {
	// Optional command line arguments passed to the script to run.
	ScriptArguments *string `pulumi:"scriptArguments"`
	// The location of scripts in the mounted volume.
	ScriptData *string `pulumi:"scriptData"`
	// The storage source of the script: inline, workspace.
	ScriptSource *string `pulumi:"scriptSource"`
	// Optional time period passed to timeout command.
	Timeout *string `pulumi:"timeout"`
}

// Script reference
type ScriptReferenceResponse struct {
	// Optional command line arguments passed to the script to run.
	ScriptArguments *string `pulumi:"scriptArguments"`
	// The location of scripts in the mounted volume.
	ScriptData *string `pulumi:"scriptData"`
	// The storage source of the script: inline, workspace.
	ScriptSource *string `pulumi:"scriptSource"`
	// Optional time period passed to timeout command.
	Timeout *string `pulumi:"timeout"`
}

// Customized setup scripts
type ScriptsToExecute struct {
	// Script that's run only once during provision of the compute.
	CreationScript *ScriptReference `pulumi:"creationScript"`
	// Script that's run every time the machine starts.
	StartupScript *ScriptReference `pulumi:"startupScript"`
}

// Customized setup scripts
type ScriptsToExecuteResponse struct {
	// Script that's run only once during provision of the compute.
	CreationScript *ScriptReferenceResponse `pulumi:"creationScript"`
	// Script that's run every time the machine starts.
	StartupScript *ScriptReferenceResponse `pulumi:"startupScript"`
}

type ServiceManagedResourcesSettings struct {
	// The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettings `pulumi:"cosmosDb"`
}

// ServiceManagedResourcesSettingsInput is an input type that accepts ServiceManagedResourcesSettingsArgs and ServiceManagedResourcesSettingsOutput values.
// You can construct a concrete instance of `ServiceManagedResourcesSettingsInput` via:
//
//	ServiceManagedResourcesSettingsArgs{...}
type ServiceManagedResourcesSettingsInput interface {
	pulumi.Input

	ToServiceManagedResourcesSettingsOutput() ServiceManagedResourcesSettingsOutput
	ToServiceManagedResourcesSettingsOutputWithContext(context.Context) ServiceManagedResourcesSettingsOutput
}

type ServiceManagedResourcesSettingsArgs struct {
	// The settings for the service managed cosmosdb account.
	CosmosDb CosmosDbSettingsPtrInput `pulumi:"cosmosDb"`
}

func (ServiceManagedResourcesSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceManagedResourcesSettings)(nil)).Elem()
}

func (i ServiceManagedResourcesSettingsArgs) ToServiceManagedResourcesSettingsOutput() ServiceManagedResourcesSettingsOutput {
	return i.ToServiceManagedResourcesSettingsOutputWithContext(context.Background())
}

func (i ServiceManagedResourcesSettingsArgs) ToServiceManagedResourcesSettingsOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceManagedResourcesSettingsOutput)
}

func (i ServiceManagedResourcesSettingsArgs) ToServiceManagedResourcesSettingsPtrOutput() ServiceManagedResourcesSettingsPtrOutput {
	return i.ToServiceManagedResourcesSettingsPtrOutputWithContext(context.Background())
}

func (i ServiceManagedResourcesSettingsArgs) ToServiceManagedResourcesSettingsPtrOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceManagedResourcesSettingsOutput).ToServiceManagedResourcesSettingsPtrOutputWithContext(ctx)
}

// ServiceManagedResourcesSettingsPtrInput is an input type that accepts ServiceManagedResourcesSettingsArgs, ServiceManagedResourcesSettingsPtr and ServiceManagedResourcesSettingsPtrOutput values.
// You can construct a concrete instance of `ServiceManagedResourcesSettingsPtrInput` via:
//
//	        ServiceManagedResourcesSettingsArgs{...}
//
//	or:
//
//	        nil
type ServiceManagedResourcesSettingsPtrInput interface {
	pulumi.Input

	ToServiceManagedResourcesSettingsPtrOutput() ServiceManagedResourcesSettingsPtrOutput
	ToServiceManagedResourcesSettingsPtrOutputWithContext(context.Context) ServiceManagedResourcesSettingsPtrOutput
}

type serviceManagedResourcesSettingsPtrType ServiceManagedResourcesSettingsArgs

func ServiceManagedResourcesSettingsPtr(v *ServiceManagedResourcesSettingsArgs) ServiceManagedResourcesSettingsPtrInput {
	return (*serviceManagedResourcesSettingsPtrType)(v)
}

func (*serviceManagedResourcesSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceManagedResourcesSettings)(nil)).Elem()
}

func (i *serviceManagedResourcesSettingsPtrType) ToServiceManagedResourcesSettingsPtrOutput() ServiceManagedResourcesSettingsPtrOutput {
	return i.ToServiceManagedResourcesSettingsPtrOutputWithContext(context.Background())
}

func (i *serviceManagedResourcesSettingsPtrType) ToServiceManagedResourcesSettingsPtrOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceManagedResourcesSettingsPtrOutput)
}

type ServiceManagedResourcesSettingsOutput struct{ *pulumi.OutputState }

func (ServiceManagedResourcesSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceManagedResourcesSettings)(nil)).Elem()
}

func (o ServiceManagedResourcesSettingsOutput) ToServiceManagedResourcesSettingsOutput() ServiceManagedResourcesSettingsOutput {
	return o
}

func (o ServiceManagedResourcesSettingsOutput) ToServiceManagedResourcesSettingsOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsOutput {
	return o
}

func (o ServiceManagedResourcesSettingsOutput) ToServiceManagedResourcesSettingsPtrOutput() ServiceManagedResourcesSettingsPtrOutput {
	return o.ToServiceManagedResourcesSettingsPtrOutputWithContext(context.Background())
}

func (o ServiceManagedResourcesSettingsOutput) ToServiceManagedResourcesSettingsPtrOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceManagedResourcesSettings) *ServiceManagedResourcesSettings {
		return &v
	}).(ServiceManagedResourcesSettingsPtrOutput)
}

// The settings for the service managed cosmosdb account.
func (o ServiceManagedResourcesSettingsOutput) CosmosDb() CosmosDbSettingsPtrOutput {
	return o.ApplyT(func(v ServiceManagedResourcesSettings) *CosmosDbSettings { return v.CosmosDb }).(CosmosDbSettingsPtrOutput)
}

type ServiceManagedResourcesSettingsPtrOutput struct{ *pulumi.OutputState }

func (ServiceManagedResourcesSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceManagedResourcesSettings)(nil)).Elem()
}

func (o ServiceManagedResourcesSettingsPtrOutput) ToServiceManagedResourcesSettingsPtrOutput() ServiceManagedResourcesSettingsPtrOutput {
	return o
}

func (o ServiceManagedResourcesSettingsPtrOutput) ToServiceManagedResourcesSettingsPtrOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsPtrOutput {
	return o
}

func (o ServiceManagedResourcesSettingsPtrOutput) Elem() ServiceManagedResourcesSettingsOutput {
	return o.ApplyT(func(v *ServiceManagedResourcesSettings) ServiceManagedResourcesSettings {
		if v != nil {
			return *v
		}
		var ret ServiceManagedResourcesSettings
		return ret
	}).(ServiceManagedResourcesSettingsOutput)
}

// The settings for the service managed cosmosdb account.
func (o ServiceManagedResourcesSettingsPtrOutput) CosmosDb() CosmosDbSettingsPtrOutput {
	return o.ApplyT(func(v *ServiceManagedResourcesSettings) *CosmosDbSettings {
		if v == nil {
			return nil
		}
		return v.CosmosDb
	}).(CosmosDbSettingsPtrOutput)
}

type ServiceManagedResourcesSettingsResponse struct {
	// The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettingsResponse `pulumi:"cosmosDb"`
}

type ServiceManagedResourcesSettingsResponseOutput struct{ *pulumi.OutputState }

func (ServiceManagedResourcesSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceManagedResourcesSettingsResponse)(nil)).Elem()
}

func (o ServiceManagedResourcesSettingsResponseOutput) ToServiceManagedResourcesSettingsResponseOutput() ServiceManagedResourcesSettingsResponseOutput {
	return o
}

func (o ServiceManagedResourcesSettingsResponseOutput) ToServiceManagedResourcesSettingsResponseOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsResponseOutput {
	return o
}

// The settings for the service managed cosmosdb account.
func (o ServiceManagedResourcesSettingsResponseOutput) CosmosDb() CosmosDbSettingsResponsePtrOutput {
	return o.ApplyT(func(v ServiceManagedResourcesSettingsResponse) *CosmosDbSettingsResponse { return v.CosmosDb }).(CosmosDbSettingsResponsePtrOutput)
}

type ServiceManagedResourcesSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (ServiceManagedResourcesSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceManagedResourcesSettingsResponse)(nil)).Elem()
}

func (o ServiceManagedResourcesSettingsResponsePtrOutput) ToServiceManagedResourcesSettingsResponsePtrOutput() ServiceManagedResourcesSettingsResponsePtrOutput {
	return o
}

func (o ServiceManagedResourcesSettingsResponsePtrOutput) ToServiceManagedResourcesSettingsResponsePtrOutputWithContext(ctx context.Context) ServiceManagedResourcesSettingsResponsePtrOutput {
	return o
}

func (o ServiceManagedResourcesSettingsResponsePtrOutput) Elem() ServiceManagedResourcesSettingsResponseOutput {
	return o.ApplyT(func(v *ServiceManagedResourcesSettingsResponse) ServiceManagedResourcesSettingsResponse {
		if v != nil {
			return *v
		}
		var ret ServiceManagedResourcesSettingsResponse
		return ret
	}).(ServiceManagedResourcesSettingsResponseOutput)
}

// The settings for the service managed cosmosdb account.
func (o ServiceManagedResourcesSettingsResponsePtrOutput) CosmosDb() CosmosDbSettingsResponsePtrOutput {
	return o.ApplyT(func(v *ServiceManagedResourcesSettingsResponse) *CosmosDbSettingsResponse {
		if v == nil {
			return nil
		}
		return v.CosmosDb
	}).(CosmosDbSettingsResponsePtrOutput)
}

// Service Principal datastore credentials configuration.
type ServicePrincipalDatastoreCredentials struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'ServicePrincipal'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] Service principal secrets.
	Secrets ServicePrincipalDatastoreSecrets `pulumi:"secrets"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
}

// Service Principal datastore credentials configuration.
type ServicePrincipalDatastoreCredentialsResponse struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'ServicePrincipal'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
}

// Datastore Service Principal secrets.
type ServicePrincipalDatastoreSecrets struct {
	// Service principal secret.
	ClientSecret *string `pulumi:"clientSecret"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'ServicePrincipal'.
	SecretsType string `pulumi:"secretsType"`
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScripts struct {
	// Customized setup scripts
	Scripts *ScriptsToExecute `pulumi:"scripts"`
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScriptsResponse struct {
	// Customized setup scripts
	Scripts *ScriptsToExecuteResponse `pulumi:"scripts"`
}

type SharedPrivateLinkResource struct {
	// The private link resource group id.
	GroupId *string `pulumi:"groupId"`
	// Unique name of the private link.
	Name *string `pulumi:"name"`
	// The resource id that private link links to.
	PrivateLinkResourceId *string `pulumi:"privateLinkResourceId"`
	// Request message.
	RequestMessage *string `pulumi:"requestMessage"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// SharedPrivateLinkResourceInput is an input type that accepts SharedPrivateLinkResourceArgs and SharedPrivateLinkResourceOutput values.
// You can construct a concrete instance of `SharedPrivateLinkResourceInput` via:
//
//	SharedPrivateLinkResourceArgs{...}
type SharedPrivateLinkResourceInput interface {
	pulumi.Input

	ToSharedPrivateLinkResourceOutput() SharedPrivateLinkResourceOutput
	ToSharedPrivateLinkResourceOutputWithContext(context.Context) SharedPrivateLinkResourceOutput
}

type SharedPrivateLinkResourceArgs struct {
	// The private link resource group id.
	GroupId pulumi.StringPtrInput `pulumi:"groupId"`
	// Unique name of the private link.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The resource id that private link links to.
	PrivateLinkResourceId pulumi.StringPtrInput `pulumi:"privateLinkResourceId"`
	// Request message.
	RequestMessage pulumi.StringPtrInput `pulumi:"requestMessage"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (SharedPrivateLinkResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SharedPrivateLinkResource)(nil)).Elem()
}

func (i SharedPrivateLinkResourceArgs) ToSharedPrivateLinkResourceOutput() SharedPrivateLinkResourceOutput {
	return i.ToSharedPrivateLinkResourceOutputWithContext(context.Background())
}

func (i SharedPrivateLinkResourceArgs) ToSharedPrivateLinkResourceOutputWithContext(ctx context.Context) SharedPrivateLinkResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SharedPrivateLinkResourceOutput)
}

// SharedPrivateLinkResourceArrayInput is an input type that accepts SharedPrivateLinkResourceArray and SharedPrivateLinkResourceArrayOutput values.
// You can construct a concrete instance of `SharedPrivateLinkResourceArrayInput` via:
//
//	SharedPrivateLinkResourceArray{ SharedPrivateLinkResourceArgs{...} }
type SharedPrivateLinkResourceArrayInput interface {
	pulumi.Input

	ToSharedPrivateLinkResourceArrayOutput() SharedPrivateLinkResourceArrayOutput
	ToSharedPrivateLinkResourceArrayOutputWithContext(context.Context) SharedPrivateLinkResourceArrayOutput
}

type SharedPrivateLinkResourceArray []SharedPrivateLinkResourceInput

func (SharedPrivateLinkResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SharedPrivateLinkResource)(nil)).Elem()
}

func (i SharedPrivateLinkResourceArray) ToSharedPrivateLinkResourceArrayOutput() SharedPrivateLinkResourceArrayOutput {
	return i.ToSharedPrivateLinkResourceArrayOutputWithContext(context.Background())
}

func (i SharedPrivateLinkResourceArray) ToSharedPrivateLinkResourceArrayOutputWithContext(ctx context.Context) SharedPrivateLinkResourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SharedPrivateLinkResourceArrayOutput)
}

type SharedPrivateLinkResourceOutput struct{ *pulumi.OutputState }

func (SharedPrivateLinkResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SharedPrivateLinkResource)(nil)).Elem()
}

func (o SharedPrivateLinkResourceOutput) ToSharedPrivateLinkResourceOutput() SharedPrivateLinkResourceOutput {
	return o
}

func (o SharedPrivateLinkResourceOutput) ToSharedPrivateLinkResourceOutputWithContext(ctx context.Context) SharedPrivateLinkResourceOutput {
	return o
}

// The private link resource group id.
func (o SharedPrivateLinkResourceOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResource) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// Unique name of the private link.
func (o SharedPrivateLinkResourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The resource id that private link links to.
func (o SharedPrivateLinkResourceOutput) PrivateLinkResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResource) *string { return v.PrivateLinkResourceId }).(pulumi.StringPtrOutput)
}

// Request message.
func (o SharedPrivateLinkResourceOutput) RequestMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResource) *string { return v.RequestMessage }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o SharedPrivateLinkResourceOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResource) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type SharedPrivateLinkResourceArrayOutput struct{ *pulumi.OutputState }

func (SharedPrivateLinkResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SharedPrivateLinkResource)(nil)).Elem()
}

func (o SharedPrivateLinkResourceArrayOutput) ToSharedPrivateLinkResourceArrayOutput() SharedPrivateLinkResourceArrayOutput {
	return o
}

func (o SharedPrivateLinkResourceArrayOutput) ToSharedPrivateLinkResourceArrayOutputWithContext(ctx context.Context) SharedPrivateLinkResourceArrayOutput {
	return o
}

func (o SharedPrivateLinkResourceArrayOutput) Index(i pulumi.IntInput) SharedPrivateLinkResourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SharedPrivateLinkResource {
		return vs[0].([]SharedPrivateLinkResource)[vs[1].(int)]
	}).(SharedPrivateLinkResourceOutput)
}

type SharedPrivateLinkResourceResponse struct {
	// The private link resource group id.
	GroupId *string `pulumi:"groupId"`
	// Unique name of the private link.
	Name *string `pulumi:"name"`
	// The resource id that private link links to.
	PrivateLinkResourceId *string `pulumi:"privateLinkResourceId"`
	// Request message.
	RequestMessage *string `pulumi:"requestMessage"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

type SharedPrivateLinkResourceResponseOutput struct{ *pulumi.OutputState }

func (SharedPrivateLinkResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SharedPrivateLinkResourceResponse)(nil)).Elem()
}

func (o SharedPrivateLinkResourceResponseOutput) ToSharedPrivateLinkResourceResponseOutput() SharedPrivateLinkResourceResponseOutput {
	return o
}

func (o SharedPrivateLinkResourceResponseOutput) ToSharedPrivateLinkResourceResponseOutputWithContext(ctx context.Context) SharedPrivateLinkResourceResponseOutput {
	return o
}

// The private link resource group id.
func (o SharedPrivateLinkResourceResponseOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResourceResponse) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// Unique name of the private link.
func (o SharedPrivateLinkResourceResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResourceResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The resource id that private link links to.
func (o SharedPrivateLinkResourceResponseOutput) PrivateLinkResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResourceResponse) *string { return v.PrivateLinkResourceId }).(pulumi.StringPtrOutput)
}

// Request message.
func (o SharedPrivateLinkResourceResponseOutput) RequestMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResourceResponse) *string { return v.RequestMessage }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o SharedPrivateLinkResourceResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SharedPrivateLinkResourceResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type SharedPrivateLinkResourceResponseArrayOutput struct{ *pulumi.OutputState }

func (SharedPrivateLinkResourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SharedPrivateLinkResourceResponse)(nil)).Elem()
}

func (o SharedPrivateLinkResourceResponseArrayOutput) ToSharedPrivateLinkResourceResponseArrayOutput() SharedPrivateLinkResourceResponseArrayOutput {
	return o
}

func (o SharedPrivateLinkResourceResponseArrayOutput) ToSharedPrivateLinkResourceResponseArrayOutputWithContext(ctx context.Context) SharedPrivateLinkResourceResponseArrayOutput {
	return o
}

func (o SharedPrivateLinkResourceResponseArrayOutput) Index(i pulumi.IntInput) SharedPrivateLinkResourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SharedPrivateLinkResourceResponse {
		return vs[0].([]SharedPrivateLinkResourceResponse)[vs[1].(int)]
	}).(SharedPrivateLinkResourceResponseOutput)
}

// The resource model definition representing SKU
type Sku struct {
	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int `pulumi:"capacity"`
	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `pulumi:"family"`
	// The name of the SKU. Ex - P3. It is typically a letter+number code
	Name string `pulumi:"name"`
	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `pulumi:"size"`
	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
	Tier *SkuTier `pulumi:"tier"`
}

// SkuInput is an input type that accepts SkuArgs and SkuOutput values.
// You can construct a concrete instance of `SkuInput` via:
//
//	SkuArgs{...}
type SkuInput interface {
	pulumi.Input

	ToSkuOutput() SkuOutput
	ToSkuOutputWithContext(context.Context) SkuOutput
}

// The resource model definition representing SKU
type SkuArgs struct {
	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity pulumi.IntPtrInput `pulumi:"capacity"`
	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family pulumi.StringPtrInput `pulumi:"family"`
	// The name of the SKU. Ex - P3. It is typically a letter+number code
	Name pulumi.StringInput `pulumi:"name"`
	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size pulumi.StringPtrInput `pulumi:"size"`
	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
	Tier SkuTierPtrInput `pulumi:"tier"`
}

func (SkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (i SkuArgs) ToSkuOutput() SkuOutput {
	return i.ToSkuOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput)
}

func (i SkuArgs) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput).ToSkuPtrOutputWithContext(ctx)
}

// SkuPtrInput is an input type that accepts SkuArgs, SkuPtr and SkuPtrOutput values.
// You can construct a concrete instance of `SkuPtrInput` via:
//
//	        SkuArgs{...}
//
//	or:
//
//	        nil
type SkuPtrInput interface {
	pulumi.Input

	ToSkuPtrOutput() SkuPtrOutput
	ToSkuPtrOutputWithContext(context.Context) SkuPtrOutput
}

type skuPtrType SkuArgs

func SkuPtr(v *SkuArgs) SkuPtrInput {
	return (*skuPtrType)(v)
}

func (*skuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (i *skuPtrType) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i *skuPtrType) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuPtrOutput)
}

// The resource model definition representing SKU
type SkuOutput struct{ *pulumi.OutputState }

func (SkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (o SkuOutput) ToSkuOutput() SkuOutput {
	return o
}

func (o SkuOutput) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return o
}

func (o SkuOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o.ToSkuPtrOutputWithContext(context.Background())
}

func (o SkuOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Sku) *Sku {
		return &v
	}).(SkuPtrOutput)
}

// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
func (o SkuOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Sku) *int { return v.Capacity }).(pulumi.IntPtrOutput)
}

// If the service has different generations of hardware, for the same SKU, then that can be captured here.
func (o SkuOutput) Family() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Sku) *string { return v.Family }).(pulumi.StringPtrOutput)
}

// The name of the SKU. Ex - P3. It is typically a letter+number code
func (o SkuOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Sku) string { return v.Name }).(pulumi.StringOutput)
}

// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
func (o SkuOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Sku) *string { return v.Size }).(pulumi.StringPtrOutput)
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
func (o SkuOutput) Tier() SkuTierPtrOutput {
	return o.ApplyT(func(v Sku) *SkuTier { return v.Tier }).(SkuTierPtrOutput)
}

type SkuPtrOutput struct{ *pulumi.OutputState }

func (SkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (o SkuPtrOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) Elem() SkuOutput {
	return o.ApplyT(func(v *Sku) Sku {
		if v != nil {
			return *v
		}
		var ret Sku
		return ret
	}).(SkuOutput)
}

// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
func (o SkuPtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Sku) *int {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.IntPtrOutput)
}

// If the service has different generations of hardware, for the same SKU, then that can be captured here.
func (o SkuPtrOutput) Family() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sku) *string {
		if v == nil {
			return nil
		}
		return v.Family
	}).(pulumi.StringPtrOutput)
}

// The name of the SKU. Ex - P3. It is typically a letter+number code
func (o SkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sku) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
func (o SkuPtrOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sku) *string {
		if v == nil {
			return nil
		}
		return v.Size
	}).(pulumi.StringPtrOutput)
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
func (o SkuPtrOutput) Tier() SkuTierPtrOutput {
	return o.ApplyT(func(v *Sku) *SkuTier {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(SkuTierPtrOutput)
}

// The resource model definition representing SKU
type SkuResponse struct {
	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int `pulumi:"capacity"`
	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `pulumi:"family"`
	// The name of the SKU. Ex - P3. It is typically a letter+number code
	Name string `pulumi:"name"`
	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `pulumi:"size"`
	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
	Tier *string `pulumi:"tier"`
}

// The resource model definition representing SKU
type SkuResponseOutput struct{ *pulumi.OutputState }

func (SkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (o SkuResponseOutput) ToSkuResponseOutput() SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return o
}

// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
func (o SkuResponseOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SkuResponse) *int { return v.Capacity }).(pulumi.IntPtrOutput)
}

// If the service has different generations of hardware, for the same SKU, then that can be captured here.
func (o SkuResponseOutput) Family() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SkuResponse) *string { return v.Family }).(pulumi.StringPtrOutput)
}

// The name of the SKU. Ex - P3. It is typically a letter+number code
func (o SkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
func (o SkuResponseOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SkuResponse) *string { return v.Size }).(pulumi.StringPtrOutput)
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
func (o SkuResponseOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SkuResponse) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type SkuResponsePtrOutput struct{ *pulumi.OutputState }

func (SkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SkuResponse)(nil)).Elem()
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) Elem() SkuResponseOutput {
	return o.ApplyT(func(v *SkuResponse) SkuResponse {
		if v != nil {
			return *v
		}
		var ret SkuResponse
		return ret
	}).(SkuResponseOutput)
}

// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
func (o SkuResponsePtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *int {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.IntPtrOutput)
}

// If the service has different generations of hardware, for the same SKU, then that can be captured here.
func (o SkuResponsePtrOutput) Family() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Family
	}).(pulumi.StringPtrOutput)
}

// The name of the SKU. Ex - P3. It is typically a letter+number code
func (o SkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
func (o SkuResponsePtrOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Size
	}).(pulumi.StringPtrOutput)
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
func (o SkuResponsePtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// The ssl configuration for scoring
type SslConfiguration struct {
	// Cert data
	Cert *string `pulumi:"cert"`
	// CNAME of the cert
	Cname *string `pulumi:"cname"`
	// Key data
	Key *string `pulumi:"key"`
	// Leaf domain label of public endpoint
	LeafDomainLabel *string `pulumi:"leafDomainLabel"`
	// Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `pulumi:"overwriteExistingDomain"`
	// Enable or disable ssl for scoring
	Status *string `pulumi:"status"`
}

// The ssl configuration for scoring
type SslConfigurationResponse struct {
	// Cert data
	Cert *string `pulumi:"cert"`
	// CNAME of the cert
	Cname *string `pulumi:"cname"`
	// Key data
	Key *string `pulumi:"key"`
	// Leaf domain label of public endpoint
	LeafDomainLabel *string `pulumi:"leafDomainLabel"`
	// Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `pulumi:"overwriteExistingDomain"`
	// Enable or disable ssl for scoring
	Status *string `pulumi:"status"`
}

// Advances setting to customize StackEnsemble run.
type StackEnsembleSettings struct {
	// Optional parameters to pass to the initializer of the meta-learner.
	StackMetaLearnerKWargs interface{} `pulumi:"stackMetaLearnerKWargs"`
	// Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
	StackMetaLearnerTrainPercentage *float64 `pulumi:"stackMetaLearnerTrainPercentage"`
	// The meta-learner is a model trained on the output of the individual heterogeneous models.
	StackMetaLearnerType *string `pulumi:"stackMetaLearnerType"`
}

// Defaults sets the appropriate defaults for StackEnsembleSettings
func (val *StackEnsembleSettings) Defaults() *StackEnsembleSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.StackMetaLearnerTrainPercentage) {
		stackMetaLearnerTrainPercentage_ := 0.2
		tmp.StackMetaLearnerTrainPercentage = &stackMetaLearnerTrainPercentage_
	}
	if isZero(tmp.StackMetaLearnerType) {
		stackMetaLearnerType_ := "None"
		tmp.StackMetaLearnerType = &stackMetaLearnerType_
	}
	return &tmp
}

// Advances setting to customize StackEnsemble run.
type StackEnsembleSettingsResponse struct {
	// Optional parameters to pass to the initializer of the meta-learner.
	StackMetaLearnerKWargs interface{} `pulumi:"stackMetaLearnerKWargs"`
	// Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
	StackMetaLearnerTrainPercentage *float64 `pulumi:"stackMetaLearnerTrainPercentage"`
	// The meta-learner is a model trained on the output of the individual heterogeneous models.
	StackMetaLearnerType *string `pulumi:"stackMetaLearnerType"`
}

// Defaults sets the appropriate defaults for StackEnsembleSettingsResponse
func (val *StackEnsembleSettingsResponse) Defaults() *StackEnsembleSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.StackMetaLearnerTrainPercentage) {
		stackMetaLearnerTrainPercentage_ := 0.2
		tmp.StackMetaLearnerTrainPercentage = &stackMetaLearnerTrainPercentage_
	}
	if isZero(tmp.StackMetaLearnerType) {
		stackMetaLearnerType_ := "None"
		tmp.StackMetaLearnerType = &stackMetaLearnerType_
	}
	return &tmp
}

// Sweep job definition.
type SweepJob struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Early termination policies enable canceling poor-performing runs before they complete
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Sweep'.
	JobType string `pulumi:"jobType"`
	// Sweep Job limit.
	Limits *SweepJobLimits `pulumi:"limits"`
	// [Required] Optimization objective.
	Objective Objective `pulumi:"objective"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The hyperparameter sampling algorithm
	SamplingAlgorithm interface{} `pulumi:"samplingAlgorithm"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
	SearchSpace interface{} `pulumi:"searchSpace"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] Trial component definition.
	Trial TrialComponent `pulumi:"trial"`
}

// Defaults sets the appropriate defaults for SweepJob
func (val *SweepJob) Defaults() *SweepJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Trial = *tmp.Trial.Defaults()

	return &tmp
}

// Sweep Job limit class.
type SweepJobLimits struct {
	// Expected value is 'Sweep'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// Sweep Job max concurrent trials.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Sweep Job max total trials.
	MaxTotalTrials *int `pulumi:"maxTotalTrials"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
	// Sweep Job Trial timeout value.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Sweep Job limit class.
type SweepJobLimitsResponse struct {
	// Expected value is 'Sweep'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// Sweep Job max concurrent trials.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Sweep Job max total trials.
	MaxTotalTrials *int `pulumi:"maxTotalTrials"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
	// Sweep Job Trial timeout value.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Sweep job definition.
type SweepJobResponse struct {
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Early termination policies enable canceling poor-performing runs before they complete
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Sweep'.
	JobType string `pulumi:"jobType"`
	// Sweep Job limit.
	Limits *SweepJobLimitsResponse `pulumi:"limits"`
	// [Required] Optimization objective.
	Objective ObjectiveResponse `pulumi:"objective"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The hyperparameter sampling algorithm
	SamplingAlgorithm interface{} `pulumi:"samplingAlgorithm"`
	// Schedule definition of job.
	// If no schedule is provided, the job is run once and immediately after submission.
	Schedule interface{} `pulumi:"schedule"`
	// [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
	SearchSpace interface{} `pulumi:"searchSpace"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] Trial component definition.
	Trial TrialComponentResponse `pulumi:"trial"`
}

// Defaults sets the appropriate defaults for SweepJobResponse
func (val *SweepJobResponse) Defaults() *SweepJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ExperimentName) {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.Trial = *tmp.Trial.Defaults()

	return &tmp
}

// A SynapseSpark compute.
type SynapseSpark struct {
	// The type of compute
	// Expected value is 'SynapseSpark'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                   `pulumi:"disableLocalAuth"`
	Properties       *SynapseSparkProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type SynapseSparkProperties struct {
	// Auto pause properties.
	AutoPauseProperties *AutoPauseProperties `pulumi:"autoPauseProperties"`
	// Auto scale properties.
	AutoScaleProperties *AutoScaleProperties `pulumi:"autoScaleProperties"`
	// The number of compute nodes currently assigned to the compute.
	NodeCount *int `pulumi:"nodeCount"`
	// Node size.
	NodeSize *string `pulumi:"nodeSize"`
	// Node size family.
	NodeSizeFamily *string `pulumi:"nodeSizeFamily"`
	// Pool name.
	PoolName *string `pulumi:"poolName"`
	// Name of the resource group in which workspace is located.
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Spark version.
	SparkVersion *string `pulumi:"sparkVersion"`
	// Azure subscription identifier.
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Name of Azure Machine Learning workspace.
	WorkspaceName *string `pulumi:"workspaceName"`
}

// A SynapseSpark compute.
type SynapseSparkResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'SynapseSpark'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string                          `pulumi:"modifiedOn"`
	Properties *SynapseSparkResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type SynapseSparkResponseProperties struct {
	// Auto pause properties.
	AutoPauseProperties *AutoPausePropertiesResponse `pulumi:"autoPauseProperties"`
	// Auto scale properties.
	AutoScaleProperties *AutoScalePropertiesResponse `pulumi:"autoScaleProperties"`
	// The number of compute nodes currently assigned to the compute.
	NodeCount *int `pulumi:"nodeCount"`
	// Node size.
	NodeSize *string `pulumi:"nodeSize"`
	// Node size family.
	NodeSizeFamily *string `pulumi:"nodeSizeFamily"`
	// Pool name.
	PoolName *string `pulumi:"poolName"`
	// Name of the resource group in which workspace is located.
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Spark version.
	SparkVersion *string `pulumi:"sparkVersion"`
	// Azure subscription identifier.
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Name of Azure Machine Learning workspace.
	WorkspaceName *string `pulumi:"workspaceName"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC)
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC)
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// A system service running on a compute.
type SystemServiceResponse struct {
	// Public IP address
	PublicIpAddress string `pulumi:"publicIpAddress"`
	// The type of this system service.
	SystemServiceType string `pulumi:"systemServiceType"`
	// The version for this type.
	Version string `pulumi:"version"`
}

// Class for data inputs.
type TableVerticalDataSettings struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettings `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettings `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *TableVerticalValidationDataSettings `pulumi:"validationData"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for TableVerticalDataSettings
func (val *TableVerticalDataSettings) Defaults() *TableVerticalDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Class for data inputs.
type TableVerticalDataSettingsResponse struct {
	// [Required] Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName string `pulumi:"targetColumnName"`
	// Test data input.
	TestData *TestDataSettingsResponse `pulumi:"testData"`
	// [Required] Training data input.
	TrainingData TrainingDataSettingsResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *TableVerticalValidationDataSettingsResponse `pulumi:"validationData"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for TableVerticalDataSettingsResponse
func (val *TableVerticalDataSettingsResponse) Defaults() *TableVerticalDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Featurization Configuration.
type TableVerticalFeaturizationSettings struct {
	// These transformers shall not be used in featurization.
	BlockedTransformers []string `pulumi:"blockedTransformers"`
	// Dictionary of column name and its type (int, float, string, datetime etc).
	ColumnNameAndTypes map[string]string `pulumi:"columnNameAndTypes"`
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
	// Columns to be dropped from data during featurization.
	DropColumns []string `pulumi:"dropColumns"`
	// Determines whether to use Dnn based featurizers for data featurization.
	EnableDnnFeaturization *bool `pulumi:"enableDnnFeaturization"`
	// Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
	// If 'Off' is selected then no featurization is done.
	// If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
	Mode *string `pulumi:"mode"`
	// User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
	TransformerParams map[string][]ColumnTransformer `pulumi:"transformerParams"`
}

// Defaults sets the appropriate defaults for TableVerticalFeaturizationSettings
func (val *TableVerticalFeaturizationSettings) Defaults() *TableVerticalFeaturizationSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableDnnFeaturization) {
		enableDnnFeaturization_ := false
		tmp.EnableDnnFeaturization = &enableDnnFeaturization_
	}
	if isZero(tmp.Mode) {
		mode_ := "Auto"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Featurization Configuration.
type TableVerticalFeaturizationSettingsResponse struct {
	// These transformers shall not be used in featurization.
	BlockedTransformers []string `pulumi:"blockedTransformers"`
	// Dictionary of column name and its type (int, float, string, datetime etc).
	ColumnNameAndTypes map[string]string `pulumi:"columnNameAndTypes"`
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
	// Columns to be dropped from data during featurization.
	DropColumns []string `pulumi:"dropColumns"`
	// Determines whether to use Dnn based featurizers for data featurization.
	EnableDnnFeaturization *bool `pulumi:"enableDnnFeaturization"`
	// Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
	// If 'Off' is selected then no featurization is done.
	// If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
	Mode *string `pulumi:"mode"`
	// User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
	TransformerParams map[string][]ColumnTransformerResponse `pulumi:"transformerParams"`
}

// Defaults sets the appropriate defaults for TableVerticalFeaturizationSettingsResponse
func (val *TableVerticalFeaturizationSettingsResponse) Defaults() *TableVerticalFeaturizationSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableDnnFeaturization) {
		enableDnnFeaturization_ := false
		tmp.EnableDnnFeaturization = &enableDnnFeaturization_
	}
	if isZero(tmp.Mode) {
		mode_ := "Auto"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Job execution constraints.
type TableVerticalLimitSettings struct {
	// Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
	EnableEarlyTermination *bool `pulumi:"enableEarlyTermination"`
	// Exit score for the AutoML job.
	ExitScore *float64 `pulumi:"exitScore"`
	// Maximum Concurrent iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Max cores per iteration.
	MaxCoresPerTrial *int `pulumi:"maxCoresPerTrial"`
	// Number of iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
	// Iteration timeout.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Defaults sets the appropriate defaults for TableVerticalLimitSettings
func (val *TableVerticalLimitSettings) Defaults() *TableVerticalLimitSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableEarlyTermination) {
		enableEarlyTermination_ := true
		tmp.EnableEarlyTermination = &enableEarlyTermination_
	}
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxCoresPerTrial) {
		maxCoresPerTrial_ := -1
		tmp.MaxCoresPerTrial = &maxCoresPerTrial_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1000
		tmp.MaxTrials = &maxTrials_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT6H"
		tmp.Timeout = &timeout_
	}
	if isZero(tmp.TrialTimeout) {
		trialTimeout_ := "PT30M"
		tmp.TrialTimeout = &trialTimeout_
	}
	return &tmp
}

// Job execution constraints.
type TableVerticalLimitSettingsResponse struct {
	// Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
	EnableEarlyTermination *bool `pulumi:"enableEarlyTermination"`
	// Exit score for the AutoML job.
	ExitScore *float64 `pulumi:"exitScore"`
	// Maximum Concurrent iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Max cores per iteration.
	MaxCoresPerTrial *int `pulumi:"maxCoresPerTrial"`
	// Number of iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
	// Iteration timeout.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Defaults sets the appropriate defaults for TableVerticalLimitSettingsResponse
func (val *TableVerticalLimitSettingsResponse) Defaults() *TableVerticalLimitSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableEarlyTermination) {
		enableEarlyTermination_ := true
		tmp.EnableEarlyTermination = &enableEarlyTermination_
	}
	if isZero(tmp.MaxConcurrentTrials) {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if isZero(tmp.MaxCoresPerTrial) {
		maxCoresPerTrial_ := -1
		tmp.MaxCoresPerTrial = &maxCoresPerTrial_
	}
	if isZero(tmp.MaxTrials) {
		maxTrials_ := 1000
		tmp.MaxTrials = &maxTrials_
	}
	if isZero(tmp.Timeout) {
		timeout_ := "PT6H"
		tmp.Timeout = &timeout_
	}
	if isZero(tmp.TrialTimeout) {
		trialTimeout_ := "PT30M"
		tmp.TrialTimeout = &trialTimeout_
	}
	return &tmp
}

// Validation settings for AutoML Table vertical tasks - Classification/Regression/Forecasting.
type TableVerticalValidationDataSettings struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Validation data MLTable.
	Data *MLTableJobInput `pulumi:"data"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for TableVerticalValidationDataSettings
func (val *TableVerticalValidationDataSettings) Defaults() *TableVerticalValidationDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

// Validation settings for AutoML Table vertical tasks - Classification/Regression/Forecasting.
type TableVerticalValidationDataSettingsResponse struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Validation data MLTable.
	Data *MLTableJobInputResponse `pulumi:"data"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for TableVerticalValidationDataSettingsResponse
func (val *TableVerticalValidationDataSettingsResponse) Defaults() *TableVerticalValidationDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

type TargetUtilizationScaleSettings struct {
	// The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
	MaxInstances *int `pulumi:"maxInstances"`
	// The minimum number of instances to always be present.
	MinInstances *int `pulumi:"minInstances"`
	// The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
	PollingInterval *string `pulumi:"pollingInterval"`
	// Expected value is 'TargetUtilization'.
	ScaleType string `pulumi:"scaleType"`
	// Target CPU usage for the autoscaler.
	TargetUtilizationPercentage *int `pulumi:"targetUtilizationPercentage"`
}

// Defaults sets the appropriate defaults for TargetUtilizationScaleSettings
func (val *TargetUtilizationScaleSettings) Defaults() *TargetUtilizationScaleSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxInstances) {
		maxInstances_ := 1
		tmp.MaxInstances = &maxInstances_
	}
	if isZero(tmp.MinInstances) {
		minInstances_ := 1
		tmp.MinInstances = &minInstances_
	}
	if isZero(tmp.PollingInterval) {
		pollingInterval_ := "PT1S"
		tmp.PollingInterval = &pollingInterval_
	}
	if isZero(tmp.TargetUtilizationPercentage) {
		targetUtilizationPercentage_ := 70
		tmp.TargetUtilizationPercentage = &targetUtilizationPercentage_
	}
	return &tmp
}

type TargetUtilizationScaleSettingsResponse struct {
	// The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
	MaxInstances *int `pulumi:"maxInstances"`
	// The minimum number of instances to always be present.
	MinInstances *int `pulumi:"minInstances"`
	// The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
	PollingInterval *string `pulumi:"pollingInterval"`
	// Expected value is 'TargetUtilization'.
	ScaleType string `pulumi:"scaleType"`
	// Target CPU usage for the autoscaler.
	TargetUtilizationPercentage *int `pulumi:"targetUtilizationPercentage"`
}

// Defaults sets the appropriate defaults for TargetUtilizationScaleSettingsResponse
func (val *TargetUtilizationScaleSettingsResponse) Defaults() *TargetUtilizationScaleSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.MaxInstances) {
		maxInstances_ := 1
		tmp.MaxInstances = &maxInstances_
	}
	if isZero(tmp.MinInstances) {
		minInstances_ := 1
		tmp.MinInstances = &minInstances_
	}
	if isZero(tmp.PollingInterval) {
		pollingInterval_ := "PT1S"
		tmp.PollingInterval = &pollingInterval_
	}
	if isZero(tmp.TargetUtilizationPercentage) {
		targetUtilizationPercentage_ := 70
		tmp.TargetUtilizationPercentage = &targetUtilizationPercentage_
	}
	return &tmp
}

// TensorFlow distribution configuration.
type TensorFlow struct {
	// Enum to determine the job distribution type.
	// Expected value is 'TensorFlow'.
	DistributionType string `pulumi:"distributionType"`
	// Number of parameter server tasks.
	ParameterServerCount *int `pulumi:"parameterServerCount"`
	// Number of workers. If not specified, will default to the instance count.
	WorkerCount *int `pulumi:"workerCount"`
}

// Defaults sets the appropriate defaults for TensorFlow
func (val *TensorFlow) Defaults() *TensorFlow {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ParameterServerCount) {
		parameterServerCount_ := 0
		tmp.ParameterServerCount = &parameterServerCount_
	}
	return &tmp
}

// TensorFlow distribution configuration.
type TensorFlowResponse struct {
	// Enum to determine the job distribution type.
	// Expected value is 'TensorFlow'.
	DistributionType string `pulumi:"distributionType"`
	// Number of parameter server tasks.
	ParameterServerCount *int `pulumi:"parameterServerCount"`
	// Number of workers. If not specified, will default to the instance count.
	WorkerCount *int `pulumi:"workerCount"`
}

// Defaults sets the appropriate defaults for TensorFlowResponse
func (val *TensorFlowResponse) Defaults() *TensorFlowResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.ParameterServerCount) {
		parameterServerCount_ := 0
		tmp.ParameterServerCount = &parameterServerCount_
	}
	return &tmp
}

// Test data inputs.
type TestDataSettings struct {
	// Test data MLTable.
	Data *MLTableJobInput `pulumi:"data"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
}

// Defaults sets the appropriate defaults for TestDataSettings
func (val *TestDataSettings) Defaults() *TestDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

// Test data inputs.
type TestDataSettingsResponse struct {
	// Test data MLTable.
	Data *MLTableJobInputResponse `pulumi:"data"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
}

// Defaults sets the appropriate defaults for TestDataSettingsResponse
func (val *TestDataSettingsResponse) Defaults() *TestDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = tmp.Data.Defaults()

	return &tmp
}

// Text Classification task in AutoML NLP vertical.
// NLP - Natural Language Processing.
type TextClassification struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for Text-Classification task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'TextClassification'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextClassification
func (val *TextClassification) Defaults() *TextClassification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Text Classification Multilabel task in AutoML NLP vertical.
// NLP - Natural Language Processing.
type TextClassificationMultilabel struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// AutoMLJob Task type.
	// Expected value is 'TextClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextClassificationMultilabel
func (val *TextClassificationMultilabel) Defaults() *TextClassificationMultilabel {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	return &tmp
}

// Text Classification Multilabel task in AutoML NLP vertical.
// NLP - Natural Language Processing.
type TextClassificationMultilabelResponse struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for Text-Classification-Multilabel task.
	// Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
	PrimaryMetric string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'TextClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextClassificationMultilabelResponse
func (val *TextClassificationMultilabelResponse) Defaults() *TextClassificationMultilabelResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	return &tmp
}

// Text Classification task in AutoML NLP vertical.
// NLP - Natural Language Processing.
type TextClassificationResponse struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for Text-Classification task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'TextClassification'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextClassificationResponse
func (val *TextClassificationResponse) Defaults() *TextClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if isZero(tmp.PrimaryMetric) {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	return &tmp
}

// Text-NER task in AutoML NLP vertical.
// NER - Named Entity Recognition.
// NLP - Natural Language Processing.
type TextNer struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettings `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// AutoMLJob Task type.
	// Expected value is 'TextNER'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextNer
func (val *TextNer) Defaults() *TextNer {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	return &tmp
}

// Text-NER task in AutoML NLP vertical.
// NER - Named Entity Recognition.
// NLP - Natural Language Processing.
type TextNerResponse struct {
	// Data inputs for AutoMLJob.
	DataSettings *NlpVerticalDataSettingsResponse `pulumi:"dataSettings"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *NlpVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *NlpVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Primary metric for Text-NER task.
	// Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly.
	PrimaryMetric string `pulumi:"primaryMetric"`
	// AutoMLJob Task type.
	// Expected value is 'TextNER'.
	TaskType string `pulumi:"taskType"`
}

// Defaults sets the appropriate defaults for TextNerResponse
func (val *TextNerResponse) Defaults() *TextNerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataSettings = tmp.DataSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if isZero(tmp.LogVerbosity) {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	return &tmp
}

// Training data input.
type TrainingDataSettings struct {
	// [Required] Training data MLTable.
	Data MLTableJobInput `pulumi:"data"`
}

// Defaults sets the appropriate defaults for TrainingDataSettings
func (val *TrainingDataSettings) Defaults() *TrainingDataSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = *tmp.Data.Defaults()

	return &tmp
}

// Training data input.
type TrainingDataSettingsResponse struct {
	// [Required] Training data MLTable.
	Data MLTableJobInputResponse `pulumi:"data"`
}

// Defaults sets the appropriate defaults for TrainingDataSettingsResponse
func (val *TrainingDataSettingsResponse) Defaults() *TrainingDataSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Data = *tmp.Data.Defaults()

	return &tmp
}

// Training related configuration.
type TrainingSettings struct {
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettings `pulumi:"stackEnsembleSettings"`
}

// Defaults sets the appropriate defaults for TrainingSettings
func (val *TrainingSettings) Defaults() *TrainingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableDnnTraining) {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if isZero(tmp.EnableModelExplainability) {
		enableModelExplainability_ := false
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if isZero(tmp.EnableOnnxCompatibleModels) {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if isZero(tmp.EnableStackEnsemble) {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if isZero(tmp.EnableVoteEnsemble) {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if isZero(tmp.EnsembleModelDownloadTimeout) {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	return &tmp
}

// Training related configuration.
type TrainingSettingsResponse struct {
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettingsResponse `pulumi:"stackEnsembleSettings"`
}

// Defaults sets the appropriate defaults for TrainingSettingsResponse
func (val *TrainingSettingsResponse) Defaults() *TrainingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.EnableDnnTraining) {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if isZero(tmp.EnableModelExplainability) {
		enableModelExplainability_ := false
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if isZero(tmp.EnableOnnxCompatibleModels) {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if isZero(tmp.EnableStackEnsemble) {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if isZero(tmp.EnableVoteEnsemble) {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if isZero(tmp.EnsembleModelDownloadTimeout) {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	return &tmp
}

// Trial component definition.
type TrialComponent struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfiguration `pulumi:"resources"`
}

// Defaults sets the appropriate defaults for TrialComponent
func (val *TrialComponent) Defaults() *TrialComponent {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// Trial component definition.
type TrialComponentResponse struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute Resource configuration for the job.
	Resources *ResourceConfigurationResponse `pulumi:"resources"`
}

// Defaults sets the appropriate defaults for TrialComponentResponse
func (val *TrialComponentResponse) Defaults() *TrialComponentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

type TritonModelJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'TritonModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for TritonModelJobInput
func (val *TritonModelJobInput) Defaults() *TritonModelJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type TritonModelJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'TritonModel'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for TritonModelJobInputResponse
func (val *TritonModelJobInputResponse) Defaults() *TritonModelJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type TritonModelJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'TritonModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for TritonModelJobOutput
func (val *TritonModelJobOutput) Defaults() *TritonModelJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type TritonModelJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'TritonModel'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for TritonModelJobOutputResponse
func (val *TritonModelJobOutputResponse) Defaults() *TritonModelJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
type TruncationSelectionPolicy struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'TruncationSelection'.
	PolicyType string `pulumi:"policyType"`
	// The percentage of runs to cancel at each evaluation interval.
	TruncationPercentage *int `pulumi:"truncationPercentage"`
}

// Defaults sets the appropriate defaults for TruncationSelectionPolicy
func (val *TruncationSelectionPolicy) Defaults() *TruncationSelectionPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if isZero(tmp.TruncationPercentage) {
		truncationPercentage_ := 0
		tmp.TruncationPercentage = &truncationPercentage_
	}
	return &tmp
}

// Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
type TruncationSelectionPolicyResponse struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'TruncationSelection'.
	PolicyType string `pulumi:"policyType"`
	// The percentage of runs to cancel at each evaluation interval.
	TruncationPercentage *int `pulumi:"truncationPercentage"`
}

// Defaults sets the appropriate defaults for TruncationSelectionPolicyResponse
func (val *TruncationSelectionPolicyResponse) Defaults() *TruncationSelectionPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.DelayEvaluation) {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if isZero(tmp.EvaluationInterval) {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if isZero(tmp.TruncationPercentage) {
		truncationPercentage_ := 0
		tmp.TruncationPercentage = &truncationPercentage_
	}
	return &tmp
}

// uri-file data version entity
type UriFileDataVersion struct {
	// Enum to determine the type of data.
	// Expected value is 'UriFile'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for UriFileDataVersion
func (val *UriFileDataVersion) Defaults() *UriFileDataVersion {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// uri-file data version entity
type UriFileDataVersionResponse struct {
	// Enum to determine the type of data.
	// Expected value is 'UriFile'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for UriFileDataVersionResponse
func (val *UriFileDataVersionResponse) Defaults() *UriFileDataVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type UriFileJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'UriFile'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFileJobInput
func (val *UriFileJobInput) Defaults() *UriFileJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFileJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'UriFile'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFileJobInputResponse
func (val *UriFileJobInputResponse) Defaults() *UriFileJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFileJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'UriFile'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFileJobOutput
func (val *UriFileJobOutput) Defaults() *UriFileJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFileJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'UriFile'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFileJobOutputResponse
func (val *UriFileJobOutputResponse) Defaults() *UriFileJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// uri-folder data version entity
type UriFolderDataVersion struct {
	// Enum to determine the type of data.
	// Expected value is 'UriFolder'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for UriFolderDataVersion
func (val *UriFolderDataVersion) Defaults() *UriFolderDataVersion {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// uri-folder data version entity
type UriFolderDataVersionResponse struct {
	// Enum to determine the type of data.
	// Expected value is 'UriFolder'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration).
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for UriFolderDataVersionResponse
func (val *UriFolderDataVersionResponse) Defaults() *UriFolderDataVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.IsAnonymous) {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if isZero(tmp.IsArchived) {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type UriFolderJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'UriFolder'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFolderJobInput
func (val *UriFolderJobInput) Defaults() *UriFolderJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFolderJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'UriFolder'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFolderJobInputResponse
func (val *UriFolderJobInputResponse) Defaults() *UriFolderJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFolderJobOutput struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'UriFolder'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFolderJobOutput
func (val *UriFolderJobOutput) Defaults() *UriFolderJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type UriFolderJobOutputResponse struct {
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'UriFolder'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for UriFolderJobOutputResponse
func (val *UriFolderJobOutputResponse) Defaults() *UriFolderJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if isZero(tmp.Mode) {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials struct {
	// Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName string `pulumi:"adminUserName"`
	// Password of the administrator user account.
	AdminUserPassword *string `pulumi:"adminUserPassword"`
	// SSH public key of the administrator user account.
	AdminUserSshPublicKey *string `pulumi:"adminUserSshPublicKey"`
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentialsResponse struct {
	// Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName string `pulumi:"adminUserName"`
	// Password of the administrator user account.
	AdminUserPassword *string `pulumi:"adminUserPassword"`
	// SSH public key of the administrator user account.
	AdminUserSshPublicKey *string `pulumi:"adminUserSshPublicKey"`
}

// User assigned identity properties
type UserAssignedIdentityResponse struct {
	// The client ID of the assigned identity.
	ClientId string `pulumi:"clientId"`
	// The principal ID of the assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// User assigned identity properties
type UserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput {
	return o
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedIdentityResponseOutput {
	return o
}

// The client ID of the assigned identity.
func (o UserAssignedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal ID of the assigned identity.
func (o UserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedIdentityResponse {
		return vs[0].(map[string]UserAssignedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedIdentityResponseOutput)
}

// User identity configuration.
type UserIdentity struct {
	// Enum to determine identity framework.
	// Expected value is 'UserIdentity'.
	IdentityType string `pulumi:"identityType"`
}

// User identity configuration.
type UserIdentityResponse struct {
	// Enum to determine identity framework.
	// Expected value is 'UserIdentity'.
	IdentityType string `pulumi:"identityType"`
}

// A Machine Learning compute based on Azure Virtual Machines.
type VirtualMachine struct {
	// The type of compute
	// Expected value is 'VirtualMachine'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                           `pulumi:"disableLocalAuth"`
	Properties       *VirtualMachineSchemaProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImage struct {
	// Virtual Machine image path
	Id string `pulumi:"id"`
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImageResponse struct {
	// Virtual Machine image path
	Id string `pulumi:"id"`
}

// A Machine Learning compute based on Azure Virtual Machines.
type VirtualMachineResponse struct {
	// Location for the underlying compute
	ComputeLocation string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'VirtualMachine'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string                                  `pulumi:"modifiedOn"`
	Properties *VirtualMachineSchemaResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type VirtualMachineSchemaProperties struct {
	// Public IP address of the virtual machine.
	Address *string `pulumi:"address"`
	// Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials `pulumi:"administratorAccount"`
	// Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `pulumi:"isNotebookInstanceCompute"`
	// Notebook server port open for ssh connections.
	NotebookServerPort *int `pulumi:"notebookServerPort"`
	// Port open for ssh connections.
	SshPort *int `pulumi:"sshPort"`
	// Virtual Machine size
	VirtualMachineSize *string `pulumi:"virtualMachineSize"`
}

type VirtualMachineSchemaResponseProperties struct {
	// Public IP address of the virtual machine.
	Address *string `pulumi:"address"`
	// Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentialsResponse `pulumi:"administratorAccount"`
	// Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `pulumi:"isNotebookInstanceCompute"`
	// Notebook server port open for ssh connections.
	NotebookServerPort *int `pulumi:"notebookServerPort"`
	// Port open for ssh connections.
	SshPort *int `pulumi:"sshPort"`
	// Virtual Machine size
	VirtualMachineSize *string `pulumi:"virtualMachineSize"`
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentials struct {
	// Password of admin account
	Password *string `pulumi:"password"`
	// Private key data
	PrivateKeyData *string `pulumi:"privateKeyData"`
	// Public key data
	PublicKeyData *string `pulumi:"publicKeyData"`
	// Username of admin account
	Username *string `pulumi:"username"`
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentialsResponse struct {
	// Password of admin account
	Password *string `pulumi:"password"`
	// Private key data
	PrivateKeyData *string `pulumi:"privateKeyData"`
	// Public key data
	PublicKeyData *string `pulumi:"publicKeyData"`
	// Username of admin account
	Username *string `pulumi:"username"`
}

func init() {
	pulumi.RegisterOutputType(AmlComputeNodeInformationResponseOutput{})
	pulumi.RegisterOutputType(AmlComputeNodeInformationResponseArrayOutput{})
	pulumi.RegisterOutputType(BatchDeploymentTypeOutput{})
	pulumi.RegisterOutputType(BatchDeploymentResponseOutput{})
	pulumi.RegisterOutputType(BatchEndpointTypeOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsPtrOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsResponseOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsResponsePtrOutput{})
	pulumi.RegisterOutputType(BatchEndpointResponseOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsPtrOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsResponseOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(BuildContextOutput{})
	pulumi.RegisterOutputType(BuildContextPtrOutput{})
	pulumi.RegisterOutputType(BuildContextResponseOutput{})
	pulumi.RegisterOutputType(BuildContextResponsePtrOutput{})
	pulumi.RegisterOutputType(CodeConfigurationOutput{})
	pulumi.RegisterOutputType(CodeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CodeConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CodeConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CodeContainerTypeOutput{})
	pulumi.RegisterOutputType(CodeContainerResponseOutput{})
	pulumi.RegisterOutputType(CodeVersionTypeOutput{})
	pulumi.RegisterOutputType(CodeVersionResponseOutput{})
	pulumi.RegisterOutputType(ComponentContainerTypeOutput{})
	pulumi.RegisterOutputType(ComponentContainerResponseOutput{})
	pulumi.RegisterOutputType(ComponentVersionTypeOutput{})
	pulumi.RegisterOutputType(ComponentVersionResponseOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsPtrOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsResponseOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(DataContainerTypeOutput{})
	pulumi.RegisterOutputType(DataContainerResponseOutput{})
	pulumi.RegisterOutputType(EncryptionKeyVaultPropertiesOutput{})
	pulumi.RegisterOutputType(EncryptionKeyVaultPropertiesPtrOutput{})
	pulumi.RegisterOutputType(EncryptionKeyVaultPropertiesResponseOutput{})
	pulumi.RegisterOutputType(EncryptionKeyVaultPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyPtrOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyResponseOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyResponsePtrOutput{})
	pulumi.RegisterOutputType(EndpointAuthKeysOutput{})
	pulumi.RegisterOutputType(EndpointAuthKeysPtrOutput{})
	pulumi.RegisterOutputType(EnvironmentContainerTypeOutput{})
	pulumi.RegisterOutputType(EnvironmentContainerResponseOutput{})
	pulumi.RegisterOutputType(EnvironmentVersionTypeOutput{})
	pulumi.RegisterOutputType(EnvironmentVersionResponseOutput{})
	pulumi.RegisterOutputType(FlavorDataOutput{})
	pulumi.RegisterOutputType(FlavorDataMapOutput{})
	pulumi.RegisterOutputType(FlavorDataResponseOutput{})
	pulumi.RegisterOutputType(FlavorDataResponseMapOutput{})
	pulumi.RegisterOutputType(IdentityForCmkOutput{})
	pulumi.RegisterOutputType(IdentityForCmkPtrOutput{})
	pulumi.RegisterOutputType(IdentityForCmkResponseOutput{})
	pulumi.RegisterOutputType(IdentityForCmkResponsePtrOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesPtrOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesResponseOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(ListNotebookKeysResultResponseOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityPtrOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityResponseOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(ModelContainerTypeOutput{})
	pulumi.RegisterOutputType(ModelContainerResponseOutput{})
	pulumi.RegisterOutputType(ModelVersionTypeOutput{})
	pulumi.RegisterOutputType(ModelVersionResponseOutput{})
	pulumi.RegisterOutputType(NotebookPreparationErrorResponseOutput{})
	pulumi.RegisterOutputType(NotebookPreparationErrorResponsePtrOutput{})
	pulumi.RegisterOutputType(NotebookResourceInfoResponseOutput{})
	pulumi.RegisterOutputType(OnlineEndpointTypeOutput{})
	pulumi.RegisterOutputType(OnlineEndpointResponseOutput{})
	pulumi.RegisterOutputType(PasswordResponseOutput{})
	pulumi.RegisterOutputType(PasswordResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(RegistryListCredentialsResultResponseOutput{})
	pulumi.RegisterOutputType(ResourceConfigurationOutput{})
	pulumi.RegisterOutputType(ResourceConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ResourceConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ResourceConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(RouteOutput{})
	pulumi.RegisterOutputType(RoutePtrOutput{})
	pulumi.RegisterOutputType(RouteResponseOutput{})
	pulumi.RegisterOutputType(RouteResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceManagedResourcesSettingsOutput{})
	pulumi.RegisterOutputType(ServiceManagedResourcesSettingsPtrOutput{})
	pulumi.RegisterOutputType(ServiceManagedResourcesSettingsResponseOutput{})
	pulumi.RegisterOutputType(ServiceManagedResourcesSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(SharedPrivateLinkResourceOutput{})
	pulumi.RegisterOutputType(SharedPrivateLinkResourceArrayOutput{})
	pulumi.RegisterOutputType(SharedPrivateLinkResourceResponseOutput{})
	pulumi.RegisterOutputType(SharedPrivateLinkResourceResponseArrayOutput{})
	pulumi.RegisterOutputType(SkuOutput{})
	pulumi.RegisterOutputType(SkuPtrOutput{})
	pulumi.RegisterOutputType(SkuResponseOutput{})
	pulumi.RegisterOutputType(SkuResponsePtrOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseMapOutput{})
}
